var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
  get: (a3, b2) => (typeof require !== "undefined" ? require : a3)[b2]
}) : x3)(function(x3) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x3 + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i3 = 0, len = code.length; i3 < len; ++i3) {
      lookup[i3] = code[i3];
      revLookup[code.charCodeAt(i3)] = i3;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i4;
      for (i4 = 0; i4 < len2; i4 += 4) {
        tmp = revLookup[b64.charCodeAt(i4)] << 18 | revLookup[b64.charCodeAt(i4 + 1)] << 12 | revLookup[b64.charCodeAt(i4 + 2)] << 6 | revLookup[b64.charCodeAt(i4 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i4)] << 2 | revLookup[b64.charCodeAt(i4 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i4)] << 10 | revLookup[b64.charCodeAt(i4 + 1)] << 4 | revLookup[b64.charCodeAt(i4 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i4 = start; i4 < end; i4 += 3) {
        tmp = (uint8[i4] << 16 & 16711680) + (uint8[i4 + 1] << 8 & 65280) + (uint8[i4 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i4 = 0, len22 = len2 - extraBytes; i4 < len22; i4 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i4, i4 + maxChunkLength > len22 ? len22 : i4 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    var i3;
    var len;
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e3, m3;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i3 = isLE ? nBytes - 1 : 0;
      var d3 = isLE ? -1 : 1;
      var s3 = buffer[offset + i3];
      i3 += d3;
      e3 = s3 & (1 << -nBits) - 1;
      s3 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e3 = e3 * 256 + buffer[offset + i3], i3 += d3, nBits -= 8) {
      }
      m3 = e3 & (1 << -nBits) - 1;
      e3 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m3 = m3 * 256 + buffer[offset + i3], i3 += d3, nBits -= 8) {
      }
      if (e3 === 0) {
        e3 = 1 - eBias;
      } else if (e3 === eMax) {
        return m3 ? NaN : (s3 ? -1 : 1) * Infinity;
      } else {
        m3 = m3 + Math.pow(2, mLen);
        e3 = e3 - eBias;
      }
      return (s3 ? -1 : 1) * m3 * Math.pow(2, e3 - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e3, m3, c3;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i3 = isLE ? 0 : nBytes - 1;
      var d3 = isLE ? 1 : -1;
      var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m3 = isNaN(value) ? 1 : 0;
        e3 = eMax;
      } else {
        e3 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c3 = Math.pow(2, -e3)) < 1) {
          e3--;
          c3 *= 2;
        }
        if (e3 + eBias >= 1) {
          value += rt / c3;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c3 >= 2) {
          e3++;
          c3 /= 2;
        }
        if (e3 + eBias >= eMax) {
          m3 = 0;
          e3 = eMax;
        } else if (e3 + eBias >= 1) {
          m3 = (value * c3 - 1) * Math.pow(2, mLen);
          e3 = e3 + eBias;
        } else {
          m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e3 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i3] = m3 & 255, i3 += d3, m3 /= 256, mLen -= 8) {
      }
      e3 = e3 << mLen | m3;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i3] = e3 & 255, i3 += d3, e3 /= 256, eLen -= 8) {
      }
      buffer[offset + i3 - d3] |= s3 * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer3;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e3) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b2 = fromObject(value);
      if (b2)
        return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i3 = 0; i3 < length; i3 += 1) {
        buf[i3] = array[i3] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer3(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a3, b2) {
      if (isInstance(a3, Uint8Array))
        a3 = Buffer3.from(a3, a3.offset, a3.byteLength);
      if (isInstance(b2, Uint8Array))
        b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
      if (!Buffer3.isBuffer(a3) || !Buffer3.isBuffer(b2)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a3 === b2)
        return 0;
      let x3 = a3.length;
      let y3 = b2.length;
      for (let i3 = 0, len = Math.min(x3, y3); i3 < len; ++i3) {
        if (a3[i3] !== b2[i3]) {
          x3 = a3[i3];
          y3 = b2[i3];
          break;
        }
      }
      if (x3 < y3)
        return -1;
      if (y3 < x3)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i3;
      if (length === void 0) {
        length = 0;
        for (i3 = 0; i3 < list.length; ++i3) {
          length += list[i3].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        let buf = list[i3];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b2, n2, m3) {
      const i3 = b2[n2];
      b2[n2] = b2[m3];
      b2[m3] = i3;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i3 = 0; i3 < len; i3 += 2) {
        swap(this, i3, i3 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i3 = 0; i3 < len; i3 += 4) {
        swap(this, i3, i3 + 3);
        swap(this, i3 + 1, i3 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i3 = 0; i3 < len; i3 += 8) {
        swap(this, i3, i3 + 7);
        swap(this, i3 + 1, i3 + 6);
        swap(this, i3 + 2, i3 + 5);
        swap(this, i3 + 3, i3 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b2) {
      if (!Buffer3.isBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer3.compare(this, b2) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x3 = thisEnd - thisStart;
      let y3 = end - start;
      const len = Math.min(x3, y3);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i3 = 0; i3 < len; ++i3) {
        if (thisCopy[i3] !== targetCopy[i3]) {
          x3 = thisCopy[i3];
          y3 = targetCopy[i3];
          break;
        }
      }
      if (x3 < y3)
        return -1;
      if (y3 < x3)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i4) {
        if (indexSize === 1) {
          return buf[i4];
        } else {
          return buf.readUInt16BE(i4 * indexSize);
        }
      }
      let i3;
      if (dir) {
        let foundIndex = -1;
        for (i3 = byteOffset; i3 < arrLength; i3++) {
          if (read(arr, i3) === read(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i3;
            if (i3 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i3 -= i3 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i3 = byteOffset; i3 >= 0; i3--) {
          let found = true;
          for (let j3 = 0; j3 < valLength; j3++) {
            if (read(arr, i3 + j3) !== read(val, j3)) {
              found = false;
              break;
            }
          }
          if (found)
            return i3;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i3;
      for (i3 = 0; i3 < length; ++i3) {
        const parsed = parseInt(string.substr(i3 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i3;
        buf[offset + i3] = parsed;
      }
      return i3;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i3 = start;
      while (i3 < end) {
        const firstByte = buf[i3];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i3 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i3 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i3 + 1];
              thirdByte = buf[i3 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i3 + 1];
              thirdByte = buf[i3 + 2];
              fourthByte = buf[i3 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i3 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i3 = 0;
      while (i3 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i3 = start; i3 < end; ++i3) {
        ret += String.fromCharCode(buf[i3] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i3 = start; i3 < end; ++i3) {
        ret += String.fromCharCode(buf[i3]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i3 = start; i3 < end; ++i3) {
        out += hexSliceLookupTable[buf[i3]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i3 = 0; i3 < bytes.length - 1; i3 += 2) {
        res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i3 = 0;
      while (++i3 < byteLength2 && (mul *= 256)) {
        val += this[offset + i3] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i3 = 0;
      while (++i3 < byteLength2 && (mul *= 256)) {
        val += this[offset + i3] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i3 = byteLength2;
      let mul = 1;
      let val = this[offset + --i3];
      while (i3 > 0 && (mul *= 256)) {
        val += this[offset + --i3] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i3 = 0;
      this[offset] = value & 255;
      while (++i3 < byteLength2 && (mul *= 256)) {
        this[offset + i3] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i3 = byteLength2 - 1;
      let mul = 1;
      this[offset + i3] = value & 255;
      while (--i3 >= 0 && (mul *= 256)) {
        this[offset + i3] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i3 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i3 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i3] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i3 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i3] = value & 255;
      while (--i3 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i3] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i3;
      if (typeof val === "number") {
        for (i3 = start; i3 < end; ++i3) {
          this[i3] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i3 = 0; i3 < end - start; ++i3) {
          this[i3 + start] = bytes[i3 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E4(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E4("ERR_INVALID_ARG_TYPE", function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E4("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i3 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i3 >= start + 4; i3 -= 3) {
        res = `_${val.slice(i3 - 3, i3)}${res}`;
      }
      return `${val.slice(0, i3)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n2 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
          } else {
            range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
          }
        } else {
          range = `>= ${min}${n2} and <= ${max}${n2}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i3 = 0; i3 < length; ++i3) {
        codePoint = string.charCodeAt(i3);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i3 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i3 = 0; i3 < str.length; ++i3) {
        byteArray.push(str.charCodeAt(i3) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c3, hi, lo;
      const byteArray = [];
      for (let i3 = 0; i3 < str.length; ++i3) {
        if ((units -= 2) < 0)
          break;
        c3 = str.charCodeAt(i3);
        hi = c3 >> 8;
        lo = c3 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i3;
      for (i3 = 0; i3 < length; ++i3) {
        if (i3 + offset >= dst.length || i3 >= src.length)
          break;
        dst[i3 + offset] = src[i3];
      }
      return i3;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i3 = 0; i3 < 16; ++i3) {
        const i16 = i3 * 16;
        for (let j3 = 0; j3 < 16; ++j3) {
          table[i16 + j3] = alphabet[i3] + alphabet[j3];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root2.CryptoJS = factory();
      }
    })(exports2, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof __require === "function") {
          try {
            crypto2 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F3() {
          }
          return function(obj) {
            var subtype;
            F3.prototype = obj;
            subtype = new F3();
            F3.prototype = null;
            return subtype;
          };
        }();
        var C3 = {};
        var C_lib = C3.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i3 = 0; i3 < thatSigBytes; i3++) {
                var thatByte = thatWords[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
                thisWords[thisSigBytes + i3 >>> 2] |= thatByte << 24 - (thisSigBytes + i3) % 4 * 8;
              }
            } else {
              for (var j3 = 0; j3 < thatSigBytes; j3 += 4) {
                thisWords[thisSigBytes + j3 >>> 2] = thatWords[j3 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words = [];
            for (var i3 = 0; i3 < nBytes; i3 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C3.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i3 = 0; i3 < sigBytes; i3++) {
              var bite = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i3 = 0; i3 < hexStrLength; i3 += 2) {
              words[i3 >>> 3] |= parseInt(hexStr.substr(i3, 2), 16) << 24 - i3 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3++) {
              var bite = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i3 = 0; i3 < latin1StrLength; i3++) {
              words[i3 >>> 2] |= (latin1Str.charCodeAt(i3) & 255) << 24 - i3 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e3) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C3.algo = {};
        return C3;
      }(Math);
      return CryptoJS2;
    });
  }
});

// node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/crypto-js/x64-core.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function(undefined2) {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C3.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i3 = 0; i3 < x64WordsLength; i3++) {
              var x64Word = x64Words[i3];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i3 = 0; i3 < wordsLength; i3++) {
              words[i3] = words[i3].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS2;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i3 = 0; i3 < typedArrayByteLength; i3++) {
              words[i3 >>> 2] |= typedArray[i3] << 24 - i3 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS2.lib.WordArray;
    });
  }
});

// node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/crypto-js/enc-utf16.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C3.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 2) {
              var codePoint = words[i3 >>> 2] >>> 16 - i3 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i3 = 0; i3 < utf16StrLength; i3++) {
              words[i3 >>> 1] |= utf16Str.charCodeAt(i3) << 16 - i3 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 2) {
              var codePoint = swapEndian(words[i3 >>> 2] >>> 16 - i3 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i3 = 0; i3 < utf16StrLength; i3++) {
              words[i3 >>> 1] |= swapEndian(utf16Str.charCodeAt(i3) << 16 - i3 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS2.enc.Utf16;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C3.enc;
        var Base64 = C_enc.Base64 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 3) {
              var byte1 = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              var byte2 = words[i3 + 1 >>> 2] >>> 24 - (i3 + 1) % 4 * 8 & 255;
              var byte3 = words[i3 + 2 >>> 2] >>> 24 - (i3 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j3 = 0; j3 < 4 && i3 + j3 * 0.75 < sigBytes; j3++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j3) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j3 = 0; j3 < map.length; j3++) {
                reverseMap[map.charCodeAt(j3)] = j3;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i3 = 0; i3 < base64StrLength; i3++) {
            if (i3 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i3 - 1)] << i3 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i3)] >>> 6 - i3 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64;
    });
  }
});

// node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "node_modules/crypto-js/enc-base64url.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C3.enc;
        var Base64url = C_enc.Base64url = {
          stringify: function(wordArray, urlSafe = true) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i3 = 0; i3 < sigBytes; i3 += 3) {
              var byte1 = words[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255;
              var byte2 = words[i3 + 1 >>> 2] >>> 24 - (i3 + 1) % 4 * 8 & 255;
              var byte3 = words[i3 + 2 >>> 2] >>> 24 - (i3 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j3 = 0; j3 < 4 && i3 + j3 * 0.75 < sigBytes; j3++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j3) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str, urlSafe = true) {
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j3 = 0; j3 < map.length; j3++) {
                reverseMap[map.charCodeAt(j3)] = j3;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i3 = 0; i3 < base64StrLength; i3++) {
            if (i3 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i3 - 1)] << i3 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i3)] >>> 6 - i3 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64url;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function(Math2) {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C3.algo;
        var T4 = [];
        (function() {
          for (var i3 = 0; i3 < 64; i3++) {
            T4[i3] = Math2.abs(Math2.sin(i3 + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M3, offset) {
            for (var i3 = 0; i3 < 16; i3++) {
              var offset_i = offset + i3;
              var M_offset_i = M3[offset_i];
              M3[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H3 = this._hash.words;
            var M_offset_0 = M3[offset + 0];
            var M_offset_1 = M3[offset + 1];
            var M_offset_2 = M3[offset + 2];
            var M_offset_3 = M3[offset + 3];
            var M_offset_4 = M3[offset + 4];
            var M_offset_5 = M3[offset + 5];
            var M_offset_6 = M3[offset + 6];
            var M_offset_7 = M3[offset + 7];
            var M_offset_8 = M3[offset + 8];
            var M_offset_9 = M3[offset + 9];
            var M_offset_10 = M3[offset + 10];
            var M_offset_11 = M3[offset + 11];
            var M_offset_12 = M3[offset + 12];
            var M_offset_13 = M3[offset + 13];
            var M_offset_14 = M3[offset + 14];
            var M_offset_15 = M3[offset + 15];
            var a3 = H3[0];
            var b2 = H3[1];
            var c3 = H3[2];
            var d3 = H3[3];
            a3 = FF(a3, b2, c3, d3, M_offset_0, 7, T4[0]);
            d3 = FF(d3, a3, b2, c3, M_offset_1, 12, T4[1]);
            c3 = FF(c3, d3, a3, b2, M_offset_2, 17, T4[2]);
            b2 = FF(b2, c3, d3, a3, M_offset_3, 22, T4[3]);
            a3 = FF(a3, b2, c3, d3, M_offset_4, 7, T4[4]);
            d3 = FF(d3, a3, b2, c3, M_offset_5, 12, T4[5]);
            c3 = FF(c3, d3, a3, b2, M_offset_6, 17, T4[6]);
            b2 = FF(b2, c3, d3, a3, M_offset_7, 22, T4[7]);
            a3 = FF(a3, b2, c3, d3, M_offset_8, 7, T4[8]);
            d3 = FF(d3, a3, b2, c3, M_offset_9, 12, T4[9]);
            c3 = FF(c3, d3, a3, b2, M_offset_10, 17, T4[10]);
            b2 = FF(b2, c3, d3, a3, M_offset_11, 22, T4[11]);
            a3 = FF(a3, b2, c3, d3, M_offset_12, 7, T4[12]);
            d3 = FF(d3, a3, b2, c3, M_offset_13, 12, T4[13]);
            c3 = FF(c3, d3, a3, b2, M_offset_14, 17, T4[14]);
            b2 = FF(b2, c3, d3, a3, M_offset_15, 22, T4[15]);
            a3 = GG(a3, b2, c3, d3, M_offset_1, 5, T4[16]);
            d3 = GG(d3, a3, b2, c3, M_offset_6, 9, T4[17]);
            c3 = GG(c3, d3, a3, b2, M_offset_11, 14, T4[18]);
            b2 = GG(b2, c3, d3, a3, M_offset_0, 20, T4[19]);
            a3 = GG(a3, b2, c3, d3, M_offset_5, 5, T4[20]);
            d3 = GG(d3, a3, b2, c3, M_offset_10, 9, T4[21]);
            c3 = GG(c3, d3, a3, b2, M_offset_15, 14, T4[22]);
            b2 = GG(b2, c3, d3, a3, M_offset_4, 20, T4[23]);
            a3 = GG(a3, b2, c3, d3, M_offset_9, 5, T4[24]);
            d3 = GG(d3, a3, b2, c3, M_offset_14, 9, T4[25]);
            c3 = GG(c3, d3, a3, b2, M_offset_3, 14, T4[26]);
            b2 = GG(b2, c3, d3, a3, M_offset_8, 20, T4[27]);
            a3 = GG(a3, b2, c3, d3, M_offset_13, 5, T4[28]);
            d3 = GG(d3, a3, b2, c3, M_offset_2, 9, T4[29]);
            c3 = GG(c3, d3, a3, b2, M_offset_7, 14, T4[30]);
            b2 = GG(b2, c3, d3, a3, M_offset_12, 20, T4[31]);
            a3 = HH(a3, b2, c3, d3, M_offset_5, 4, T4[32]);
            d3 = HH(d3, a3, b2, c3, M_offset_8, 11, T4[33]);
            c3 = HH(c3, d3, a3, b2, M_offset_11, 16, T4[34]);
            b2 = HH(b2, c3, d3, a3, M_offset_14, 23, T4[35]);
            a3 = HH(a3, b2, c3, d3, M_offset_1, 4, T4[36]);
            d3 = HH(d3, a3, b2, c3, M_offset_4, 11, T4[37]);
            c3 = HH(c3, d3, a3, b2, M_offset_7, 16, T4[38]);
            b2 = HH(b2, c3, d3, a3, M_offset_10, 23, T4[39]);
            a3 = HH(a3, b2, c3, d3, M_offset_13, 4, T4[40]);
            d3 = HH(d3, a3, b2, c3, M_offset_0, 11, T4[41]);
            c3 = HH(c3, d3, a3, b2, M_offset_3, 16, T4[42]);
            b2 = HH(b2, c3, d3, a3, M_offset_6, 23, T4[43]);
            a3 = HH(a3, b2, c3, d3, M_offset_9, 4, T4[44]);
            d3 = HH(d3, a3, b2, c3, M_offset_12, 11, T4[45]);
            c3 = HH(c3, d3, a3, b2, M_offset_15, 16, T4[46]);
            b2 = HH(b2, c3, d3, a3, M_offset_2, 23, T4[47]);
            a3 = II(a3, b2, c3, d3, M_offset_0, 6, T4[48]);
            d3 = II(d3, a3, b2, c3, M_offset_7, 10, T4[49]);
            c3 = II(c3, d3, a3, b2, M_offset_14, 15, T4[50]);
            b2 = II(b2, c3, d3, a3, M_offset_5, 21, T4[51]);
            a3 = II(a3, b2, c3, d3, M_offset_12, 6, T4[52]);
            d3 = II(d3, a3, b2, c3, M_offset_3, 10, T4[53]);
            c3 = II(c3, d3, a3, b2, M_offset_10, 15, T4[54]);
            b2 = II(b2, c3, d3, a3, M_offset_1, 21, T4[55]);
            a3 = II(a3, b2, c3, d3, M_offset_8, 6, T4[56]);
            d3 = II(d3, a3, b2, c3, M_offset_15, 10, T4[57]);
            c3 = II(c3, d3, a3, b2, M_offset_6, 15, T4[58]);
            b2 = II(b2, c3, d3, a3, M_offset_13, 21, T4[59]);
            a3 = II(a3, b2, c3, d3, M_offset_4, 6, T4[60]);
            d3 = II(d3, a3, b2, c3, M_offset_11, 10, T4[61]);
            c3 = II(c3, d3, a3, b2, M_offset_2, 15, T4[62]);
            b2 = II(b2, c3, d3, a3, M_offset_9, 21, T4[63]);
            H3[0] = H3[0] + a3 | 0;
            H3[1] = H3[1] + b2 | 0;
            H3[2] = H3[2] + c3 | 0;
            H3[3] = H3[3] + d3 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H3 = hash.words;
            for (var i3 = 0; i3 < 4; i3++) {
              var H_i = H3[i3];
              H3[i3] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a3, b2, c3, d3, x3, s3, t3) {
          var n2 = a3 + (b2 & c3 | ~b2 & d3) + x3 + t3;
          return (n2 << s3 | n2 >>> 32 - s3) + b2;
        }
        function GG(a3, b2, c3, d3, x3, s3, t3) {
          var n2 = a3 + (b2 & d3 | c3 & ~d3) + x3 + t3;
          return (n2 << s3 | n2 >>> 32 - s3) + b2;
        }
        function HH(a3, b2, c3, d3, x3, s3, t3) {
          var n2 = a3 + (b2 ^ c3 ^ d3) + x3 + t3;
          return (n2 << s3 | n2 >>> 32 - s3) + b2;
        }
        function II(a3, b2, c3, d3, x3, s3, t3) {
          var n2 = a3 + (c3 ^ (b2 | ~d3)) + x3 + t3;
          return (n2 << s3 | n2 >>> 32 - s3) + b2;
        }
        C3.MD5 = Hasher._createHelper(MD5);
        C3.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS2.MD5;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C3.algo;
        var W2 = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M3, offset) {
            var H3 = this._hash.words;
            var a3 = H3[0];
            var b2 = H3[1];
            var c3 = H3[2];
            var d3 = H3[3];
            var e3 = H3[4];
            for (var i3 = 0; i3 < 80; i3++) {
              if (i3 < 16) {
                W2[i3] = M3[offset + i3] | 0;
              } else {
                var n2 = W2[i3 - 3] ^ W2[i3 - 8] ^ W2[i3 - 14] ^ W2[i3 - 16];
                W2[i3] = n2 << 1 | n2 >>> 31;
              }
              var t3 = (a3 << 5 | a3 >>> 27) + e3 + W2[i3];
              if (i3 < 20) {
                t3 += (b2 & c3 | ~b2 & d3) + 1518500249;
              } else if (i3 < 40) {
                t3 += (b2 ^ c3 ^ d3) + 1859775393;
              } else if (i3 < 60) {
                t3 += (b2 & c3 | b2 & d3 | c3 & d3) - 1894007588;
              } else {
                t3 += (b2 ^ c3 ^ d3) - 899497514;
              }
              e3 = d3;
              d3 = c3;
              c3 = b2 << 30 | b2 >>> 2;
              b2 = a3;
              a3 = t3;
            }
            H3[0] = H3[0] + a3 | 0;
            H3[1] = H3[1] + b2 | 0;
            H3[2] = H3[2] + c3 | 0;
            H3[3] = H3[3] + d3 | 0;
            H3[4] = H3[4] + e3 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C3.SHA1 = Hasher._createHelper(SHA1);
        C3.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS2.SHA1;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function(Math2) {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C3.algo;
        var H3 = [];
        var K3 = [];
        (function() {
          function isPrime(n3) {
            var sqrtN = Math2.sqrt(n3);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n3 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n3) {
            return (n3 - (n3 | 0)) * 4294967296 | 0;
          }
          var n2 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n2)) {
              if (nPrime < 8) {
                H3[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
              }
              K3[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
              nPrime++;
            }
            n2++;
          }
        })();
        var W2 = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H3.slice(0));
          },
          _doProcessBlock: function(M3, offset) {
            var H4 = this._hash.words;
            var a3 = H4[0];
            var b2 = H4[1];
            var c3 = H4[2];
            var d3 = H4[3];
            var e3 = H4[4];
            var f3 = H4[5];
            var g3 = H4[6];
            var h3 = H4[7];
            for (var i3 = 0; i3 < 64; i3++) {
              if (i3 < 16) {
                W2[i3] = M3[offset + i3] | 0;
              } else {
                var gamma0x = W2[i3 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W2[i3 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W2[i3] = gamma0 + W2[i3 - 7] + gamma1 + W2[i3 - 16];
              }
              var ch = e3 & f3 ^ ~e3 & g3;
              var maj = a3 & b2 ^ a3 & c3 ^ b2 & c3;
              var sigma0 = (a3 << 30 | a3 >>> 2) ^ (a3 << 19 | a3 >>> 13) ^ (a3 << 10 | a3 >>> 22);
              var sigma1 = (e3 << 26 | e3 >>> 6) ^ (e3 << 21 | e3 >>> 11) ^ (e3 << 7 | e3 >>> 25);
              var t1 = h3 + sigma1 + ch + K3[i3] + W2[i3];
              var t22 = sigma0 + maj;
              h3 = g3;
              g3 = f3;
              f3 = e3;
              e3 = d3 + t1 | 0;
              d3 = c3;
              c3 = b2;
              b2 = a3;
              a3 = t1 + t22 | 0;
            }
            H4[0] = H4[0] + a3 | 0;
            H4[1] = H4[1] + b2 | 0;
            H4[2] = H4[2] + c3 | 0;
            H4[3] = H4[3] + d3 | 0;
            H4[4] = H4[4] + e3 | 0;
            H4[5] = H4[5] + f3 | 0;
            H4[6] = H4[6] + g3 | 0;
            H4[7] = H4[7] + h3 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C3.SHA256 = Hasher._createHelper(SHA256);
        C3.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS2.SHA256;
    });
  }
});

// node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/crypto-js/sha224.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C3.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C3.SHA224 = SHA256._createHelper(SHA224);
        C3.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS2.SHA224;
    });
  }
});

// node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/crypto-js/sha512.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C3.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C3.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K3 = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W2 = [];
        (function() {
          for (var i3 = 0; i3 < 80; i3++) {
            W2[i3] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M3, offset) {
            var H3 = this._hash.words;
            var H0 = H3[0];
            var H1 = H3[1];
            var H22 = H3[2];
            var H32 = H3[3];
            var H4 = H3[4];
            var H5 = H3[5];
            var H6 = H3[6];
            var H7 = H3[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H22.high;
            var H2l = H22.low;
            var H3h = H32.high;
            var H3l = H32.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i3 = 0; i3 < 80; i3++) {
              var Wil;
              var Wih;
              var Wi = W2[i3];
              if (i3 < 16) {
                Wih = Wi.high = M3[offset + i3 * 2] | 0;
                Wil = Wi.low = M3[offset + i3 * 2 + 1] | 0;
              } else {
                var gamma0x = W2[i3 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W2[i3 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W2[i3 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W2[i3 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K3[i3];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H22.low = H2l + cl;
            H22.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H32.low = H3l + dl;
            H32.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C3.SHA512 = Hasher._createHelper(SHA512);
        C3.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS2.SHA512;
    });
  }
});

// node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/crypto-js/sha384.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_x64 = C3.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C3.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C3.SHA384 = SHA512._createHelper(SHA384);
        C3.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS2.SHA384;
    });
  }
});

// node_modules/crypto-js/sha3.js
var require_sha3 = __commonJS({
  "node_modules/crypto-js/sha3.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function(Math2) {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C3.x64;
        var X64Word = C_x64.Word;
        var C_algo = C3.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x3 = 1, y3 = 0;
          for (var t3 = 0; t3 < 24; t3++) {
            RHO_OFFSETS[x3 + 5 * y3] = (t3 + 1) * (t3 + 2) / 2 % 64;
            var newX = y3 % 5;
            var newY = (2 * x3 + 3 * y3) % 5;
            x3 = newX;
            y3 = newY;
          }
          for (var x3 = 0; x3 < 5; x3++) {
            for (var y3 = 0; y3 < 5; y3++) {
              PI_INDEXES[x3 + 5 * y3] = y3 + (2 * x3 + 3 * y3) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i3 = 0; i3 < 24; i3++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j3 = 0; j3 < 7; j3++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j3) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i3] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T4 = [];
        (function() {
          for (var i3 = 0; i3 < 25; i3++) {
            T4[i3] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i3 = 0; i3 < 25; i3++) {
              state[i3] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M3, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i3 = 0; i3 < nBlockSizeLanes; i3++) {
              var M2i = M3[offset + 2 * i3];
              var M2i1 = M3[offset + 2 * i3 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i3];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x3 = 0; x3 < 5; x3++) {
                var tMsw = 0, tLsw = 0;
                for (var y3 = 0; y3 < 5; y3++) {
                  var lane = state[x3 + 5 * y3];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T4[x3];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x3 = 0; x3 < 5; x3++) {
                var Tx4 = T4[(x3 + 4) % 5];
                var Tx1 = T4[(x3 + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y3 = 0; y3 < 5; y3++) {
                  var lane = state[x3 + 5 * y3];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T4[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T4[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x3 = 0; x3 < 5; x3++) {
                for (var y3 = 0; y3 < 5; y3++) {
                  var laneIndex = x3 + 5 * y3;
                  var lane = state[laneIndex];
                  var TLane = T4[laneIndex];
                  var Tx1Lane = T4[(x3 + 1) % 5 + 5 * y3];
                  var Tx2Lane = T4[(x3 + 2) % 5 + 5 * y3];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i3 = 0; i3 < outputLengthLanes; i3++) {
              var lane = state[i3];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i3 = 0; i3 < 25; i3++) {
              state[i3] = state[i3].clone();
            }
            return clone;
          }
        });
        C3.SHA3 = Hasher._createHelper(SHA3);
        C3.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS2.SHA3;
    });
  }
});

// node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/crypto-js/ripemd160.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function(Math2) {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C3.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M3, offset) {
            for (var i3 = 0; i3 < 16; i3++) {
              var offset_i = offset + i3;
              var M_offset_i = M3[offset_i];
              M3[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H3 = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H3[0];
            br = bl = H3[1];
            cr = cl = H3[2];
            dr = dl = H3[3];
            er = el = H3[4];
            var t3;
            for (var i3 = 0; i3 < 80; i3 += 1) {
              t3 = al + M3[offset + zl[i3]] | 0;
              if (i3 < 16) {
                t3 += f1(bl, cl, dl) + hl[0];
              } else if (i3 < 32) {
                t3 += f22(bl, cl, dl) + hl[1];
              } else if (i3 < 48) {
                t3 += f3(bl, cl, dl) + hl[2];
              } else if (i3 < 64) {
                t3 += f4(bl, cl, dl) + hl[3];
              } else {
                t3 += f5(bl, cl, dl) + hl[4];
              }
              t3 = t3 | 0;
              t3 = rotl(t3, sl[i3]);
              t3 = t3 + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t3;
              t3 = ar + M3[offset + zr[i3]] | 0;
              if (i3 < 16) {
                t3 += f5(br, cr, dr) + hr[0];
              } else if (i3 < 32) {
                t3 += f4(br, cr, dr) + hr[1];
              } else if (i3 < 48) {
                t3 += f3(br, cr, dr) + hr[2];
              } else if (i3 < 64) {
                t3 += f22(br, cr, dr) + hr[3];
              } else {
                t3 += f1(br, cr, dr) + hr[4];
              }
              t3 = t3 | 0;
              t3 = rotl(t3, sr[i3]);
              t3 = t3 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t3;
            }
            t3 = H3[1] + cl + dr | 0;
            H3[1] = H3[2] + dl + er | 0;
            H3[2] = H3[3] + el + ar | 0;
            H3[3] = H3[4] + al + br | 0;
            H3[4] = H3[0] + bl + cr | 0;
            H3[0] = t3;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H3 = hash.words;
            for (var i3 = 0; i3 < 5; i3++) {
              var H_i = H3[i3];
              H3[i3] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x3, y3, z3) {
          return x3 ^ y3 ^ z3;
        }
        function f22(x3, y3, z3) {
          return x3 & y3 | ~x3 & z3;
        }
        function f3(x3, y3, z3) {
          return (x3 | ~y3) ^ z3;
        }
        function f4(x3, y3, z3) {
          return x3 & z3 | y3 & ~z3;
        }
        function f5(x3, y3, z3) {
          return x3 ^ (y3 | ~z3);
        }
        function rotl(x3, n2) {
          return x3 << n2 | x3 >>> 32 - n2;
        }
        C3.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C3.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS2.RIPEMD160;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports2, module2) {
    ;
    (function(root2, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var Base = C_lib.Base;
        var C_enc = C3.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C3.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i3 = 0; i3 < hasherBlockSize; i3++) {
              oKeyWords[i3] ^= 1549556828;
              iKeyWords[i3] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/crypto-js/pbkdf2.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C3.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA1,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i3 = 1; i3 < iterations; i3++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j3 = 0; j3 < blockWordsLength; j3++) {
                  blockWords[j3] ^= intermediateWords[j3];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C3.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.PBKDF2;
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C3.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i3 = 1; i3 < iterations; i3++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C3.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.lib.Cipher || function(undefined2) {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C3.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C3.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C3.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset + i3] ^= block[i3];
            }
          }
          return CBC2;
        }();
        var C_pad = C3.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i3 = 0; i3 < nPaddingBytes; i3 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C3.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C3.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/crypto-js/mode-cfb.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.mode.CFB = function() {
        var CFB = CryptoJS2.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i3 = 0; i3 < blockSize; i3++) {
            words[offset + i3] ^= keystream[i3];
          }
        }
        return CFB;
      }();
      return CryptoJS2.mode.CFB;
    });
  }
});

// node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/crypto-js/mode-ctr.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.mode.CTR = function() {
        var CTR = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset + i3] ^= keystream[i3];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS2.mode.CTR;
    });
  }
});

// node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/crypto-js/mode-ctr-gladman.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset + i3] ^= keystream[i3];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS2.mode.CTRGladman;
    });
  }
});

// node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/crypto-js/mode-ofb.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.mode.OFB = function() {
        var OFB = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i3 = 0; i3 < blockSize; i3++) {
              words[offset + i3] ^= keystream[i3];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS2.mode.OFB;
    });
  }
});

// node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/crypto-js/mode-ecb.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.mode.ECB = function() {
        var ECB = CryptoJS2.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS2.mode.ECB;
    });
  }
});

// node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/crypto-js/pad-ansix923.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Ansix923;
    });
  }
});

// node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/crypto-js/pad-iso10126.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Iso10126;
    });
  }
});

// node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/crypto-js/pad-iso97971.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
          CryptoJS2.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS2.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS2.pad.Iso97971;
    });
  }
});

// node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/crypto-js/pad-zeropadding.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i3 = data.sigBytes - 1;
          for (var i3 = data.sigBytes - 1; i3 >= 0; i3--) {
            if (dataWords[i3 >>> 2] >>> 24 - i3 % 4 * 8 & 255) {
              data.sigBytes = i3 + 1;
              break;
            }
          }
        }
      };
      return CryptoJS2.pad.ZeroPadding;
    });
  }
});

// node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/crypto-js/pad-nopadding.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      CryptoJS2.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS2.pad.NoPadding;
    });
  }
});

// node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/crypto-js/format-hex.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function(undefined2) {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C3.enc;
        var Hex = C_enc.Hex;
        var C_format = C3.format;
        var HexFormatter = C_format.Hex = {
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS2.format.Hex;
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/crypto-js/aes.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C3.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d3 = [];
          for (var i3 = 0; i3 < 256; i3++) {
            if (i3 < 128) {
              d3[i3] = i3 << 1;
            } else {
              d3[i3] = i3 << 1 ^ 283;
            }
          }
          var x3 = 0;
          var xi = 0;
          for (var i3 = 0; i3 < 256; i3++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x3] = sx;
            INV_SBOX[sx] = x3;
            var x22 = d3[x3];
            var x4 = d3[x22];
            var x8 = d3[x4];
            var t3 = d3[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x3] = t3 << 24 | t3 >>> 8;
            SUB_MIX_1[x3] = t3 << 16 | t3 >>> 16;
            SUB_MIX_2[x3] = t3 << 8 | t3 >>> 24;
            SUB_MIX_3[x3] = t3;
            var t3 = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x3 * 16843008;
            INV_SUB_MIX_0[sx] = t3 << 24 | t3 >>> 8;
            INV_SUB_MIX_1[sx] = t3 << 16 | t3 >>> 16;
            INV_SUB_MIX_2[sx] = t3 << 8 | t3 >>> 24;
            INV_SUB_MIX_3[sx] = t3;
            if (!x3) {
              x3 = xi = 1;
            } else {
              x3 = x22 ^ d3[d3[d3[x8 ^ x22]]];
              xi ^= d3[d3[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t3;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t3 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t3 = t3 << 8 | t3 >>> 24;
                  t3 = SBOX[t3 >>> 24] << 24 | SBOX[t3 >>> 16 & 255] << 16 | SBOX[t3 >>> 8 & 255] << 8 | SBOX[t3 & 255];
                  t3 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t3 = SBOX[t3 >>> 24] << 24 | SBOX[t3 >>> 16 & 255] << 16 | SBOX[t3 >>> 8 & 255] << 8 | SBOX[t3 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t3;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t3 = keySchedule[ksRow];
              } else {
                var t3 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t3;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t3 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t3 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t3 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t3 & 255]];
              }
            }
          },
          encryptBlock: function(M3, offset) {
            this._doCryptBlock(M3, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M3, offset) {
            var t3 = M3[offset + 1];
            M3[offset + 1] = M3[offset + 3];
            M3[offset + 3] = t3;
            this._doCryptBlock(M3, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t3 = M3[offset + 1];
            M3[offset + 1] = M3[offset + 3];
            M3[offset + 3] = t3;
          },
          _doCryptBlock: function(M3, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M3[offset] ^ keySchedule[0];
            var s1 = M3[offset + 1] ^ keySchedule[1];
            var s22 = M3[offset + 2] ^ keySchedule[2];
            var s3 = M3[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s22 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s22 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t22 = SUB_MIX_02[s22 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s22 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s22 = t22;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s22 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s22 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t22 = (SBOX2[s22 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s22 & 255]) ^ keySchedule[ksRow++];
            M3[offset] = t0;
            M3[offset + 1] = t1;
            M3[offset + 2] = t22;
            M3[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C3.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS2.AES;
    });
  }
});

// node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/crypto-js/tripledes.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C3.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i3 = 0; i3 < 56; i3++) {
              var keyBitPos = PC1[i3] - 1;
              keyBits[i3] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i3 = 0; i3 < 24; i3++) {
                subKey[i3 / 6 | 0] |= keyBits[(PC2[i3] - 1 + bitShift) % 28] << 31 - i3 % 6;
                subKey[4 + (i3 / 6 | 0)] |= keyBits[28 + (PC2[i3 + 24] - 1 + bitShift) % 28] << 31 - i3 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i3 = 1; i3 < 7; i3++) {
                subKey[i3] = subKey[i3] >>> (i3 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i3 = 0; i3 < 16; i3++) {
              invSubKeys[i3] = subKeys[15 - i3];
            }
          },
          encryptBlock: function(M3, offset) {
            this._doCryptBlock(M3, offset, this._subKeys);
          },
          decryptBlock: function(M3, offset) {
            this._doCryptBlock(M3, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M3, offset, subKeys) {
            this._lBlock = M3[offset];
            this._rBlock = M3[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f3 = 0;
              for (var i3 = 0; i3 < 8; i3++) {
                f3 |= SBOX_P[i3][((rBlock ^ subKey[i3]) & SBOX_MASK[i3]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f3;
            }
            var t3 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t3;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M3[offset] = this._lBlock;
            M3[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t3 = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t3;
          this._lBlock ^= t3 << offset;
        }
        function exchangeRL(offset, mask) {
          var t3 = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t3;
          this._rBlock ^= t3 << offset;
        }
        C3.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M3, offset) {
            this._des1.encryptBlock(M3, offset);
            this._des2.decryptBlock(M3, offset);
            this._des3.encryptBlock(M3, offset);
          },
          decryptBlock: function(M3, offset) {
            this._des3.decryptBlock(M3, offset);
            this._des2.encryptBlock(M3, offset);
            this._des1.decryptBlock(M3, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C3.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS2.TripleDES;
    });
  }
});

// node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/crypto-js/rc4.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C3.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S2 = this._S = [];
            for (var i3 = 0; i3 < 256; i3++) {
              S2[i3] = i3;
            }
            for (var i3 = 0, j3 = 0; i3 < 256; i3++) {
              var keyByteIndex = i3 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j3 = (j3 + S2[i3] + keyByte) % 256;
              var t3 = S2[i3];
              S2[i3] = S2[j3];
              S2[j3] = t3;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M3, offset) {
            M3[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S2 = this._S;
          var i3 = this._i;
          var j3 = this._j;
          var keystreamWord = 0;
          for (var n2 = 0; n2 < 4; n2++) {
            i3 = (i3 + 1) % 256;
            j3 = (j3 + S2[i3]) % 256;
            var t3 = S2[i3];
            S2[i3] = S2[j3];
            S2[j3] = t3;
            keystreamWord |= S2[(S2[i3] + S2[j3]) % 256] << 24 - n2 * 8;
          }
          this._i = i3;
          this._j = j3;
          return keystreamWord;
        }
        C3.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i3 = this.cfg.drop; i3 > 0; i3--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C3.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS2.RC4;
    });
  }
});

// node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/crypto-js/rabbit.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C3.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K3 = this._key.words;
            var iv = this.cfg.iv;
            for (var i3 = 0; i3 < 4; i3++) {
              K3[i3] = (K3[i3] << 8 | K3[i3] >>> 24) & 16711935 | (K3[i3] << 24 | K3[i3] >>> 8) & 4278255360;
            }
            var X2 = this._X = [
              K3[0],
              K3[3] << 16 | K3[2] >>> 16,
              K3[1],
              K3[0] << 16 | K3[3] >>> 16,
              K3[2],
              K3[1] << 16 | K3[0] >>> 16,
              K3[3],
              K3[2] << 16 | K3[1] >>> 16
            ];
            var C4 = this._C = [
              K3[2] << 16 | K3[2] >>> 16,
              K3[0] & 4294901760 | K3[1] & 65535,
              K3[3] << 16 | K3[3] >>> 16,
              K3[1] & 4294901760 | K3[2] & 65535,
              K3[0] << 16 | K3[0] >>> 16,
              K3[2] & 4294901760 | K3[3] & 65535,
              K3[1] << 16 | K3[1] >>> 16,
              K3[3] & 4294901760 | K3[0] & 65535
            ];
            this._b = 0;
            for (var i3 = 0; i3 < 4; i3++) {
              nextState.call(this);
            }
            for (var i3 = 0; i3 < 8; i3++) {
              C4[i3] ^= X2[i3 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i0 & 65535;
              C4[0] ^= i0;
              C4[1] ^= i1;
              C4[2] ^= i22;
              C4[3] ^= i32;
              C4[4] ^= i0;
              C4[5] ^= i1;
              C4[6] ^= i22;
              C4[7] ^= i32;
              for (var i3 = 0; i3 < 4; i3++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M3, offset) {
            var X2 = this._X;
            nextState.call(this);
            S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i3 = 0; i3 < 4; i3++) {
              S2[i3] = (S2[i3] << 8 | S2[i3] >>> 24) & 16711935 | (S2[i3] << 24 | S2[i3] >>> 8) & 4278255360;
              M3[offset + i3] ^= S2[i3];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C4 = this._C;
          for (var i3 = 0; i3 < 8; i3++) {
            C_[i3] = C4[i3];
          }
          C4[0] = C4[0] + 1295307597 + this._b | 0;
          C4[1] = C4[1] + 3545052371 + (C4[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C4[2] = C4[2] + 886263092 + (C4[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C4[3] = C4[3] + 1295307597 + (C4[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C4[4] = C4[4] + 3545052371 + (C4[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C4[5] = C4[5] + 886263092 + (C4[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C4[6] = C4[6] + 1295307597 + (C4[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C4[7] = C4[7] + 3545052371 + (C4[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C4[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i3 = 0; i3 < 8; i3++) {
            var gx = X2[i3] + C4[i3];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i3] = gh ^ gl;
          }
          X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C3.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS2.Rabbit;
    });
  }
});

// node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/crypto-js/rabbit-legacy.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function() {
        var C3 = CryptoJS2;
        var C_lib = C3.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C3.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K3 = this._key.words;
            var iv = this.cfg.iv;
            var X2 = this._X = [
              K3[0],
              K3[3] << 16 | K3[2] >>> 16,
              K3[1],
              K3[0] << 16 | K3[3] >>> 16,
              K3[2],
              K3[1] << 16 | K3[0] >>> 16,
              K3[3],
              K3[2] << 16 | K3[1] >>> 16
            ];
            var C4 = this._C = [
              K3[2] << 16 | K3[2] >>> 16,
              K3[0] & 4294901760 | K3[1] & 65535,
              K3[3] << 16 | K3[3] >>> 16,
              K3[1] & 4294901760 | K3[2] & 65535,
              K3[0] << 16 | K3[0] >>> 16,
              K3[2] & 4294901760 | K3[3] & 65535,
              K3[1] << 16 | K3[1] >>> 16,
              K3[3] & 4294901760 | K3[0] & 65535
            ];
            this._b = 0;
            for (var i3 = 0; i3 < 4; i3++) {
              nextState.call(this);
            }
            for (var i3 = 0; i3 < 8; i3++) {
              C4[i3] ^= X2[i3 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i32 = i22 << 16 | i0 & 65535;
              C4[0] ^= i0;
              C4[1] ^= i1;
              C4[2] ^= i22;
              C4[3] ^= i32;
              C4[4] ^= i0;
              C4[5] ^= i1;
              C4[6] ^= i22;
              C4[7] ^= i32;
              for (var i3 = 0; i3 < 4; i3++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M3, offset) {
            var X2 = this._X;
            nextState.call(this);
            S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i3 = 0; i3 < 4; i3++) {
              S2[i3] = (S2[i3] << 8 | S2[i3] >>> 24) & 16711935 | (S2[i3] << 24 | S2[i3] >>> 8) & 4278255360;
              M3[offset + i3] ^= S2[i3];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C4 = this._C;
          for (var i3 = 0; i3 < 8; i3++) {
            C_[i3] = C4[i3];
          }
          C4[0] = C4[0] + 1295307597 + this._b | 0;
          C4[1] = C4[1] + 3545052371 + (C4[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C4[2] = C4[2] + 886263092 + (C4[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C4[3] = C4[3] + 1295307597 + (C4[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C4[4] = C4[4] + 3545052371 + (C4[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C4[5] = C4[5] + 886263092 + (C4[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C4[6] = C4[6] + 1295307597 + (C4[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C4[7] = C4[7] + 3545052371 + (C4[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C4[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i3 = 0; i3 < 8; i3++) {
            var gx = X2[i3] + C4[i3];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i3] = gh ^ gl;
          }
          X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C3.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS2.RabbitLegacy;
    });
  }
});

// node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/crypto-js/index.js"(exports2, module2) {
    ;
    (function(root2, factory, undef) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
      } else {
        root2.CryptoJS = factory(root2.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      return CryptoJS2;
    });
  }
});

// node_modules/algosdk/dist/browser/algosdk.min.js
var require_algosdk_min = __commonJS({
  "node_modules/algosdk/dist/browser/algosdk.min.js"(exports, module) {
    !function(e3, t3) {
      typeof exports == "object" && typeof module == "object" ? module.exports = t3() : typeof define == "function" && define.amd ? define([], t3) : typeof exports == "object" ? exports.algosdk = t3() : e3.algosdk = t3();
    }(self, function() {
      return (() => {
        var __webpack_modules__ = { 5406: function(e3) {
          e3.exports = function(e4) {
            var t3 = {};
            function r3(n2) {
              if (t3[n2])
                return t3[n2].exports;
              var o3 = t3[n2] = { i: n2, l: false, exports: {} };
              return e4[n2].call(o3.exports, o3, o3.exports, r3), o3.l = true, o3.exports;
            }
            return r3.m = e4, r3.c = t3, r3.d = function(e5, t4, n2) {
              r3.o(e5, t4) || Object.defineProperty(e5, t4, { enumerable: true, get: n2 });
            }, r3.r = function(e5) {
              typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e5, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e5, "__esModule", { value: true });
            }, r3.t = function(e5, t4) {
              if (1 & t4 && (e5 = r3(e5)), 8 & t4)
                return e5;
              if (4 & t4 && typeof e5 == "object" && e5 && e5.__esModule)
                return e5;
              var n2 = /* @__PURE__ */ Object.create(null);
              if (r3.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: e5 }), 2 & t4 && typeof e5 != "string")
                for (var o3 in e5)
                  r3.d(n2, o3, function(t5) {
                    return e5[t5];
                  }.bind(null, o3));
              return n2;
            }, r3.n = function(e5) {
              var t4 = e5 && e5.__esModule ? function() {
                return e5.default;
              } : function() {
                return e5;
              };
              return r3.d(t4, "a", t4), t4;
            }, r3.o = function(e5, t4) {
              return Object.prototype.hasOwnProperty.call(e5, t4);
            }, r3.p = "", r3(r3.s = 0);
          }([function(e4, t3, r3) {
            "use strict";
            r3.r(t3), r3.d(t3, "encode", function() {
              return U2;
            }), r3.d(t3, "decode", function() {
              return H3;
            }), r3.d(t3, "decodeAsync", function() {
              return W2;
            }), r3.d(t3, "decodeArrayStream", function() {
              return X2;
            }), r3.d(t3, "decodeStream", function() {
              return Y2;
            }), r3.d(t3, "Decoder", function() {
              return j3;
            }), r3.d(t3, "Encoder", function() {
              return _4;
            }), r3.d(t3, "ExtensionCodec", function() {
              return S2;
            }), r3.d(t3, "ExtData", function() {
              return f3;
            }), r3.d(t3, "EXT_TIMESTAMP", function() {
              return y3;
            }), r3.d(t3, "encodeDateToTimeSpec", function() {
              return b2;
            }), r3.d(t3, "encodeTimeSpecToTimestamp", function() {
              return m3;
            }), r3.d(t3, "decodeTimestampToTimeSpec", function() {
              return w4;
            }), r3.d(t3, "encodeTimestampExtension", function() {
              return A4;
            }), r3.d(t3, "decodeTimestampExtension", function() {
              return v3;
            });
            var n2 = function(e5, t4) {
              var r4 = typeof Symbol == "function" && e5[Symbol.iterator];
              if (!r4)
                return e5;
              var n3, o4, s4 = r4.call(e5), i4 = [];
              try {
                for (; (t4 === void 0 || t4-- > 0) && !(n3 = s4.next()).done; )
                  i4.push(n3.value);
              } catch (e6) {
                o4 = { error: e6 };
              } finally {
                try {
                  n3 && !n3.done && (r4 = s4.return) && r4.call(s4);
                } finally {
                  if (o4)
                    throw o4.error;
                }
              }
              return i4;
            }, o3 = function() {
              for (var e5 = [], t4 = 0; t4 < arguments.length; t4++)
                e5 = e5.concat(n2(arguments[t4]));
              return e5;
            }, s3 = typeof process != "undefined" && typeof TextEncoder != "undefined" && typeof TextDecoder != "undefined";
            function i3(e5) {
              for (var t4 = e5.length, r4 = 0, n3 = 0; n3 < t4; ) {
                var o4 = e5.charCodeAt(n3++);
                if ((4294967168 & o4) != 0)
                  if ((4294965248 & o4) == 0)
                    r4 += 2;
                  else {
                    if (o4 >= 55296 && o4 <= 56319 && n3 < t4) {
                      var s4 = e5.charCodeAt(n3);
                      (64512 & s4) == 56320 && (++n3, o4 = ((1023 & o4) << 10) + (1023 & s4) + 65536);
                    }
                    r4 += (4294901760 & o4) == 0 ? 3 : 4;
                  }
                else
                  r4++;
              }
              return r4;
            }
            var a3 = s3 ? new TextEncoder() : void 0, c3 = typeof process != "undefined" ? 200 : 0, u3 = (a3 == null ? void 0 : a3.encodeInto) ? function(e5, t4, r4) {
              a3.encodeInto(e5, t4.subarray(r4));
            } : function(e5, t4, r4) {
              t4.set(a3.encode(e5), r4);
            };
            function l3(e5, t4, r4) {
              for (var n3 = t4, s4 = n3 + r4, i4 = [], a4 = ""; n3 < s4; ) {
                var c4 = e5[n3++];
                if ((128 & c4) == 0)
                  i4.push(c4);
                else if ((224 & c4) == 192) {
                  var u4 = 63 & e5[n3++];
                  i4.push((31 & c4) << 6 | u4);
                } else if ((240 & c4) == 224) {
                  u4 = 63 & e5[n3++];
                  var l4 = 63 & e5[n3++];
                  i4.push((31 & c4) << 12 | u4 << 6 | l4);
                } else if ((248 & c4) == 240) {
                  var h4 = (7 & c4) << 18 | (u4 = 63 & e5[n3++]) << 12 | (l4 = 63 & e5[n3++]) << 6 | 63 & e5[n3++];
                  h4 > 65535 && (h4 -= 65536, i4.push(h4 >>> 10 & 1023 | 55296), h4 = 56320 | 1023 & h4), i4.push(h4);
                } else
                  i4.push(c4);
                i4.length >= 4096 && (a4 += String.fromCharCode.apply(String, o3(i4)), i4.length = 0);
              }
              return i4.length > 0 && (a4 += String.fromCharCode.apply(String, o3(i4))), a4;
            }
            var h3 = s3 ? new TextDecoder() : null, p3 = typeof process != "undefined" ? 200 : 0, f3 = function(e5, t4) {
              this.type = e5, this.data = t4;
            };
            function d3(e5, t4, r4) {
              var n3 = Math.floor(r4 / 4294967296), o4 = r4;
              e5.setUint32(t4, n3), e5.setUint32(t4 + 4, o4);
            }
            function g3(e5, t4) {
              var r4 = e5.getInt32(t4), n3 = e5.getUint32(t4 + 4), o4 = r4 < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || r4 === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && n3 === 0, s4 = r4 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
              return o4 || s4 ? BigInt(r4) * BigInt(4294967296) + BigInt(n3) : 4294967296 * r4 + n3;
            }
            var y3 = -1;
            function m3(e5) {
              var t4, r4 = e5.sec, n3 = e5.nsec;
              if (r4 >= 0 && n3 >= 0 && r4 <= 17179869183) {
                if (n3 === 0 && r4 <= 4294967295) {
                  var o4 = new Uint8Array(4);
                  return (t4 = new DataView(o4.buffer)).setUint32(0, r4), o4;
                }
                var s4 = r4 / 4294967296, i4 = 4294967295 & r4;
                return o4 = new Uint8Array(8), (t4 = new DataView(o4.buffer)).setUint32(0, n3 << 2 | 3 & s4), t4.setUint32(4, i4), o4;
              }
              return o4 = new Uint8Array(12), (t4 = new DataView(o4.buffer)).setUint32(0, n3), d3(t4, 4, r4), o4;
            }
            function b2(e5) {
              var t4 = e5.getTime(), r4 = Math.floor(t4 / 1e3), n3 = 1e6 * (t4 - 1e3 * r4), o4 = Math.floor(n3 / 1e9);
              return { sec: r4 + o4, nsec: n3 - 1e9 * o4 };
            }
            function A4(e5) {
              return e5 instanceof Date ? m3(b2(e5)) : null;
            }
            function w4(e5) {
              var t4 = new DataView(e5.buffer, e5.byteOffset, e5.byteLength);
              switch (e5.byteLength) {
                case 4:
                  return { sec: t4.getUint32(0), nsec: 0 };
                case 8:
                  var r4 = t4.getUint32(0);
                  return { sec: 4294967296 * (3 & r4) + t4.getUint32(4), nsec: r4 >>> 2 };
                case 12:
                  return { sec: g3(t4, 4), nsec: t4.getUint32(0) };
                default:
                  throw new Error("Unrecognized data size for timestamp: " + e5.length);
              }
            }
            function v3(e5) {
              var t4 = w4(e5);
              return new Date(1e3 * t4.sec + t4.nsec / 1e6);
            }
            var x3 = { type: y3, encode: A4, decode: v3 }, S2 = function() {
              function e5() {
                this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(x3);
              }
              return e5.prototype.register = function(e6) {
                var t4 = e6.type, r4 = e6.encode, n3 = e6.decode;
                if (t4 >= 0)
                  this.encoders[t4] = r4, this.decoders[t4] = n3;
                else {
                  var o4 = 1 + t4;
                  this.builtInEncoders[o4] = r4, this.builtInDecoders[o4] = n3;
                }
              }, e5.prototype.tryToEncode = function(e6, t4) {
                for (var r4 = 0; r4 < this.builtInEncoders.length; r4++)
                  if ((n3 = this.builtInEncoders[r4]) != null && (o4 = n3(e6, t4)) != null)
                    return new f3(-1 - r4, o4);
                for (r4 = 0; r4 < this.encoders.length; r4++) {
                  var n3, o4;
                  if ((n3 = this.encoders[r4]) != null && (o4 = n3(e6, t4)) != null)
                    return new f3(r4, o4);
                }
                return e6 instanceof f3 ? e6 : null;
              }, e5.prototype.decode = function(e6, t4, r4) {
                var n3 = t4 < 0 ? this.builtInDecoders[-1 - t4] : this.decoders[t4];
                return n3 ? n3(e6, t4, r4) : new f3(t4, e6);
              }, e5.defaultCodec = new e5(), e5;
            }();
            function E4(e5) {
              return e5 instanceof Uint8Array ? e5 : ArrayBuffer.isView(e5) ? new Uint8Array(e5.buffer, e5.byteOffset, e5.byteLength) : e5 instanceof ArrayBuffer ? new Uint8Array(e5) : Uint8Array.from(e5);
            }
            var T4 = function(e5) {
              var t4 = typeof Symbol == "function" && Symbol.iterator, r4 = t4 && e5[t4], n3 = 0;
              if (r4)
                return r4.call(e5);
              if (e5 && typeof e5.length == "number")
                return { next: function() {
                  return e5 && n3 >= e5.length && (e5 = void 0), { value: e5 && e5[n3++], done: !e5 };
                } };
              throw new TypeError(t4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }, _4 = function() {
              function e5(e6, t4, r4, n3, o4, s4, i4, a4) {
                e6 === void 0 && (e6 = S2.defaultCodec), t4 === void 0 && (t4 = void 0), r4 === void 0 && (r4 = 100), n3 === void 0 && (n3 = 2048), o4 === void 0 && (o4 = false), s4 === void 0 && (s4 = false), i4 === void 0 && (i4 = false), a4 === void 0 && (a4 = false), this.extensionCodec = e6, this.context = t4, this.maxDepth = r4, this.initialBufferSize = n3, this.sortKeys = o4, this.forceFloat32 = s4, this.ignoreUndefined = i4, this.forceIntegerToFloat = a4, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
              }
              return e5.prototype.getUint8Array = function() {
                return this.bytes.subarray(0, this.pos);
              }, e5.prototype.reinitializeState = function() {
                this.pos = 0;
              }, e5.prototype.encode = function(e6) {
                return this.reinitializeState(), this.doEncode(e6, 1), this.getUint8Array();
              }, e5.prototype.doEncode = function(e6, t4) {
                if (t4 > this.maxDepth)
                  throw new Error("Too deep objects in depth " + t4);
                e6 == null ? this.encodeNil() : typeof e6 == "boolean" ? this.encodeBoolean(e6) : typeof e6 == "number" ? this.encodeNumber(e6) : typeof e6 == "string" ? this.encodeString(e6) : typeof e6 == "bigint" ? this.encodebigint(e6) : this.encodeObject(e6, t4);
              }, e5.prototype.ensureBufferSizeToWrite = function(e6) {
                var t4 = this.pos + e6;
                this.view.byteLength < t4 && this.resizeBuffer(2 * t4);
              }, e5.prototype.resizeBuffer = function(e6) {
                var t4 = new ArrayBuffer(e6), r4 = new Uint8Array(t4), n3 = new DataView(t4);
                r4.set(this.bytes), this.view = n3, this.bytes = r4;
              }, e5.prototype.encodeNil = function() {
                this.writeU8(192);
              }, e5.prototype.encodeBoolean = function(e6) {
                e6 === false ? this.writeU8(194) : this.writeU8(195);
              }, e5.prototype.encodeNumber = function(e6) {
                Number.isSafeInteger(e6) && !this.forceIntegerToFloat ? e6 >= 0 ? e6 < 128 ? this.writeU8(e6) : e6 < 256 ? (this.writeU8(204), this.writeU8(e6)) : e6 < 65536 ? (this.writeU8(205), this.writeU16(e6)) : e6 < 4294967296 ? (this.writeU8(206), this.writeU32(e6)) : (this.writeU8(207), this.writeU64(e6)) : e6 >= -32 ? this.writeU8(224 | e6 + 32) : e6 >= -128 ? (this.writeU8(208), this.writeI8(e6)) : e6 >= -32768 ? (this.writeU8(209), this.writeI16(e6)) : e6 >= -2147483648 ? (this.writeU8(210), this.writeI32(e6)) : (this.writeU8(211), this.writeI64(e6)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(e6)) : (this.writeU8(203), this.writeF64(e6));
              }, e5.prototype.encodebigint = function(e6) {
                e6 >= BigInt(0) ? e6 < BigInt(128) ? this.writeU8(Number(e6)) : e6 < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(e6))) : e6 < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(e6))) : e6 < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(e6))) : (this.writeU8(207), this.writeBig64(e6)) : e6 >= BigInt(-32) ? this.writeU8(224 | Number(e6) + 32) : e6 >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(e6))) : e6 >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(e6))) : e6 >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(e6))) : (this.writeU8(211), this.writeBig64(e6));
              }, e5.prototype.writeStringHeader = function(e6) {
                if (e6 < 32)
                  this.writeU8(160 + e6);
                else if (e6 < 256)
                  this.writeU8(217), this.writeU8(e6);
                else if (e6 < 65536)
                  this.writeU8(218), this.writeU16(e6);
                else {
                  if (!(e6 < 4294967296))
                    throw new Error("Too long string: " + e6 + " bytes in UTF-8");
                  this.writeU8(219), this.writeU32(e6);
                }
              }, e5.prototype.encodeString = function(e6) {
                var t4 = e6.length;
                if (s3 && t4 > c3) {
                  var r4 = i3(e6);
                  this.ensureBufferSizeToWrite(5 + r4), this.writeStringHeader(r4), u3(e6, this.bytes, this.pos), this.pos += r4;
                } else
                  r4 = i3(e6), this.ensureBufferSizeToWrite(5 + r4), this.writeStringHeader(r4), function(e7, t5, r5) {
                    for (var n3 = e7.length, o4 = r5, s4 = 0; s4 < n3; ) {
                      var i4 = e7.charCodeAt(s4++);
                      if ((4294967168 & i4) != 0) {
                        if ((4294965248 & i4) == 0)
                          t5[o4++] = i4 >> 6 & 31 | 192;
                        else {
                          if (i4 >= 55296 && i4 <= 56319 && s4 < n3) {
                            var a4 = e7.charCodeAt(s4);
                            (64512 & a4) == 56320 && (++s4, i4 = ((1023 & i4) << 10) + (1023 & a4) + 65536);
                          }
                          (4294901760 & i4) == 0 ? (t5[o4++] = i4 >> 12 & 15 | 224, t5[o4++] = i4 >> 6 & 63 | 128) : (t5[o4++] = i4 >> 18 & 7 | 240, t5[o4++] = i4 >> 12 & 63 | 128, t5[o4++] = i4 >> 6 & 63 | 128);
                        }
                        t5[o4++] = 63 & i4 | 128;
                      } else
                        t5[o4++] = i4;
                    }
                  }(e6, this.bytes, this.pos), this.pos += r4;
              }, e5.prototype.encodeObject = function(e6, t4) {
                var r4 = this.extensionCodec.tryToEncode(e6, this.context);
                if (r4 != null)
                  this.encodeExtension(r4);
                else if (Array.isArray(e6))
                  this.encodeArray(e6, t4);
                else if (ArrayBuffer.isView(e6))
                  this.encodeBinary(e6);
                else {
                  if (typeof e6 != "object")
                    throw new Error("Unrecognized object: " + Object.prototype.toString.apply(e6));
                  this.encodeMap(e6, t4);
                }
              }, e5.prototype.encodeBinary = function(e6) {
                var t4 = e6.byteLength;
                if (t4 < 256)
                  this.writeU8(196), this.writeU8(t4);
                else if (t4 < 65536)
                  this.writeU8(197), this.writeU16(t4);
                else {
                  if (!(t4 < 4294967296))
                    throw new Error("Too large binary: " + t4);
                  this.writeU8(198), this.writeU32(t4);
                }
                var r4 = E4(e6);
                this.writeU8a(r4);
              }, e5.prototype.encodeArray = function(e6, t4) {
                var r4, n3, o4 = e6.length;
                if (o4 < 16)
                  this.writeU8(144 + o4);
                else if (o4 < 65536)
                  this.writeU8(220), this.writeU16(o4);
                else {
                  if (!(o4 < 4294967296))
                    throw new Error("Too large array: " + o4);
                  this.writeU8(221), this.writeU32(o4);
                }
                try {
                  for (var s4 = T4(e6), i4 = s4.next(); !i4.done; i4 = s4.next()) {
                    var a4 = i4.value;
                    this.doEncode(a4, t4 + 1);
                  }
                } catch (e7) {
                  r4 = { error: e7 };
                } finally {
                  try {
                    i4 && !i4.done && (n3 = s4.return) && n3.call(s4);
                  } finally {
                    if (r4)
                      throw r4.error;
                  }
                }
              }, e5.prototype.countWithoutUndefined = function(e6, t4) {
                var r4, n3, o4 = 0;
                try {
                  for (var s4 = T4(t4), i4 = s4.next(); !i4.done; i4 = s4.next())
                    e6[i4.value] !== void 0 && o4++;
                } catch (e7) {
                  r4 = { error: e7 };
                } finally {
                  try {
                    i4 && !i4.done && (n3 = s4.return) && n3.call(s4);
                  } finally {
                    if (r4)
                      throw r4.error;
                  }
                }
                return o4;
              }, e5.prototype.encodeMap = function(e6, t4) {
                var r4, n3, o4 = Object.keys(e6);
                this.sortKeys && o4.sort();
                var s4 = this.ignoreUndefined ? this.countWithoutUndefined(e6, o4) : o4.length;
                if (s4 < 16)
                  this.writeU8(128 + s4);
                else if (s4 < 65536)
                  this.writeU8(222), this.writeU16(s4);
                else {
                  if (!(s4 < 4294967296))
                    throw new Error("Too large map object: " + s4);
                  this.writeU8(223), this.writeU32(s4);
                }
                try {
                  for (var i4 = T4(o4), a4 = i4.next(); !a4.done; a4 = i4.next()) {
                    var c4 = a4.value, u4 = e6[c4];
                    this.ignoreUndefined && u4 === void 0 || (this.encodeString(c4), this.doEncode(u4, t4 + 1));
                  }
                } catch (e7) {
                  r4 = { error: e7 };
                } finally {
                  try {
                    a4 && !a4.done && (n3 = i4.return) && n3.call(i4);
                  } finally {
                    if (r4)
                      throw r4.error;
                  }
                }
              }, e5.prototype.encodeExtension = function(e6) {
                var t4 = e6.data.length;
                if (t4 === 1)
                  this.writeU8(212);
                else if (t4 === 2)
                  this.writeU8(213);
                else if (t4 === 4)
                  this.writeU8(214);
                else if (t4 === 8)
                  this.writeU8(215);
                else if (t4 === 16)
                  this.writeU8(216);
                else if (t4 < 256)
                  this.writeU8(199), this.writeU8(t4);
                else if (t4 < 65536)
                  this.writeU8(200), this.writeU16(t4);
                else {
                  if (!(t4 < 4294967296))
                    throw new Error("Too large extension object: " + t4);
                  this.writeU8(201), this.writeU32(t4);
                }
                this.writeI8(e6.type), this.writeU8a(e6.data);
              }, e5.prototype.writeU8 = function(e6) {
                this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, e6), this.pos++;
              }, e5.prototype.writeU8a = function(e6) {
                var t4 = e6.length;
                this.ensureBufferSizeToWrite(t4), this.bytes.set(e6, this.pos), this.pos += t4;
              }, e5.prototype.writeI8 = function(e6) {
                this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, e6), this.pos++;
              }, e5.prototype.writeU16 = function(e6) {
                this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, e6), this.pos += 2;
              }, e5.prototype.writeI16 = function(e6) {
                this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, e6), this.pos += 2;
              }, e5.prototype.writeU32 = function(e6) {
                this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, e6), this.pos += 4;
              }, e5.prototype.writeI32 = function(e6) {
                this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, e6), this.pos += 4;
              }, e5.prototype.writeF32 = function(e6) {
                this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, e6), this.pos += 4;
              }, e5.prototype.writeF64 = function(e6) {
                this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, e6), this.pos += 8;
              }, e5.prototype.writeU64 = function(e6) {
                this.ensureBufferSizeToWrite(8), function(e7, t4, r4) {
                  var n3 = r4 / 4294967296, o4 = r4;
                  e7.setUint32(t4, n3), e7.setUint32(t4 + 4, o4);
                }(this.view, this.pos, e6), this.pos += 8;
              }, e5.prototype.writeI64 = function(e6) {
                this.ensureBufferSizeToWrite(8), d3(this.view, this.pos, e6), this.pos += 8;
              }, e5.prototype.writeBig64 = function(e6) {
                this.ensureBufferSizeToWrite(8), function(e7, t4, r4) {
                  var n3 = Number(r4 / BigInt(4294967296)), o4 = Number(r4 % BigInt(4294967296));
                  n3 < 0 && o4 !== 0 && (n3 -= 1), e7.setUint32(t4, n3), e7.setUint32(t4 + 4, o4);
                }(this.view, this.pos, e6), this.pos += 8;
              }, e5;
            }(), B2 = {};
            function U2(e5, t4) {
              return t4 === void 0 && (t4 = B2), new _4(t4.extensionCodec, t4.context, t4.maxDepth, t4.initialBufferSize, t4.sortKeys, t4.forceFloat32, t4.ignoreUndefined, t4.forceIntegerToFloat).encode(e5);
            }
            function k3(e5) {
              return (e5 < 0 ? "-" : "") + "0x" + Math.abs(e5).toString(16).padStart(2, "0");
            }
            var I3 = function() {
              function e5(e6, t4) {
                e6 === void 0 && (e6 = 16), t4 === void 0 && (t4 = 16), this.maxKeyLength = e6, this.maxLengthPerKey = t4, this.hit = 0, this.miss = 0, this.caches = [];
                for (var r4 = 0; r4 < this.maxKeyLength; r4++)
                  this.caches.push([]);
              }
              return e5.prototype.canBeCached = function(e6) {
                return e6 > 0 && e6 <= this.maxKeyLength;
              }, e5.prototype.get = function(e6, t4, r4) {
                var n3 = this.caches[r4 - 1], o4 = n3.length;
                e:
                  for (var s4 = 0; s4 < o4; s4++) {
                    for (var i4 = n3[s4], a4 = i4.bytes, c4 = 0; c4 < r4; c4++)
                      if (a4[c4] !== e6[t4 + c4])
                        continue e;
                    return i4.value;
                  }
                return null;
              }, e5.prototype.store = function(e6, t4) {
                var r4 = this.caches[e6.length - 1], n3 = { bytes: e6, value: t4 };
                r4.length >= this.maxLengthPerKey ? r4[Math.random() * r4.length | 0] = n3 : r4.push(n3);
              }, e5.prototype.decode = function(e6, t4, r4) {
                var n3 = this.get(e6, t4, r4);
                if (n3 != null)
                  return this.hit++, n3;
                this.miss++;
                var o4 = l3(e6, t4, r4), s4 = Uint8Array.prototype.slice.call(e6, t4, t4 + r4);
                return this.store(s4, o4), o4;
              }, e5;
            }(), C3 = function(e5, t4) {
              var r4, n3, o4, s4, i4 = { label: 0, sent: function() {
                if (1 & o4[0])
                  throw o4[1];
                return o4[1];
              }, trys: [], ops: [] };
              return s4 = { next: a4(0), throw: a4(1), return: a4(2) }, typeof Symbol == "function" && (s4[Symbol.iterator] = function() {
                return this;
              }), s4;
              function a4(s5) {
                return function(a5) {
                  return function(s6) {
                    if (r4)
                      throw new TypeError("Generator is already executing.");
                    for (; i4; )
                      try {
                        if (r4 = 1, n3 && (o4 = 2 & s6[0] ? n3.return : s6[0] ? n3.throw || ((o4 = n3.return) && o4.call(n3), 0) : n3.next) && !(o4 = o4.call(n3, s6[1])).done)
                          return o4;
                        switch (n3 = 0, o4 && (s6 = [2 & s6[0], o4.value]), s6[0]) {
                          case 0:
                          case 1:
                            o4 = s6;
                            break;
                          case 4:
                            return i4.label++, { value: s6[1], done: false };
                          case 5:
                            i4.label++, n3 = s6[1], s6 = [0];
                            continue;
                          case 7:
                            s6 = i4.ops.pop(), i4.trys.pop();
                            continue;
                          default:
                            if (!((o4 = (o4 = i4.trys).length > 0 && o4[o4.length - 1]) || s6[0] !== 6 && s6[0] !== 2)) {
                              i4 = 0;
                              continue;
                            }
                            if (s6[0] === 3 && (!o4 || s6[1] > o4[0] && s6[1] < o4[3])) {
                              i4.label = s6[1];
                              break;
                            }
                            if (s6[0] === 6 && i4.label < o4[1]) {
                              i4.label = o4[1], o4 = s6;
                              break;
                            }
                            if (o4 && i4.label < o4[2]) {
                              i4.label = o4[2], i4.ops.push(s6);
                              break;
                            }
                            o4[2] && i4.ops.pop(), i4.trys.pop();
                            continue;
                        }
                        s6 = t4.call(e5, i4);
                      } catch (e6) {
                        s6 = [6, e6], n3 = 0;
                      } finally {
                        r4 = o4 = 0;
                      }
                    if (5 & s6[0])
                      throw s6[1];
                    return { value: s6[0] ? s6[1] : void 0, done: true };
                  }([s5, a5]);
                };
              }
            }, R2 = function(e5) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var t4, r4 = e5[Symbol.asyncIterator];
              return r4 ? r4.call(e5) : (e5 = typeof __values == "function" ? __values(e5) : e5[Symbol.iterator](), t4 = {}, n3("next"), n3("throw"), n3("return"), t4[Symbol.asyncIterator] = function() {
                return this;
              }, t4);
              function n3(r5) {
                t4[r5] = e5[r5] && function(t5) {
                  return new Promise(function(n4, o4) {
                    !function(e6, t6, r6, n5) {
                      Promise.resolve(n5).then(function(t7) {
                        e6({ value: t7, done: r6 });
                      }, t6);
                    }(n4, o4, (t5 = e5[r5](t5)).done, t5.value);
                  });
                };
              }
            }, O2 = function(e5) {
              return this instanceof O2 ? (this.v = e5, this) : new O2(e5);
            }, D3 = function(e5, t4, r4) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var n3, o4 = r4.apply(e5, t4 || []), s4 = [];
              return n3 = {}, i4("next"), i4("throw"), i4("return"), n3[Symbol.asyncIterator] = function() {
                return this;
              }, n3;
              function i4(e6) {
                o4[e6] && (n3[e6] = function(t5) {
                  return new Promise(function(r5, n4) {
                    s4.push([e6, t5, r5, n4]) > 1 || a4(e6, t5);
                  });
                });
              }
              function a4(e6, t5) {
                try {
                  (r5 = o4[e6](t5)).value instanceof O2 ? Promise.resolve(r5.value.v).then(c4, u4) : l4(s4[0][2], r5);
                } catch (e7) {
                  l4(s4[0][3], e7);
                }
                var r5;
              }
              function c4(e6) {
                a4("next", e6);
              }
              function u4(e6) {
                a4("throw", e6);
              }
              function l4(e6, t5) {
                e6(t5), s4.shift(), s4.length && a4(s4[0][0], s4[0][1]);
              }
            }, N3 = new DataView(new ArrayBuffer(0)), P3 = new Uint8Array(N3.buffer), L3 = function() {
              try {
                N3.getInt8(0);
              } catch (e5) {
                return e5.constructor;
              }
              throw new Error("never reached");
            }(), F3 = new L3("Insufficient data"), z3 = new I3(), j3 = function() {
              function e5(e6, t4, r4, n3, o4, s4, i4, a4) {
                e6 === void 0 && (e6 = S2.defaultCodec), t4 === void 0 && (t4 = void 0), r4 === void 0 && (r4 = 4294967295), n3 === void 0 && (n3 = 4294967295), o4 === void 0 && (o4 = 4294967295), s4 === void 0 && (s4 = 4294967295), i4 === void 0 && (i4 = 4294967295), a4 === void 0 && (a4 = z3), this.extensionCodec = e6, this.context = t4, this.maxStrLength = r4, this.maxBinLength = n3, this.maxArrayLength = o4, this.maxMapLength = s4, this.maxExtLength = i4, this.keyDecoder = a4, this.totalPos = 0, this.pos = 0, this.view = N3, this.bytes = P3, this.headByte = -1, this.stack = [];
              }
              return e5.prototype.reinitializeState = function() {
                this.totalPos = 0, this.headByte = -1;
              }, e5.prototype.setBuffer = function(e6) {
                this.bytes = E4(e6), this.view = function(e7) {
                  if (e7 instanceof ArrayBuffer)
                    return new DataView(e7);
                  var t4 = E4(e7);
                  return new DataView(t4.buffer, t4.byteOffset, t4.byteLength);
                }(this.bytes), this.pos = 0;
              }, e5.prototype.appendBuffer = function(e6) {
                if (this.headByte !== -1 || this.hasRemaining()) {
                  var t4 = this.bytes.subarray(this.pos), r4 = E4(e6), n3 = new Uint8Array(t4.length + r4.length);
                  n3.set(t4), n3.set(r4, t4.length), this.setBuffer(n3);
                } else
                  this.setBuffer(e6);
              }, e5.prototype.hasRemaining = function(e6) {
                return e6 === void 0 && (e6 = 1), this.view.byteLength - this.pos >= e6;
              }, e5.prototype.createNoExtraBytesError = function(e6) {
                var t4 = this.view, r4 = this.pos;
                return new RangeError("Extra " + (t4.byteLength - r4) + " of " + t4.byteLength + " byte(s) found at buffer[" + e6 + "]");
              }, e5.prototype.decode = function(e6) {
                return this.reinitializeState(), this.setBuffer(e6), this.doDecodeSingleSync();
              }, e5.prototype.doDecodeSingleSync = function() {
                var e6 = this.doDecodeSync();
                if (this.hasRemaining())
                  throw this.createNoExtraBytesError(this.pos);
                return e6;
              }, e5.prototype.decodeAsync = function(e6) {
                var t4, r4, n3, o4;
                return function(e7, t5, r5, n4) {
                  return new (r5 || (r5 = Promise))(function(o5, s4) {
                    function i4(e8) {
                      try {
                        c4(n4.next(e8));
                      } catch (e9) {
                        s4(e9);
                      }
                    }
                    function a4(e8) {
                      try {
                        c4(n4.throw(e8));
                      } catch (e9) {
                        s4(e9);
                      }
                    }
                    function c4(e8) {
                      var t6;
                      e8.done ? o5(e8.value) : (t6 = e8.value, t6 instanceof r5 ? t6 : new r5(function(e9) {
                        e9(t6);
                      })).then(i4, a4);
                    }
                    c4((n4 = n4.apply(e7, t5 || [])).next());
                  });
                }(this, void 0, void 0, function() {
                  var s4, i4, a4, c4, u4, l4, h4, p4;
                  return C3(this, function(f4) {
                    switch (f4.label) {
                      case 0:
                        s4 = false, f4.label = 1;
                      case 1:
                        f4.trys.push([1, 6, 7, 12]), t4 = R2(e6), f4.label = 2;
                      case 2:
                        return [4, t4.next()];
                      case 3:
                        if ((r4 = f4.sent()).done)
                          return [3, 5];
                        if (a4 = r4.value, s4)
                          throw this.createNoExtraBytesError(this.totalPos);
                        this.appendBuffer(a4);
                        try {
                          i4 = this.doDecodeSync(), s4 = true;
                        } catch (e7) {
                          if (!(e7 instanceof L3))
                            throw e7;
                        }
                        this.totalPos += this.pos, f4.label = 4;
                      case 4:
                        return [3, 2];
                      case 5:
                        return [3, 12];
                      case 6:
                        return c4 = f4.sent(), n3 = { error: c4 }, [3, 12];
                      case 7:
                        return f4.trys.push([7, , 10, 11]), r4 && !r4.done && (o4 = t4.return) ? [4, o4.call(t4)] : [3, 9];
                      case 8:
                        f4.sent(), f4.label = 9;
                      case 9:
                        return [3, 11];
                      case 10:
                        if (n3)
                          throw n3.error;
                        return [7];
                      case 11:
                        return [7];
                      case 12:
                        if (s4) {
                          if (this.hasRemaining())
                            throw this.createNoExtraBytesError(this.totalPos);
                          return [2, i4];
                        }
                        throw l4 = (u4 = this).headByte, h4 = u4.pos, p4 = u4.totalPos, new RangeError("Insufficient data in parcing " + k3(l4) + " at " + p4 + " (" + h4 + " in the current buffer)");
                    }
                  });
                });
              }, e5.prototype.decodeArrayStream = function(e6) {
                return this.decodeMultiAsync(e6, true);
              }, e5.prototype.decodeStream = function(e6) {
                return this.decodeMultiAsync(e6, false);
              }, e5.prototype.decodeMultiAsync = function(e6, t4) {
                return D3(this, arguments, function() {
                  var r4, n3, o4, s4, i4, a4, c4, u4, l4;
                  return C3(this, function(h4) {
                    switch (h4.label) {
                      case 0:
                        r4 = t4, n3 = -1, h4.label = 1;
                      case 1:
                        h4.trys.push([1, 13, 14, 19]), o4 = R2(e6), h4.label = 2;
                      case 2:
                        return [4, O2(o4.next())];
                      case 3:
                        if ((s4 = h4.sent()).done)
                          return [3, 12];
                        if (i4 = s4.value, t4 && n3 === 0)
                          throw this.createNoExtraBytesError(this.totalPos);
                        this.appendBuffer(i4), r4 && (n3 = this.readArraySize(), r4 = false, this.complete()), h4.label = 4;
                      case 4:
                        h4.trys.push([4, 9, , 10]), h4.label = 5;
                      case 5:
                        return [4, O2(this.doDecodeSync())];
                      case 6:
                        return [4, h4.sent()];
                      case 7:
                        return h4.sent(), --n3 == 0 ? [3, 8] : [3, 5];
                      case 8:
                        return [3, 10];
                      case 9:
                        if (!((a4 = h4.sent()) instanceof L3))
                          throw a4;
                        return [3, 10];
                      case 10:
                        this.totalPos += this.pos, h4.label = 11;
                      case 11:
                        return [3, 2];
                      case 12:
                        return [3, 19];
                      case 13:
                        return c4 = h4.sent(), u4 = { error: c4 }, [3, 19];
                      case 14:
                        return h4.trys.push([14, , 17, 18]), s4 && !s4.done && (l4 = o4.return) ? [4, O2(l4.call(o4))] : [3, 16];
                      case 15:
                        h4.sent(), h4.label = 16;
                      case 16:
                        return [3, 18];
                      case 17:
                        if (u4)
                          throw u4.error;
                        return [7];
                      case 18:
                        return [7];
                      case 19:
                        return [2];
                    }
                  });
                });
              }, e5.prototype.doDecodeSync = function() {
                e:
                  for (; ; ) {
                    var e6 = this.readHeadByte(), t4 = void 0;
                    if (e6 >= 224)
                      t4 = e6 - 256;
                    else if (e6 < 192)
                      if (e6 < 128)
                        t4 = e6;
                      else if (e6 < 144) {
                        if ((n3 = e6 - 128) != 0) {
                          this.pushMapState(n3), this.complete();
                          continue e;
                        }
                        t4 = {};
                      } else if (e6 < 160) {
                        if ((n3 = e6 - 144) != 0) {
                          this.pushArrayState(n3), this.complete();
                          continue e;
                        }
                        t4 = [];
                      } else {
                        var r4 = e6 - 160;
                        t4 = this.decodeUtf8String(r4, 0);
                      }
                    else if (e6 === 192)
                      t4 = null;
                    else if (e6 === 194)
                      t4 = false;
                    else if (e6 === 195)
                      t4 = true;
                    else if (e6 === 202)
                      t4 = this.readF32();
                    else if (e6 === 203)
                      t4 = this.readF64();
                    else if (e6 === 204)
                      t4 = this.readU8();
                    else if (e6 === 205)
                      t4 = this.readU16();
                    else if (e6 === 206)
                      t4 = this.readU32();
                    else if (e6 === 207)
                      t4 = this.readU64();
                    else if (e6 === 208)
                      t4 = this.readI8();
                    else if (e6 === 209)
                      t4 = this.readI16();
                    else if (e6 === 210)
                      t4 = this.readI32();
                    else if (e6 === 211)
                      t4 = this.readI64();
                    else if (e6 === 217)
                      r4 = this.lookU8(), t4 = this.decodeUtf8String(r4, 1);
                    else if (e6 === 218)
                      r4 = this.lookU16(), t4 = this.decodeUtf8String(r4, 2);
                    else if (e6 === 219)
                      r4 = this.lookU32(), t4 = this.decodeUtf8String(r4, 4);
                    else if (e6 === 220) {
                      if ((n3 = this.readU16()) !== 0) {
                        this.pushArrayState(n3), this.complete();
                        continue e;
                      }
                      t4 = [];
                    } else if (e6 === 221) {
                      if ((n3 = this.readU32()) !== 0) {
                        this.pushArrayState(n3), this.complete();
                        continue e;
                      }
                      t4 = [];
                    } else if (e6 === 222) {
                      if ((n3 = this.readU16()) !== 0) {
                        this.pushMapState(n3), this.complete();
                        continue e;
                      }
                      t4 = {};
                    } else if (e6 === 223) {
                      if ((n3 = this.readU32()) !== 0) {
                        this.pushMapState(n3), this.complete();
                        continue e;
                      }
                      t4 = {};
                    } else if (e6 === 196) {
                      var n3 = this.lookU8();
                      t4 = this.decodeBinary(n3, 1);
                    } else if (e6 === 197)
                      n3 = this.lookU16(), t4 = this.decodeBinary(n3, 2);
                    else if (e6 === 198)
                      n3 = this.lookU32(), t4 = this.decodeBinary(n3, 4);
                    else if (e6 === 212)
                      t4 = this.decodeExtension(1, 0);
                    else if (e6 === 213)
                      t4 = this.decodeExtension(2, 0);
                    else if (e6 === 214)
                      t4 = this.decodeExtension(4, 0);
                    else if (e6 === 215)
                      t4 = this.decodeExtension(8, 0);
                    else if (e6 === 216)
                      t4 = this.decodeExtension(16, 0);
                    else if (e6 === 199)
                      n3 = this.lookU8(), t4 = this.decodeExtension(n3, 1);
                    else if (e6 === 200)
                      n3 = this.lookU16(), t4 = this.decodeExtension(n3, 2);
                    else {
                      if (e6 !== 201)
                        throw new Error("Unrecognized type byte: " + k3(e6));
                      n3 = this.lookU32(), t4 = this.decodeExtension(n3, 4);
                    }
                    this.complete();
                    for (var o4 = this.stack; o4.length > 0; ) {
                      var s4 = o4[o4.length - 1];
                      if (s4.type === 0) {
                        if (s4.array[s4.position] = t4, s4.position++, s4.position !== s4.size)
                          continue e;
                        o4.pop(), t4 = s4.array;
                      } else {
                        if (s4.type === 1) {
                          if (void 0, (i4 = typeof t4) != "string" && i4 !== "number")
                            throw new Error("The type of key must be string or number but " + typeof t4);
                          s4.key = t4, s4.type = 2;
                          continue e;
                        }
                        if (s4.map[s4.key] = t4, s4.readCount++, s4.readCount !== s4.size) {
                          s4.key = null, s4.type = 1;
                          continue e;
                        }
                        o4.pop(), t4 = s4.map;
                      }
                    }
                    return t4;
                  }
                var i4;
              }, e5.prototype.readHeadByte = function() {
                return this.headByte === -1 && (this.headByte = this.readU8()), this.headByte;
              }, e5.prototype.complete = function() {
                this.headByte = -1;
              }, e5.prototype.readArraySize = function() {
                var e6 = this.readHeadByte();
                switch (e6) {
                  case 220:
                    return this.readU16();
                  case 221:
                    return this.readU32();
                  default:
                    if (e6 < 160)
                      return e6 - 144;
                    throw new Error("Unrecognized array type byte: " + k3(e6));
                }
              }, e5.prototype.pushMapState = function(e6) {
                if (e6 > this.maxMapLength)
                  throw new Error("Max length exceeded: map length (" + e6 + ") > maxMapLengthLength (" + this.maxMapLength + ")");
                this.stack.push({ type: 1, size: e6, key: null, readCount: 0, map: {} });
              }, e5.prototype.pushArrayState = function(e6) {
                if (e6 > this.maxArrayLength)
                  throw new Error("Max length exceeded: array length (" + e6 + ") > maxArrayLength (" + this.maxArrayLength + ")");
                this.stack.push({ type: 0, size: e6, array: new Array(e6), position: 0 });
              }, e5.prototype.decodeUtf8String = function(e6, t4) {
                var r4;
                if (e6 > this.maxStrLength)
                  throw new Error("Max length exceeded: UTF-8 byte length (" + e6 + ") > maxStrLength (" + this.maxStrLength + ")");
                if (this.bytes.byteLength < this.pos + t4 + e6)
                  throw F3;
                var n3, o4 = this.pos + t4;
                return n3 = this.stateIsMapKey() && ((r4 = this.keyDecoder) === null || r4 === void 0 ? void 0 : r4.canBeCached(e6)) ? this.keyDecoder.decode(this.bytes, o4, e6) : s3 && e6 > p3 ? function(e7, t5, r5) {
                  var n4 = e7.subarray(t5, t5 + r5);
                  return h3.decode(n4);
                }(this.bytes, o4, e6) : l3(this.bytes, o4, e6), this.pos += t4 + e6, n3;
              }, e5.prototype.stateIsMapKey = function() {
                return this.stack.length > 0 && this.stack[this.stack.length - 1].type === 1;
              }, e5.prototype.decodeBinary = function(e6, t4) {
                if (e6 > this.maxBinLength)
                  throw new Error("Max length exceeded: bin length (" + e6 + ") > maxBinLength (" + this.maxBinLength + ")");
                if (!this.hasRemaining(e6 + t4))
                  throw F3;
                var r4 = this.pos + t4, n3 = this.bytes.subarray(r4, r4 + e6);
                return this.pos += t4 + e6, n3;
              }, e5.prototype.decodeExtension = function(e6, t4) {
                if (e6 > this.maxExtLength)
                  throw new Error("Max length exceeded: ext length (" + e6 + ") > maxExtLength (" + this.maxExtLength + ")");
                var r4 = this.view.getInt8(this.pos + t4), n3 = this.decodeBinary(e6, t4 + 1);
                return this.extensionCodec.decode(n3, r4, this.context);
              }, e5.prototype.lookU8 = function() {
                return this.view.getUint8(this.pos);
              }, e5.prototype.lookU16 = function() {
                return this.view.getUint16(this.pos);
              }, e5.prototype.lookU32 = function() {
                return this.view.getUint32(this.pos);
              }, e5.prototype.readU8 = function() {
                var e6 = this.view.getUint8(this.pos);
                return this.pos++, e6;
              }, e5.prototype.readI8 = function() {
                var e6 = this.view.getInt8(this.pos);
                return this.pos++, e6;
              }, e5.prototype.readU16 = function() {
                var e6 = this.view.getUint16(this.pos);
                return this.pos += 2, e6;
              }, e5.prototype.readI16 = function() {
                var e6 = this.view.getInt16(this.pos);
                return this.pos += 2, e6;
              }, e5.prototype.readU32 = function() {
                var e6 = this.view.getUint32(this.pos);
                return this.pos += 4, e6;
              }, e5.prototype.readI32 = function() {
                var e6 = this.view.getInt32(this.pos);
                return this.pos += 4, e6;
              }, e5.prototype.readU64 = function() {
                var e6, t4, r4, n3, o4 = (e6 = this.view, t4 = this.pos, r4 = e6.getUint32(t4), n3 = e6.getUint32(t4 + 4), r4 > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(r4) * BigInt(4294967296) + BigInt(n3) : 4294967296 * r4 + n3);
                return this.pos += 8, o4;
              }, e5.prototype.readI64 = function() {
                var e6 = g3(this.view, this.pos);
                return this.pos += 8, e6;
              }, e5.prototype.readF32 = function() {
                var e6 = this.view.getFloat32(this.pos);
                return this.pos += 4, e6;
              }, e5.prototype.readF64 = function() {
                var e6 = this.view.getFloat64(this.pos);
                return this.pos += 8, e6;
              }, e5;
            }(), M3 = {};
            function H3(e5, t4) {
              return t4 === void 0 && (t4 = M3), new j3(t4.extensionCodec, t4.context, t4.maxStrLength, t4.maxBinLength, t4.maxArrayLength, t4.maxMapLength, t4.maxExtLength).decode(e5);
            }
            var G2 = function(e5, t4) {
              var r4, n3, o4, s4, i4 = { label: 0, sent: function() {
                if (1 & o4[0])
                  throw o4[1];
                return o4[1];
              }, trys: [], ops: [] };
              return s4 = { next: a4(0), throw: a4(1), return: a4(2) }, typeof Symbol == "function" && (s4[Symbol.iterator] = function() {
                return this;
              }), s4;
              function a4(s5) {
                return function(a5) {
                  return function(s6) {
                    if (r4)
                      throw new TypeError("Generator is already executing.");
                    for (; i4; )
                      try {
                        if (r4 = 1, n3 && (o4 = 2 & s6[0] ? n3.return : s6[0] ? n3.throw || ((o4 = n3.return) && o4.call(n3), 0) : n3.next) && !(o4 = o4.call(n3, s6[1])).done)
                          return o4;
                        switch (n3 = 0, o4 && (s6 = [2 & s6[0], o4.value]), s6[0]) {
                          case 0:
                          case 1:
                            o4 = s6;
                            break;
                          case 4:
                            return i4.label++, { value: s6[1], done: false };
                          case 5:
                            i4.label++, n3 = s6[1], s6 = [0];
                            continue;
                          case 7:
                            s6 = i4.ops.pop(), i4.trys.pop();
                            continue;
                          default:
                            if (!((o4 = (o4 = i4.trys).length > 0 && o4[o4.length - 1]) || s6[0] !== 6 && s6[0] !== 2)) {
                              i4 = 0;
                              continue;
                            }
                            if (s6[0] === 3 && (!o4 || s6[1] > o4[0] && s6[1] < o4[3])) {
                              i4.label = s6[1];
                              break;
                            }
                            if (s6[0] === 6 && i4.label < o4[1]) {
                              i4.label = o4[1], o4 = s6;
                              break;
                            }
                            if (o4 && i4.label < o4[2]) {
                              i4.label = o4[2], i4.ops.push(s6);
                              break;
                            }
                            o4[2] && i4.ops.pop(), i4.trys.pop();
                            continue;
                        }
                        s6 = t4.call(e5, i4);
                      } catch (e6) {
                        s6 = [6, e6], n3 = 0;
                      } finally {
                        r4 = o4 = 0;
                      }
                    if (5 & s6[0])
                      throw s6[1];
                    return { value: s6[0] ? s6[1] : void 0, done: true };
                  }([s5, a5]);
                };
              }
            }, K3 = function(e5) {
              return this instanceof K3 ? (this.v = e5, this) : new K3(e5);
            }, q3 = function(e5, t4, r4) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var n3, o4 = r4.apply(e5, t4 || []), s4 = [];
              return n3 = {}, i4("next"), i4("throw"), i4("return"), n3[Symbol.asyncIterator] = function() {
                return this;
              }, n3;
              function i4(e6) {
                o4[e6] && (n3[e6] = function(t5) {
                  return new Promise(function(r5, n4) {
                    s4.push([e6, t5, r5, n4]) > 1 || a4(e6, t5);
                  });
                });
              }
              function a4(e6, t5) {
                try {
                  (r5 = o4[e6](t5)).value instanceof K3 ? Promise.resolve(r5.value.v).then(c4, u4) : l4(s4[0][2], r5);
                } catch (e7) {
                  l4(s4[0][3], e7);
                }
                var r5;
              }
              function c4(e6) {
                a4("next", e6);
              }
              function u4(e6) {
                a4("throw", e6);
              }
              function l4(e6, t5) {
                e6(t5), s4.shift(), s4.length && a4(s4[0][0], s4[0][1]);
              }
            };
            function V2(e5) {
              if (e5 == null)
                throw new Error("Assertion Failure: value must not be null nor undefined");
            }
            function $3(e5) {
              return e5[Symbol.asyncIterator] != null ? e5 : function(e6) {
                return q3(this, arguments, function() {
                  var t4, r4, n3, o4;
                  return G2(this, function(s4) {
                    switch (s4.label) {
                      case 0:
                        t4 = e6.getReader(), s4.label = 1;
                      case 1:
                        s4.trys.push([1, , 9, 10]), s4.label = 2;
                      case 2:
                        return [4, K3(t4.read())];
                      case 3:
                        return r4 = s4.sent(), n3 = r4.done, o4 = r4.value, n3 ? [4, K3(void 0)] : [3, 5];
                      case 4:
                        return [2, s4.sent()];
                      case 5:
                        return V2(o4), [4, K3(o4)];
                      case 6:
                        return [4, s4.sent()];
                      case 7:
                        return s4.sent(), [3, 2];
                      case 8:
                        return [3, 10];
                      case 9:
                        return t4.releaseLock(), [7];
                      case 10:
                        return [2];
                    }
                  });
                });
              }(e5);
            }
            function W2(e5, t4) {
              return t4 === void 0 && (t4 = M3), function(e6, t5, r4, n3) {
                return new (r4 || (r4 = Promise))(function(o4, s4) {
                  function i4(e7) {
                    try {
                      c4(n3.next(e7));
                    } catch (e8) {
                      s4(e8);
                    }
                  }
                  function a4(e7) {
                    try {
                      c4(n3.throw(e7));
                    } catch (e8) {
                      s4(e8);
                    }
                  }
                  function c4(e7) {
                    var t6;
                    e7.done ? o4(e7.value) : (t6 = e7.value, t6 instanceof r4 ? t6 : new r4(function(e8) {
                      e8(t6);
                    })).then(i4, a4);
                  }
                  c4((n3 = n3.apply(e6, t5 || [])).next());
                });
              }(this, void 0, void 0, function() {
                var r4;
                return function(e6, t5) {
                  var r5, n3, o4, s4, i4 = { label: 0, sent: function() {
                    if (1 & o4[0])
                      throw o4[1];
                    return o4[1];
                  }, trys: [], ops: [] };
                  return s4 = { next: a4(0), throw: a4(1), return: a4(2) }, typeof Symbol == "function" && (s4[Symbol.iterator] = function() {
                    return this;
                  }), s4;
                  function a4(s5) {
                    return function(a5) {
                      return function(s6) {
                        if (r5)
                          throw new TypeError("Generator is already executing.");
                        for (; i4; )
                          try {
                            if (r5 = 1, n3 && (o4 = 2 & s6[0] ? n3.return : s6[0] ? n3.throw || ((o4 = n3.return) && o4.call(n3), 0) : n3.next) && !(o4 = o4.call(n3, s6[1])).done)
                              return o4;
                            switch (n3 = 0, o4 && (s6 = [2 & s6[0], o4.value]), s6[0]) {
                              case 0:
                              case 1:
                                o4 = s6;
                                break;
                              case 4:
                                return i4.label++, { value: s6[1], done: false };
                              case 5:
                                i4.label++, n3 = s6[1], s6 = [0];
                                continue;
                              case 7:
                                s6 = i4.ops.pop(), i4.trys.pop();
                                continue;
                              default:
                                if (!((o4 = (o4 = i4.trys).length > 0 && o4[o4.length - 1]) || s6[0] !== 6 && s6[0] !== 2)) {
                                  i4 = 0;
                                  continue;
                                }
                                if (s6[0] === 3 && (!o4 || s6[1] > o4[0] && s6[1] < o4[3])) {
                                  i4.label = s6[1];
                                  break;
                                }
                                if (s6[0] === 6 && i4.label < o4[1]) {
                                  i4.label = o4[1], o4 = s6;
                                  break;
                                }
                                if (o4 && i4.label < o4[2]) {
                                  i4.label = o4[2], i4.ops.push(s6);
                                  break;
                                }
                                o4[2] && i4.ops.pop(), i4.trys.pop();
                                continue;
                            }
                            s6 = t5.call(e6, i4);
                          } catch (e7) {
                            s6 = [6, e7], n3 = 0;
                          } finally {
                            r5 = o4 = 0;
                          }
                        if (5 & s6[0])
                          throw s6[1];
                        return { value: s6[0] ? s6[1] : void 0, done: true };
                      }([s5, a5]);
                    };
                  }
                }(this, function(n3) {
                  return r4 = $3(e5), [2, new j3(t4.extensionCodec, t4.context, t4.maxStrLength, t4.maxBinLength, t4.maxArrayLength, t4.maxMapLength, t4.maxExtLength).decodeAsync(r4)];
                });
              });
            }
            function X2(e5, t4) {
              t4 === void 0 && (t4 = M3);
              var r4 = $3(e5);
              return new j3(t4.extensionCodec, t4.context, t4.maxStrLength, t4.maxBinLength, t4.maxArrayLength, t4.maxMapLength, t4.maxExtLength).decodeArrayStream(r4);
            }
            function Y2(e5, t4) {
              t4 === void 0 && (t4 = M3);
              var r4 = $3(e5);
              return new j3(t4.extensionCodec, t4.context, t4.maxStrLength, t4.maxBinLength, t4.maxArrayLength, t4.maxMapLength, t4.maxExtLength).decodeStream(r4);
            }
          }]);
        }, 5155: (e3, t3) => {
          "use strict";
          t3.byteLength = function(e4) {
            var t4 = c3(e4), r4 = t4[0], n3 = t4[1];
            return 3 * (r4 + n3) / 4 - n3;
          }, t3.toByteArray = function(e4) {
            var t4, r4, s4 = c3(e4), i4 = s4[0], a4 = s4[1], u4 = new o3(function(e5, t5, r5) {
              return 3 * (t5 + r5) / 4 - r5;
            }(0, i4, a4)), l3 = 0, h3 = a4 > 0 ? i4 - 4 : i4;
            for (r4 = 0; r4 < h3; r4 += 4)
              t4 = n2[e4.charCodeAt(r4)] << 18 | n2[e4.charCodeAt(r4 + 1)] << 12 | n2[e4.charCodeAt(r4 + 2)] << 6 | n2[e4.charCodeAt(r4 + 3)], u4[l3++] = t4 >> 16 & 255, u4[l3++] = t4 >> 8 & 255, u4[l3++] = 255 & t4;
            return a4 === 2 && (t4 = n2[e4.charCodeAt(r4)] << 2 | n2[e4.charCodeAt(r4 + 1)] >> 4, u4[l3++] = 255 & t4), a4 === 1 && (t4 = n2[e4.charCodeAt(r4)] << 10 | n2[e4.charCodeAt(r4 + 1)] << 4 | n2[e4.charCodeAt(r4 + 2)] >> 2, u4[l3++] = t4 >> 8 & 255, u4[l3++] = 255 & t4), u4;
          }, t3.fromByteArray = function(e4) {
            for (var t4, n3 = e4.length, o4 = n3 % 3, s4 = [], i4 = 16383, a4 = 0, c4 = n3 - o4; a4 < c4; a4 += i4)
              s4.push(u3(e4, a4, a4 + i4 > c4 ? c4 : a4 + i4));
            return o4 === 1 ? (t4 = e4[n3 - 1], s4.push(r3[t4 >> 2] + r3[t4 << 4 & 63] + "==")) : o4 === 2 && (t4 = (e4[n3 - 2] << 8) + e4[n3 - 1], s4.push(r3[t4 >> 10] + r3[t4 >> 4 & 63] + r3[t4 << 2 & 63] + "=")), s4.join("");
          };
          for (var r3 = [], n2 = [], o3 = typeof Uint8Array != "undefined" ? Uint8Array : Array, s3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i3 = 0, a3 = s3.length; i3 < a3; ++i3)
            r3[i3] = s3[i3], n2[s3.charCodeAt(i3)] = i3;
          function c3(e4) {
            var t4 = e4.length;
            if (t4 % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var r4 = e4.indexOf("=");
            return r4 === -1 && (r4 = t4), [r4, r4 === t4 ? 0 : 4 - r4 % 4];
          }
          function u3(e4, t4, n3) {
            for (var o4, s4, i4 = [], a4 = t4; a4 < n3; a4 += 3)
              o4 = (e4[a4] << 16 & 16711680) + (e4[a4 + 1] << 8 & 65280) + (255 & e4[a4 + 2]), i4.push(r3[(s4 = o4) >> 18 & 63] + r3[s4 >> 12 & 63] + r3[s4 >> 6 & 63] + r3[63 & s4]);
            return i4.join("");
          }
          n2["-".charCodeAt(0)] = 62, n2["_".charCodeAt(0)] = 63;
        }, 5117: function(e3, t3, r3) {
          var n2;
          !function(o3) {
            "use strict";
            var s3, i3 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, a3 = Math.ceil, c3 = Math.floor, u3 = "[BigNumber Error] ", l3 = u3 + "Number primitive has more than 15 significant digits: ", h3 = 1e14, p3 = 14, f3 = 9007199254740991, d3 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], g3 = 1e7, y3 = 1e9;
            function m3(e4) {
              var t4 = 0 | e4;
              return e4 > 0 || e4 === t4 ? t4 : t4 - 1;
            }
            function b2(e4) {
              for (var t4, r4, n3 = 1, o4 = e4.length, s4 = e4[0] + ""; n3 < o4; ) {
                for (t4 = e4[n3++] + "", r4 = p3 - t4.length; r4--; t4 = "0" + t4)
                  ;
                s4 += t4;
              }
              for (o4 = s4.length; s4.charCodeAt(--o4) === 48; )
                ;
              return s4.slice(0, o4 + 1 || 1);
            }
            function A4(e4, t4) {
              var r4, n3, o4 = e4.c, s4 = t4.c, i4 = e4.s, a4 = t4.s, c4 = e4.e, u4 = t4.e;
              if (!i4 || !a4)
                return null;
              if (r4 = o4 && !o4[0], n3 = s4 && !s4[0], r4 || n3)
                return r4 ? n3 ? 0 : -a4 : i4;
              if (i4 != a4)
                return i4;
              if (r4 = i4 < 0, n3 = c4 == u4, !o4 || !s4)
                return n3 ? 0 : !o4 ^ r4 ? 1 : -1;
              if (!n3)
                return c4 > u4 ^ r4 ? 1 : -1;
              for (a4 = (c4 = o4.length) < (u4 = s4.length) ? c4 : u4, i4 = 0; i4 < a4; i4++)
                if (o4[i4] != s4[i4])
                  return o4[i4] > s4[i4] ^ r4 ? 1 : -1;
              return c4 == u4 ? 0 : c4 > u4 ^ r4 ? 1 : -1;
            }
            function w4(e4, t4, r4, n3) {
              if (e4 < t4 || e4 > r4 || e4 !== c3(e4))
                throw Error(u3 + (n3 || "Argument") + (typeof e4 == "number" ? e4 < t4 || e4 > r4 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e4));
            }
            function v3(e4) {
              var t4 = e4.c.length - 1;
              return m3(e4.e / p3) == t4 && e4.c[t4] % 2 != 0;
            }
            function x3(e4, t4) {
              return (e4.length > 1 ? e4.charAt(0) + "." + e4.slice(1) : e4) + (t4 < 0 ? "e" : "e+") + t4;
            }
            function S2(e4, t4, r4) {
              var n3, o4;
              if (t4 < 0) {
                for (o4 = r4 + "."; ++t4; o4 += r4)
                  ;
                e4 = o4 + e4;
              } else if (++t4 > (n3 = e4.length)) {
                for (o4 = r4, t4 -= n3; --t4; o4 += r4)
                  ;
                e4 += o4;
              } else
                t4 < n3 && (e4 = e4.slice(0, t4) + "." + e4.slice(t4));
              return e4;
            }
            (s3 = function e4(t4) {
              var r4, n3, o4, s4, E4, T4, _4, B2, U2, k3, I3 = G2.prototype = { constructor: G2, toString: null, valueOf: null }, C3 = new G2(1), R2 = 20, O2 = 4, D3 = -7, N3 = 21, P3 = -1e7, L3 = 1e7, F3 = false, z3 = 1, j3 = 0, M3 = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "\xA0", suffix: "" }, H3 = "0123456789abcdefghijklmnopqrstuvwxyz";
              function G2(e5, t5) {
                var r5, s5, a4, u4, h4, d4, g4, y4, m4 = this;
                if (!(m4 instanceof G2))
                  return new G2(e5, t5);
                if (t5 == null) {
                  if (e5 && e5._isBigNumber === true)
                    return m4.s = e5.s, void (!e5.c || e5.e > L3 ? m4.c = m4.e = null : e5.e < P3 ? m4.c = [m4.e = 0] : (m4.e = e5.e, m4.c = e5.c.slice()));
                  if ((d4 = typeof e5 == "number") && 0 * e5 == 0) {
                    if (m4.s = 1 / e5 < 0 ? (e5 = -e5, -1) : 1, e5 === ~~e5) {
                      for (u4 = 0, h4 = e5; h4 >= 10; h4 /= 10, u4++)
                        ;
                      return void (u4 > L3 ? m4.c = m4.e = null : (m4.e = u4, m4.c = [e5]));
                    }
                    y4 = String(e5);
                  } else {
                    if (!i3.test(y4 = String(e5)))
                      return o4(m4, y4, d4);
                    m4.s = y4.charCodeAt(0) == 45 ? (y4 = y4.slice(1), -1) : 1;
                  }
                  (u4 = y4.indexOf(".")) > -1 && (y4 = y4.replace(".", "")), (h4 = y4.search(/e/i)) > 0 ? (u4 < 0 && (u4 = h4), u4 += +y4.slice(h4 + 1), y4 = y4.substring(0, h4)) : u4 < 0 && (u4 = y4.length);
                } else {
                  if (w4(t5, 2, H3.length, "Base"), t5 == 10)
                    return $3(m4 = new G2(e5), R2 + m4.e + 1, O2);
                  if (y4 = String(e5), d4 = typeof e5 == "number") {
                    if (0 * e5 != 0)
                      return o4(m4, y4, d4, t5);
                    if (m4.s = 1 / e5 < 0 ? (y4 = y4.slice(1), -1) : 1, G2.DEBUG && y4.replace(/^0\.0*|\./, "").length > 15)
                      throw Error(l3 + e5);
                  } else
                    m4.s = y4.charCodeAt(0) === 45 ? (y4 = y4.slice(1), -1) : 1;
                  for (r5 = H3.slice(0, t5), u4 = h4 = 0, g4 = y4.length; h4 < g4; h4++)
                    if (r5.indexOf(s5 = y4.charAt(h4)) < 0) {
                      if (s5 == ".") {
                        if (h4 > u4) {
                          u4 = g4;
                          continue;
                        }
                      } else if (!a4 && (y4 == y4.toUpperCase() && (y4 = y4.toLowerCase()) || y4 == y4.toLowerCase() && (y4 = y4.toUpperCase()))) {
                        a4 = true, h4 = -1, u4 = 0;
                        continue;
                      }
                      return o4(m4, String(e5), d4, t5);
                    }
                  d4 = false, (u4 = (y4 = n3(y4, t5, 10, m4.s)).indexOf(".")) > -1 ? y4 = y4.replace(".", "") : u4 = y4.length;
                }
                for (h4 = 0; y4.charCodeAt(h4) === 48; h4++)
                  ;
                for (g4 = y4.length; y4.charCodeAt(--g4) === 48; )
                  ;
                if (y4 = y4.slice(h4, ++g4)) {
                  if (g4 -= h4, d4 && G2.DEBUG && g4 > 15 && (e5 > f3 || e5 !== c3(e5)))
                    throw Error(l3 + m4.s * e5);
                  if ((u4 = u4 - h4 - 1) > L3)
                    m4.c = m4.e = null;
                  else if (u4 < P3)
                    m4.c = [m4.e = 0];
                  else {
                    if (m4.e = u4, m4.c = [], h4 = (u4 + 1) % p3, u4 < 0 && (h4 += p3), h4 < g4) {
                      for (h4 && m4.c.push(+y4.slice(0, h4)), g4 -= p3; h4 < g4; )
                        m4.c.push(+y4.slice(h4, h4 += p3));
                      h4 = p3 - (y4 = y4.slice(h4)).length;
                    } else
                      h4 -= g4;
                    for (; h4--; y4 += "0")
                      ;
                    m4.c.push(+y4);
                  }
                } else
                  m4.c = [m4.e = 0];
              }
              function K3(e5, t5, r5, n4) {
                var o5, s5, i4, a4, c4;
                if (r5 == null ? r5 = O2 : w4(r5, 0, 8), !e5.c)
                  return e5.toString();
                if (o5 = e5.c[0], i4 = e5.e, t5 == null)
                  c4 = b2(e5.c), c4 = n4 == 1 || n4 == 2 && (i4 <= D3 || i4 >= N3) ? x3(c4, i4) : S2(c4, i4, "0");
                else if (s5 = (e5 = $3(new G2(e5), t5, r5)).e, a4 = (c4 = b2(e5.c)).length, n4 == 1 || n4 == 2 && (t5 <= s5 || s5 <= D3)) {
                  for (; a4 < t5; c4 += "0", a4++)
                    ;
                  c4 = x3(c4, s5);
                } else if (t5 -= i4, c4 = S2(c4, s5, "0"), s5 + 1 > a4) {
                  if (--t5 > 0)
                    for (c4 += "."; t5--; c4 += "0")
                      ;
                } else if ((t5 += s5 - a4) > 0)
                  for (s5 + 1 == a4 && (c4 += "."); t5--; c4 += "0")
                    ;
                return e5.s < 0 && o5 ? "-" + c4 : c4;
              }
              function q3(e5, t5) {
                for (var r5, n4 = 1, o5 = new G2(e5[0]); n4 < e5.length; n4++) {
                  if (!(r5 = new G2(e5[n4])).s) {
                    o5 = r5;
                    break;
                  }
                  t5.call(o5, r5) && (o5 = r5);
                }
                return o5;
              }
              function V2(e5, t5, r5) {
                for (var n4 = 1, o5 = t5.length; !t5[--o5]; t5.pop())
                  ;
                for (o5 = t5[0]; o5 >= 10; o5 /= 10, n4++)
                  ;
                return (r5 = n4 + r5 * p3 - 1) > L3 ? e5.c = e5.e = null : r5 < P3 ? e5.c = [e5.e = 0] : (e5.e = r5, e5.c = t5), e5;
              }
              function $3(e5, t5, r5, n4) {
                var o5, s5, i4, u4, l4, f4, g4, y4 = e5.c, m4 = d3;
                if (y4) {
                  e: {
                    for (o5 = 1, u4 = y4[0]; u4 >= 10; u4 /= 10, o5++)
                      ;
                    if ((s5 = t5 - o5) < 0)
                      s5 += p3, i4 = t5, g4 = (l4 = y4[f4 = 0]) / m4[o5 - i4 - 1] % 10 | 0;
                    else if ((f4 = a3((s5 + 1) / p3)) >= y4.length) {
                      if (!n4)
                        break e;
                      for (; y4.length <= f4; y4.push(0))
                        ;
                      l4 = g4 = 0, o5 = 1, i4 = (s5 %= p3) - p3 + 1;
                    } else {
                      for (l4 = u4 = y4[f4], o5 = 1; u4 >= 10; u4 /= 10, o5++)
                        ;
                      g4 = (i4 = (s5 %= p3) - p3 + o5) < 0 ? 0 : l4 / m4[o5 - i4 - 1] % 10 | 0;
                    }
                    if (n4 = n4 || t5 < 0 || y4[f4 + 1] != null || (i4 < 0 ? l4 : l4 % m4[o5 - i4 - 1]), n4 = r5 < 4 ? (g4 || n4) && (r5 == 0 || r5 == (e5.s < 0 ? 3 : 2)) : g4 > 5 || g4 == 5 && (r5 == 4 || n4 || r5 == 6 && (s5 > 0 ? i4 > 0 ? l4 / m4[o5 - i4] : 0 : y4[f4 - 1]) % 10 & 1 || r5 == (e5.s < 0 ? 8 : 7)), t5 < 1 || !y4[0])
                      return y4.length = 0, n4 ? (t5 -= e5.e + 1, y4[0] = m4[(p3 - t5 % p3) % p3], e5.e = -t5 || 0) : y4[0] = e5.e = 0, e5;
                    if (s5 == 0 ? (y4.length = f4, u4 = 1, f4--) : (y4.length = f4 + 1, u4 = m4[p3 - s5], y4[f4] = i4 > 0 ? c3(l4 / m4[o5 - i4] % m4[i4]) * u4 : 0), n4)
                      for (; ; ) {
                        if (f4 == 0) {
                          for (s5 = 1, i4 = y4[0]; i4 >= 10; i4 /= 10, s5++)
                            ;
                          for (i4 = y4[0] += u4, u4 = 1; i4 >= 10; i4 /= 10, u4++)
                            ;
                          s5 != u4 && (e5.e++, y4[0] == h3 && (y4[0] = 1));
                          break;
                        }
                        if (y4[f4] += u4, y4[f4] != h3)
                          break;
                        y4[f4--] = 0, u4 = 1;
                      }
                    for (s5 = y4.length; y4[--s5] === 0; y4.pop())
                      ;
                  }
                  e5.e > L3 ? e5.c = e5.e = null : e5.e < P3 && (e5.c = [e5.e = 0]);
                }
                return e5;
              }
              function W2(e5) {
                var t5, r5 = e5.e;
                return r5 === null ? e5.toString() : (t5 = b2(e5.c), t5 = r5 <= D3 || r5 >= N3 ? x3(t5, r5) : S2(t5, r5, "0"), e5.s < 0 ? "-" + t5 : t5);
              }
              return G2.clone = e4, G2.ROUND_UP = 0, G2.ROUND_DOWN = 1, G2.ROUND_CEIL = 2, G2.ROUND_FLOOR = 3, G2.ROUND_HALF_UP = 4, G2.ROUND_HALF_DOWN = 5, G2.ROUND_HALF_EVEN = 6, G2.ROUND_HALF_CEIL = 7, G2.ROUND_HALF_FLOOR = 8, G2.EUCLID = 9, G2.config = G2.set = function(e5) {
                var t5, r5;
                if (e5 != null) {
                  if (typeof e5 != "object")
                    throw Error(u3 + "Object expected: " + e5);
                  if (e5.hasOwnProperty(t5 = "DECIMAL_PLACES") && (w4(r5 = e5[t5], 0, y3, t5), R2 = r5), e5.hasOwnProperty(t5 = "ROUNDING_MODE") && (w4(r5 = e5[t5], 0, 8, t5), O2 = r5), e5.hasOwnProperty(t5 = "EXPONENTIAL_AT") && ((r5 = e5[t5]) && r5.pop ? (w4(r5[0], -y3, 0, t5), w4(r5[1], 0, y3, t5), D3 = r5[0], N3 = r5[1]) : (w4(r5, -y3, y3, t5), D3 = -(N3 = r5 < 0 ? -r5 : r5))), e5.hasOwnProperty(t5 = "RANGE"))
                    if ((r5 = e5[t5]) && r5.pop)
                      w4(r5[0], -y3, -1, t5), w4(r5[1], 1, y3, t5), P3 = r5[0], L3 = r5[1];
                    else {
                      if (w4(r5, -y3, y3, t5), !r5)
                        throw Error(u3 + t5 + " cannot be zero: " + r5);
                      P3 = -(L3 = r5 < 0 ? -r5 : r5);
                    }
                  if (e5.hasOwnProperty(t5 = "CRYPTO")) {
                    if ((r5 = e5[t5]) !== !!r5)
                      throw Error(u3 + t5 + " not true or false: " + r5);
                    if (r5) {
                      if (typeof crypto == "undefined" || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                        throw F3 = !r5, Error(u3 + "crypto unavailable");
                      F3 = r5;
                    } else
                      F3 = r5;
                  }
                  if (e5.hasOwnProperty(t5 = "MODULO_MODE") && (w4(r5 = e5[t5], 0, 9, t5), z3 = r5), e5.hasOwnProperty(t5 = "POW_PRECISION") && (w4(r5 = e5[t5], 0, y3, t5), j3 = r5), e5.hasOwnProperty(t5 = "FORMAT")) {
                    if (typeof (r5 = e5[t5]) != "object")
                      throw Error(u3 + t5 + " not an object: " + r5);
                    M3 = r5;
                  }
                  if (e5.hasOwnProperty(t5 = "ALPHABET")) {
                    if (typeof (r5 = e5[t5]) != "string" || /^.?$|[+\-.\s]|(.).*\1/.test(r5))
                      throw Error(u3 + t5 + " invalid: " + r5);
                    H3 = r5;
                  }
                }
                return { DECIMAL_PLACES: R2, ROUNDING_MODE: O2, EXPONENTIAL_AT: [D3, N3], RANGE: [P3, L3], CRYPTO: F3, MODULO_MODE: z3, POW_PRECISION: j3, FORMAT: M3, ALPHABET: H3 };
              }, G2.isBigNumber = function(e5) {
                if (!e5 || e5._isBigNumber !== true)
                  return false;
                if (!G2.DEBUG)
                  return true;
                var t5, r5, n4 = e5.c, o5 = e5.e, s5 = e5.s;
                e:
                  if ({}.toString.call(n4) == "[object Array]") {
                    if ((s5 === 1 || s5 === -1) && o5 >= -y3 && o5 <= y3 && o5 === c3(o5)) {
                      if (n4[0] === 0) {
                        if (o5 === 0 && n4.length === 1)
                          return true;
                        break e;
                      }
                      if ((t5 = (o5 + 1) % p3) < 1 && (t5 += p3), String(n4[0]).length == t5) {
                        for (t5 = 0; t5 < n4.length; t5++)
                          if ((r5 = n4[t5]) < 0 || r5 >= h3 || r5 !== c3(r5))
                            break e;
                        if (r5 !== 0)
                          return true;
                      }
                    }
                  } else if (n4 === null && o5 === null && (s5 === null || s5 === 1 || s5 === -1))
                    return true;
                throw Error(u3 + "Invalid BigNumber: " + e5);
              }, G2.maximum = G2.max = function() {
                return q3(arguments, I3.lt);
              }, G2.minimum = G2.min = function() {
                return q3(arguments, I3.gt);
              }, G2.random = (s4 = 9007199254740992, E4 = Math.random() * s4 & 2097151 ? function() {
                return c3(Math.random() * s4);
              } : function() {
                return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
              }, function(e5) {
                var t5, r5, n4, o5, s5, i4 = 0, l4 = [], h4 = new G2(C3);
                if (e5 == null ? e5 = R2 : w4(e5, 0, y3), o5 = a3(e5 / p3), F3)
                  if (crypto.getRandomValues) {
                    for (t5 = crypto.getRandomValues(new Uint32Array(o5 *= 2)); i4 < o5; )
                      (s5 = 131072 * t5[i4] + (t5[i4 + 1] >>> 11)) >= 9e15 ? (r5 = crypto.getRandomValues(new Uint32Array(2)), t5[i4] = r5[0], t5[i4 + 1] = r5[1]) : (l4.push(s5 % 1e14), i4 += 2);
                    i4 = o5 / 2;
                  } else {
                    if (!crypto.randomBytes)
                      throw F3 = false, Error(u3 + "crypto unavailable");
                    for (t5 = crypto.randomBytes(o5 *= 7); i4 < o5; )
                      (s5 = 281474976710656 * (31 & t5[i4]) + 1099511627776 * t5[i4 + 1] + 4294967296 * t5[i4 + 2] + 16777216 * t5[i4 + 3] + (t5[i4 + 4] << 16) + (t5[i4 + 5] << 8) + t5[i4 + 6]) >= 9e15 ? crypto.randomBytes(7).copy(t5, i4) : (l4.push(s5 % 1e14), i4 += 7);
                    i4 = o5 / 7;
                  }
                if (!F3)
                  for (; i4 < o5; )
                    (s5 = E4()) < 9e15 && (l4[i4++] = s5 % 1e14);
                for (o5 = l4[--i4], e5 %= p3, o5 && e5 && (s5 = d3[p3 - e5], l4[i4] = c3(o5 / s5) * s5); l4[i4] === 0; l4.pop(), i4--)
                  ;
                if (i4 < 0)
                  l4 = [n4 = 0];
                else {
                  for (n4 = -1; l4[0] === 0; l4.splice(0, 1), n4 -= p3)
                    ;
                  for (i4 = 1, s5 = l4[0]; s5 >= 10; s5 /= 10, i4++)
                    ;
                  i4 < p3 && (n4 -= p3 - i4);
                }
                return h4.e = n4, h4.c = l4, h4;
              }), G2.sum = function() {
                for (var e5 = 1, t5 = arguments, r5 = new G2(t5[0]); e5 < t5.length; )
                  r5 = r5.plus(t5[e5++]);
                return r5;
              }, n3 = function() {
                var e5 = "0123456789";
                function t5(e6, t6, r5, n4) {
                  for (var o5, s5, i4 = [0], a4 = 0, c4 = e6.length; a4 < c4; ) {
                    for (s5 = i4.length; s5--; i4[s5] *= t6)
                      ;
                    for (i4[0] += n4.indexOf(e6.charAt(a4++)), o5 = 0; o5 < i4.length; o5++)
                      i4[o5] > r5 - 1 && (i4[o5 + 1] == null && (i4[o5 + 1] = 0), i4[o5 + 1] += i4[o5] / r5 | 0, i4[o5] %= r5);
                  }
                  return i4.reverse();
                }
                return function(n4, o5, s5, i4, a4) {
                  var c4, u4, l4, h4, p4, f4, d4, g4, y4 = n4.indexOf("."), m4 = R2, A5 = O2;
                  for (y4 >= 0 && (h4 = j3, j3 = 0, n4 = n4.replace(".", ""), f4 = (g4 = new G2(o5)).pow(n4.length - y4), j3 = h4, g4.c = t5(S2(b2(f4.c), f4.e, "0"), 10, s5, e5), g4.e = g4.c.length), l4 = h4 = (d4 = t5(n4, o5, s5, a4 ? (c4 = H3, e5) : (c4 = e5, H3))).length; d4[--h4] == 0; d4.pop())
                    ;
                  if (!d4[0])
                    return c4.charAt(0);
                  if (y4 < 0 ? --l4 : (f4.c = d4, f4.e = l4, f4.s = i4, d4 = (f4 = r4(f4, g4, m4, A5, s5)).c, p4 = f4.r, l4 = f4.e), y4 = d4[u4 = l4 + m4 + 1], h4 = s5 / 2, p4 = p4 || u4 < 0 || d4[u4 + 1] != null, p4 = A5 < 4 ? (y4 != null || p4) && (A5 == 0 || A5 == (f4.s < 0 ? 3 : 2)) : y4 > h4 || y4 == h4 && (A5 == 4 || p4 || A5 == 6 && 1 & d4[u4 - 1] || A5 == (f4.s < 0 ? 8 : 7)), u4 < 1 || !d4[0])
                    n4 = p4 ? S2(c4.charAt(1), -m4, c4.charAt(0)) : c4.charAt(0);
                  else {
                    if (d4.length = u4, p4)
                      for (--s5; ++d4[--u4] > s5; )
                        d4[u4] = 0, u4 || (++l4, d4 = [1].concat(d4));
                    for (h4 = d4.length; !d4[--h4]; )
                      ;
                    for (y4 = 0, n4 = ""; y4 <= h4; n4 += c4.charAt(d4[y4++]))
                      ;
                    n4 = S2(n4, l4, c4.charAt(0));
                  }
                  return n4;
                };
              }(), r4 = function() {
                function e5(e6, t6, r6) {
                  var n4, o5, s5, i4, a4 = 0, c4 = e6.length, u4 = t6 % g3, l4 = t6 / g3 | 0;
                  for (e6 = e6.slice(); c4--; )
                    a4 = ((o5 = u4 * (s5 = e6[c4] % g3) + (n4 = l4 * s5 + (i4 = e6[c4] / g3 | 0) * u4) % g3 * g3 + a4) / r6 | 0) + (n4 / g3 | 0) + l4 * i4, e6[c4] = o5 % r6;
                  return a4 && (e6 = [a4].concat(e6)), e6;
                }
                function t5(e6, t6, r6, n4) {
                  var o5, s5;
                  if (r6 != n4)
                    s5 = r6 > n4 ? 1 : -1;
                  else
                    for (o5 = s5 = 0; o5 < r6; o5++)
                      if (e6[o5] != t6[o5]) {
                        s5 = e6[o5] > t6[o5] ? 1 : -1;
                        break;
                      }
                  return s5;
                }
                function r5(e6, t6, r6, n4) {
                  for (var o5 = 0; r6--; )
                    e6[r6] -= o5, o5 = e6[r6] < t6[r6] ? 1 : 0, e6[r6] = o5 * n4 + e6[r6] - t6[r6];
                  for (; !e6[0] && e6.length > 1; e6.splice(0, 1))
                    ;
                }
                return function(n4, o5, s5, i4, a4) {
                  var u4, l4, f4, d4, g4, y4, b3, A5, w5, v4, x4, S3, E5, T5, _5, B3, U3, k4 = n4.s == o5.s ? 1 : -1, I4 = n4.c, C4 = o5.c;
                  if (!(I4 && I4[0] && C4 && C4[0]))
                    return new G2(n4.s && o5.s && (I4 ? !C4 || I4[0] != C4[0] : C4) ? I4 && I4[0] == 0 || !C4 ? 0 * k4 : k4 / 0 : NaN);
                  for (w5 = (A5 = new G2(k4)).c = [], k4 = s5 + (l4 = n4.e - o5.e) + 1, a4 || (a4 = h3, l4 = m3(n4.e / p3) - m3(o5.e / p3), k4 = k4 / p3 | 0), f4 = 0; C4[f4] == (I4[f4] || 0); f4++)
                    ;
                  if (C4[f4] > (I4[f4] || 0) && l4--, k4 < 0)
                    w5.push(1), d4 = true;
                  else {
                    for (T5 = I4.length, B3 = C4.length, f4 = 0, k4 += 2, (g4 = c3(a4 / (C4[0] + 1))) > 1 && (C4 = e5(C4, g4, a4), I4 = e5(I4, g4, a4), B3 = C4.length, T5 = I4.length), E5 = B3, x4 = (v4 = I4.slice(0, B3)).length; x4 < B3; v4[x4++] = 0)
                      ;
                    U3 = C4.slice(), U3 = [0].concat(U3), _5 = C4[0], C4[1] >= a4 / 2 && _5++;
                    do {
                      if (g4 = 0, (u4 = t5(C4, v4, B3, x4)) < 0) {
                        if (S3 = v4[0], B3 != x4 && (S3 = S3 * a4 + (v4[1] || 0)), (g4 = c3(S3 / _5)) > 1)
                          for (g4 >= a4 && (g4 = a4 - 1), b3 = (y4 = e5(C4, g4, a4)).length, x4 = v4.length; t5(y4, v4, b3, x4) == 1; )
                            g4--, r5(y4, B3 < b3 ? U3 : C4, b3, a4), b3 = y4.length, u4 = 1;
                        else
                          g4 == 0 && (u4 = g4 = 1), b3 = (y4 = C4.slice()).length;
                        if (b3 < x4 && (y4 = [0].concat(y4)), r5(v4, y4, x4, a4), x4 = v4.length, u4 == -1)
                          for (; t5(C4, v4, B3, x4) < 1; )
                            g4++, r5(v4, B3 < x4 ? U3 : C4, x4, a4), x4 = v4.length;
                      } else
                        u4 === 0 && (g4++, v4 = [0]);
                      w5[f4++] = g4, v4[0] ? v4[x4++] = I4[E5] || 0 : (v4 = [I4[E5]], x4 = 1);
                    } while ((E5++ < T5 || v4[0] != null) && k4--);
                    d4 = v4[0] != null, w5[0] || w5.splice(0, 1);
                  }
                  if (a4 == h3) {
                    for (f4 = 1, k4 = w5[0]; k4 >= 10; k4 /= 10, f4++)
                      ;
                    $3(A5, s5 + (A5.e = f4 + l4 * p3 - 1) + 1, i4, d4);
                  } else
                    A5.e = l4, A5.r = +d4;
                  return A5;
                };
              }(), T4 = /^(-?)0([xbo])(?=\w[\w.]*$)/i, _4 = /^([^.]+)\.$/, B2 = /^\.([^.]+)$/, U2 = /^-?(Infinity|NaN)$/, k3 = /^\s*\+(?=[\w.])|^\s+|\s+$/g, o4 = function(e5, t5, r5, n4) {
                var o5, s5 = r5 ? t5 : t5.replace(k3, "");
                if (U2.test(s5))
                  e5.s = isNaN(s5) ? null : s5 < 0 ? -1 : 1;
                else {
                  if (!r5 && (s5 = s5.replace(T4, function(e6, t6, r6) {
                    return o5 = (r6 = r6.toLowerCase()) == "x" ? 16 : r6 == "b" ? 2 : 8, n4 && n4 != o5 ? e6 : t6;
                  }), n4 && (o5 = n4, s5 = s5.replace(_4, "$1").replace(B2, "0.$1")), t5 != s5))
                    return new G2(s5, o5);
                  if (G2.DEBUG)
                    throw Error(u3 + "Not a" + (n4 ? " base " + n4 : "") + " number: " + t5);
                  e5.s = null;
                }
                e5.c = e5.e = null;
              }, I3.absoluteValue = I3.abs = function() {
                var e5 = new G2(this);
                return e5.s < 0 && (e5.s = 1), e5;
              }, I3.comparedTo = function(e5, t5) {
                return A4(this, new G2(e5, t5));
              }, I3.decimalPlaces = I3.dp = function(e5, t5) {
                var r5, n4, o5, s5 = this;
                if (e5 != null)
                  return w4(e5, 0, y3), t5 == null ? t5 = O2 : w4(t5, 0, 8), $3(new G2(s5), e5 + s5.e + 1, t5);
                if (!(r5 = s5.c))
                  return null;
                if (n4 = ((o5 = r5.length - 1) - m3(this.e / p3)) * p3, o5 = r5[o5])
                  for (; o5 % 10 == 0; o5 /= 10, n4--)
                    ;
                return n4 < 0 && (n4 = 0), n4;
              }, I3.dividedBy = I3.div = function(e5, t5) {
                return r4(this, new G2(e5, t5), R2, O2);
              }, I3.dividedToIntegerBy = I3.idiv = function(e5, t5) {
                return r4(this, new G2(e5, t5), 0, 1);
              }, I3.exponentiatedBy = I3.pow = function(e5, t5) {
                var r5, n4, o5, s5, i4, l4, h4, f4, d4 = this;
                if ((e5 = new G2(e5)).c && !e5.isInteger())
                  throw Error(u3 + "Exponent not an integer: " + W2(e5));
                if (t5 != null && (t5 = new G2(t5)), i4 = e5.e > 14, !d4.c || !d4.c[0] || d4.c[0] == 1 && !d4.e && d4.c.length == 1 || !e5.c || !e5.c[0])
                  return f4 = new G2(Math.pow(+W2(d4), i4 ? 2 - v3(e5) : +W2(e5))), t5 ? f4.mod(t5) : f4;
                if (l4 = e5.s < 0, t5) {
                  if (t5.c ? !t5.c[0] : !t5.s)
                    return new G2(NaN);
                  (n4 = !l4 && d4.isInteger() && t5.isInteger()) && (d4 = d4.mod(t5));
                } else {
                  if (e5.e > 9 && (d4.e > 0 || d4.e < -1 || (d4.e == 0 ? d4.c[0] > 1 || i4 && d4.c[1] >= 24e7 : d4.c[0] < 8e13 || i4 && d4.c[0] <= 9999975e7)))
                    return s5 = d4.s < 0 && v3(e5) ? -0 : 0, d4.e > -1 && (s5 = 1 / s5), new G2(l4 ? 1 / s5 : s5);
                  j3 && (s5 = a3(j3 / p3 + 2));
                }
                for (i4 ? (r5 = new G2(0.5), l4 && (e5.s = 1), h4 = v3(e5)) : h4 = (o5 = Math.abs(+W2(e5))) % 2, f4 = new G2(C3); ; ) {
                  if (h4) {
                    if (!(f4 = f4.times(d4)).c)
                      break;
                    s5 ? f4.c.length > s5 && (f4.c.length = s5) : n4 && (f4 = f4.mod(t5));
                  }
                  if (o5) {
                    if ((o5 = c3(o5 / 2)) === 0)
                      break;
                    h4 = o5 % 2;
                  } else if ($3(e5 = e5.times(r5), e5.e + 1, 1), e5.e > 14)
                    h4 = v3(e5);
                  else {
                    if ((o5 = +W2(e5)) == 0)
                      break;
                    h4 = o5 % 2;
                  }
                  d4 = d4.times(d4), s5 ? d4.c && d4.c.length > s5 && (d4.c.length = s5) : n4 && (d4 = d4.mod(t5));
                }
                return n4 ? f4 : (l4 && (f4 = C3.div(f4)), t5 ? f4.mod(t5) : s5 ? $3(f4, j3, O2, void 0) : f4);
              }, I3.integerValue = function(e5) {
                var t5 = new G2(this);
                return e5 == null ? e5 = O2 : w4(e5, 0, 8), $3(t5, t5.e + 1, e5);
              }, I3.isEqualTo = I3.eq = function(e5, t5) {
                return A4(this, new G2(e5, t5)) === 0;
              }, I3.isFinite = function() {
                return !!this.c;
              }, I3.isGreaterThan = I3.gt = function(e5, t5) {
                return A4(this, new G2(e5, t5)) > 0;
              }, I3.isGreaterThanOrEqualTo = I3.gte = function(e5, t5) {
                return (t5 = A4(this, new G2(e5, t5))) === 1 || t5 === 0;
              }, I3.isInteger = function() {
                return !!this.c && m3(this.e / p3) > this.c.length - 2;
              }, I3.isLessThan = I3.lt = function(e5, t5) {
                return A4(this, new G2(e5, t5)) < 0;
              }, I3.isLessThanOrEqualTo = I3.lte = function(e5, t5) {
                return (t5 = A4(this, new G2(e5, t5))) === -1 || t5 === 0;
              }, I3.isNaN = function() {
                return !this.s;
              }, I3.isNegative = function() {
                return this.s < 0;
              }, I3.isPositive = function() {
                return this.s > 0;
              }, I3.isZero = function() {
                return !!this.c && this.c[0] == 0;
              }, I3.minus = function(e5, t5) {
                var r5, n4, o5, s5, i4 = this, a4 = i4.s;
                if (t5 = (e5 = new G2(e5, t5)).s, !a4 || !t5)
                  return new G2(NaN);
                if (a4 != t5)
                  return e5.s = -t5, i4.plus(e5);
                var c4 = i4.e / p3, u4 = e5.e / p3, l4 = i4.c, f4 = e5.c;
                if (!c4 || !u4) {
                  if (!l4 || !f4)
                    return l4 ? (e5.s = -t5, e5) : new G2(f4 ? i4 : NaN);
                  if (!l4[0] || !f4[0])
                    return f4[0] ? (e5.s = -t5, e5) : new G2(l4[0] ? i4 : O2 == 3 ? -0 : 0);
                }
                if (c4 = m3(c4), u4 = m3(u4), l4 = l4.slice(), a4 = c4 - u4) {
                  for ((s5 = a4 < 0) ? (a4 = -a4, o5 = l4) : (u4 = c4, o5 = f4), o5.reverse(), t5 = a4; t5--; o5.push(0))
                    ;
                  o5.reverse();
                } else
                  for (n4 = (s5 = (a4 = l4.length) < (t5 = f4.length)) ? a4 : t5, a4 = t5 = 0; t5 < n4; t5++)
                    if (l4[t5] != f4[t5]) {
                      s5 = l4[t5] < f4[t5];
                      break;
                    }
                if (s5 && (o5 = l4, l4 = f4, f4 = o5, e5.s = -e5.s), (t5 = (n4 = f4.length) - (r5 = l4.length)) > 0)
                  for (; t5--; l4[r5++] = 0)
                    ;
                for (t5 = h3 - 1; n4 > a4; ) {
                  if (l4[--n4] < f4[n4]) {
                    for (r5 = n4; r5 && !l4[--r5]; l4[r5] = t5)
                      ;
                    --l4[r5], l4[n4] += h3;
                  }
                  l4[n4] -= f4[n4];
                }
                for (; l4[0] == 0; l4.splice(0, 1), --u4)
                  ;
                return l4[0] ? V2(e5, l4, u4) : (e5.s = O2 == 3 ? -1 : 1, e5.c = [e5.e = 0], e5);
              }, I3.modulo = I3.mod = function(e5, t5) {
                var n4, o5, s5 = this;
                return e5 = new G2(e5, t5), !s5.c || !e5.s || e5.c && !e5.c[0] ? new G2(NaN) : !e5.c || s5.c && !s5.c[0] ? new G2(s5) : (z3 == 9 ? (o5 = e5.s, e5.s = 1, n4 = r4(s5, e5, 0, 3), e5.s = o5, n4.s *= o5) : n4 = r4(s5, e5, 0, z3), (e5 = s5.minus(n4.times(e5))).c[0] || z3 != 1 || (e5.s = s5.s), e5);
              }, I3.multipliedBy = I3.times = function(e5, t5) {
                var r5, n4, o5, s5, i4, a4, c4, u4, l4, f4, d4, y4, b3, A5, w5, v4 = this, x4 = v4.c, S3 = (e5 = new G2(e5, t5)).c;
                if (!(x4 && S3 && x4[0] && S3[0]))
                  return !v4.s || !e5.s || x4 && !x4[0] && !S3 || S3 && !S3[0] && !x4 ? e5.c = e5.e = e5.s = null : (e5.s *= v4.s, x4 && S3 ? (e5.c = [0], e5.e = 0) : e5.c = e5.e = null), e5;
                for (n4 = m3(v4.e / p3) + m3(e5.e / p3), e5.s *= v4.s, (c4 = x4.length) < (f4 = S3.length) && (b3 = x4, x4 = S3, S3 = b3, o5 = c4, c4 = f4, f4 = o5), o5 = c4 + f4, b3 = []; o5--; b3.push(0))
                  ;
                for (A5 = h3, w5 = g3, o5 = f4; --o5 >= 0; ) {
                  for (r5 = 0, d4 = S3[o5] % w5, y4 = S3[o5] / w5 | 0, s5 = o5 + (i4 = c4); s5 > o5; )
                    r5 = ((u4 = d4 * (u4 = x4[--i4] % w5) + (a4 = y4 * u4 + (l4 = x4[i4] / w5 | 0) * d4) % w5 * w5 + b3[s5] + r5) / A5 | 0) + (a4 / w5 | 0) + y4 * l4, b3[s5--] = u4 % A5;
                  b3[s5] = r5;
                }
                return r5 ? ++n4 : b3.splice(0, 1), V2(e5, b3, n4);
              }, I3.negated = function() {
                var e5 = new G2(this);
                return e5.s = -e5.s || null, e5;
              }, I3.plus = function(e5, t5) {
                var r5, n4 = this, o5 = n4.s;
                if (t5 = (e5 = new G2(e5, t5)).s, !o5 || !t5)
                  return new G2(NaN);
                if (o5 != t5)
                  return e5.s = -t5, n4.minus(e5);
                var s5 = n4.e / p3, i4 = e5.e / p3, a4 = n4.c, c4 = e5.c;
                if (!s5 || !i4) {
                  if (!a4 || !c4)
                    return new G2(o5 / 0);
                  if (!a4[0] || !c4[0])
                    return c4[0] ? e5 : new G2(a4[0] ? n4 : 0 * o5);
                }
                if (s5 = m3(s5), i4 = m3(i4), a4 = a4.slice(), o5 = s5 - i4) {
                  for (o5 > 0 ? (i4 = s5, r5 = c4) : (o5 = -o5, r5 = a4), r5.reverse(); o5--; r5.push(0))
                    ;
                  r5.reverse();
                }
                for ((o5 = a4.length) - (t5 = c4.length) < 0 && (r5 = c4, c4 = a4, a4 = r5, t5 = o5), o5 = 0; t5; )
                  o5 = (a4[--t5] = a4[t5] + c4[t5] + o5) / h3 | 0, a4[t5] = h3 === a4[t5] ? 0 : a4[t5] % h3;
                return o5 && (a4 = [o5].concat(a4), ++i4), V2(e5, a4, i4);
              }, I3.precision = I3.sd = function(e5, t5) {
                var r5, n4, o5, s5 = this;
                if (e5 != null && e5 !== !!e5)
                  return w4(e5, 1, y3), t5 == null ? t5 = O2 : w4(t5, 0, 8), $3(new G2(s5), e5, t5);
                if (!(r5 = s5.c))
                  return null;
                if (n4 = (o5 = r5.length - 1) * p3 + 1, o5 = r5[o5]) {
                  for (; o5 % 10 == 0; o5 /= 10, n4--)
                    ;
                  for (o5 = r5[0]; o5 >= 10; o5 /= 10, n4++)
                    ;
                }
                return e5 && s5.e + 1 > n4 && (n4 = s5.e + 1), n4;
              }, I3.shiftedBy = function(e5) {
                return w4(e5, -9007199254740991, f3), this.times("1e" + e5);
              }, I3.squareRoot = I3.sqrt = function() {
                var e5, t5, n4, o5, s5, i4 = this, a4 = i4.c, c4 = i4.s, u4 = i4.e, l4 = R2 + 4, h4 = new G2("0.5");
                if (c4 !== 1 || !a4 || !a4[0])
                  return new G2(!c4 || c4 < 0 && (!a4 || a4[0]) ? NaN : a4 ? i4 : 1 / 0);
                if ((c4 = Math.sqrt(+W2(i4))) == 0 || c4 == 1 / 0 ? (((t5 = b2(a4)).length + u4) % 2 == 0 && (t5 += "0"), c4 = Math.sqrt(+t5), u4 = m3((u4 + 1) / 2) - (u4 < 0 || u4 % 2), n4 = new G2(t5 = c4 == 1 / 0 ? "5e" + u4 : (t5 = c4.toExponential()).slice(0, t5.indexOf("e") + 1) + u4)) : n4 = new G2(c4 + ""), n4.c[0]) {
                  for ((c4 = (u4 = n4.e) + l4) < 3 && (c4 = 0); ; )
                    if (s5 = n4, n4 = h4.times(s5.plus(r4(i4, s5, l4, 1))), b2(s5.c).slice(0, c4) === (t5 = b2(n4.c)).slice(0, c4)) {
                      if (n4.e < u4 && --c4, (t5 = t5.slice(c4 - 3, c4 + 1)) != "9999" && (o5 || t5 != "4999")) {
                        +t5 && (+t5.slice(1) || t5.charAt(0) != "5") || ($3(n4, n4.e + R2 + 2, 1), e5 = !n4.times(n4).eq(i4));
                        break;
                      }
                      if (!o5 && ($3(s5, s5.e + R2 + 2, 0), s5.times(s5).eq(i4))) {
                        n4 = s5;
                        break;
                      }
                      l4 += 4, c4 += 4, o5 = 1;
                    }
                }
                return $3(n4, n4.e + R2 + 1, O2, e5);
              }, I3.toExponential = function(e5, t5) {
                return e5 != null && (w4(e5, 0, y3), e5++), K3(this, e5, t5, 1);
              }, I3.toFixed = function(e5, t5) {
                return e5 != null && (w4(e5, 0, y3), e5 = e5 + this.e + 1), K3(this, e5, t5);
              }, I3.toFormat = function(e5, t5, r5) {
                var n4, o5 = this;
                if (r5 == null)
                  e5 != null && t5 && typeof t5 == "object" ? (r5 = t5, t5 = null) : e5 && typeof e5 == "object" ? (r5 = e5, e5 = t5 = null) : r5 = M3;
                else if (typeof r5 != "object")
                  throw Error(u3 + "Argument not an object: " + r5);
                if (n4 = o5.toFixed(e5, t5), o5.c) {
                  var s5, i4 = n4.split("."), a4 = +r5.groupSize, c4 = +r5.secondaryGroupSize, l4 = r5.groupSeparator || "", h4 = i4[0], p4 = i4[1], f4 = o5.s < 0, d4 = f4 ? h4.slice(1) : h4, g4 = d4.length;
                  if (c4 && (s5 = a4, a4 = c4, c4 = s5, g4 -= s5), a4 > 0 && g4 > 0) {
                    for (s5 = g4 % a4 || a4, h4 = d4.substr(0, s5); s5 < g4; s5 += a4)
                      h4 += l4 + d4.substr(s5, a4);
                    c4 > 0 && (h4 += l4 + d4.slice(s5)), f4 && (h4 = "-" + h4);
                  }
                  n4 = p4 ? h4 + (r5.decimalSeparator || "") + ((c4 = +r5.fractionGroupSize) ? p4.replace(new RegExp("\\d{" + c4 + "}\\B", "g"), "$&" + (r5.fractionGroupSeparator || "")) : p4) : h4;
                }
                return (r5.prefix || "") + n4 + (r5.suffix || "");
              }, I3.toFraction = function(e5) {
                var t5, n4, o5, s5, i4, a4, c4, l4, h4, f4, g4, y4, m4 = this, A5 = m4.c;
                if (e5 != null && (!(c4 = new G2(e5)).isInteger() && (c4.c || c4.s !== 1) || c4.lt(C3)))
                  throw Error(u3 + "Argument " + (c4.isInteger() ? "out of range: " : "not an integer: ") + W2(c4));
                if (!A5)
                  return new G2(m4);
                for (t5 = new G2(C3), h4 = n4 = new G2(C3), o5 = l4 = new G2(C3), y4 = b2(A5), i4 = t5.e = y4.length - m4.e - 1, t5.c[0] = d3[(a4 = i4 % p3) < 0 ? p3 + a4 : a4], e5 = !e5 || c4.comparedTo(t5) > 0 ? i4 > 0 ? t5 : h4 : c4, a4 = L3, L3 = 1 / 0, c4 = new G2(y4), l4.c[0] = 0; f4 = r4(c4, t5, 0, 1), (s5 = n4.plus(f4.times(o5))).comparedTo(e5) != 1; )
                  n4 = o5, o5 = s5, h4 = l4.plus(f4.times(s5 = h4)), l4 = s5, t5 = c4.minus(f4.times(s5 = t5)), c4 = s5;
                return s5 = r4(e5.minus(n4), o5, 0, 1), l4 = l4.plus(s5.times(h4)), n4 = n4.plus(s5.times(o5)), l4.s = h4.s = m4.s, g4 = r4(h4, o5, i4 *= 2, O2).minus(m4).abs().comparedTo(r4(l4, n4, i4, O2).minus(m4).abs()) < 1 ? [h4, o5] : [l4, n4], L3 = a4, g4;
              }, I3.toNumber = function() {
                return +W2(this);
              }, I3.toPrecision = function(e5, t5) {
                return e5 != null && w4(e5, 1, y3), K3(this, e5, t5, 2);
              }, I3.toString = function(e5) {
                var t5, r5 = this, o5 = r5.s, s5 = r5.e;
                return s5 === null ? o5 ? (t5 = "Infinity", o5 < 0 && (t5 = "-" + t5)) : t5 = "NaN" : (e5 == null ? t5 = s5 <= D3 || s5 >= N3 ? x3(b2(r5.c), s5) : S2(b2(r5.c), s5, "0") : e5 === 10 ? t5 = S2(b2((r5 = $3(new G2(r5), R2 + s5 + 1, O2)).c), r5.e, "0") : (w4(e5, 2, H3.length, "Base"), t5 = n3(S2(b2(r5.c), s5, "0"), 10, e5, o5, true)), o5 < 0 && r5.c[0] && (t5 = "-" + t5)), t5;
              }, I3.valueOf = I3.toJSON = function() {
                return W2(this);
              }, I3._isBigNumber = true, t4 != null && G2.set(t4), G2;
            }()).default = s3.BigNumber = s3, (n2 = function() {
              return s3;
            }.call(t3, r3, t3, e3)) === void 0 || (e3.exports = n2);
          }();
        }, 2486: (e3, t3, r3) => {
          "use strict";
          const n2 = r3(5155), o3 = r3(4525), s3 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
          t3.Buffer = c3, t3.SlowBuffer = function(e4) {
            return +e4 != e4 && (e4 = 0), c3.alloc(+e4);
          }, t3.INSPECT_MAX_BYTES = 50;
          const i3 = 2147483647;
          function a3(e4) {
            if (e4 > i3)
              throw new RangeError('The value "' + e4 + '" is invalid for option "size"');
            const t4 = new Uint8Array(e4);
            return Object.setPrototypeOf(t4, c3.prototype), t4;
          }
          function c3(e4, t4, r4) {
            if (typeof e4 == "number") {
              if (typeof t4 == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
              return h3(e4);
            }
            return u3(e4, t4, r4);
          }
          function u3(e4, t4, r4) {
            if (typeof e4 == "string")
              return function(e5, t5) {
                if (typeof t5 == "string" && t5 !== "" || (t5 = "utf8"), !c3.isEncoding(t5))
                  throw new TypeError("Unknown encoding: " + t5);
                const r5 = 0 | g3(e5, t5);
                let n4 = a3(r5);
                const o5 = n4.write(e5, t5);
                return o5 !== r5 && (n4 = n4.slice(0, o5)), n4;
              }(e4, t4);
            if (ArrayBuffer.isView(e4))
              return function(e5) {
                if (X2(e5, Uint8Array)) {
                  const t5 = new Uint8Array(e5);
                  return f3(t5.buffer, t5.byteOffset, t5.byteLength);
                }
                return p3(e5);
              }(e4);
            if (e4 == null)
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e4);
            if (X2(e4, ArrayBuffer) || e4 && X2(e4.buffer, ArrayBuffer))
              return f3(e4, t4, r4);
            if (typeof SharedArrayBuffer != "undefined" && (X2(e4, SharedArrayBuffer) || e4 && X2(e4.buffer, SharedArrayBuffer)))
              return f3(e4, t4, r4);
            if (typeof e4 == "number")
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            const n3 = e4.valueOf && e4.valueOf();
            if (n3 != null && n3 !== e4)
              return c3.from(n3, t4, r4);
            const o4 = function(e5) {
              if (c3.isBuffer(e5)) {
                const t5 = 0 | d3(e5.length), r5 = a3(t5);
                return r5.length === 0 || e5.copy(r5, 0, 0, t5), r5;
              }
              return e5.length !== void 0 ? typeof e5.length != "number" || Y2(e5.length) ? a3(0) : p3(e5) : e5.type === "Buffer" && Array.isArray(e5.data) ? p3(e5.data) : void 0;
            }(e4);
            if (o4)
              return o4;
            if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof e4[Symbol.toPrimitive] == "function")
              return c3.from(e4[Symbol.toPrimitive]("string"), t4, r4);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e4);
          }
          function l3(e4) {
            if (typeof e4 != "number")
              throw new TypeError('"size" argument must be of type number');
            if (e4 < 0)
              throw new RangeError('The value "' + e4 + '" is invalid for option "size"');
          }
          function h3(e4) {
            return l3(e4), a3(e4 < 0 ? 0 : 0 | d3(e4));
          }
          function p3(e4) {
            const t4 = e4.length < 0 ? 0 : 0 | d3(e4.length), r4 = a3(t4);
            for (let n3 = 0; n3 < t4; n3 += 1)
              r4[n3] = 255 & e4[n3];
            return r4;
          }
          function f3(e4, t4, r4) {
            if (t4 < 0 || e4.byteLength < t4)
              throw new RangeError('"offset" is outside of buffer bounds');
            if (e4.byteLength < t4 + (r4 || 0))
              throw new RangeError('"length" is outside of buffer bounds');
            let n3;
            return n3 = t4 === void 0 && r4 === void 0 ? new Uint8Array(e4) : r4 === void 0 ? new Uint8Array(e4, t4) : new Uint8Array(e4, t4, r4), Object.setPrototypeOf(n3, c3.prototype), n3;
          }
          function d3(e4) {
            if (e4 >= i3)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i3.toString(16) + " bytes");
            return 0 | e4;
          }
          function g3(e4, t4) {
            if (c3.isBuffer(e4))
              return e4.length;
            if (ArrayBuffer.isView(e4) || X2(e4, ArrayBuffer))
              return e4.byteLength;
            if (typeof e4 != "string")
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e4);
            const r4 = e4.length, n3 = arguments.length > 2 && arguments[2] === true;
            if (!n3 && r4 === 0)
              return 0;
            let o4 = false;
            for (; ; )
              switch (t4) {
                case "ascii":
                case "latin1":
                case "binary":
                  return r4;
                case "utf8":
                case "utf-8":
                  return V2(e4).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * r4;
                case "hex":
                  return r4 >>> 1;
                case "base64":
                  return $3(e4).length;
                default:
                  if (o4)
                    return n3 ? -1 : V2(e4).length;
                  t4 = ("" + t4).toLowerCase(), o4 = true;
              }
          }
          function y3(e4, t4, r4) {
            let n3 = false;
            if ((t4 === void 0 || t4 < 0) && (t4 = 0), t4 > this.length)
              return "";
            if ((r4 === void 0 || r4 > this.length) && (r4 = this.length), r4 <= 0)
              return "";
            if ((r4 >>>= 0) <= (t4 >>>= 0))
              return "";
            for (e4 || (e4 = "utf8"); ; )
              switch (e4) {
                case "hex":
                  return I3(this, t4, r4);
                case "utf8":
                case "utf-8":
                  return _4(this, t4, r4);
                case "ascii":
                  return U2(this, t4, r4);
                case "latin1":
                case "binary":
                  return k3(this, t4, r4);
                case "base64":
                  return T4(this, t4, r4);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return C3(this, t4, r4);
                default:
                  if (n3)
                    throw new TypeError("Unknown encoding: " + e4);
                  e4 = (e4 + "").toLowerCase(), n3 = true;
              }
          }
          function m3(e4, t4, r4) {
            const n3 = e4[t4];
            e4[t4] = e4[r4], e4[r4] = n3;
          }
          function b2(e4, t4, r4, n3, o4) {
            if (e4.length === 0)
              return -1;
            if (typeof r4 == "string" ? (n3 = r4, r4 = 0) : r4 > 2147483647 ? r4 = 2147483647 : r4 < -2147483648 && (r4 = -2147483648), Y2(r4 = +r4) && (r4 = o4 ? 0 : e4.length - 1), r4 < 0 && (r4 = e4.length + r4), r4 >= e4.length) {
              if (o4)
                return -1;
              r4 = e4.length - 1;
            } else if (r4 < 0) {
              if (!o4)
                return -1;
              r4 = 0;
            }
            if (typeof t4 == "string" && (t4 = c3.from(t4, n3)), c3.isBuffer(t4))
              return t4.length === 0 ? -1 : A4(e4, t4, r4, n3, o4);
            if (typeof t4 == "number")
              return t4 &= 255, typeof Uint8Array.prototype.indexOf == "function" ? o4 ? Uint8Array.prototype.indexOf.call(e4, t4, r4) : Uint8Array.prototype.lastIndexOf.call(e4, t4, r4) : A4(e4, [t4], r4, n3, o4);
            throw new TypeError("val must be string, number or Buffer");
          }
          function A4(e4, t4, r4, n3, o4) {
            let s4, i4 = 1, a4 = e4.length, c4 = t4.length;
            if (n3 !== void 0 && ((n3 = String(n3).toLowerCase()) === "ucs2" || n3 === "ucs-2" || n3 === "utf16le" || n3 === "utf-16le")) {
              if (e4.length < 2 || t4.length < 2)
                return -1;
              i4 = 2, a4 /= 2, c4 /= 2, r4 /= 2;
            }
            function u4(e5, t5) {
              return i4 === 1 ? e5[t5] : e5.readUInt16BE(t5 * i4);
            }
            if (o4) {
              let n4 = -1;
              for (s4 = r4; s4 < a4; s4++)
                if (u4(e4, s4) === u4(t4, n4 === -1 ? 0 : s4 - n4)) {
                  if (n4 === -1 && (n4 = s4), s4 - n4 + 1 === c4)
                    return n4 * i4;
                } else
                  n4 !== -1 && (s4 -= s4 - n4), n4 = -1;
            } else
              for (r4 + c4 > a4 && (r4 = a4 - c4), s4 = r4; s4 >= 0; s4--) {
                let r5 = true;
                for (let n4 = 0; n4 < c4; n4++)
                  if (u4(e4, s4 + n4) !== u4(t4, n4)) {
                    r5 = false;
                    break;
                  }
                if (r5)
                  return s4;
              }
            return -1;
          }
          function w4(e4, t4, r4, n3) {
            r4 = Number(r4) || 0;
            const o4 = e4.length - r4;
            n3 ? (n3 = Number(n3)) > o4 && (n3 = o4) : n3 = o4;
            const s4 = t4.length;
            let i4;
            for (n3 > s4 / 2 && (n3 = s4 / 2), i4 = 0; i4 < n3; ++i4) {
              const n4 = parseInt(t4.substr(2 * i4, 2), 16);
              if (Y2(n4))
                return i4;
              e4[r4 + i4] = n4;
            }
            return i4;
          }
          function v3(e4, t4, r4, n3) {
            return W2(V2(t4, e4.length - r4), e4, r4, n3);
          }
          function x3(e4, t4, r4, n3) {
            return W2(function(e5) {
              const t5 = [];
              for (let r5 = 0; r5 < e5.length; ++r5)
                t5.push(255 & e5.charCodeAt(r5));
              return t5;
            }(t4), e4, r4, n3);
          }
          function S2(e4, t4, r4, n3) {
            return W2($3(t4), e4, r4, n3);
          }
          function E4(e4, t4, r4, n3) {
            return W2(function(e5, t5) {
              let r5, n4, o4;
              const s4 = [];
              for (let i4 = 0; i4 < e5.length && !((t5 -= 2) < 0); ++i4)
                r5 = e5.charCodeAt(i4), n4 = r5 >> 8, o4 = r5 % 256, s4.push(o4), s4.push(n4);
              return s4;
            }(t4, e4.length - r4), e4, r4, n3);
          }
          function T4(e4, t4, r4) {
            return t4 === 0 && r4 === e4.length ? n2.fromByteArray(e4) : n2.fromByteArray(e4.slice(t4, r4));
          }
          function _4(e4, t4, r4) {
            r4 = Math.min(e4.length, r4);
            const n3 = [];
            let o4 = t4;
            for (; o4 < r4; ) {
              const t5 = e4[o4];
              let s4 = null, i4 = t5 > 239 ? 4 : t5 > 223 ? 3 : t5 > 191 ? 2 : 1;
              if (o4 + i4 <= r4) {
                let r5, n4, a4, c4;
                switch (i4) {
                  case 1:
                    t5 < 128 && (s4 = t5);
                    break;
                  case 2:
                    r5 = e4[o4 + 1], (192 & r5) == 128 && (c4 = (31 & t5) << 6 | 63 & r5, c4 > 127 && (s4 = c4));
                    break;
                  case 3:
                    r5 = e4[o4 + 1], n4 = e4[o4 + 2], (192 & r5) == 128 && (192 & n4) == 128 && (c4 = (15 & t5) << 12 | (63 & r5) << 6 | 63 & n4, c4 > 2047 && (c4 < 55296 || c4 > 57343) && (s4 = c4));
                    break;
                  case 4:
                    r5 = e4[o4 + 1], n4 = e4[o4 + 2], a4 = e4[o4 + 3], (192 & r5) == 128 && (192 & n4) == 128 && (192 & a4) == 128 && (c4 = (15 & t5) << 18 | (63 & r5) << 12 | (63 & n4) << 6 | 63 & a4, c4 > 65535 && c4 < 1114112 && (s4 = c4));
                }
              }
              s4 === null ? (s4 = 65533, i4 = 1) : s4 > 65535 && (s4 -= 65536, n3.push(s4 >>> 10 & 1023 | 55296), s4 = 56320 | 1023 & s4), n3.push(s4), o4 += i4;
            }
            return function(e5) {
              const t5 = e5.length;
              if (t5 <= B2)
                return String.fromCharCode.apply(String, e5);
              let r5 = "", n4 = 0;
              for (; n4 < t5; )
                r5 += String.fromCharCode.apply(String, e5.slice(n4, n4 += B2));
              return r5;
            }(n3);
          }
          t3.kMaxLength = i3, c3.TYPED_ARRAY_SUPPORT = function() {
            try {
              const e4 = new Uint8Array(1), t4 = { foo: function() {
                return 42;
              } };
              return Object.setPrototypeOf(t4, Uint8Array.prototype), Object.setPrototypeOf(e4, t4), e4.foo() === 42;
            } catch (e4) {
              return false;
            }
          }(), c3.TYPED_ARRAY_SUPPORT || typeof console == "undefined" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(c3.prototype, "parent", { enumerable: true, get: function() {
            if (c3.isBuffer(this))
              return this.buffer;
          } }), Object.defineProperty(c3.prototype, "offset", { enumerable: true, get: function() {
            if (c3.isBuffer(this))
              return this.byteOffset;
          } }), c3.poolSize = 8192, c3.from = function(e4, t4, r4) {
            return u3(e4, t4, r4);
          }, Object.setPrototypeOf(c3.prototype, Uint8Array.prototype), Object.setPrototypeOf(c3, Uint8Array), c3.alloc = function(e4, t4, r4) {
            return function(e5, t5, r5) {
              return l3(e5), e5 <= 0 ? a3(e5) : t5 !== void 0 ? typeof r5 == "string" ? a3(e5).fill(t5, r5) : a3(e5).fill(t5) : a3(e5);
            }(e4, t4, r4);
          }, c3.allocUnsafe = function(e4) {
            return h3(e4);
          }, c3.allocUnsafeSlow = function(e4) {
            return h3(e4);
          }, c3.isBuffer = function(e4) {
            return e4 != null && e4._isBuffer === true && e4 !== c3.prototype;
          }, c3.compare = function(e4, t4) {
            if (X2(e4, Uint8Array) && (e4 = c3.from(e4, e4.offset, e4.byteLength)), X2(t4, Uint8Array) && (t4 = c3.from(t4, t4.offset, t4.byteLength)), !c3.isBuffer(e4) || !c3.isBuffer(t4))
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (e4 === t4)
              return 0;
            let r4 = e4.length, n3 = t4.length;
            for (let o4 = 0, s4 = Math.min(r4, n3); o4 < s4; ++o4)
              if (e4[o4] !== t4[o4]) {
                r4 = e4[o4], n3 = t4[o4];
                break;
              }
            return r4 < n3 ? -1 : n3 < r4 ? 1 : 0;
          }, c3.isEncoding = function(e4) {
            switch (String(e4).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, c3.concat = function(e4, t4) {
            if (!Array.isArray(e4))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (e4.length === 0)
              return c3.alloc(0);
            let r4;
            if (t4 === void 0)
              for (t4 = 0, r4 = 0; r4 < e4.length; ++r4)
                t4 += e4[r4].length;
            const n3 = c3.allocUnsafe(t4);
            let o4 = 0;
            for (r4 = 0; r4 < e4.length; ++r4) {
              let t5 = e4[r4];
              if (X2(t5, Uint8Array))
                o4 + t5.length > n3.length ? (c3.isBuffer(t5) || (t5 = c3.from(t5)), t5.copy(n3, o4)) : Uint8Array.prototype.set.call(n3, t5, o4);
              else {
                if (!c3.isBuffer(t5))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                t5.copy(n3, o4);
              }
              o4 += t5.length;
            }
            return n3;
          }, c3.byteLength = g3, c3.prototype._isBuffer = true, c3.prototype.swap16 = function() {
            const e4 = this.length;
            if (e4 % 2 != 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let t4 = 0; t4 < e4; t4 += 2)
              m3(this, t4, t4 + 1);
            return this;
          }, c3.prototype.swap32 = function() {
            const e4 = this.length;
            if (e4 % 4 != 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let t4 = 0; t4 < e4; t4 += 4)
              m3(this, t4, t4 + 3), m3(this, t4 + 1, t4 + 2);
            return this;
          }, c3.prototype.swap64 = function() {
            const e4 = this.length;
            if (e4 % 8 != 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let t4 = 0; t4 < e4; t4 += 8)
              m3(this, t4, t4 + 7), m3(this, t4 + 1, t4 + 6), m3(this, t4 + 2, t4 + 5), m3(this, t4 + 3, t4 + 4);
            return this;
          }, c3.prototype.toString = function() {
            const e4 = this.length;
            return e4 === 0 ? "" : arguments.length === 0 ? _4(this, 0, e4) : y3.apply(this, arguments);
          }, c3.prototype.toLocaleString = c3.prototype.toString, c3.prototype.equals = function(e4) {
            if (!c3.isBuffer(e4))
              throw new TypeError("Argument must be a Buffer");
            return this === e4 || c3.compare(this, e4) === 0;
          }, c3.prototype.inspect = function() {
            let e4 = "";
            const r4 = t3.INSPECT_MAX_BYTES;
            return e4 = this.toString("hex", 0, r4).replace(/(.{2})/g, "$1 ").trim(), this.length > r4 && (e4 += " ... "), "<Buffer " + e4 + ">";
          }, s3 && (c3.prototype[s3] = c3.prototype.inspect), c3.prototype.compare = function(e4, t4, r4, n3, o4) {
            if (X2(e4, Uint8Array) && (e4 = c3.from(e4, e4.offset, e4.byteLength)), !c3.isBuffer(e4))
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e4);
            if (t4 === void 0 && (t4 = 0), r4 === void 0 && (r4 = e4 ? e4.length : 0), n3 === void 0 && (n3 = 0), o4 === void 0 && (o4 = this.length), t4 < 0 || r4 > e4.length || n3 < 0 || o4 > this.length)
              throw new RangeError("out of range index");
            if (n3 >= o4 && t4 >= r4)
              return 0;
            if (n3 >= o4)
              return -1;
            if (t4 >= r4)
              return 1;
            if (this === e4)
              return 0;
            let s4 = (o4 >>>= 0) - (n3 >>>= 0), i4 = (r4 >>>= 0) - (t4 >>>= 0);
            const a4 = Math.min(s4, i4), u4 = this.slice(n3, o4), l4 = e4.slice(t4, r4);
            for (let e5 = 0; e5 < a4; ++e5)
              if (u4[e5] !== l4[e5]) {
                s4 = u4[e5], i4 = l4[e5];
                break;
              }
            return s4 < i4 ? -1 : i4 < s4 ? 1 : 0;
          }, c3.prototype.includes = function(e4, t4, r4) {
            return this.indexOf(e4, t4, r4) !== -1;
          }, c3.prototype.indexOf = function(e4, t4, r4) {
            return b2(this, e4, t4, r4, true);
          }, c3.prototype.lastIndexOf = function(e4, t4, r4) {
            return b2(this, e4, t4, r4, false);
          }, c3.prototype.write = function(e4, t4, r4, n3) {
            if (t4 === void 0)
              n3 = "utf8", r4 = this.length, t4 = 0;
            else if (r4 === void 0 && typeof t4 == "string")
              n3 = t4, r4 = this.length, t4 = 0;
            else {
              if (!isFinite(t4))
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              t4 >>>= 0, isFinite(r4) ? (r4 >>>= 0, n3 === void 0 && (n3 = "utf8")) : (n3 = r4, r4 = void 0);
            }
            const o4 = this.length - t4;
            if ((r4 === void 0 || r4 > o4) && (r4 = o4), e4.length > 0 && (r4 < 0 || t4 < 0) || t4 > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            n3 || (n3 = "utf8");
            let s4 = false;
            for (; ; )
              switch (n3) {
                case "hex":
                  return w4(this, e4, t4, r4);
                case "utf8":
                case "utf-8":
                  return v3(this, e4, t4, r4);
                case "ascii":
                case "latin1":
                case "binary":
                  return x3(this, e4, t4, r4);
                case "base64":
                  return S2(this, e4, t4, r4);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return E4(this, e4, t4, r4);
                default:
                  if (s4)
                    throw new TypeError("Unknown encoding: " + n3);
                  n3 = ("" + n3).toLowerCase(), s4 = true;
              }
          }, c3.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          const B2 = 4096;
          function U2(e4, t4, r4) {
            let n3 = "";
            r4 = Math.min(e4.length, r4);
            for (let o4 = t4; o4 < r4; ++o4)
              n3 += String.fromCharCode(127 & e4[o4]);
            return n3;
          }
          function k3(e4, t4, r4) {
            let n3 = "";
            r4 = Math.min(e4.length, r4);
            for (let o4 = t4; o4 < r4; ++o4)
              n3 += String.fromCharCode(e4[o4]);
            return n3;
          }
          function I3(e4, t4, r4) {
            const n3 = e4.length;
            (!t4 || t4 < 0) && (t4 = 0), (!r4 || r4 < 0 || r4 > n3) && (r4 = n3);
            let o4 = "";
            for (let n4 = t4; n4 < r4; ++n4)
              o4 += J2[e4[n4]];
            return o4;
          }
          function C3(e4, t4, r4) {
            const n3 = e4.slice(t4, r4);
            let o4 = "";
            for (let e5 = 0; e5 < n3.length - 1; e5 += 2)
              o4 += String.fromCharCode(n3[e5] + 256 * n3[e5 + 1]);
            return o4;
          }
          function R2(e4, t4, r4) {
            if (e4 % 1 != 0 || e4 < 0)
              throw new RangeError("offset is not uint");
            if (e4 + t4 > r4)
              throw new RangeError("Trying to access beyond buffer length");
          }
          function O2(e4, t4, r4, n3, o4, s4) {
            if (!c3.isBuffer(e4))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (t4 > o4 || t4 < s4)
              throw new RangeError('"value" argument is out of bounds');
            if (r4 + n3 > e4.length)
              throw new RangeError("Index out of range");
          }
          function D3(e4, t4, r4, n3, o4) {
            H3(t4, n3, o4, e4, r4, 7);
            let s4 = Number(t4 & BigInt(4294967295));
            e4[r4++] = s4, s4 >>= 8, e4[r4++] = s4, s4 >>= 8, e4[r4++] = s4, s4 >>= 8, e4[r4++] = s4;
            let i4 = Number(t4 >> BigInt(32) & BigInt(4294967295));
            return e4[r4++] = i4, i4 >>= 8, e4[r4++] = i4, i4 >>= 8, e4[r4++] = i4, i4 >>= 8, e4[r4++] = i4, r4;
          }
          function N3(e4, t4, r4, n3, o4) {
            H3(t4, n3, o4, e4, r4, 7);
            let s4 = Number(t4 & BigInt(4294967295));
            e4[r4 + 7] = s4, s4 >>= 8, e4[r4 + 6] = s4, s4 >>= 8, e4[r4 + 5] = s4, s4 >>= 8, e4[r4 + 4] = s4;
            let i4 = Number(t4 >> BigInt(32) & BigInt(4294967295));
            return e4[r4 + 3] = i4, i4 >>= 8, e4[r4 + 2] = i4, i4 >>= 8, e4[r4 + 1] = i4, i4 >>= 8, e4[r4] = i4, r4 + 8;
          }
          function P3(e4, t4, r4, n3, o4, s4) {
            if (r4 + n3 > e4.length)
              throw new RangeError("Index out of range");
            if (r4 < 0)
              throw new RangeError("Index out of range");
          }
          function L3(e4, t4, r4, n3, s4) {
            return t4 = +t4, r4 >>>= 0, s4 || P3(e4, 0, r4, 4), o3.write(e4, t4, r4, n3, 23, 4), r4 + 4;
          }
          function F3(e4, t4, r4, n3, s4) {
            return t4 = +t4, r4 >>>= 0, s4 || P3(e4, 0, r4, 8), o3.write(e4, t4, r4, n3, 52, 8), r4 + 8;
          }
          c3.prototype.slice = function(e4, t4) {
            const r4 = this.length;
            (e4 = ~~e4) < 0 ? (e4 += r4) < 0 && (e4 = 0) : e4 > r4 && (e4 = r4), (t4 = t4 === void 0 ? r4 : ~~t4) < 0 ? (t4 += r4) < 0 && (t4 = 0) : t4 > r4 && (t4 = r4), t4 < e4 && (t4 = e4);
            const n3 = this.subarray(e4, t4);
            return Object.setPrototypeOf(n3, c3.prototype), n3;
          }, c3.prototype.readUintLE = c3.prototype.readUIntLE = function(e4, t4, r4) {
            e4 >>>= 0, t4 >>>= 0, r4 || R2(e4, t4, this.length);
            let n3 = this[e4], o4 = 1, s4 = 0;
            for (; ++s4 < t4 && (o4 *= 256); )
              n3 += this[e4 + s4] * o4;
            return n3;
          }, c3.prototype.readUintBE = c3.prototype.readUIntBE = function(e4, t4, r4) {
            e4 >>>= 0, t4 >>>= 0, r4 || R2(e4, t4, this.length);
            let n3 = this[e4 + --t4], o4 = 1;
            for (; t4 > 0 && (o4 *= 256); )
              n3 += this[e4 + --t4] * o4;
            return n3;
          }, c3.prototype.readUint8 = c3.prototype.readUInt8 = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 1, this.length), this[e4];
          }, c3.prototype.readUint16LE = c3.prototype.readUInt16LE = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 2, this.length), this[e4] | this[e4 + 1] << 8;
          }, c3.prototype.readUint16BE = c3.prototype.readUInt16BE = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 2, this.length), this[e4] << 8 | this[e4 + 1];
          }, c3.prototype.readUint32LE = c3.prototype.readUInt32LE = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 4, this.length), (this[e4] | this[e4 + 1] << 8 | this[e4 + 2] << 16) + 16777216 * this[e4 + 3];
          }, c3.prototype.readUint32BE = c3.prototype.readUInt32BE = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 4, this.length), 16777216 * this[e4] + (this[e4 + 1] << 16 | this[e4 + 2] << 8 | this[e4 + 3]);
          }, c3.prototype.readBigUInt64LE = Q2(function(e4) {
            G2(e4 >>>= 0, "offset");
            const t4 = this[e4], r4 = this[e4 + 7];
            t4 !== void 0 && r4 !== void 0 || K3(e4, this.length - 8);
            const n3 = t4 + 256 * this[++e4] + 65536 * this[++e4] + this[++e4] * 2 ** 24, o4 = this[++e4] + 256 * this[++e4] + 65536 * this[++e4] + r4 * 2 ** 24;
            return BigInt(n3) + (BigInt(o4) << BigInt(32));
          }), c3.prototype.readBigUInt64BE = Q2(function(e4) {
            G2(e4 >>>= 0, "offset");
            const t4 = this[e4], r4 = this[e4 + 7];
            t4 !== void 0 && r4 !== void 0 || K3(e4, this.length - 8);
            const n3 = t4 * 2 ** 24 + 65536 * this[++e4] + 256 * this[++e4] + this[++e4], o4 = this[++e4] * 2 ** 24 + 65536 * this[++e4] + 256 * this[++e4] + r4;
            return (BigInt(n3) << BigInt(32)) + BigInt(o4);
          }), c3.prototype.readIntLE = function(e4, t4, r4) {
            e4 >>>= 0, t4 >>>= 0, r4 || R2(e4, t4, this.length);
            let n3 = this[e4], o4 = 1, s4 = 0;
            for (; ++s4 < t4 && (o4 *= 256); )
              n3 += this[e4 + s4] * o4;
            return o4 *= 128, n3 >= o4 && (n3 -= Math.pow(2, 8 * t4)), n3;
          }, c3.prototype.readIntBE = function(e4, t4, r4) {
            e4 >>>= 0, t4 >>>= 0, r4 || R2(e4, t4, this.length);
            let n3 = t4, o4 = 1, s4 = this[e4 + --n3];
            for (; n3 > 0 && (o4 *= 256); )
              s4 += this[e4 + --n3] * o4;
            return o4 *= 128, s4 >= o4 && (s4 -= Math.pow(2, 8 * t4)), s4;
          }, c3.prototype.readInt8 = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 1, this.length), 128 & this[e4] ? -1 * (255 - this[e4] + 1) : this[e4];
          }, c3.prototype.readInt16LE = function(e4, t4) {
            e4 >>>= 0, t4 || R2(e4, 2, this.length);
            const r4 = this[e4] | this[e4 + 1] << 8;
            return 32768 & r4 ? 4294901760 | r4 : r4;
          }, c3.prototype.readInt16BE = function(e4, t4) {
            e4 >>>= 0, t4 || R2(e4, 2, this.length);
            const r4 = this[e4 + 1] | this[e4] << 8;
            return 32768 & r4 ? 4294901760 | r4 : r4;
          }, c3.prototype.readInt32LE = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 4, this.length), this[e4] | this[e4 + 1] << 8 | this[e4 + 2] << 16 | this[e4 + 3] << 24;
          }, c3.prototype.readInt32BE = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 4, this.length), this[e4] << 24 | this[e4 + 1] << 16 | this[e4 + 2] << 8 | this[e4 + 3];
          }, c3.prototype.readBigInt64LE = Q2(function(e4) {
            G2(e4 >>>= 0, "offset");
            const t4 = this[e4], r4 = this[e4 + 7];
            t4 !== void 0 && r4 !== void 0 || K3(e4, this.length - 8);
            const n3 = this[e4 + 4] + 256 * this[e4 + 5] + 65536 * this[e4 + 6] + (r4 << 24);
            return (BigInt(n3) << BigInt(32)) + BigInt(t4 + 256 * this[++e4] + 65536 * this[++e4] + this[++e4] * 2 ** 24);
          }), c3.prototype.readBigInt64BE = Q2(function(e4) {
            G2(e4 >>>= 0, "offset");
            const t4 = this[e4], r4 = this[e4 + 7];
            t4 !== void 0 && r4 !== void 0 || K3(e4, this.length - 8);
            const n3 = (t4 << 24) + 65536 * this[++e4] + 256 * this[++e4] + this[++e4];
            return (BigInt(n3) << BigInt(32)) + BigInt(this[++e4] * 2 ** 24 + 65536 * this[++e4] + 256 * this[++e4] + r4);
          }), c3.prototype.readFloatLE = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 4, this.length), o3.read(this, e4, true, 23, 4);
          }, c3.prototype.readFloatBE = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 4, this.length), o3.read(this, e4, false, 23, 4);
          }, c3.prototype.readDoubleLE = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 8, this.length), o3.read(this, e4, true, 52, 8);
          }, c3.prototype.readDoubleBE = function(e4, t4) {
            return e4 >>>= 0, t4 || R2(e4, 8, this.length), o3.read(this, e4, false, 52, 8);
          }, c3.prototype.writeUintLE = c3.prototype.writeUIntLE = function(e4, t4, r4, n3) {
            e4 = +e4, t4 >>>= 0, r4 >>>= 0, n3 || O2(this, e4, t4, r4, Math.pow(2, 8 * r4) - 1, 0);
            let o4 = 1, s4 = 0;
            for (this[t4] = 255 & e4; ++s4 < r4 && (o4 *= 256); )
              this[t4 + s4] = e4 / o4 & 255;
            return t4 + r4;
          }, c3.prototype.writeUintBE = c3.prototype.writeUIntBE = function(e4, t4, r4, n3) {
            e4 = +e4, t4 >>>= 0, r4 >>>= 0, n3 || O2(this, e4, t4, r4, Math.pow(2, 8 * r4) - 1, 0);
            let o4 = r4 - 1, s4 = 1;
            for (this[t4 + o4] = 255 & e4; --o4 >= 0 && (s4 *= 256); )
              this[t4 + o4] = e4 / s4 & 255;
            return t4 + r4;
          }, c3.prototype.writeUint8 = c3.prototype.writeUInt8 = function(e4, t4, r4) {
            return e4 = +e4, t4 >>>= 0, r4 || O2(this, e4, t4, 1, 255, 0), this[t4] = 255 & e4, t4 + 1;
          }, c3.prototype.writeUint16LE = c3.prototype.writeUInt16LE = function(e4, t4, r4) {
            return e4 = +e4, t4 >>>= 0, r4 || O2(this, e4, t4, 2, 65535, 0), this[t4] = 255 & e4, this[t4 + 1] = e4 >>> 8, t4 + 2;
          }, c3.prototype.writeUint16BE = c3.prototype.writeUInt16BE = function(e4, t4, r4) {
            return e4 = +e4, t4 >>>= 0, r4 || O2(this, e4, t4, 2, 65535, 0), this[t4] = e4 >>> 8, this[t4 + 1] = 255 & e4, t4 + 2;
          }, c3.prototype.writeUint32LE = c3.prototype.writeUInt32LE = function(e4, t4, r4) {
            return e4 = +e4, t4 >>>= 0, r4 || O2(this, e4, t4, 4, 4294967295, 0), this[t4 + 3] = e4 >>> 24, this[t4 + 2] = e4 >>> 16, this[t4 + 1] = e4 >>> 8, this[t4] = 255 & e4, t4 + 4;
          }, c3.prototype.writeUint32BE = c3.prototype.writeUInt32BE = function(e4, t4, r4) {
            return e4 = +e4, t4 >>>= 0, r4 || O2(this, e4, t4, 4, 4294967295, 0), this[t4] = e4 >>> 24, this[t4 + 1] = e4 >>> 16, this[t4 + 2] = e4 >>> 8, this[t4 + 3] = 255 & e4, t4 + 4;
          }, c3.prototype.writeBigUInt64LE = Q2(function(e4, t4 = 0) {
            return D3(this, e4, t4, BigInt(0), BigInt("0xffffffffffffffff"));
          }), c3.prototype.writeBigUInt64BE = Q2(function(e4, t4 = 0) {
            return N3(this, e4, t4, BigInt(0), BigInt("0xffffffffffffffff"));
          }), c3.prototype.writeIntLE = function(e4, t4, r4, n3) {
            if (e4 = +e4, t4 >>>= 0, !n3) {
              const n4 = Math.pow(2, 8 * r4 - 1);
              O2(this, e4, t4, r4, n4 - 1, -n4);
            }
            let o4 = 0, s4 = 1, i4 = 0;
            for (this[t4] = 255 & e4; ++o4 < r4 && (s4 *= 256); )
              e4 < 0 && i4 === 0 && this[t4 + o4 - 1] !== 0 && (i4 = 1), this[t4 + o4] = (e4 / s4 >> 0) - i4 & 255;
            return t4 + r4;
          }, c3.prototype.writeIntBE = function(e4, t4, r4, n3) {
            if (e4 = +e4, t4 >>>= 0, !n3) {
              const n4 = Math.pow(2, 8 * r4 - 1);
              O2(this, e4, t4, r4, n4 - 1, -n4);
            }
            let o4 = r4 - 1, s4 = 1, i4 = 0;
            for (this[t4 + o4] = 255 & e4; --o4 >= 0 && (s4 *= 256); )
              e4 < 0 && i4 === 0 && this[t4 + o4 + 1] !== 0 && (i4 = 1), this[t4 + o4] = (e4 / s4 >> 0) - i4 & 255;
            return t4 + r4;
          }, c3.prototype.writeInt8 = function(e4, t4, r4) {
            return e4 = +e4, t4 >>>= 0, r4 || O2(this, e4, t4, 1, 127, -128), e4 < 0 && (e4 = 255 + e4 + 1), this[t4] = 255 & e4, t4 + 1;
          }, c3.prototype.writeInt16LE = function(e4, t4, r4) {
            return e4 = +e4, t4 >>>= 0, r4 || O2(this, e4, t4, 2, 32767, -32768), this[t4] = 255 & e4, this[t4 + 1] = e4 >>> 8, t4 + 2;
          }, c3.prototype.writeInt16BE = function(e4, t4, r4) {
            return e4 = +e4, t4 >>>= 0, r4 || O2(this, e4, t4, 2, 32767, -32768), this[t4] = e4 >>> 8, this[t4 + 1] = 255 & e4, t4 + 2;
          }, c3.prototype.writeInt32LE = function(e4, t4, r4) {
            return e4 = +e4, t4 >>>= 0, r4 || O2(this, e4, t4, 4, 2147483647, -2147483648), this[t4] = 255 & e4, this[t4 + 1] = e4 >>> 8, this[t4 + 2] = e4 >>> 16, this[t4 + 3] = e4 >>> 24, t4 + 4;
          }, c3.prototype.writeInt32BE = function(e4, t4, r4) {
            return e4 = +e4, t4 >>>= 0, r4 || O2(this, e4, t4, 4, 2147483647, -2147483648), e4 < 0 && (e4 = 4294967295 + e4 + 1), this[t4] = e4 >>> 24, this[t4 + 1] = e4 >>> 16, this[t4 + 2] = e4 >>> 8, this[t4 + 3] = 255 & e4, t4 + 4;
          }, c3.prototype.writeBigInt64LE = Q2(function(e4, t4 = 0) {
            return D3(this, e4, t4, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
          }), c3.prototype.writeBigInt64BE = Q2(function(e4, t4 = 0) {
            return N3(this, e4, t4, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
          }), c3.prototype.writeFloatLE = function(e4, t4, r4) {
            return L3(this, e4, t4, true, r4);
          }, c3.prototype.writeFloatBE = function(e4, t4, r4) {
            return L3(this, e4, t4, false, r4);
          }, c3.prototype.writeDoubleLE = function(e4, t4, r4) {
            return F3(this, e4, t4, true, r4);
          }, c3.prototype.writeDoubleBE = function(e4, t4, r4) {
            return F3(this, e4, t4, false, r4);
          }, c3.prototype.copy = function(e4, t4, r4, n3) {
            if (!c3.isBuffer(e4))
              throw new TypeError("argument should be a Buffer");
            if (r4 || (r4 = 0), n3 || n3 === 0 || (n3 = this.length), t4 >= e4.length && (t4 = e4.length), t4 || (t4 = 0), n3 > 0 && n3 < r4 && (n3 = r4), n3 === r4)
              return 0;
            if (e4.length === 0 || this.length === 0)
              return 0;
            if (t4 < 0)
              throw new RangeError("targetStart out of bounds");
            if (r4 < 0 || r4 >= this.length)
              throw new RangeError("Index out of range");
            if (n3 < 0)
              throw new RangeError("sourceEnd out of bounds");
            n3 > this.length && (n3 = this.length), e4.length - t4 < n3 - r4 && (n3 = e4.length - t4 + r4);
            const o4 = n3 - r4;
            return this === e4 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t4, r4, n3) : Uint8Array.prototype.set.call(e4, this.subarray(r4, n3), t4), o4;
          }, c3.prototype.fill = function(e4, t4, r4, n3) {
            if (typeof e4 == "string") {
              if (typeof t4 == "string" ? (n3 = t4, t4 = 0, r4 = this.length) : typeof r4 == "string" && (n3 = r4, r4 = this.length), n3 !== void 0 && typeof n3 != "string")
                throw new TypeError("encoding must be a string");
              if (typeof n3 == "string" && !c3.isEncoding(n3))
                throw new TypeError("Unknown encoding: " + n3);
              if (e4.length === 1) {
                const t5 = e4.charCodeAt(0);
                (n3 === "utf8" && t5 < 128 || n3 === "latin1") && (e4 = t5);
              }
            } else
              typeof e4 == "number" ? e4 &= 255 : typeof e4 == "boolean" && (e4 = Number(e4));
            if (t4 < 0 || this.length < t4 || this.length < r4)
              throw new RangeError("Out of range index");
            if (r4 <= t4)
              return this;
            let o4;
            if (t4 >>>= 0, r4 = r4 === void 0 ? this.length : r4 >>> 0, e4 || (e4 = 0), typeof e4 == "number")
              for (o4 = t4; o4 < r4; ++o4)
                this[o4] = e4;
            else {
              const s4 = c3.isBuffer(e4) ? e4 : c3.from(e4, n3), i4 = s4.length;
              if (i4 === 0)
                throw new TypeError('The value "' + e4 + '" is invalid for argument "value"');
              for (o4 = 0; o4 < r4 - t4; ++o4)
                this[o4 + t4] = s4[o4 % i4];
            }
            return this;
          };
          const z3 = {};
          function j3(e4, t4, r4) {
            z3[e4] = class extends r4 {
              constructor() {
                super(), Object.defineProperty(this, "message", { value: t4.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e4}]`, this.stack, delete this.name;
              }
              get code() {
                return e4;
              }
              set code(e5) {
                Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e5, writable: true });
              }
              toString() {
                return `${this.name} [${e4}]: ${this.message}`;
              }
            };
          }
          function M3(e4) {
            let t4 = "", r4 = e4.length;
            const n3 = e4[0] === "-" ? 1 : 0;
            for (; r4 >= n3 + 4; r4 -= 3)
              t4 = `_${e4.slice(r4 - 3, r4)}${t4}`;
            return `${e4.slice(0, r4)}${t4}`;
          }
          function H3(e4, t4, r4, n3, o4, s4) {
            if (e4 > r4 || e4 < t4) {
              const n4 = typeof t4 == "bigint" ? "n" : "";
              let o5;
              throw o5 = s4 > 3 ? t4 === 0 || t4 === BigInt(0) ? `>= 0${n4} and < 2${n4} ** ${8 * (s4 + 1)}${n4}` : `>= -(2${n4} ** ${8 * (s4 + 1) - 1}${n4}) and < 2 ** ${8 * (s4 + 1) - 1}${n4}` : `>= ${t4}${n4} and <= ${r4}${n4}`, new z3.ERR_OUT_OF_RANGE("value", o5, e4);
            }
            !function(e5, t5, r5) {
              G2(t5, "offset"), e5[t5] !== void 0 && e5[t5 + r5] !== void 0 || K3(t5, e5.length - (r5 + 1));
            }(n3, o4, s4);
          }
          function G2(e4, t4) {
            if (typeof e4 != "number")
              throw new z3.ERR_INVALID_ARG_TYPE(t4, "number", e4);
          }
          function K3(e4, t4, r4) {
            if (Math.floor(e4) !== e4)
              throw G2(e4, r4), new z3.ERR_OUT_OF_RANGE(r4 || "offset", "an integer", e4);
            if (t4 < 0)
              throw new z3.ERR_BUFFER_OUT_OF_BOUNDS();
            throw new z3.ERR_OUT_OF_RANGE(r4 || "offset", `>= ${r4 ? 1 : 0} and <= ${t4}`, e4);
          }
          j3("ERR_BUFFER_OUT_OF_BOUNDS", function(e4) {
            return e4 ? `${e4} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
          }, RangeError), j3("ERR_INVALID_ARG_TYPE", function(e4, t4) {
            return `The "${e4}" argument must be of type number. Received type ${typeof t4}`;
          }, TypeError), j3("ERR_OUT_OF_RANGE", function(e4, t4, r4) {
            let n3 = `The value of "${e4}" is out of range.`, o4 = r4;
            return Number.isInteger(r4) && Math.abs(r4) > 2 ** 32 ? o4 = M3(String(r4)) : typeof r4 == "bigint" && (o4 = String(r4), (r4 > BigInt(2) ** BigInt(32) || r4 < -(BigInt(2) ** BigInt(32))) && (o4 = M3(o4)), o4 += "n"), n3 += ` It must be ${t4}. Received ${o4}`, n3;
          }, RangeError);
          const q3 = /[^+/0-9A-Za-z-_]/g;
          function V2(e4, t4) {
            let r4;
            t4 = t4 || 1 / 0;
            const n3 = e4.length;
            let o4 = null;
            const s4 = [];
            for (let i4 = 0; i4 < n3; ++i4) {
              if (r4 = e4.charCodeAt(i4), r4 > 55295 && r4 < 57344) {
                if (!o4) {
                  if (r4 > 56319) {
                    (t4 -= 3) > -1 && s4.push(239, 191, 189);
                    continue;
                  }
                  if (i4 + 1 === n3) {
                    (t4 -= 3) > -1 && s4.push(239, 191, 189);
                    continue;
                  }
                  o4 = r4;
                  continue;
                }
                if (r4 < 56320) {
                  (t4 -= 3) > -1 && s4.push(239, 191, 189), o4 = r4;
                  continue;
                }
                r4 = 65536 + (o4 - 55296 << 10 | r4 - 56320);
              } else
                o4 && (t4 -= 3) > -1 && s4.push(239, 191, 189);
              if (o4 = null, r4 < 128) {
                if ((t4 -= 1) < 0)
                  break;
                s4.push(r4);
              } else if (r4 < 2048) {
                if ((t4 -= 2) < 0)
                  break;
                s4.push(r4 >> 6 | 192, 63 & r4 | 128);
              } else if (r4 < 65536) {
                if ((t4 -= 3) < 0)
                  break;
                s4.push(r4 >> 12 | 224, r4 >> 6 & 63 | 128, 63 & r4 | 128);
              } else {
                if (!(r4 < 1114112))
                  throw new Error("Invalid code point");
                if ((t4 -= 4) < 0)
                  break;
                s4.push(r4 >> 18 | 240, r4 >> 12 & 63 | 128, r4 >> 6 & 63 | 128, 63 & r4 | 128);
              }
            }
            return s4;
          }
          function $3(e4) {
            return n2.toByteArray(function(e5) {
              if ((e5 = (e5 = e5.split("=")[0]).trim().replace(q3, "")).length < 2)
                return "";
              for (; e5.length % 4 != 0; )
                e5 += "=";
              return e5;
            }(e4));
          }
          function W2(e4, t4, r4, n3) {
            let o4;
            for (o4 = 0; o4 < n3 && !(o4 + r4 >= t4.length || o4 >= e4.length); ++o4)
              t4[o4 + r4] = e4[o4];
            return o4;
          }
          function X2(e4, t4) {
            return e4 instanceof t4 || e4 != null && e4.constructor != null && e4.constructor.name != null && e4.constructor.name === t4.name;
          }
          function Y2(e4) {
            return e4 != e4;
          }
          const J2 = function() {
            const e4 = "0123456789abcdef", t4 = new Array(256);
            for (let r4 = 0; r4 < 16; ++r4) {
              const n3 = 16 * r4;
              for (let o4 = 0; o4 < 16; ++o4)
                t4[n3 + o4] = e4[r4] + e4[o4];
            }
            return t4;
          }();
          function Q2(e4) {
            return typeof BigInt == "undefined" ? Z2 : e4;
          }
          function Z2() {
            throw new Error("BigInt not supported");
          }
        }, 7615: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(1801), o3 = r3(2550), s3 = o3(n2("String.prototype.indexOf"));
          e3.exports = function(e4, t4) {
            var r4 = n2(e4, !!t4);
            return typeof r4 == "function" && s3(e4, ".prototype.") > -1 ? o3(r4) : r4;
          };
        }, 2550: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(1930), o3 = r3(1801), s3 = o3("%Function.prototype.apply%"), i3 = o3("%Function.prototype.call%"), a3 = o3("%Reflect.apply%", true) || n2.call(i3, s3), c3 = o3("%Object.getOwnPropertyDescriptor%", true), u3 = o3("%Object.defineProperty%", true), l3 = o3("%Math.max%");
          if (u3)
            try {
              u3({}, "a", { value: 1 });
            } catch (e4) {
              u3 = null;
            }
          e3.exports = function(e4) {
            var t4 = a3(n2, i3, arguments);
            if (c3 && u3) {
              var r4 = c3(t4, "length");
              r4.configurable && u3(t4, "length", { value: 1 + l3(0, e4.length - (arguments.length - 1)) });
            }
            return t4;
          };
          var h3 = function() {
            return a3(n2, s3, arguments);
          };
          u3 ? u3(e3.exports, "apply", { value: h3 }) : e3.exports.apply = h3;
        }, 1069: (e3) => {
          function t3(e4) {
            if (e4)
              return function(e5) {
                for (var r3 in t3.prototype)
                  e5[r3] = t3.prototype[r3];
                return e5;
              }(e4);
          }
          e3.exports = t3, t3.prototype.on = t3.prototype.addEventListener = function(e4, t4) {
            return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e4] = this._callbacks["$" + e4] || []).push(t4), this;
          }, t3.prototype.once = function(e4, t4) {
            function r3() {
              this.off(e4, r3), t4.apply(this, arguments);
            }
            return r3.fn = t4, this.on(e4, r3), this;
          }, t3.prototype.off = t3.prototype.removeListener = t3.prototype.removeAllListeners = t3.prototype.removeEventListener = function(e4, t4) {
            if (this._callbacks = this._callbacks || {}, arguments.length == 0)
              return this._callbacks = {}, this;
            var r3, n2 = this._callbacks["$" + e4];
            if (!n2)
              return this;
            if (arguments.length == 1)
              return delete this._callbacks["$" + e4], this;
            for (var o3 = 0; o3 < n2.length; o3++)
              if ((r3 = n2[o3]) === t4 || r3.fn === t4) {
                n2.splice(o3, 1);
                break;
              }
            return n2.length === 0 && delete this._callbacks["$" + e4], this;
          }, t3.prototype.emit = function(e4) {
            this._callbacks = this._callbacks || {};
            for (var t4 = new Array(arguments.length - 1), r3 = this._callbacks["$" + e4], n2 = 1; n2 < arguments.length; n2++)
              t4[n2 - 1] = arguments[n2];
            if (r3) {
              n2 = 0;
              for (var o3 = (r3 = r3.slice(0)).length; n2 < o3; ++n2)
                r3[n2].apply(this, t4);
            }
            return this;
          }, t3.prototype.listeners = function(e4) {
            return this._callbacks = this._callbacks || {}, this._callbacks["$" + e4] || [];
          }, t3.prototype.hasListeners = function(e4) {
            return !!this.listeners(e4).length;
          };
        }, 5799: (e3) => {
          e3.exports = n2, n2.default = n2, n2.stable = i3, n2.stableStringify = i3;
          var t3 = [], r3 = [];
          function n2(e4, n3, s4) {
            var i4;
            for (o3(e4, "", [], void 0), i4 = r3.length === 0 ? JSON.stringify(e4, n3, s4) : JSON.stringify(e4, c3(n3), s4); t3.length !== 0; ) {
              var a4 = t3.pop();
              a4.length === 4 ? Object.defineProperty(a4[0], a4[1], a4[3]) : a4[0][a4[1]] = a4[2];
            }
            return i4;
          }
          function o3(e4, n3, s4, i4) {
            var a4;
            if (typeof e4 == "object" && e4 !== null) {
              for (a4 = 0; a4 < s4.length; a4++)
                if (s4[a4] === e4) {
                  var c4 = Object.getOwnPropertyDescriptor(i4, n3);
                  return void (c4.get !== void 0 ? c4.configurable ? (Object.defineProperty(i4, n3, { value: "[Circular]" }), t3.push([i4, n3, e4, c4])) : r3.push([e4, n3]) : (i4[n3] = "[Circular]", t3.push([i4, n3, e4])));
                }
              if (s4.push(e4), Array.isArray(e4))
                for (a4 = 0; a4 < e4.length; a4++)
                  o3(e4[a4], a4, s4, e4);
              else {
                var u3 = Object.keys(e4);
                for (a4 = 0; a4 < u3.length; a4++) {
                  var l3 = u3[a4];
                  o3(e4[l3], l3, s4, e4);
                }
              }
              s4.pop();
            }
          }
          function s3(e4, t4) {
            return e4 < t4 ? -1 : e4 > t4 ? 1 : 0;
          }
          function i3(e4, n3, o4) {
            var s4, i4 = a3(e4, "", [], void 0) || e4;
            for (s4 = r3.length === 0 ? JSON.stringify(i4, n3, o4) : JSON.stringify(i4, c3(n3), o4); t3.length !== 0; ) {
              var u3 = t3.pop();
              u3.length === 4 ? Object.defineProperty(u3[0], u3[1], u3[3]) : u3[0][u3[1]] = u3[2];
            }
            return s4;
          }
          function a3(e4, n3, o4, i4) {
            var c4;
            if (typeof e4 == "object" && e4 !== null) {
              for (c4 = 0; c4 < o4.length; c4++)
                if (o4[c4] === e4) {
                  var u3 = Object.getOwnPropertyDescriptor(i4, n3);
                  return void (u3.get !== void 0 ? u3.configurable ? (Object.defineProperty(i4, n3, { value: "[Circular]" }), t3.push([i4, n3, e4, u3])) : r3.push([e4, n3]) : (i4[n3] = "[Circular]", t3.push([i4, n3, e4])));
                }
              if (typeof e4.toJSON == "function")
                return;
              if (o4.push(e4), Array.isArray(e4))
                for (c4 = 0; c4 < e4.length; c4++)
                  a3(e4[c4], c4, o4, e4);
              else {
                var l3 = {}, h3 = Object.keys(e4).sort(s3);
                for (c4 = 0; c4 < h3.length; c4++) {
                  var p3 = h3[c4];
                  a3(e4[p3], p3, o4, e4), l3[p3] = e4[p3];
                }
                if (i4 === void 0)
                  return l3;
                t3.push([i4, n3, e4]), i4[n3] = l3;
              }
              o4.pop();
            }
          }
          function c3(e4) {
            return e4 = e4 !== void 0 ? e4 : function(e5, t4) {
              return t4;
            }, function(t4, n3) {
              if (r3.length > 0)
                for (var o4 = 0; o4 < r3.length; o4++) {
                  var s4 = r3[o4];
                  if (s4[1] === t4 && s4[0] === n3) {
                    n3 = "[Circular]", r3.splice(o4, 1);
                    break;
                  }
                }
              return e4.call(this, t4, n3);
            };
          }
        }, 9930: (e3) => {
          "use strict";
          var t3 = "Function.prototype.bind called on incompatible ", r3 = Array.prototype.slice, n2 = Object.prototype.toString, o3 = "[object Function]";
          e3.exports = function(e4) {
            var s3 = this;
            if (typeof s3 != "function" || n2.call(s3) !== o3)
              throw new TypeError(t3 + s3);
            for (var i3, a3 = r3.call(arguments, 1), c3 = function() {
              if (this instanceof i3) {
                var t4 = s3.apply(this, a3.concat(r3.call(arguments)));
                return Object(t4) === t4 ? t4 : this;
              }
              return s3.apply(e4, a3.concat(r3.call(arguments)));
            }, u3 = Math.max(0, s3.length - a3.length), l3 = [], h3 = 0; h3 < u3; h3++)
              l3.push("$" + h3);
            if (i3 = Function("binder", "return function (" + l3.join(",") + "){ return binder.apply(this,arguments); }")(c3), s3.prototype) {
              var p3 = function() {
              };
              p3.prototype = s3.prototype, i3.prototype = new p3(), p3.prototype = null;
            }
            return i3;
          };
        }, 1930: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(9930);
          e3.exports = Function.prototype.bind || n2;
        }, 1801: (e3, t3, r3) => {
          "use strict";
          var n2, o3 = SyntaxError, s3 = Function, i3 = TypeError, a3 = function(e4) {
            try {
              return s3('"use strict"; return (' + e4 + ").constructor;")();
            } catch (e5) {
            }
          }, c3 = Object.getOwnPropertyDescriptor;
          if (c3)
            try {
              c3({}, "");
            } catch (e4) {
              c3 = null;
            }
          var u3 = function() {
            throw new i3();
          }, l3 = c3 ? function() {
            try {
              return u3;
            } catch (e4) {
              try {
                return c3(arguments, "callee").get;
              } catch (e5) {
                return u3;
              }
            }
          }() : u3, h3 = r3(9905)(), p3 = Object.getPrototypeOf || function(e4) {
            return e4.__proto__;
          }, f3 = {}, d3 = typeof Uint8Array == "undefined" ? n2 : p3(Uint8Array), g3 = { "%AggregateError%": typeof AggregateError == "undefined" ? n2 : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? n2 : ArrayBuffer, "%ArrayIteratorPrototype%": h3 ? p3([][Symbol.iterator]()) : n2, "%AsyncFromSyncIteratorPrototype%": n2, "%AsyncFunction%": f3, "%AsyncGenerator%": f3, "%AsyncGeneratorFunction%": f3, "%AsyncIteratorPrototype%": f3, "%Atomics%": typeof Atomics == "undefined" ? n2 : Atomics, "%BigInt%": typeof BigInt == "undefined" ? n2 : BigInt, "%Boolean%": Boolean, "%DataView%": typeof DataView == "undefined" ? n2 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array == "undefined" ? n2 : Float32Array, "%Float64Array%": typeof Float64Array == "undefined" ? n2 : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? n2 : FinalizationRegistry, "%Function%": s3, "%GeneratorFunction%": f3, "%Int8Array%": typeof Int8Array == "undefined" ? n2 : Int8Array, "%Int16Array%": typeof Int16Array == "undefined" ? n2 : Int16Array, "%Int32Array%": typeof Int32Array == "undefined" ? n2 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": h3 ? p3(p3([][Symbol.iterator]())) : n2, "%JSON%": typeof JSON == "object" ? JSON : n2, "%Map%": typeof Map == "undefined" ? n2 : Map, "%MapIteratorPrototype%": typeof Map != "undefined" && h3 ? p3((/* @__PURE__ */ new Map())[Symbol.iterator]()) : n2, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise == "undefined" ? n2 : Promise, "%Proxy%": typeof Proxy == "undefined" ? n2 : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect == "undefined" ? n2 : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set == "undefined" ? n2 : Set, "%SetIteratorPrototype%": typeof Set != "undefined" && h3 ? p3((/* @__PURE__ */ new Set())[Symbol.iterator]()) : n2, "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? n2 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": h3 ? p3(""[Symbol.iterator]()) : n2, "%Symbol%": h3 ? Symbol : n2, "%SyntaxError%": o3, "%ThrowTypeError%": l3, "%TypedArray%": d3, "%TypeError%": i3, "%Uint8Array%": typeof Uint8Array == "undefined" ? n2 : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? n2 : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array == "undefined" ? n2 : Uint16Array, "%Uint32Array%": typeof Uint32Array == "undefined" ? n2 : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap == "undefined" ? n2 : WeakMap, "%WeakRef%": typeof WeakRef == "undefined" ? n2 : WeakRef, "%WeakSet%": typeof WeakSet == "undefined" ? n2 : WeakSet }, y3 = function e4(t4) {
            var r4;
            if (t4 === "%AsyncFunction%")
              r4 = a3("async function () {}");
            else if (t4 === "%GeneratorFunction%")
              r4 = a3("function* () {}");
            else if (t4 === "%AsyncGeneratorFunction%")
              r4 = a3("async function* () {}");
            else if (t4 === "%AsyncGenerator%") {
              var n3 = e4("%AsyncGeneratorFunction%");
              n3 && (r4 = n3.prototype);
            } else if (t4 === "%AsyncIteratorPrototype%") {
              var o4 = e4("%AsyncGenerator%");
              o4 && (r4 = p3(o4.prototype));
            }
            return g3[t4] = r4, r4;
          }, m3 = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, b2 = r3(1930), A4 = r3(9284), w4 = b2.call(Function.call, Array.prototype.concat), v3 = b2.call(Function.apply, Array.prototype.splice), x3 = b2.call(Function.call, String.prototype.replace), S2 = b2.call(Function.call, String.prototype.slice), E4 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, T4 = /\\(\\)?/g, _4 = function(e4) {
            var t4 = S2(e4, 0, 1), r4 = S2(e4, -1);
            if (t4 === "%" && r4 !== "%")
              throw new o3("invalid intrinsic syntax, expected closing `%`");
            if (r4 === "%" && t4 !== "%")
              throw new o3("invalid intrinsic syntax, expected opening `%`");
            var n3 = [];
            return x3(e4, E4, function(e5, t5, r5, o4) {
              n3[n3.length] = r5 ? x3(o4, T4, "$1") : t5 || e5;
            }), n3;
          }, B2 = function(e4, t4) {
            var r4, n3 = e4;
            if (A4(m3, n3) && (n3 = "%" + (r4 = m3[n3])[0] + "%"), A4(g3, n3)) {
              var s4 = g3[n3];
              if (s4 === f3 && (s4 = y3(n3)), s4 === void 0 && !t4)
                throw new i3("intrinsic " + e4 + " exists, but is not available. Please file an issue!");
              return { alias: r4, name: n3, value: s4 };
            }
            throw new o3("intrinsic " + e4 + " does not exist!");
          };
          e3.exports = function(e4, t4) {
            if (typeof e4 != "string" || e4.length === 0)
              throw new i3("intrinsic name must be a non-empty string");
            if (arguments.length > 1 && typeof t4 != "boolean")
              throw new i3('"allowMissing" argument must be a boolean');
            var r4 = _4(e4), n3 = r4.length > 0 ? r4[0] : "", s4 = B2("%" + n3 + "%", t4), a4 = s4.name, u4 = s4.value, l4 = false, h4 = s4.alias;
            h4 && (n3 = h4[0], v3(r4, w4([0, 1], h4)));
            for (var p4 = 1, f4 = true; p4 < r4.length; p4 += 1) {
              var d4 = r4[p4], y4 = S2(d4, 0, 1), m4 = S2(d4, -1);
              if ((y4 === '"' || y4 === "'" || y4 === "`" || m4 === '"' || m4 === "'" || m4 === "`") && y4 !== m4)
                throw new o3("property names with quotes must have matching quotes");
              if (d4 !== "constructor" && f4 || (l4 = true), A4(g3, a4 = "%" + (n3 += "." + d4) + "%"))
                u4 = g3[a4];
              else if (u4 != null) {
                if (!(d4 in u4)) {
                  if (!t4)
                    throw new i3("base intrinsic for " + e4 + " exists, but the property is not available.");
                  return;
                }
                if (c3 && p4 + 1 >= r4.length) {
                  var b3 = c3(u4, d4);
                  u4 = (f4 = !!b3) && "get" in b3 && !("originalValue" in b3.get) ? b3.get : u4[d4];
                } else
                  f4 = A4(u4, d4), u4 = u4[d4];
                f4 && !l4 && (g3[a4] = u4);
              }
            }
            return u4;
          };
        }, 9905: (e3, t3, r3) => {
          "use strict";
          var n2 = typeof Symbol != "undefined" && Symbol, o3 = r3(5682);
          e3.exports = function() {
            return typeof n2 == "function" && typeof Symbol == "function" && typeof n2("foo") == "symbol" && typeof Symbol("bar") == "symbol" && o3();
          };
        }, 5682: (e3) => {
          "use strict";
          e3.exports = function() {
            if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
              return false;
            if (typeof Symbol.iterator == "symbol")
              return true;
            var e4 = {}, t3 = Symbol("test"), r3 = Object(t3);
            if (typeof t3 == "string")
              return false;
            if (Object.prototype.toString.call(t3) !== "[object Symbol]")
              return false;
            if (Object.prototype.toString.call(r3) !== "[object Symbol]")
              return false;
            for (t3 in e4[t3] = 42, e4)
              return false;
            if (typeof Object.keys == "function" && Object.keys(e4).length !== 0)
              return false;
            if (typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e4).length !== 0)
              return false;
            var n2 = Object.getOwnPropertySymbols(e4);
            if (n2.length !== 1 || n2[0] !== t3)
              return false;
            if (!Object.prototype.propertyIsEnumerable.call(e4, t3))
              return false;
            if (typeof Object.getOwnPropertyDescriptor == "function") {
              var o3 = Object.getOwnPropertyDescriptor(e4, t3);
              if (o3.value !== 42 || o3.enumerable !== true)
                return false;
            }
            return true;
          };
        }, 9284: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(1930);
          e3.exports = n2.call(Function.call, Object.prototype.hasOwnProperty);
        }, 7267: (e3, t3, r3) => {
          var n2;
          !function() {
            "use strict";
            var t4 = typeof window == "object" ? window : {};
            !t4.HI_BASE32_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node && (t4 = r3.g);
            var o3 = !t4.HI_BASE32_NO_COMMON_JS && e3.exports, s3 = r3.amdO, i3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split(""), a3 = { A: 0, B: 1, C: 2, D: 3, E: 4, F: 5, G: 6, H: 7, I: 8, J: 9, K: 10, L: 11, M: 12, N: 13, O: 14, P: 15, Q: 16, R: 17, S: 18, T: 19, U: 20, V: 21, W: 22, X: 23, Y: 24, Z: 25, 2: 26, 3: 27, 4: 28, 5: 29, 6: 30, 7: 31 }, c3 = [0, 0, 0, 0, 0, 0, 0, 0], u3 = function(e4, t5) {
              t5.length > 10 && (t5 = "..." + t5.substr(-10));
              var r4 = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + e4 + " bytes: " + t5 + " <-");
              throw r4.position = e4, r4;
            }, l3 = function(e4) {
              if (e4 === "")
                return [];
              if (!/^[A-Z2-7=]+$/.test(e4))
                throw new Error("Invalid base32 characters");
              for (var t5, r4, n3, o4, s4, i4, c4, u4, l4 = [], h4 = 0, p4 = (e4 = e4.replace(/=/g, "")).length, f3 = 0, d3 = p4 >> 3 << 3; f3 < d3; )
                t5 = a3[e4.charAt(f3++)], r4 = a3[e4.charAt(f3++)], n3 = a3[e4.charAt(f3++)], o4 = a3[e4.charAt(f3++)], s4 = a3[e4.charAt(f3++)], i4 = a3[e4.charAt(f3++)], c4 = a3[e4.charAt(f3++)], u4 = a3[e4.charAt(f3++)], l4[h4++] = 255 & (t5 << 3 | r4 >>> 2), l4[h4++] = 255 & (r4 << 6 | n3 << 1 | o4 >>> 4), l4[h4++] = 255 & (o4 << 4 | s4 >>> 1), l4[h4++] = 255 & (s4 << 7 | i4 << 2 | c4 >>> 3), l4[h4++] = 255 & (c4 << 5 | u4);
              var g3 = p4 - d3;
              return g3 === 2 ? (t5 = a3[e4.charAt(f3++)], r4 = a3[e4.charAt(f3++)], l4[h4++] = 255 & (t5 << 3 | r4 >>> 2)) : g3 === 4 ? (t5 = a3[e4.charAt(f3++)], r4 = a3[e4.charAt(f3++)], n3 = a3[e4.charAt(f3++)], o4 = a3[e4.charAt(f3++)], l4[h4++] = 255 & (t5 << 3 | r4 >>> 2), l4[h4++] = 255 & (r4 << 6 | n3 << 1 | o4 >>> 4)) : g3 === 5 ? (t5 = a3[e4.charAt(f3++)], r4 = a3[e4.charAt(f3++)], n3 = a3[e4.charAt(f3++)], o4 = a3[e4.charAt(f3++)], s4 = a3[e4.charAt(f3++)], l4[h4++] = 255 & (t5 << 3 | r4 >>> 2), l4[h4++] = 255 & (r4 << 6 | n3 << 1 | o4 >>> 4), l4[h4++] = 255 & (o4 << 4 | s4 >>> 1)) : g3 === 7 && (t5 = a3[e4.charAt(f3++)], r4 = a3[e4.charAt(f3++)], n3 = a3[e4.charAt(f3++)], o4 = a3[e4.charAt(f3++)], s4 = a3[e4.charAt(f3++)], i4 = a3[e4.charAt(f3++)], c4 = a3[e4.charAt(f3++)], l4[h4++] = 255 & (t5 << 3 | r4 >>> 2), l4[h4++] = 255 & (r4 << 6 | n3 << 1 | o4 >>> 4), l4[h4++] = 255 & (o4 << 4 | s4 >>> 1), l4[h4++] = 255 & (s4 << 7 | i4 << 2 | c4 >>> 3)), l4;
            }, h3 = function(e4, t5) {
              if (!t5)
                return function(e5) {
                  for (var t6, r5, n4 = "", o5 = e5.length, s5 = 0, i5 = 0; s5 < o5; )
                    if ((t6 = e5[s5++]) <= 127)
                      n4 += String.fromCharCode(t6);
                    else {
                      t6 > 191 && t6 <= 223 ? (r5 = 31 & t6, i5 = 1) : t6 <= 239 ? (r5 = 15 & t6, i5 = 2) : t6 <= 247 ? (r5 = 7 & t6, i5 = 3) : u3(s5, n4);
                      for (var a4 = 0; a4 < i5; ++a4)
                        ((t6 = e5[s5++]) < 128 || t6 > 191) && u3(s5, n4), r5 <<= 6, r5 += 63 & t6;
                      r5 >= 55296 && r5 <= 57343 && u3(s5, n4), r5 > 1114111 && u3(s5, n4), r5 <= 65535 ? n4 += String.fromCharCode(r5) : (r5 -= 65536, n4 += String.fromCharCode(55296 + (r5 >> 10)), n4 += String.fromCharCode(56320 + (1023 & r5)));
                    }
                  return n4;
                }(l3(e4));
              if (e4 === "")
                return "";
              if (!/^[A-Z2-7=]+$/.test(e4))
                throw new Error("Invalid base32 characters");
              var r4, n3, o4, s4, i4, c4, h4, p4, f3 = "", d3 = e4.indexOf("=");
              d3 === -1 && (d3 = e4.length);
              for (var g3 = 0, y3 = d3 >> 3 << 3; g3 < y3; )
                r4 = a3[e4.charAt(g3++)], n3 = a3[e4.charAt(g3++)], o4 = a3[e4.charAt(g3++)], s4 = a3[e4.charAt(g3++)], i4 = a3[e4.charAt(g3++)], c4 = a3[e4.charAt(g3++)], h4 = a3[e4.charAt(g3++)], p4 = a3[e4.charAt(g3++)], f3 += String.fromCharCode(255 & (r4 << 3 | n3 >>> 2)) + String.fromCharCode(255 & (n3 << 6 | o4 << 1 | s4 >>> 4)) + String.fromCharCode(255 & (s4 << 4 | i4 >>> 1)) + String.fromCharCode(255 & (i4 << 7 | c4 << 2 | h4 >>> 3)) + String.fromCharCode(255 & (h4 << 5 | p4));
              var m3 = d3 - y3;
              return m3 === 2 ? (r4 = a3[e4.charAt(g3++)], n3 = a3[e4.charAt(g3++)], f3 += String.fromCharCode(255 & (r4 << 3 | n3 >>> 2))) : m3 === 4 ? (r4 = a3[e4.charAt(g3++)], n3 = a3[e4.charAt(g3++)], o4 = a3[e4.charAt(g3++)], s4 = a3[e4.charAt(g3++)], f3 += String.fromCharCode(255 & (r4 << 3 | n3 >>> 2)) + String.fromCharCode(255 & (n3 << 6 | o4 << 1 | s4 >>> 4))) : m3 === 5 ? (r4 = a3[e4.charAt(g3++)], n3 = a3[e4.charAt(g3++)], o4 = a3[e4.charAt(g3++)], s4 = a3[e4.charAt(g3++)], i4 = a3[e4.charAt(g3++)], f3 += String.fromCharCode(255 & (r4 << 3 | n3 >>> 2)) + String.fromCharCode(255 & (n3 << 6 | o4 << 1 | s4 >>> 4)) + String.fromCharCode(255 & (s4 << 4 | i4 >>> 1))) : m3 === 7 && (r4 = a3[e4.charAt(g3++)], n3 = a3[e4.charAt(g3++)], o4 = a3[e4.charAt(g3++)], s4 = a3[e4.charAt(g3++)], i4 = a3[e4.charAt(g3++)], c4 = a3[e4.charAt(g3++)], h4 = a3[e4.charAt(g3++)], f3 += String.fromCharCode(255 & (r4 << 3 | n3 >>> 2)) + String.fromCharCode(255 & (n3 << 6 | o4 << 1 | s4 >>> 4)) + String.fromCharCode(255 & (s4 << 4 | i4 >>> 1)) + String.fromCharCode(255 & (i4 << 7 | c4 << 2 | h4 >>> 3))), f3;
            }, p3 = { encode: function(e4, t5) {
              var r4 = typeof e4 != "string";
              return r4 && e4.constructor === ArrayBuffer && (e4 = new Uint8Array(e4)), r4 ? function(e5) {
                for (var t6, r5, n3, o4, s4, a4 = "", c4 = e5.length, u4 = 0, l4 = 5 * parseInt(c4 / 5); u4 < l4; )
                  t6 = e5[u4++], r5 = e5[u4++], n3 = e5[u4++], o4 = e5[u4++], s4 = e5[u4++], a4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[31 & (r5 << 4 | n3 >>> 4)] + i3[31 & (n3 << 1 | o4 >>> 7)] + i3[o4 >>> 2 & 31] + i3[31 & (o4 << 3 | s4 >>> 5)] + i3[31 & s4];
                var h4 = c4 - l4;
                return h4 === 1 ? (t6 = e5[u4], a4 += i3[t6 >>> 3] + i3[t6 << 2 & 31] + "======") : h4 === 2 ? (t6 = e5[u4++], r5 = e5[u4], a4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[r5 << 4 & 31] + "====") : h4 === 3 ? (t6 = e5[u4++], r5 = e5[u4++], n3 = e5[u4], a4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[31 & (r5 << 4 | n3 >>> 4)] + i3[n3 << 1 & 31] + "===") : h4 === 4 && (t6 = e5[u4++], r5 = e5[u4++], n3 = e5[u4++], o4 = e5[u4], a4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[31 & (r5 << 4 | n3 >>> 4)] + i3[31 & (n3 << 1 | o4 >>> 7)] + i3[o4 >>> 2 & 31] + i3[o4 << 3 & 31] + "="), a4;
              }(e4) : t5 ? function(e5) {
                for (var t6, r5, n3, o4, s4, a4 = "", c4 = e5.length, u4 = 0, l4 = 5 * parseInt(c4 / 5); u4 < l4; )
                  t6 = e5.charCodeAt(u4++), r5 = e5.charCodeAt(u4++), n3 = e5.charCodeAt(u4++), o4 = e5.charCodeAt(u4++), s4 = e5.charCodeAt(u4++), a4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[31 & (r5 << 4 | n3 >>> 4)] + i3[31 & (n3 << 1 | o4 >>> 7)] + i3[o4 >>> 2 & 31] + i3[31 & (o4 << 3 | s4 >>> 5)] + i3[31 & s4];
                var h4 = c4 - l4;
                return h4 === 1 ? (t6 = e5.charCodeAt(u4), a4 += i3[t6 >>> 3] + i3[t6 << 2 & 31] + "======") : h4 === 2 ? (t6 = e5.charCodeAt(u4++), r5 = e5.charCodeAt(u4), a4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[r5 << 4 & 31] + "====") : h4 === 3 ? (t6 = e5.charCodeAt(u4++), r5 = e5.charCodeAt(u4++), n3 = e5.charCodeAt(u4), a4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[31 & (r5 << 4 | n3 >>> 4)] + i3[n3 << 1 & 31] + "===") : h4 === 4 && (t6 = e5.charCodeAt(u4++), r5 = e5.charCodeAt(u4++), n3 = e5.charCodeAt(u4++), o4 = e5.charCodeAt(u4), a4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[31 & (r5 << 4 | n3 >>> 4)] + i3[31 & (n3 << 1 | o4 >>> 7)] + i3[o4 >>> 2 & 31] + i3[o4 << 3 & 31] + "="), a4;
              }(e4) : function(e5) {
                var t6, r5, n3, o4, s4, a4, u4, l4 = false, h4 = "", p4 = 0, f3 = 0, d3 = e5.length;
                if (e5 === "")
                  return h4;
                do {
                  for (c3[0] = c3[5], c3[1] = c3[6], c3[2] = c3[7], u4 = f3; p4 < d3 && u4 < 5; ++p4)
                    (a4 = e5.charCodeAt(p4)) < 128 ? c3[u4++] = a4 : a4 < 2048 ? (c3[u4++] = 192 | a4 >> 6, c3[u4++] = 128 | 63 & a4) : a4 < 55296 || a4 >= 57344 ? (c3[u4++] = 224 | a4 >> 12, c3[u4++] = 128 | a4 >> 6 & 63, c3[u4++] = 128 | 63 & a4) : (a4 = 65536 + ((1023 & a4) << 10 | 1023 & e5.charCodeAt(++p4)), c3[u4++] = 240 | a4 >> 18, c3[u4++] = 128 | a4 >> 12 & 63, c3[u4++] = 128 | a4 >> 6 & 63, c3[u4++] = 128 | 63 & a4);
                  f3 = u4 - 5, p4 === d3 && ++p4, p4 > d3 && u4 < 6 && (l4 = true), t6 = c3[0], u4 > 4 ? (r5 = c3[1], n3 = c3[2], o4 = c3[3], s4 = c3[4], h4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[31 & (r5 << 4 | n3 >>> 4)] + i3[31 & (n3 << 1 | o4 >>> 7)] + i3[o4 >>> 2 & 31] + i3[31 & (o4 << 3 | s4 >>> 5)] + i3[31 & s4]) : u4 === 1 ? h4 += i3[t6 >>> 3] + i3[t6 << 2 & 31] + "======" : u4 === 2 ? (r5 = c3[1], h4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[r5 << 4 & 31] + "====") : u4 === 3 ? (r5 = c3[1], n3 = c3[2], h4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[31 & (r5 << 4 | n3 >>> 4)] + i3[n3 << 1 & 31] + "===") : (r5 = c3[1], n3 = c3[2], o4 = c3[3], h4 += i3[t6 >>> 3] + i3[31 & (t6 << 2 | r5 >>> 6)] + i3[r5 >>> 1 & 31] + i3[31 & (r5 << 4 | n3 >>> 4)] + i3[31 & (n3 << 1 | o4 >>> 7)] + i3[o4 >>> 2 & 31] + i3[o4 << 3 & 31] + "=");
                } while (!l4);
                return h4;
              }(e4);
            }, decode: h3 };
            h3.asBytes = l3, o3 ? e3.exports = p3 : (t4.base32 = p3, s3 && ((n2 = function() {
              return p3;
            }.call(p3, r3, p3, e3)) === void 0 || (e3.exports = n2)));
          }();
        }, 4525: (e3, t3) => {
          t3.read = function(e4, t4, r3, n2, o3) {
            var s3, i3, a3 = 8 * o3 - n2 - 1, c3 = (1 << a3) - 1, u3 = c3 >> 1, l3 = -7, h3 = r3 ? o3 - 1 : 0, p3 = r3 ? -1 : 1, f3 = e4[t4 + h3];
            for (h3 += p3, s3 = f3 & (1 << -l3) - 1, f3 >>= -l3, l3 += a3; l3 > 0; s3 = 256 * s3 + e4[t4 + h3], h3 += p3, l3 -= 8)
              ;
            for (i3 = s3 & (1 << -l3) - 1, s3 >>= -l3, l3 += n2; l3 > 0; i3 = 256 * i3 + e4[t4 + h3], h3 += p3, l3 -= 8)
              ;
            if (s3 === 0)
              s3 = 1 - u3;
            else {
              if (s3 === c3)
                return i3 ? NaN : 1 / 0 * (f3 ? -1 : 1);
              i3 += Math.pow(2, n2), s3 -= u3;
            }
            return (f3 ? -1 : 1) * i3 * Math.pow(2, s3 - n2);
          }, t3.write = function(e4, t4, r3, n2, o3, s3) {
            var i3, a3, c3, u3 = 8 * s3 - o3 - 1, l3 = (1 << u3) - 1, h3 = l3 >> 1, p3 = o3 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f3 = n2 ? 0 : s3 - 1, d3 = n2 ? 1 : -1, g3 = t4 < 0 || t4 === 0 && 1 / t4 < 0 ? 1 : 0;
            for (t4 = Math.abs(t4), isNaN(t4) || t4 === 1 / 0 ? (a3 = isNaN(t4) ? 1 : 0, i3 = l3) : (i3 = Math.floor(Math.log(t4) / Math.LN2), t4 * (c3 = Math.pow(2, -i3)) < 1 && (i3--, c3 *= 2), (t4 += i3 + h3 >= 1 ? p3 / c3 : p3 * Math.pow(2, 1 - h3)) * c3 >= 2 && (i3++, c3 /= 2), i3 + h3 >= l3 ? (a3 = 0, i3 = l3) : i3 + h3 >= 1 ? (a3 = (t4 * c3 - 1) * Math.pow(2, o3), i3 += h3) : (a3 = t4 * Math.pow(2, h3 - 1) * Math.pow(2, o3), i3 = 0)); o3 >= 8; e4[r3 + f3] = 255 & a3, f3 += d3, a3 /= 256, o3 -= 8)
              ;
            for (i3 = i3 << o3 | a3, u3 += o3; u3 > 0; e4[r3 + f3] = 255 & i3, f3 += d3, i3 /= 256, u3 -= 8)
              ;
            e4[r3 + f3 - d3] |= 128 * g3;
          };
        }, 3477: (module, exports, __webpack_require__) => {
          var __WEBPACK_AMD_DEFINE_RESULT__;
          (function() {
            "use strict";
            var ERROR = "input is invalid type", WINDOW = typeof window == "object", root = WINDOW ? window : {};
            root.JS_SHA256_NO_WINDOW && (WINDOW = false);
            var WEB_WORKER = !WINDOW && typeof self == "object", NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
            NODE_JS ? root = __webpack_require__.g : WEB_WORKER && (root = self);
            var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && module.exports, AMD = __webpack_require__.amdO, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined", HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"], blocks = [];
            !root.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(e3) {
              return Object.prototype.toString.call(e3) === "[object Array]";
            }), !ARRAY_BUFFER || !root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e3) {
              return typeof e3 == "object" && e3.buffer && e3.buffer.constructor === ArrayBuffer;
            });
            var createOutputMethod = function(e3, t3) {
              return function(r3) {
                return new Sha256(t3, true).update(r3)[e3]();
              };
            }, createMethod = function(e3) {
              var t3 = createOutputMethod("hex", e3);
              NODE_JS && (t3 = nodeWrap(t3, e3)), t3.create = function() {
                return new Sha256(e3);
              }, t3.update = function(e4) {
                return t3.create().update(e4);
              };
              for (var r3 = 0; r3 < OUTPUT_TYPES.length; ++r3) {
                var n2 = OUTPUT_TYPES[r3];
                t3[n2] = createOutputMethod(n2, e3);
              }
              return t3;
            }, nodeWrap = function(method, is224) {
              var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? "sha224" : "sha256", nodeMethod = function(e3) {
                if (typeof e3 == "string")
                  return crypto.createHash(algorithm).update(e3, "utf8").digest("hex");
                if (e3 == null)
                  throw new Error(ERROR);
                return e3.constructor === ArrayBuffer && (e3 = new Uint8Array(e3)), Array.isArray(e3) || ArrayBuffer.isView(e3) || e3.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(e3)).digest("hex") : method(e3);
              };
              return nodeMethod;
            }, createHmacOutputMethod = function(e3, t3) {
              return function(r3, n2) {
                return new HmacSha256(r3, t3, true).update(n2)[e3]();
              };
            }, createHmacMethod = function(e3) {
              var t3 = createHmacOutputMethod("hex", e3);
              t3.create = function(t4) {
                return new HmacSha256(t4, e3);
              }, t3.update = function(e4, r4) {
                return t3.create(e4).update(r4);
              };
              for (var r3 = 0; r3 < OUTPUT_TYPES.length; ++r3) {
                var n2 = OUTPUT_TYPES[r3];
                t3[n2] = createHmacOutputMethod(n2, e3);
              }
              return t3;
            };
            function Sha256(e3, t3) {
              t3 ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], e3 ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = false, this.first = true, this.is224 = e3;
            }
            function HmacSha256(e3, t3, r3) {
              var n2, o3 = typeof e3;
              if (o3 === "string") {
                var s3, i3 = [], a3 = e3.length, c3 = 0;
                for (n2 = 0; n2 < a3; ++n2)
                  (s3 = e3.charCodeAt(n2)) < 128 ? i3[c3++] = s3 : s3 < 2048 ? (i3[c3++] = 192 | s3 >> 6, i3[c3++] = 128 | 63 & s3) : s3 < 55296 || s3 >= 57344 ? (i3[c3++] = 224 | s3 >> 12, i3[c3++] = 128 | s3 >> 6 & 63, i3[c3++] = 128 | 63 & s3) : (s3 = 65536 + ((1023 & s3) << 10 | 1023 & e3.charCodeAt(++n2)), i3[c3++] = 240 | s3 >> 18, i3[c3++] = 128 | s3 >> 12 & 63, i3[c3++] = 128 | s3 >> 6 & 63, i3[c3++] = 128 | 63 & s3);
                e3 = i3;
              } else {
                if (o3 !== "object")
                  throw new Error(ERROR);
                if (e3 === null)
                  throw new Error(ERROR);
                if (ARRAY_BUFFER && e3.constructor === ArrayBuffer)
                  e3 = new Uint8Array(e3);
                else if (!(Array.isArray(e3) || ARRAY_BUFFER && ArrayBuffer.isView(e3)))
                  throw new Error(ERROR);
              }
              e3.length > 64 && (e3 = new Sha256(t3, true).update(e3).array());
              var u3 = [], l3 = [];
              for (n2 = 0; n2 < 64; ++n2) {
                var h3 = e3[n2] || 0;
                u3[n2] = 92 ^ h3, l3[n2] = 54 ^ h3;
              }
              Sha256.call(this, t3, r3), this.update(l3), this.oKeyPad = u3, this.inner = true, this.sharedMemory = r3;
            }
            Sha256.prototype.update = function(e3) {
              if (!this.finalized) {
                var t3, r3 = typeof e3;
                if (r3 !== "string") {
                  if (r3 !== "object")
                    throw new Error(ERROR);
                  if (e3 === null)
                    throw new Error(ERROR);
                  if (ARRAY_BUFFER && e3.constructor === ArrayBuffer)
                    e3 = new Uint8Array(e3);
                  else if (!(Array.isArray(e3) || ARRAY_BUFFER && ArrayBuffer.isView(e3)))
                    throw new Error(ERROR);
                  t3 = true;
                }
                for (var n2, o3, s3 = 0, i3 = e3.length, a3 = this.blocks; s3 < i3; ) {
                  if (this.hashed && (this.hashed = false, a3[0] = this.block, a3[16] = a3[1] = a3[2] = a3[3] = a3[4] = a3[5] = a3[6] = a3[7] = a3[8] = a3[9] = a3[10] = a3[11] = a3[12] = a3[13] = a3[14] = a3[15] = 0), t3)
                    for (o3 = this.start; s3 < i3 && o3 < 64; ++s3)
                      a3[o3 >> 2] |= e3[s3] << SHIFT[3 & o3++];
                  else
                    for (o3 = this.start; s3 < i3 && o3 < 64; ++s3)
                      (n2 = e3.charCodeAt(s3)) < 128 ? a3[o3 >> 2] |= n2 << SHIFT[3 & o3++] : n2 < 2048 ? (a3[o3 >> 2] |= (192 | n2 >> 6) << SHIFT[3 & o3++], a3[o3 >> 2] |= (128 | 63 & n2) << SHIFT[3 & o3++]) : n2 < 55296 || n2 >= 57344 ? (a3[o3 >> 2] |= (224 | n2 >> 12) << SHIFT[3 & o3++], a3[o3 >> 2] |= (128 | n2 >> 6 & 63) << SHIFT[3 & o3++], a3[o3 >> 2] |= (128 | 63 & n2) << SHIFT[3 & o3++]) : (n2 = 65536 + ((1023 & n2) << 10 | 1023 & e3.charCodeAt(++s3)), a3[o3 >> 2] |= (240 | n2 >> 18) << SHIFT[3 & o3++], a3[o3 >> 2] |= (128 | n2 >> 12 & 63) << SHIFT[3 & o3++], a3[o3 >> 2] |= (128 | n2 >> 6 & 63) << SHIFT[3 & o3++], a3[o3 >> 2] |= (128 | 63 & n2) << SHIFT[3 & o3++]);
                  this.lastByteIndex = o3, this.bytes += o3 - this.start, o3 >= 64 ? (this.block = a3[16], this.start = o3 - 64, this.hash(), this.hashed = true) : this.start = o3;
                }
                return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
              }
            }, Sha256.prototype.finalize = function() {
              if (!this.finalized) {
                this.finalized = true;
                var e3 = this.blocks, t3 = this.lastByteIndex;
                e3[16] = this.block, e3[t3 >> 2] |= EXTRA[3 & t3], this.block = e3[16], t3 >= 56 && (this.hashed || this.hash(), e3[0] = this.block, e3[16] = e3[1] = e3[2] = e3[3] = e3[4] = e3[5] = e3[6] = e3[7] = e3[8] = e3[9] = e3[10] = e3[11] = e3[12] = e3[13] = e3[14] = e3[15] = 0), e3[14] = this.hBytes << 3 | this.bytes >>> 29, e3[15] = this.bytes << 3, this.hash();
              }
            }, Sha256.prototype.hash = function() {
              var e3, t3, r3, n2, o3, s3, i3, a3, c3, u3 = this.h0, l3 = this.h1, h3 = this.h2, p3 = this.h3, f3 = this.h4, d3 = this.h5, g3 = this.h6, y3 = this.h7, m3 = this.blocks;
              for (e3 = 16; e3 < 64; ++e3)
                t3 = ((o3 = m3[e3 - 15]) >>> 7 | o3 << 25) ^ (o3 >>> 18 | o3 << 14) ^ o3 >>> 3, r3 = ((o3 = m3[e3 - 2]) >>> 17 | o3 << 15) ^ (o3 >>> 19 | o3 << 13) ^ o3 >>> 10, m3[e3] = m3[e3 - 16] + t3 + m3[e3 - 7] + r3 << 0;
              for (c3 = l3 & h3, e3 = 0; e3 < 64; e3 += 4)
                this.first ? (this.is224 ? (s3 = 300032, y3 = (o3 = m3[0] - 1413257819) - 150054599 << 0, p3 = o3 + 24177077 << 0) : (s3 = 704751109, y3 = (o3 = m3[0] - 210244248) - 1521486534 << 0, p3 = o3 + 143694565 << 0), this.first = false) : (t3 = (u3 >>> 2 | u3 << 30) ^ (u3 >>> 13 | u3 << 19) ^ (u3 >>> 22 | u3 << 10), n2 = (s3 = u3 & l3) ^ u3 & h3 ^ c3, y3 = p3 + (o3 = y3 + (r3 = (f3 >>> 6 | f3 << 26) ^ (f3 >>> 11 | f3 << 21) ^ (f3 >>> 25 | f3 << 7)) + (f3 & d3 ^ ~f3 & g3) + K[e3] + m3[e3]) << 0, p3 = o3 + (t3 + n2) << 0), t3 = (p3 >>> 2 | p3 << 30) ^ (p3 >>> 13 | p3 << 19) ^ (p3 >>> 22 | p3 << 10), n2 = (i3 = p3 & u3) ^ p3 & l3 ^ s3, g3 = h3 + (o3 = g3 + (r3 = (y3 >>> 6 | y3 << 26) ^ (y3 >>> 11 | y3 << 21) ^ (y3 >>> 25 | y3 << 7)) + (y3 & f3 ^ ~y3 & d3) + K[e3 + 1] + m3[e3 + 1]) << 0, t3 = ((h3 = o3 + (t3 + n2) << 0) >>> 2 | h3 << 30) ^ (h3 >>> 13 | h3 << 19) ^ (h3 >>> 22 | h3 << 10), n2 = (a3 = h3 & p3) ^ h3 & u3 ^ i3, d3 = l3 + (o3 = d3 + (r3 = (g3 >>> 6 | g3 << 26) ^ (g3 >>> 11 | g3 << 21) ^ (g3 >>> 25 | g3 << 7)) + (g3 & y3 ^ ~g3 & f3) + K[e3 + 2] + m3[e3 + 2]) << 0, t3 = ((l3 = o3 + (t3 + n2) << 0) >>> 2 | l3 << 30) ^ (l3 >>> 13 | l3 << 19) ^ (l3 >>> 22 | l3 << 10), n2 = (c3 = l3 & h3) ^ l3 & p3 ^ a3, f3 = u3 + (o3 = f3 + (r3 = (d3 >>> 6 | d3 << 26) ^ (d3 >>> 11 | d3 << 21) ^ (d3 >>> 25 | d3 << 7)) + (d3 & g3 ^ ~d3 & y3) + K[e3 + 3] + m3[e3 + 3]) << 0, u3 = o3 + (t3 + n2) << 0;
              this.h0 = this.h0 + u3 << 0, this.h1 = this.h1 + l3 << 0, this.h2 = this.h2 + h3 << 0, this.h3 = this.h3 + p3 << 0, this.h4 = this.h4 + f3 << 0, this.h5 = this.h5 + d3 << 0, this.h6 = this.h6 + g3 << 0, this.h7 = this.h7 + y3 << 0;
            }, Sha256.prototype.hex = function() {
              this.finalize();
              var e3 = this.h0, t3 = this.h1, r3 = this.h2, n2 = this.h3, o3 = this.h4, s3 = this.h5, i3 = this.h6, a3 = this.h7, c3 = HEX_CHARS[e3 >> 28 & 15] + HEX_CHARS[e3 >> 24 & 15] + HEX_CHARS[e3 >> 20 & 15] + HEX_CHARS[e3 >> 16 & 15] + HEX_CHARS[e3 >> 12 & 15] + HEX_CHARS[e3 >> 8 & 15] + HEX_CHARS[e3 >> 4 & 15] + HEX_CHARS[15 & e3] + HEX_CHARS[t3 >> 28 & 15] + HEX_CHARS[t3 >> 24 & 15] + HEX_CHARS[t3 >> 20 & 15] + HEX_CHARS[t3 >> 16 & 15] + HEX_CHARS[t3 >> 12 & 15] + HEX_CHARS[t3 >> 8 & 15] + HEX_CHARS[t3 >> 4 & 15] + HEX_CHARS[15 & t3] + HEX_CHARS[r3 >> 28 & 15] + HEX_CHARS[r3 >> 24 & 15] + HEX_CHARS[r3 >> 20 & 15] + HEX_CHARS[r3 >> 16 & 15] + HEX_CHARS[r3 >> 12 & 15] + HEX_CHARS[r3 >> 8 & 15] + HEX_CHARS[r3 >> 4 & 15] + HEX_CHARS[15 & r3] + HEX_CHARS[n2 >> 28 & 15] + HEX_CHARS[n2 >> 24 & 15] + HEX_CHARS[n2 >> 20 & 15] + HEX_CHARS[n2 >> 16 & 15] + HEX_CHARS[n2 >> 12 & 15] + HEX_CHARS[n2 >> 8 & 15] + HEX_CHARS[n2 >> 4 & 15] + HEX_CHARS[15 & n2] + HEX_CHARS[o3 >> 28 & 15] + HEX_CHARS[o3 >> 24 & 15] + HEX_CHARS[o3 >> 20 & 15] + HEX_CHARS[o3 >> 16 & 15] + HEX_CHARS[o3 >> 12 & 15] + HEX_CHARS[o3 >> 8 & 15] + HEX_CHARS[o3 >> 4 & 15] + HEX_CHARS[15 & o3] + HEX_CHARS[s3 >> 28 & 15] + HEX_CHARS[s3 >> 24 & 15] + HEX_CHARS[s3 >> 20 & 15] + HEX_CHARS[s3 >> 16 & 15] + HEX_CHARS[s3 >> 12 & 15] + HEX_CHARS[s3 >> 8 & 15] + HEX_CHARS[s3 >> 4 & 15] + HEX_CHARS[15 & s3] + HEX_CHARS[i3 >> 28 & 15] + HEX_CHARS[i3 >> 24 & 15] + HEX_CHARS[i3 >> 20 & 15] + HEX_CHARS[i3 >> 16 & 15] + HEX_CHARS[i3 >> 12 & 15] + HEX_CHARS[i3 >> 8 & 15] + HEX_CHARS[i3 >> 4 & 15] + HEX_CHARS[15 & i3];
              return this.is224 || (c3 += HEX_CHARS[a3 >> 28 & 15] + HEX_CHARS[a3 >> 24 & 15] + HEX_CHARS[a3 >> 20 & 15] + HEX_CHARS[a3 >> 16 & 15] + HEX_CHARS[a3 >> 12 & 15] + HEX_CHARS[a3 >> 8 & 15] + HEX_CHARS[a3 >> 4 & 15] + HEX_CHARS[15 & a3]), c3;
            }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
              this.finalize();
              var e3 = this.h0, t3 = this.h1, r3 = this.h2, n2 = this.h3, o3 = this.h4, s3 = this.h5, i3 = this.h6, a3 = this.h7, c3 = [e3 >> 24 & 255, e3 >> 16 & 255, e3 >> 8 & 255, 255 & e3, t3 >> 24 & 255, t3 >> 16 & 255, t3 >> 8 & 255, 255 & t3, r3 >> 24 & 255, r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3, n2 >> 24 & 255, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2, o3 >> 24 & 255, o3 >> 16 & 255, o3 >> 8 & 255, 255 & o3, s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255, 255 & s3, i3 >> 24 & 255, i3 >> 16 & 255, i3 >> 8 & 255, 255 & i3];
              return this.is224 || c3.push(a3 >> 24 & 255, a3 >> 16 & 255, a3 >> 8 & 255, 255 & a3), c3;
            }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
              this.finalize();
              var e3 = new ArrayBuffer(this.is224 ? 28 : 32), t3 = new DataView(e3);
              return t3.setUint32(0, this.h0), t3.setUint32(4, this.h1), t3.setUint32(8, this.h2), t3.setUint32(12, this.h3), t3.setUint32(16, this.h4), t3.setUint32(20, this.h5), t3.setUint32(24, this.h6), this.is224 || t3.setUint32(28, this.h7), e3;
            }, HmacSha256.prototype = new Sha256(), HmacSha256.prototype.finalize = function() {
              if (Sha256.prototype.finalize.call(this), this.inner) {
                this.inner = false;
                var e3 = this.array();
                Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(e3), Sha256.prototype.finalize.call(this);
              }
            };
            var exports = createMethod();
            exports.sha256 = exports, exports.sha224 = createMethod(true), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(true), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
              return exports;
            }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ === void 0 || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)));
          })();
        }, 583: (e3, t3, r3) => {
          var n2;
          !function() {
            "use strict";
            var o3 = "input is invalid type", s3 = typeof window == "object", i3 = s3 ? window : {};
            i3.JS_SHA3_NO_WINDOW && (s3 = false);
            var a3 = !s3 && typeof self == "object";
            !i3.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node ? i3 = r3.g : a3 && (i3 = self);
            var c3 = !i3.JS_SHA3_NO_COMMON_JS && e3.exports, u3 = r3.amdO, l3 = !i3.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined", h3 = "0123456789abcdef".split(""), p3 = [4, 1024, 262144, 67108864], f3 = [0, 8, 16, 24], d3 = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], g3 = [224, 256, 384, 512], y3 = [128, 256], m3 = ["hex", "buffer", "arrayBuffer", "array", "digest"], b2 = { 128: 168, 256: 136 };
            !i3.JS_SHA3_NO_NODE_JS && Array.isArray || (Array.isArray = function(e4) {
              return Object.prototype.toString.call(e4) === "[object Array]";
            }), !l3 || !i3.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e4) {
              return typeof e4 == "object" && e4.buffer && e4.buffer.constructor === ArrayBuffer;
            });
            for (var A4 = function(e4, t4, r4) {
              return function(n3) {
                return new D3(e4, t4, e4).update(n3)[r4]();
              };
            }, w4 = function(e4, t4, r4) {
              return function(n3, o4) {
                return new D3(e4, t4, o4).update(n3)[r4]();
              };
            }, v3 = function(e4, t4, r4) {
              return function(t5, n3, o4, s4) {
                return _4["cshake" + e4].update(t5, n3, o4, s4)[r4]();
              };
            }, x3 = function(e4, t4, r4) {
              return function(t5, n3, o4, s4) {
                return _4["kmac" + e4].update(t5, n3, o4, s4)[r4]();
              };
            }, S2 = function(e4, t4, r4, n3) {
              for (var o4 = 0; o4 < m3.length; ++o4) {
                var s4 = m3[o4];
                e4[s4] = t4(r4, n3, s4);
              }
              return e4;
            }, E4 = function(e4, t4) {
              var r4 = A4(e4, t4, "hex");
              return r4.create = function() {
                return new D3(e4, t4, e4);
              }, r4.update = function(e5) {
                return r4.create().update(e5);
              }, S2(r4, A4, e4, t4);
            }, T4 = [{ name: "keccak", padding: [1, 256, 65536, 16777216], bits: g3, createMethod: E4 }, { name: "sha3", padding: [6, 1536, 393216, 100663296], bits: g3, createMethod: E4 }, { name: "shake", padding: [31, 7936, 2031616, 520093696], bits: y3, createMethod: function(e4, t4) {
              var r4 = w4(e4, t4, "hex");
              return r4.create = function(r5) {
                return new D3(e4, t4, r5);
              }, r4.update = function(e5, t5) {
                return r4.create(t5).update(e5);
              }, S2(r4, w4, e4, t4);
            } }, { name: "cshake", padding: p3, bits: y3, createMethod: function(e4, t4) {
              var r4 = b2[e4], n3 = v3(e4, 0, "hex");
              return n3.create = function(n4, o4, s4) {
                return o4 || s4 ? new D3(e4, t4, n4).bytepad([o4, s4], r4) : _4["shake" + e4].create(n4);
              }, n3.update = function(e5, t5, r5, o4) {
                return n3.create(t5, r5, o4).update(e5);
              }, S2(n3, v3, e4, t4);
            } }, { name: "kmac", padding: p3, bits: y3, createMethod: function(e4, t4) {
              var r4 = b2[e4], n3 = x3(e4, 0, "hex");
              return n3.create = function(n4, o4, s4) {
                return new N3(e4, t4, o4).bytepad(["KMAC", s4], r4).bytepad([n4], r4);
              }, n3.update = function(e5, t5, r5, o4) {
                return n3.create(e5, r5, o4).update(t5);
              }, S2(n3, x3, e4, t4);
            } }], _4 = {}, B2 = [], U2 = 0; U2 < T4.length; ++U2)
              for (var k3 = T4[U2], I3 = k3.bits, C3 = 0; C3 < I3.length; ++C3) {
                var R2 = k3.name + "_" + I3[C3];
                if (B2.push(R2), _4[R2] = k3.createMethod(I3[C3], k3.padding), k3.name !== "sha3") {
                  var O2 = k3.name + I3[C3];
                  B2.push(O2), _4[O2] = _4[R2];
                }
              }
            function D3(e4, t4, r4) {
              this.blocks = [], this.s = [], this.padding = t4, this.outputBits = r4, this.reset = true, this.finalized = false, this.block = 0, this.start = 0, this.blockCount = 1600 - (e4 << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = r4 >> 5, this.extraBytes = (31 & r4) >> 3;
              for (var n3 = 0; n3 < 50; ++n3)
                this.s[n3] = 0;
            }
            function N3(e4, t4, r4) {
              D3.call(this, e4, t4, r4);
            }
            D3.prototype.update = function(e4) {
              if (this.finalized)
                throw new Error("finalize already called");
              var t4, r4 = typeof e4;
              if (r4 !== "string") {
                if (r4 !== "object")
                  throw new Error(o3);
                if (e4 === null)
                  throw new Error(o3);
                if (l3 && e4.constructor === ArrayBuffer)
                  e4 = new Uint8Array(e4);
                else if (!(Array.isArray(e4) || l3 && ArrayBuffer.isView(e4)))
                  throw new Error(o3);
                t4 = true;
              }
              for (var n3, s4, i4 = this.blocks, a4 = this.byteCount, c4 = e4.length, u4 = this.blockCount, h4 = 0, p4 = this.s; h4 < c4; ) {
                if (this.reset)
                  for (this.reset = false, i4[0] = this.block, n3 = 1; n3 < u4 + 1; ++n3)
                    i4[n3] = 0;
                if (t4)
                  for (n3 = this.start; h4 < c4 && n3 < a4; ++h4)
                    i4[n3 >> 2] |= e4[h4] << f3[3 & n3++];
                else
                  for (n3 = this.start; h4 < c4 && n3 < a4; ++h4)
                    (s4 = e4.charCodeAt(h4)) < 128 ? i4[n3 >> 2] |= s4 << f3[3 & n3++] : s4 < 2048 ? (i4[n3 >> 2] |= (192 | s4 >> 6) << f3[3 & n3++], i4[n3 >> 2] |= (128 | 63 & s4) << f3[3 & n3++]) : s4 < 55296 || s4 >= 57344 ? (i4[n3 >> 2] |= (224 | s4 >> 12) << f3[3 & n3++], i4[n3 >> 2] |= (128 | s4 >> 6 & 63) << f3[3 & n3++], i4[n3 >> 2] |= (128 | 63 & s4) << f3[3 & n3++]) : (s4 = 65536 + ((1023 & s4) << 10 | 1023 & e4.charCodeAt(++h4)), i4[n3 >> 2] |= (240 | s4 >> 18) << f3[3 & n3++], i4[n3 >> 2] |= (128 | s4 >> 12 & 63) << f3[3 & n3++], i4[n3 >> 2] |= (128 | s4 >> 6 & 63) << f3[3 & n3++], i4[n3 >> 2] |= (128 | 63 & s4) << f3[3 & n3++]);
                if (this.lastByteIndex = n3, n3 >= a4) {
                  for (this.start = n3 - a4, this.block = i4[u4], n3 = 0; n3 < u4; ++n3)
                    p4[n3] ^= i4[n3];
                  P3(p4), this.reset = true;
                } else
                  this.start = n3;
              }
              return this;
            }, D3.prototype.encode = function(e4, t4) {
              var r4 = 255 & e4, n3 = 1, o4 = [r4];
              for (r4 = 255 & (e4 >>= 8); r4 > 0; )
                o4.unshift(r4), r4 = 255 & (e4 >>= 8), ++n3;
              return t4 ? o4.push(n3) : o4.unshift(n3), this.update(o4), o4.length;
            }, D3.prototype.encodeString = function(e4) {
              var t4, r4 = typeof e4;
              if (r4 !== "string") {
                if (r4 !== "object")
                  throw new Error(o3);
                if (e4 === null)
                  throw new Error(o3);
                if (l3 && e4.constructor === ArrayBuffer)
                  e4 = new Uint8Array(e4);
                else if (!(Array.isArray(e4) || l3 && ArrayBuffer.isView(e4)))
                  throw new Error(o3);
                t4 = true;
              }
              var n3 = 0, s4 = e4.length;
              if (t4)
                n3 = s4;
              else
                for (var i4 = 0; i4 < e4.length; ++i4) {
                  var a4 = e4.charCodeAt(i4);
                  a4 < 128 ? n3 += 1 : a4 < 2048 ? n3 += 2 : a4 < 55296 || a4 >= 57344 ? n3 += 3 : (a4 = 65536 + ((1023 & a4) << 10 | 1023 & e4.charCodeAt(++i4)), n3 += 4);
                }
              return n3 += this.encode(8 * n3), this.update(e4), n3;
            }, D3.prototype.bytepad = function(e4, t4) {
              for (var r4 = this.encode(t4), n3 = 0; n3 < e4.length; ++n3)
                r4 += this.encodeString(e4[n3]);
              var o4 = t4 - r4 % t4, s4 = [];
              return s4.length = o4, this.update(s4), this;
            }, D3.prototype.finalize = function() {
              if (!this.finalized) {
                this.finalized = true;
                var e4 = this.blocks, t4 = this.lastByteIndex, r4 = this.blockCount, n3 = this.s;
                if (e4[t4 >> 2] |= this.padding[3 & t4], this.lastByteIndex === this.byteCount)
                  for (e4[0] = e4[r4], t4 = 1; t4 < r4 + 1; ++t4)
                    e4[t4] = 0;
                for (e4[r4 - 1] |= 2147483648, t4 = 0; t4 < r4; ++t4)
                  n3[t4] ^= e4[t4];
                P3(n3);
              }
            }, D3.prototype.toString = D3.prototype.hex = function() {
              this.finalize();
              for (var e4, t4 = this.blockCount, r4 = this.s, n3 = this.outputBlocks, o4 = this.extraBytes, s4 = 0, i4 = 0, a4 = ""; i4 < n3; ) {
                for (s4 = 0; s4 < t4 && i4 < n3; ++s4, ++i4)
                  e4 = r4[s4], a4 += h3[e4 >> 4 & 15] + h3[15 & e4] + h3[e4 >> 12 & 15] + h3[e4 >> 8 & 15] + h3[e4 >> 20 & 15] + h3[e4 >> 16 & 15] + h3[e4 >> 28 & 15] + h3[e4 >> 24 & 15];
                i4 % t4 == 0 && (P3(r4), s4 = 0);
              }
              return o4 && (e4 = r4[s4], a4 += h3[e4 >> 4 & 15] + h3[15 & e4], o4 > 1 && (a4 += h3[e4 >> 12 & 15] + h3[e4 >> 8 & 15]), o4 > 2 && (a4 += h3[e4 >> 20 & 15] + h3[e4 >> 16 & 15])), a4;
            }, D3.prototype.arrayBuffer = function() {
              this.finalize();
              var e4, t4 = this.blockCount, r4 = this.s, n3 = this.outputBlocks, o4 = this.extraBytes, s4 = 0, i4 = 0, a4 = this.outputBits >> 3;
              e4 = o4 ? new ArrayBuffer(n3 + 1 << 2) : new ArrayBuffer(a4);
              for (var c4 = new Uint32Array(e4); i4 < n3; ) {
                for (s4 = 0; s4 < t4 && i4 < n3; ++s4, ++i4)
                  c4[i4] = r4[s4];
                i4 % t4 == 0 && P3(r4);
              }
              return o4 && (c4[s4] = r4[s4], e4 = e4.slice(0, a4)), e4;
            }, D3.prototype.buffer = D3.prototype.arrayBuffer, D3.prototype.digest = D3.prototype.array = function() {
              this.finalize();
              for (var e4, t4, r4 = this.blockCount, n3 = this.s, o4 = this.outputBlocks, s4 = this.extraBytes, i4 = 0, a4 = 0, c4 = []; a4 < o4; ) {
                for (i4 = 0; i4 < r4 && a4 < o4; ++i4, ++a4)
                  e4 = a4 << 2, t4 = n3[i4], c4[e4] = 255 & t4, c4[e4 + 1] = t4 >> 8 & 255, c4[e4 + 2] = t4 >> 16 & 255, c4[e4 + 3] = t4 >> 24 & 255;
                a4 % r4 == 0 && P3(n3);
              }
              return s4 && (e4 = a4 << 2, t4 = n3[i4], c4[e4] = 255 & t4, s4 > 1 && (c4[e4 + 1] = t4 >> 8 & 255), s4 > 2 && (c4[e4 + 2] = t4 >> 16 & 255)), c4;
            }, N3.prototype = new D3(), N3.prototype.finalize = function() {
              return this.encode(this.outputBits, true), D3.prototype.finalize.call(this);
            };
            var P3 = function(e4) {
              var t4, r4, n3, o4, s4, i4, a4, c4, u4, l4, h4, p4, f4, g4, y4, m4, b3, A5, w5, v4, x4, S3, E5, T5, _5, B3, U3, k4, I4, C4, R3, O3, D4, N4, P4, L3, F3, z3, j3, M3, H3, G2, K3, q3, V2, $3, W2, X2, Y2, J2, Q2, Z2, ee, te, re, ne, oe, se, ie, ae, ce, ue, le;
              for (n3 = 0; n3 < 48; n3 += 2)
                o4 = e4[0] ^ e4[10] ^ e4[20] ^ e4[30] ^ e4[40], s4 = e4[1] ^ e4[11] ^ e4[21] ^ e4[31] ^ e4[41], i4 = e4[2] ^ e4[12] ^ e4[22] ^ e4[32] ^ e4[42], a4 = e4[3] ^ e4[13] ^ e4[23] ^ e4[33] ^ e4[43], c4 = e4[4] ^ e4[14] ^ e4[24] ^ e4[34] ^ e4[44], u4 = e4[5] ^ e4[15] ^ e4[25] ^ e4[35] ^ e4[45], l4 = e4[6] ^ e4[16] ^ e4[26] ^ e4[36] ^ e4[46], h4 = e4[7] ^ e4[17] ^ e4[27] ^ e4[37] ^ e4[47], t4 = (p4 = e4[8] ^ e4[18] ^ e4[28] ^ e4[38] ^ e4[48]) ^ (i4 << 1 | a4 >>> 31), r4 = (f4 = e4[9] ^ e4[19] ^ e4[29] ^ e4[39] ^ e4[49]) ^ (a4 << 1 | i4 >>> 31), e4[0] ^= t4, e4[1] ^= r4, e4[10] ^= t4, e4[11] ^= r4, e4[20] ^= t4, e4[21] ^= r4, e4[30] ^= t4, e4[31] ^= r4, e4[40] ^= t4, e4[41] ^= r4, t4 = o4 ^ (c4 << 1 | u4 >>> 31), r4 = s4 ^ (u4 << 1 | c4 >>> 31), e4[2] ^= t4, e4[3] ^= r4, e4[12] ^= t4, e4[13] ^= r4, e4[22] ^= t4, e4[23] ^= r4, e4[32] ^= t4, e4[33] ^= r4, e4[42] ^= t4, e4[43] ^= r4, t4 = i4 ^ (l4 << 1 | h4 >>> 31), r4 = a4 ^ (h4 << 1 | l4 >>> 31), e4[4] ^= t4, e4[5] ^= r4, e4[14] ^= t4, e4[15] ^= r4, e4[24] ^= t4, e4[25] ^= r4, e4[34] ^= t4, e4[35] ^= r4, e4[44] ^= t4, e4[45] ^= r4, t4 = c4 ^ (p4 << 1 | f4 >>> 31), r4 = u4 ^ (f4 << 1 | p4 >>> 31), e4[6] ^= t4, e4[7] ^= r4, e4[16] ^= t4, e4[17] ^= r4, e4[26] ^= t4, e4[27] ^= r4, e4[36] ^= t4, e4[37] ^= r4, e4[46] ^= t4, e4[47] ^= r4, t4 = l4 ^ (o4 << 1 | s4 >>> 31), r4 = h4 ^ (s4 << 1 | o4 >>> 31), e4[8] ^= t4, e4[9] ^= r4, e4[18] ^= t4, e4[19] ^= r4, e4[28] ^= t4, e4[29] ^= r4, e4[38] ^= t4, e4[39] ^= r4, e4[48] ^= t4, e4[49] ^= r4, g4 = e4[0], y4 = e4[1], $3 = e4[11] << 4 | e4[10] >>> 28, W2 = e4[10] << 4 | e4[11] >>> 28, k4 = e4[20] << 3 | e4[21] >>> 29, I4 = e4[21] << 3 | e4[20] >>> 29, ae = e4[31] << 9 | e4[30] >>> 23, ce = e4[30] << 9 | e4[31] >>> 23, G2 = e4[40] << 18 | e4[41] >>> 14, K3 = e4[41] << 18 | e4[40] >>> 14, N4 = e4[2] << 1 | e4[3] >>> 31, P4 = e4[3] << 1 | e4[2] >>> 31, m4 = e4[13] << 12 | e4[12] >>> 20, b3 = e4[12] << 12 | e4[13] >>> 20, X2 = e4[22] << 10 | e4[23] >>> 22, Y2 = e4[23] << 10 | e4[22] >>> 22, C4 = e4[33] << 13 | e4[32] >>> 19, R3 = e4[32] << 13 | e4[33] >>> 19, ue = e4[42] << 2 | e4[43] >>> 30, le = e4[43] << 2 | e4[42] >>> 30, te = e4[5] << 30 | e4[4] >>> 2, re = e4[4] << 30 | e4[5] >>> 2, L3 = e4[14] << 6 | e4[15] >>> 26, F3 = e4[15] << 6 | e4[14] >>> 26, A5 = e4[25] << 11 | e4[24] >>> 21, w5 = e4[24] << 11 | e4[25] >>> 21, J2 = e4[34] << 15 | e4[35] >>> 17, Q2 = e4[35] << 15 | e4[34] >>> 17, O3 = e4[45] << 29 | e4[44] >>> 3, D4 = e4[44] << 29 | e4[45] >>> 3, T5 = e4[6] << 28 | e4[7] >>> 4, _5 = e4[7] << 28 | e4[6] >>> 4, ne = e4[17] << 23 | e4[16] >>> 9, oe = e4[16] << 23 | e4[17] >>> 9, z3 = e4[26] << 25 | e4[27] >>> 7, j3 = e4[27] << 25 | e4[26] >>> 7, v4 = e4[36] << 21 | e4[37] >>> 11, x4 = e4[37] << 21 | e4[36] >>> 11, Z2 = e4[47] << 24 | e4[46] >>> 8, ee = e4[46] << 24 | e4[47] >>> 8, q3 = e4[8] << 27 | e4[9] >>> 5, V2 = e4[9] << 27 | e4[8] >>> 5, B3 = e4[18] << 20 | e4[19] >>> 12, U3 = e4[19] << 20 | e4[18] >>> 12, se = e4[29] << 7 | e4[28] >>> 25, ie = e4[28] << 7 | e4[29] >>> 25, M3 = e4[38] << 8 | e4[39] >>> 24, H3 = e4[39] << 8 | e4[38] >>> 24, S3 = e4[48] << 14 | e4[49] >>> 18, E5 = e4[49] << 14 | e4[48] >>> 18, e4[0] = g4 ^ ~m4 & A5, e4[1] = y4 ^ ~b3 & w5, e4[10] = T5 ^ ~B3 & k4, e4[11] = _5 ^ ~U3 & I4, e4[20] = N4 ^ ~L3 & z3, e4[21] = P4 ^ ~F3 & j3, e4[30] = q3 ^ ~$3 & X2, e4[31] = V2 ^ ~W2 & Y2, e4[40] = te ^ ~ne & se, e4[41] = re ^ ~oe & ie, e4[2] = m4 ^ ~A5 & v4, e4[3] = b3 ^ ~w5 & x4, e4[12] = B3 ^ ~k4 & C4, e4[13] = U3 ^ ~I4 & R3, e4[22] = L3 ^ ~z3 & M3, e4[23] = F3 ^ ~j3 & H3, e4[32] = $3 ^ ~X2 & J2, e4[33] = W2 ^ ~Y2 & Q2, e4[42] = ne ^ ~se & ae, e4[43] = oe ^ ~ie & ce, e4[4] = A5 ^ ~v4 & S3, e4[5] = w5 ^ ~x4 & E5, e4[14] = k4 ^ ~C4 & O3, e4[15] = I4 ^ ~R3 & D4, e4[24] = z3 ^ ~M3 & G2, e4[25] = j3 ^ ~H3 & K3, e4[34] = X2 ^ ~J2 & Z2, e4[35] = Y2 ^ ~Q2 & ee, e4[44] = se ^ ~ae & ue, e4[45] = ie ^ ~ce & le, e4[6] = v4 ^ ~S3 & g4, e4[7] = x4 ^ ~E5 & y4, e4[16] = C4 ^ ~O3 & T5, e4[17] = R3 ^ ~D4 & _5, e4[26] = M3 ^ ~G2 & N4, e4[27] = H3 ^ ~K3 & P4, e4[36] = J2 ^ ~Z2 & q3, e4[37] = Q2 ^ ~ee & V2, e4[46] = ae ^ ~ue & te, e4[47] = ce ^ ~le & re, e4[8] = S3 ^ ~g4 & m4, e4[9] = E5 ^ ~y4 & b3, e4[18] = O3 ^ ~T5 & B3, e4[19] = D4 ^ ~_5 & U3, e4[28] = G2 ^ ~N4 & L3, e4[29] = K3 ^ ~P4 & F3, e4[38] = Z2 ^ ~q3 & $3, e4[39] = ee ^ ~V2 & W2, e4[48] = ue ^ ~te & ne, e4[49] = le ^ ~re & oe, e4[0] ^= d3[n3], e4[1] ^= d3[n3 + 1];
            };
            if (c3)
              e3.exports = _4;
            else {
              for (U2 = 0; U2 < B2.length; ++U2)
                i3[B2[U2]] = _4[B2[U2]];
              u3 && ((n2 = function() {
                return _4;
              }.call(t3, r3, t3, e3)) === void 0 || (e3.exports = n2));
            }
          }();
        }, 9757: (e3, t3, r3) => {
          var n2;
          !function() {
            "use strict";
            var t4 = "input is invalid type", o3 = typeof window == "object", s3 = o3 ? window : {};
            s3.JS_SHA512_NO_WINDOW && (o3 = false);
            var i3 = !o3 && typeof self == "object";
            !s3.JS_SHA512_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node ? s3 = r3.g : i3 && (s3 = self);
            var a3 = !s3.JS_SHA512_NO_COMMON_JS && e3.exports, c3 = r3.amdO, u3 = !s3.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined", l3 = "0123456789abcdef".split(""), h3 = [-2147483648, 8388608, 32768, 128], p3 = [24, 16, 8, 0], f3 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], d3 = ["hex", "array", "digest", "arrayBuffer"], g3 = [];
            !s3.JS_SHA512_NO_NODE_JS && Array.isArray || (Array.isArray = function(e4) {
              return Object.prototype.toString.call(e4) === "[object Array]";
            }), !u3 || !s3.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e4) {
              return typeof e4 == "object" && e4.buffer && e4.buffer.constructor === ArrayBuffer;
            });
            var y3 = function(e4, t5) {
              return function(r4) {
                return new w4(t5, true).update(r4)[e4]();
              };
            }, m3 = function(e4) {
              var t5 = y3("hex", e4);
              t5.create = function() {
                return new w4(e4);
              }, t5.update = function(e5) {
                return t5.create().update(e5);
              };
              for (var r4 = 0; r4 < d3.length; ++r4) {
                var n3 = d3[r4];
                t5[n3] = y3(n3, e4);
              }
              return t5;
            }, b2 = function(e4, t5) {
              return function(r4, n3) {
                return new v3(r4, t5, true).update(n3)[e4]();
              };
            }, A4 = function(e4) {
              var t5 = b2("hex", e4);
              t5.create = function(t6) {
                return new v3(t6, e4);
              }, t5.update = function(e5, r5) {
                return t5.create(e5).update(r5);
              };
              for (var r4 = 0; r4 < d3.length; ++r4) {
                var n3 = d3[r4];
                t5[n3] = b2(n3, e4);
              }
              return t5;
            };
            function w4(e4, t5) {
              t5 ? (g3[0] = g3[1] = g3[2] = g3[3] = g3[4] = g3[5] = g3[6] = g3[7] = g3[8] = g3[9] = g3[10] = g3[11] = g3[12] = g3[13] = g3[14] = g3[15] = g3[16] = g3[17] = g3[18] = g3[19] = g3[20] = g3[21] = g3[22] = g3[23] = g3[24] = g3[25] = g3[26] = g3[27] = g3[28] = g3[29] = g3[30] = g3[31] = g3[32] = 0, this.blocks = g3) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], e4 == 384 ? (this.h0h = 3418070365, this.h0l = 3238371032, this.h1h = 1654270250, this.h1l = 914150663, this.h2h = 2438529370, this.h2l = 812702999, this.h3h = 355462360, this.h3l = 4144912697, this.h4h = 1731405415, this.h4l = 4290775857, this.h5h = 2394180231, this.h5l = 1750603025, this.h6h = 3675008525, this.h6l = 1694076839, this.h7h = 1203062813, this.h7l = 3204075428) : e4 == 256 ? (this.h0h = 573645204, this.h0l = 4230739756, this.h1h = 2673172387, this.h1l = 3360449730, this.h2h = 596883563, this.h2l = 1867755857, this.h3h = 2520282905, this.h3l = 1497426621, this.h4h = 2519219938, this.h4l = 2827943907, this.h5h = 3193839141, this.h5l = 1401305490, this.h6h = 721525244, this.h6l = 746961066, this.h7h = 246885852, this.h7l = 2177182882) : e4 == 224 ? (this.h0h = 2352822216, this.h0l = 424955298, this.h1h = 1944164710, this.h1l = 2312950998, this.h2h = 502970286, this.h2l = 855612546, this.h3h = 1738396948, this.h3l = 1479516111, this.h4h = 258812777, this.h4l = 2077511080, this.h5h = 2011393907, this.h5l = 79989058, this.h6h = 1067287976, this.h6l = 1780299464, this.h7h = 286451373, this.h7l = 2446758561) : (this.h0h = 1779033703, this.h0l = 4089235720, this.h1h = 3144134277, this.h1l = 2227873595, this.h2h = 1013904242, this.h2l = 4271175723, this.h3h = 2773480762, this.h3l = 1595750129, this.h4h = 1359893119, this.h4l = 2917565137, this.h5h = 2600822924, this.h5l = 725511199, this.h6h = 528734635, this.h6l = 4215389547, this.h7h = 1541459225, this.h7l = 327033209), this.bits = e4, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = false;
            }
            function v3(e4, r4, n3) {
              var o4, s4 = typeof e4;
              if (s4 !== "string") {
                if (s4 !== "object")
                  throw new Error(t4);
                if (e4 === null)
                  throw new Error(t4);
                if (u3 && e4.constructor === ArrayBuffer)
                  e4 = new Uint8Array(e4);
                else if (!(Array.isArray(e4) || u3 && ArrayBuffer.isView(e4)))
                  throw new Error(t4);
                o4 = true;
              }
              var i4 = e4.length;
              if (!o4) {
                for (var a4, c4 = [], l4 = (i4 = e4.length, 0), h4 = 0; h4 < i4; ++h4)
                  (a4 = e4.charCodeAt(h4)) < 128 ? c4[l4++] = a4 : a4 < 2048 ? (c4[l4++] = 192 | a4 >> 6, c4[l4++] = 128 | 63 & a4) : a4 < 55296 || a4 >= 57344 ? (c4[l4++] = 224 | a4 >> 12, c4[l4++] = 128 | a4 >> 6 & 63, c4[l4++] = 128 | 63 & a4) : (a4 = 65536 + ((1023 & a4) << 10 | 1023 & e4.charCodeAt(++h4)), c4[l4++] = 240 | a4 >> 18, c4[l4++] = 128 | a4 >> 12 & 63, c4[l4++] = 128 | a4 >> 6 & 63, c4[l4++] = 128 | 63 & a4);
                e4 = c4;
              }
              e4.length > 128 && (e4 = new w4(r4, true).update(e4).array());
              var p4 = [], f4 = [];
              for (h4 = 0; h4 < 128; ++h4) {
                var d4 = e4[h4] || 0;
                p4[h4] = 92 ^ d4, f4[h4] = 54 ^ d4;
              }
              w4.call(this, r4, n3), this.update(f4), this.oKeyPad = p4, this.inner = true, this.sharedMemory = n3;
            }
            w4.prototype.update = function(e4) {
              if (this.finalized)
                throw new Error("finalize already called");
              var r4, n3 = typeof e4;
              if (n3 !== "string") {
                if (n3 !== "object")
                  throw new Error(t4);
                if (e4 === null)
                  throw new Error(t4);
                if (u3 && e4.constructor === ArrayBuffer)
                  e4 = new Uint8Array(e4);
                else if (!(Array.isArray(e4) || u3 && ArrayBuffer.isView(e4)))
                  throw new Error(t4);
                r4 = true;
              }
              for (var o4, s4, i4 = 0, a4 = e4.length, c4 = this.blocks; i4 < a4; ) {
                if (this.hashed && (this.hashed = false, c4[0] = this.block, c4[1] = c4[2] = c4[3] = c4[4] = c4[5] = c4[6] = c4[7] = c4[8] = c4[9] = c4[10] = c4[11] = c4[12] = c4[13] = c4[14] = c4[15] = c4[16] = c4[17] = c4[18] = c4[19] = c4[20] = c4[21] = c4[22] = c4[23] = c4[24] = c4[25] = c4[26] = c4[27] = c4[28] = c4[29] = c4[30] = c4[31] = c4[32] = 0), r4)
                  for (s4 = this.start; i4 < a4 && s4 < 128; ++i4)
                    c4[s4 >> 2] |= e4[i4] << p3[3 & s4++];
                else
                  for (s4 = this.start; i4 < a4 && s4 < 128; ++i4)
                    (o4 = e4.charCodeAt(i4)) < 128 ? c4[s4 >> 2] |= o4 << p3[3 & s4++] : o4 < 2048 ? (c4[s4 >> 2] |= (192 | o4 >> 6) << p3[3 & s4++], c4[s4 >> 2] |= (128 | 63 & o4) << p3[3 & s4++]) : o4 < 55296 || o4 >= 57344 ? (c4[s4 >> 2] |= (224 | o4 >> 12) << p3[3 & s4++], c4[s4 >> 2] |= (128 | o4 >> 6 & 63) << p3[3 & s4++], c4[s4 >> 2] |= (128 | 63 & o4) << p3[3 & s4++]) : (o4 = 65536 + ((1023 & o4) << 10 | 1023 & e4.charCodeAt(++i4)), c4[s4 >> 2] |= (240 | o4 >> 18) << p3[3 & s4++], c4[s4 >> 2] |= (128 | o4 >> 12 & 63) << p3[3 & s4++], c4[s4 >> 2] |= (128 | o4 >> 6 & 63) << p3[3 & s4++], c4[s4 >> 2] |= (128 | 63 & o4) << p3[3 & s4++]);
                this.lastByteIndex = s4, this.bytes += s4 - this.start, s4 >= 128 ? (this.block = c4[32], this.start = s4 - 128, this.hash(), this.hashed = true) : this.start = s4;
              }
              return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
            }, w4.prototype.finalize = function() {
              if (!this.finalized) {
                this.finalized = true;
                var e4 = this.blocks, t5 = this.lastByteIndex;
                e4[32] = this.block, e4[t5 >> 2] |= h3[3 & t5], this.block = e4[32], t5 >= 112 && (this.hashed || this.hash(), e4[0] = this.block, e4[1] = e4[2] = e4[3] = e4[4] = e4[5] = e4[6] = e4[7] = e4[8] = e4[9] = e4[10] = e4[11] = e4[12] = e4[13] = e4[14] = e4[15] = e4[16] = e4[17] = e4[18] = e4[19] = e4[20] = e4[21] = e4[22] = e4[23] = e4[24] = e4[25] = e4[26] = e4[27] = e4[28] = e4[29] = e4[30] = e4[31] = e4[32] = 0), e4[30] = this.hBytes << 3 | this.bytes >>> 29, e4[31] = this.bytes << 3, this.hash();
              }
            }, w4.prototype.hash = function() {
              var e4, t5, r4, n3, o4, s4, i4, a4, c4, u4, l4, h4, p4, d4, g4, y4, m4, b3, A5, w5, v4, x4, S2, E4, T4, _4 = this.h0h, B2 = this.h0l, U2 = this.h1h, k3 = this.h1l, I3 = this.h2h, C3 = this.h2l, R2 = this.h3h, O2 = this.h3l, D3 = this.h4h, N3 = this.h4l, P3 = this.h5h, L3 = this.h5l, F3 = this.h6h, z3 = this.h6l, j3 = this.h7h, M3 = this.h7l, H3 = this.blocks;
              for (e4 = 32; e4 < 160; e4 += 2)
                t5 = ((w5 = H3[e4 - 30]) >>> 1 | (v4 = H3[e4 - 29]) << 31) ^ (w5 >>> 8 | v4 << 24) ^ w5 >>> 7, r4 = (v4 >>> 1 | w5 << 31) ^ (v4 >>> 8 | w5 << 24) ^ (v4 >>> 7 | w5 << 25), n3 = ((w5 = H3[e4 - 4]) >>> 19 | (v4 = H3[e4 - 3]) << 13) ^ (v4 >>> 29 | w5 << 3) ^ w5 >>> 6, o4 = (v4 >>> 19 | w5 << 13) ^ (w5 >>> 29 | v4 << 3) ^ (v4 >>> 6 | w5 << 26), w5 = H3[e4 - 32], v4 = H3[e4 - 31], c4 = ((x4 = H3[e4 - 14]) >>> 16) + (w5 >>> 16) + (t5 >>> 16) + (n3 >>> 16) + ((a4 = (65535 & x4) + (65535 & w5) + (65535 & t5) + (65535 & n3) + ((i4 = ((S2 = H3[e4 - 13]) >>> 16) + (v4 >>> 16) + (r4 >>> 16) + (o4 >>> 16) + ((s4 = (65535 & S2) + (65535 & v4) + (65535 & r4) + (65535 & o4)) >>> 16)) >>> 16)) >>> 16), H3[e4] = c4 << 16 | 65535 & a4, H3[e4 + 1] = i4 << 16 | 65535 & s4;
              var G2 = _4, K3 = B2, q3 = U2, V2 = k3, $3 = I3, W2 = C3, X2 = R2, Y2 = O2, J2 = D3, Q2 = N3, Z2 = P3, ee = L3, te = F3, re = z3, ne = j3, oe = M3;
              for (y4 = q3 & $3, m4 = V2 & W2, e4 = 0; e4 < 160; e4 += 8)
                t5 = (G2 >>> 28 | K3 << 4) ^ (K3 >>> 2 | G2 << 30) ^ (K3 >>> 7 | G2 << 25), r4 = (K3 >>> 28 | G2 << 4) ^ (G2 >>> 2 | K3 << 30) ^ (G2 >>> 7 | K3 << 25), n3 = (J2 >>> 14 | Q2 << 18) ^ (J2 >>> 18 | Q2 << 14) ^ (Q2 >>> 9 | J2 << 23), o4 = (Q2 >>> 14 | J2 << 18) ^ (Q2 >>> 18 | J2 << 14) ^ (J2 >>> 9 | Q2 << 23), b3 = (u4 = G2 & q3) ^ G2 & $3 ^ y4, A5 = (l4 = K3 & V2) ^ K3 & W2 ^ m4, E4 = J2 & Z2 ^ ~J2 & te, T4 = Q2 & ee ^ ~Q2 & re, w5 = H3[e4], v4 = H3[e4 + 1], w5 = (c4 = ((x4 = f3[e4]) >>> 16) + (w5 >>> 16) + (E4 >>> 16) + (n3 >>> 16) + (ne >>> 16) + ((a4 = (65535 & x4) + (65535 & w5) + (65535 & E4) + (65535 & n3) + (65535 & ne) + ((i4 = ((S2 = f3[e4 + 1]) >>> 16) + (v4 >>> 16) + (T4 >>> 16) + (o4 >>> 16) + (oe >>> 16) + ((s4 = (65535 & S2) + (65535 & v4) + (65535 & T4) + (65535 & o4) + (65535 & oe)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, v4 = i4 << 16 | 65535 & s4, x4 = (c4 = (b3 >>> 16) + (t5 >>> 16) + ((a4 = (65535 & b3) + (65535 & t5) + ((i4 = (A5 >>> 16) + (r4 >>> 16) + ((s4 = (65535 & A5) + (65535 & r4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, S2 = i4 << 16 | 65535 & s4, ne = (c4 = (X2 >>> 16) + (w5 >>> 16) + ((a4 = (65535 & X2) + (65535 & w5) + ((i4 = (Y2 >>> 16) + (v4 >>> 16) + ((s4 = (65535 & Y2) + (65535 & v4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, oe = i4 << 16 | 65535 & s4, t5 = ((X2 = (c4 = (x4 >>> 16) + (w5 >>> 16) + ((a4 = (65535 & x4) + (65535 & w5) + ((i4 = (S2 >>> 16) + (v4 >>> 16) + ((s4 = (65535 & S2) + (65535 & v4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4) >>> 28 | (Y2 = i4 << 16 | 65535 & s4) << 4) ^ (Y2 >>> 2 | X2 << 30) ^ (Y2 >>> 7 | X2 << 25), r4 = (Y2 >>> 28 | X2 << 4) ^ (X2 >>> 2 | Y2 << 30) ^ (X2 >>> 7 | Y2 << 25), n3 = (ne >>> 14 | oe << 18) ^ (ne >>> 18 | oe << 14) ^ (oe >>> 9 | ne << 23), o4 = (oe >>> 14 | ne << 18) ^ (oe >>> 18 | ne << 14) ^ (ne >>> 9 | oe << 23), b3 = (h4 = X2 & G2) ^ X2 & q3 ^ u4, A5 = (p4 = Y2 & K3) ^ Y2 & V2 ^ l4, E4 = ne & J2 ^ ~ne & Z2, T4 = oe & Q2 ^ ~oe & ee, w5 = H3[e4 + 2], v4 = H3[e4 + 3], w5 = (c4 = ((x4 = f3[e4 + 2]) >>> 16) + (w5 >>> 16) + (E4 >>> 16) + (n3 >>> 16) + (te >>> 16) + ((a4 = (65535 & x4) + (65535 & w5) + (65535 & E4) + (65535 & n3) + (65535 & te) + ((i4 = ((S2 = f3[e4 + 3]) >>> 16) + (v4 >>> 16) + (T4 >>> 16) + (o4 >>> 16) + (re >>> 16) + ((s4 = (65535 & S2) + (65535 & v4) + (65535 & T4) + (65535 & o4) + (65535 & re)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, v4 = i4 << 16 | 65535 & s4, x4 = (c4 = (b3 >>> 16) + (t5 >>> 16) + ((a4 = (65535 & b3) + (65535 & t5) + ((i4 = (A5 >>> 16) + (r4 >>> 16) + ((s4 = (65535 & A5) + (65535 & r4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, S2 = i4 << 16 | 65535 & s4, te = (c4 = ($3 >>> 16) + (w5 >>> 16) + ((a4 = (65535 & $3) + (65535 & w5) + ((i4 = (W2 >>> 16) + (v4 >>> 16) + ((s4 = (65535 & W2) + (65535 & v4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, re = i4 << 16 | 65535 & s4, t5 = (($3 = (c4 = (x4 >>> 16) + (w5 >>> 16) + ((a4 = (65535 & x4) + (65535 & w5) + ((i4 = (S2 >>> 16) + (v4 >>> 16) + ((s4 = (65535 & S2) + (65535 & v4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4) >>> 28 | (W2 = i4 << 16 | 65535 & s4) << 4) ^ (W2 >>> 2 | $3 << 30) ^ (W2 >>> 7 | $3 << 25), r4 = (W2 >>> 28 | $3 << 4) ^ ($3 >>> 2 | W2 << 30) ^ ($3 >>> 7 | W2 << 25), n3 = (te >>> 14 | re << 18) ^ (te >>> 18 | re << 14) ^ (re >>> 9 | te << 23), o4 = (re >>> 14 | te << 18) ^ (re >>> 18 | te << 14) ^ (te >>> 9 | re << 23), b3 = (d4 = $3 & X2) ^ $3 & G2 ^ h4, A5 = (g4 = W2 & Y2) ^ W2 & K3 ^ p4, E4 = te & ne ^ ~te & J2, T4 = re & oe ^ ~re & Q2, w5 = H3[e4 + 4], v4 = H3[e4 + 5], w5 = (c4 = ((x4 = f3[e4 + 4]) >>> 16) + (w5 >>> 16) + (E4 >>> 16) + (n3 >>> 16) + (Z2 >>> 16) + ((a4 = (65535 & x4) + (65535 & w5) + (65535 & E4) + (65535 & n3) + (65535 & Z2) + ((i4 = ((S2 = f3[e4 + 5]) >>> 16) + (v4 >>> 16) + (T4 >>> 16) + (o4 >>> 16) + (ee >>> 16) + ((s4 = (65535 & S2) + (65535 & v4) + (65535 & T4) + (65535 & o4) + (65535 & ee)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, v4 = i4 << 16 | 65535 & s4, x4 = (c4 = (b3 >>> 16) + (t5 >>> 16) + ((a4 = (65535 & b3) + (65535 & t5) + ((i4 = (A5 >>> 16) + (r4 >>> 16) + ((s4 = (65535 & A5) + (65535 & r4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, S2 = i4 << 16 | 65535 & s4, Z2 = (c4 = (q3 >>> 16) + (w5 >>> 16) + ((a4 = (65535 & q3) + (65535 & w5) + ((i4 = (V2 >>> 16) + (v4 >>> 16) + ((s4 = (65535 & V2) + (65535 & v4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, ee = i4 << 16 | 65535 & s4, t5 = ((q3 = (c4 = (x4 >>> 16) + (w5 >>> 16) + ((a4 = (65535 & x4) + (65535 & w5) + ((i4 = (S2 >>> 16) + (v4 >>> 16) + ((s4 = (65535 & S2) + (65535 & v4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4) >>> 28 | (V2 = i4 << 16 | 65535 & s4) << 4) ^ (V2 >>> 2 | q3 << 30) ^ (V2 >>> 7 | q3 << 25), r4 = (V2 >>> 28 | q3 << 4) ^ (q3 >>> 2 | V2 << 30) ^ (q3 >>> 7 | V2 << 25), n3 = (Z2 >>> 14 | ee << 18) ^ (Z2 >>> 18 | ee << 14) ^ (ee >>> 9 | Z2 << 23), o4 = (ee >>> 14 | Z2 << 18) ^ (ee >>> 18 | Z2 << 14) ^ (Z2 >>> 9 | ee << 23), b3 = (y4 = q3 & $3) ^ q3 & X2 ^ d4, A5 = (m4 = V2 & W2) ^ V2 & Y2 ^ g4, E4 = Z2 & te ^ ~Z2 & ne, T4 = ee & re ^ ~ee & oe, w5 = H3[e4 + 6], v4 = H3[e4 + 7], w5 = (c4 = ((x4 = f3[e4 + 6]) >>> 16) + (w5 >>> 16) + (E4 >>> 16) + (n3 >>> 16) + (J2 >>> 16) + ((a4 = (65535 & x4) + (65535 & w5) + (65535 & E4) + (65535 & n3) + (65535 & J2) + ((i4 = ((S2 = f3[e4 + 7]) >>> 16) + (v4 >>> 16) + (T4 >>> 16) + (o4 >>> 16) + (Q2 >>> 16) + ((s4 = (65535 & S2) + (65535 & v4) + (65535 & T4) + (65535 & o4) + (65535 & Q2)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, v4 = i4 << 16 | 65535 & s4, x4 = (c4 = (b3 >>> 16) + (t5 >>> 16) + ((a4 = (65535 & b3) + (65535 & t5) + ((i4 = (A5 >>> 16) + (r4 >>> 16) + ((s4 = (65535 & A5) + (65535 & r4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, S2 = i4 << 16 | 65535 & s4, J2 = (c4 = (G2 >>> 16) + (w5 >>> 16) + ((a4 = (65535 & G2) + (65535 & w5) + ((i4 = (K3 >>> 16) + (v4 >>> 16) + ((s4 = (65535 & K3) + (65535 & v4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, Q2 = i4 << 16 | 65535 & s4, G2 = (c4 = (x4 >>> 16) + (w5 >>> 16) + ((a4 = (65535 & x4) + (65535 & w5) + ((i4 = (S2 >>> 16) + (v4 >>> 16) + ((s4 = (65535 & S2) + (65535 & v4)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & a4, K3 = i4 << 16 | 65535 & s4;
              c4 = (_4 >>> 16) + (G2 >>> 16) + ((a4 = (65535 & _4) + (65535 & G2) + ((i4 = (B2 >>> 16) + (K3 >>> 16) + ((s4 = (65535 & B2) + (65535 & K3)) >>> 16)) >>> 16)) >>> 16), this.h0h = c4 << 16 | 65535 & a4, this.h0l = i4 << 16 | 65535 & s4, c4 = (U2 >>> 16) + (q3 >>> 16) + ((a4 = (65535 & U2) + (65535 & q3) + ((i4 = (k3 >>> 16) + (V2 >>> 16) + ((s4 = (65535 & k3) + (65535 & V2)) >>> 16)) >>> 16)) >>> 16), this.h1h = c4 << 16 | 65535 & a4, this.h1l = i4 << 16 | 65535 & s4, c4 = (I3 >>> 16) + ($3 >>> 16) + ((a4 = (65535 & I3) + (65535 & $3) + ((i4 = (C3 >>> 16) + (W2 >>> 16) + ((s4 = (65535 & C3) + (65535 & W2)) >>> 16)) >>> 16)) >>> 16), this.h2h = c4 << 16 | 65535 & a4, this.h2l = i4 << 16 | 65535 & s4, c4 = (R2 >>> 16) + (X2 >>> 16) + ((a4 = (65535 & R2) + (65535 & X2) + ((i4 = (O2 >>> 16) + (Y2 >>> 16) + ((s4 = (65535 & O2) + (65535 & Y2)) >>> 16)) >>> 16)) >>> 16), this.h3h = c4 << 16 | 65535 & a4, this.h3l = i4 << 16 | 65535 & s4, c4 = (D3 >>> 16) + (J2 >>> 16) + ((a4 = (65535 & D3) + (65535 & J2) + ((i4 = (N3 >>> 16) + (Q2 >>> 16) + ((s4 = (65535 & N3) + (65535 & Q2)) >>> 16)) >>> 16)) >>> 16), this.h4h = c4 << 16 | 65535 & a4, this.h4l = i4 << 16 | 65535 & s4, c4 = (P3 >>> 16) + (Z2 >>> 16) + ((a4 = (65535 & P3) + (65535 & Z2) + ((i4 = (L3 >>> 16) + (ee >>> 16) + ((s4 = (65535 & L3) + (65535 & ee)) >>> 16)) >>> 16)) >>> 16), this.h5h = c4 << 16 | 65535 & a4, this.h5l = i4 << 16 | 65535 & s4, c4 = (F3 >>> 16) + (te >>> 16) + ((a4 = (65535 & F3) + (65535 & te) + ((i4 = (z3 >>> 16) + (re >>> 16) + ((s4 = (65535 & z3) + (65535 & re)) >>> 16)) >>> 16)) >>> 16), this.h6h = c4 << 16 | 65535 & a4, this.h6l = i4 << 16 | 65535 & s4, c4 = (j3 >>> 16) + (ne >>> 16) + ((a4 = (65535 & j3) + (65535 & ne) + ((i4 = (M3 >>> 16) + (oe >>> 16) + ((s4 = (65535 & M3) + (65535 & oe)) >>> 16)) >>> 16)) >>> 16), this.h7h = c4 << 16 | 65535 & a4, this.h7l = i4 << 16 | 65535 & s4;
            }, w4.prototype.hex = function() {
              this.finalize();
              var e4 = this.h0h, t5 = this.h0l, r4 = this.h1h, n3 = this.h1l, o4 = this.h2h, s4 = this.h2l, i4 = this.h3h, a4 = this.h3l, c4 = this.h4h, u4 = this.h4l, h4 = this.h5h, p4 = this.h5l, f4 = this.h6h, d4 = this.h6l, g4 = this.h7h, y4 = this.h7l, m4 = this.bits, b3 = l3[e4 >> 28 & 15] + l3[e4 >> 24 & 15] + l3[e4 >> 20 & 15] + l3[e4 >> 16 & 15] + l3[e4 >> 12 & 15] + l3[e4 >> 8 & 15] + l3[e4 >> 4 & 15] + l3[15 & e4] + l3[t5 >> 28 & 15] + l3[t5 >> 24 & 15] + l3[t5 >> 20 & 15] + l3[t5 >> 16 & 15] + l3[t5 >> 12 & 15] + l3[t5 >> 8 & 15] + l3[t5 >> 4 & 15] + l3[15 & t5] + l3[r4 >> 28 & 15] + l3[r4 >> 24 & 15] + l3[r4 >> 20 & 15] + l3[r4 >> 16 & 15] + l3[r4 >> 12 & 15] + l3[r4 >> 8 & 15] + l3[r4 >> 4 & 15] + l3[15 & r4] + l3[n3 >> 28 & 15] + l3[n3 >> 24 & 15] + l3[n3 >> 20 & 15] + l3[n3 >> 16 & 15] + l3[n3 >> 12 & 15] + l3[n3 >> 8 & 15] + l3[n3 >> 4 & 15] + l3[15 & n3] + l3[o4 >> 28 & 15] + l3[o4 >> 24 & 15] + l3[o4 >> 20 & 15] + l3[o4 >> 16 & 15] + l3[o4 >> 12 & 15] + l3[o4 >> 8 & 15] + l3[o4 >> 4 & 15] + l3[15 & o4] + l3[s4 >> 28 & 15] + l3[s4 >> 24 & 15] + l3[s4 >> 20 & 15] + l3[s4 >> 16 & 15] + l3[s4 >> 12 & 15] + l3[s4 >> 8 & 15] + l3[s4 >> 4 & 15] + l3[15 & s4] + l3[i4 >> 28 & 15] + l3[i4 >> 24 & 15] + l3[i4 >> 20 & 15] + l3[i4 >> 16 & 15] + l3[i4 >> 12 & 15] + l3[i4 >> 8 & 15] + l3[i4 >> 4 & 15] + l3[15 & i4];
              return m4 >= 256 && (b3 += l3[a4 >> 28 & 15] + l3[a4 >> 24 & 15] + l3[a4 >> 20 & 15] + l3[a4 >> 16 & 15] + l3[a4 >> 12 & 15] + l3[a4 >> 8 & 15] + l3[a4 >> 4 & 15] + l3[15 & a4]), m4 >= 384 && (b3 += l3[c4 >> 28 & 15] + l3[c4 >> 24 & 15] + l3[c4 >> 20 & 15] + l3[c4 >> 16 & 15] + l3[c4 >> 12 & 15] + l3[c4 >> 8 & 15] + l3[c4 >> 4 & 15] + l3[15 & c4] + l3[u4 >> 28 & 15] + l3[u4 >> 24 & 15] + l3[u4 >> 20 & 15] + l3[u4 >> 16 & 15] + l3[u4 >> 12 & 15] + l3[u4 >> 8 & 15] + l3[u4 >> 4 & 15] + l3[15 & u4] + l3[h4 >> 28 & 15] + l3[h4 >> 24 & 15] + l3[h4 >> 20 & 15] + l3[h4 >> 16 & 15] + l3[h4 >> 12 & 15] + l3[h4 >> 8 & 15] + l3[h4 >> 4 & 15] + l3[15 & h4] + l3[p4 >> 28 & 15] + l3[p4 >> 24 & 15] + l3[p4 >> 20 & 15] + l3[p4 >> 16 & 15] + l3[p4 >> 12 & 15] + l3[p4 >> 8 & 15] + l3[p4 >> 4 & 15] + l3[15 & p4]), m4 == 512 && (b3 += l3[f4 >> 28 & 15] + l3[f4 >> 24 & 15] + l3[f4 >> 20 & 15] + l3[f4 >> 16 & 15] + l3[f4 >> 12 & 15] + l3[f4 >> 8 & 15] + l3[f4 >> 4 & 15] + l3[15 & f4] + l3[d4 >> 28 & 15] + l3[d4 >> 24 & 15] + l3[d4 >> 20 & 15] + l3[d4 >> 16 & 15] + l3[d4 >> 12 & 15] + l3[d4 >> 8 & 15] + l3[d4 >> 4 & 15] + l3[15 & d4] + l3[g4 >> 28 & 15] + l3[g4 >> 24 & 15] + l3[g4 >> 20 & 15] + l3[g4 >> 16 & 15] + l3[g4 >> 12 & 15] + l3[g4 >> 8 & 15] + l3[g4 >> 4 & 15] + l3[15 & g4] + l3[y4 >> 28 & 15] + l3[y4 >> 24 & 15] + l3[y4 >> 20 & 15] + l3[y4 >> 16 & 15] + l3[y4 >> 12 & 15] + l3[y4 >> 8 & 15] + l3[y4 >> 4 & 15] + l3[15 & y4]), b3;
            }, w4.prototype.toString = w4.prototype.hex, w4.prototype.digest = function() {
              this.finalize();
              var e4 = this.h0h, t5 = this.h0l, r4 = this.h1h, n3 = this.h1l, o4 = this.h2h, s4 = this.h2l, i4 = this.h3h, a4 = this.h3l, c4 = this.h4h, u4 = this.h4l, l4 = this.h5h, h4 = this.h5l, p4 = this.h6h, f4 = this.h6l, d4 = this.h7h, g4 = this.h7l, y4 = this.bits, m4 = [e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4, t5 >> 24 & 255, t5 >> 16 & 255, t5 >> 8 & 255, 255 & t5, r4 >> 24 & 255, r4 >> 16 & 255, r4 >> 8 & 255, 255 & r4, n3 >> 24 & 255, n3 >> 16 & 255, n3 >> 8 & 255, 255 & n3, o4 >> 24 & 255, o4 >> 16 & 255, o4 >> 8 & 255, 255 & o4, s4 >> 24 & 255, s4 >> 16 & 255, s4 >> 8 & 255, 255 & s4, i4 >> 24 & 255, i4 >> 16 & 255, i4 >> 8 & 255, 255 & i4];
              return y4 >= 256 && m4.push(a4 >> 24 & 255, a4 >> 16 & 255, a4 >> 8 & 255, 255 & a4), y4 >= 384 && m4.push(c4 >> 24 & 255, c4 >> 16 & 255, c4 >> 8 & 255, 255 & c4, u4 >> 24 & 255, u4 >> 16 & 255, u4 >> 8 & 255, 255 & u4, l4 >> 24 & 255, l4 >> 16 & 255, l4 >> 8 & 255, 255 & l4, h4 >> 24 & 255, h4 >> 16 & 255, h4 >> 8 & 255, 255 & h4), y4 == 512 && m4.push(p4 >> 24 & 255, p4 >> 16 & 255, p4 >> 8 & 255, 255 & p4, f4 >> 24 & 255, f4 >> 16 & 255, f4 >> 8 & 255, 255 & f4, d4 >> 24 & 255, d4 >> 16 & 255, d4 >> 8 & 255, 255 & d4, g4 >> 24 & 255, g4 >> 16 & 255, g4 >> 8 & 255, 255 & g4), m4;
            }, w4.prototype.array = w4.prototype.digest, w4.prototype.arrayBuffer = function() {
              this.finalize();
              var e4 = this.bits, t5 = new ArrayBuffer(e4 / 8), r4 = new DataView(t5);
              return r4.setUint32(0, this.h0h), r4.setUint32(4, this.h0l), r4.setUint32(8, this.h1h), r4.setUint32(12, this.h1l), r4.setUint32(16, this.h2h), r4.setUint32(20, this.h2l), r4.setUint32(24, this.h3h), e4 >= 256 && r4.setUint32(28, this.h3l), e4 >= 384 && (r4.setUint32(32, this.h4h), r4.setUint32(36, this.h4l), r4.setUint32(40, this.h5h), r4.setUint32(44, this.h5l)), e4 == 512 && (r4.setUint32(48, this.h6h), r4.setUint32(52, this.h6l), r4.setUint32(56, this.h7h), r4.setUint32(60, this.h7l)), t5;
            }, w4.prototype.clone = function() {
              var e4 = new w4(this.bits, false);
              return this.copyTo(e4), e4;
            }, w4.prototype.copyTo = function(e4) {
              var t5 = 0, r4 = ["h0h", "h0l", "h1h", "h1l", "h2h", "h2l", "h3h", "h3l", "h4h", "h4l", "h5h", "h5l", "h6h", "h6l", "h7h", "h7l", "start", "bytes", "hBytes", "finalized", "hashed", "lastByteIndex"];
              for (t5 = 0; t5 < r4.length; ++t5)
                e4[r4[t5]] = this[r4[t5]];
              for (t5 = 0; t5 < this.blocks.length; ++t5)
                e4.blocks[t5] = this.blocks[t5];
            }, v3.prototype = new w4(), v3.prototype.finalize = function() {
              if (w4.prototype.finalize.call(this), this.inner) {
                this.inner = false;
                var e4 = this.array();
                w4.call(this, this.bits, this.sharedMemory), this.update(this.oKeyPad), this.update(e4), w4.prototype.finalize.call(this);
              }
            }, v3.prototype.clone = function() {
              var e4 = new v3([], this.bits, false);
              this.copyTo(e4), e4.inner = this.inner;
              for (var t5 = 0; t5 < this.oKeyPad.length; ++t5)
                e4.oKeyPad[t5] = this.oKeyPad[t5];
              return e4;
            };
            var x3 = m3(512);
            x3.sha512 = x3, x3.sha384 = m3(384), x3.sha512_256 = m3(256), x3.sha512_224 = m3(224), x3.sha512.hmac = A4(512), x3.sha384.hmac = A4(384), x3.sha512_256.hmac = A4(256), x3.sha512_224.hmac = A4(224), a3 ? e3.exports = x3 : (s3.sha512 = x3.sha512, s3.sha384 = x3.sha384, s3.sha512_256 = x3.sha512_256, s3.sha512_224 = x3.sha512_224, c3 && ((n2 = function() {
              return x3;
            }.call(x3, r3, x3, e3)) === void 0 || (e3.exports = n2)));
          }();
        }, 4360: (e3, t3, r3) => {
          var n2 = r3(592).stringify, o3 = r3(9385);
          e3.exports = function(e4) {
            return { parse: o3(e4), stringify: n2 };
          }, e3.exports.parse = o3(), e3.exports.stringify = n2;
        }, 9385: (e3, t3, r3) => {
          var n2 = null;
          const o3 = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/, s3 = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
          e3.exports = function(e4) {
            "use strict";
            var t4 = { strict: false, storeAsString: false, alwaysParseAsBig: false, useNativeBigInt: false, protoAction: "error", constructorAction: "error" };
            if (e4 != null) {
              if (e4.strict === true && (t4.strict = true), e4.storeAsString === true && (t4.storeAsString = true), t4.alwaysParseAsBig = e4.alwaysParseAsBig === true && e4.alwaysParseAsBig, t4.useNativeBigInt = e4.useNativeBigInt === true && e4.useNativeBigInt, e4.constructorAction !== void 0) {
                if (e4.constructorAction !== "error" && e4.constructorAction !== "ignore" && e4.constructorAction !== "preserve")
                  throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${e4.constructorAction}`);
                t4.constructorAction = e4.constructorAction;
              }
              if (e4.protoAction !== void 0) {
                if (e4.protoAction !== "error" && e4.protoAction !== "ignore" && e4.protoAction !== "preserve")
                  throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${e4.protoAction}`);
                t4.protoAction = e4.protoAction;
              }
            }
            var i3, a3, c3, u3, l3 = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: "\n", r: "\r", t: "	" }, h3 = function(e5) {
              throw { name: "SyntaxError", message: e5, at: i3, text: c3 };
            }, p3 = function(e5) {
              return e5 && e5 !== a3 && h3("Expected '" + e5 + "' instead of '" + a3 + "'"), a3 = c3.charAt(i3), i3 += 1, a3;
            }, f3 = function() {
              var e5, o4 = "";
              for (a3 === "-" && (o4 = "-", p3("-")); a3 >= "0" && a3 <= "9"; )
                o4 += a3, p3();
              if (a3 === ".")
                for (o4 += "."; p3() && a3 >= "0" && a3 <= "9"; )
                  o4 += a3;
              if (a3 === "e" || a3 === "E")
                for (o4 += a3, p3(), a3 !== "-" && a3 !== "+" || (o4 += a3, p3()); a3 >= "0" && a3 <= "9"; )
                  o4 += a3, p3();
              if (e5 = +o4, isFinite(e5))
                return n2 == null && (n2 = r3(5117)), o4.length > 15 ? t4.storeAsString ? o4 : t4.useNativeBigInt ? BigInt(o4) : new n2(o4) : t4.alwaysParseAsBig ? t4.useNativeBigInt ? BigInt(e5) : new n2(e5) : e5;
              h3("Bad number");
            }, d3 = function() {
              var e5, t5, r4, n3 = "";
              if (a3 === '"')
                for (var o4 = i3; p3(); ) {
                  if (a3 === '"')
                    return i3 - 1 > o4 && (n3 += c3.substring(o4, i3 - 1)), p3(), n3;
                  if (a3 === "\\") {
                    if (i3 - 1 > o4 && (n3 += c3.substring(o4, i3 - 1)), p3(), a3 === "u") {
                      for (r4 = 0, t5 = 0; t5 < 4 && (e5 = parseInt(p3(), 16), isFinite(e5)); t5 += 1)
                        r4 = 16 * r4 + e5;
                      n3 += String.fromCharCode(r4);
                    } else {
                      if (typeof l3[a3] != "string")
                        break;
                      n3 += l3[a3];
                    }
                    o4 = i3;
                  }
                }
              h3("Bad string");
            }, g3 = function() {
              for (; a3 && a3 <= " "; )
                p3();
            };
            return u3 = function() {
              switch (g3(), a3) {
                case "{":
                  return function() {
                    var e5, r4 = /* @__PURE__ */ Object.create(null);
                    if (a3 === "{") {
                      if (p3("{"), g3(), a3 === "}")
                        return p3("}"), r4;
                      for (; a3; ) {
                        if (e5 = d3(), g3(), p3(":"), t4.strict === true && Object.hasOwnProperty.call(r4, e5) && h3('Duplicate key "' + e5 + '"'), o3.test(e5) === true ? t4.protoAction === "error" ? h3("Object contains forbidden prototype property") : t4.protoAction === "ignore" ? u3() : r4[e5] = u3() : s3.test(e5) === true ? t4.constructorAction === "error" ? h3("Object contains forbidden constructor property") : t4.constructorAction === "ignore" ? u3() : r4[e5] = u3() : r4[e5] = u3(), g3(), a3 === "}")
                          return p3("}"), r4;
                        p3(","), g3();
                      }
                    }
                    h3("Bad object");
                  }();
                case "[":
                  return function() {
                    var e5 = [];
                    if (a3 === "[") {
                      if (p3("["), g3(), a3 === "]")
                        return p3("]"), e5;
                      for (; a3; ) {
                        if (e5.push(u3()), g3(), a3 === "]")
                          return p3("]"), e5;
                        p3(","), g3();
                      }
                    }
                    h3("Bad array");
                  }();
                case '"':
                  return d3();
                case "-":
                  return f3();
                default:
                  return a3 >= "0" && a3 <= "9" ? f3() : function() {
                    switch (a3) {
                      case "t":
                        return p3("t"), p3("r"), p3("u"), p3("e"), true;
                      case "f":
                        return p3("f"), p3("a"), p3("l"), p3("s"), p3("e"), false;
                      case "n":
                        return p3("n"), p3("u"), p3("l"), p3("l"), null;
                    }
                    h3("Unexpected '" + a3 + "'");
                  }();
              }
            }, function(e5, t5) {
              var r4;
              return c3 = e5 + "", i3 = 0, a3 = " ", r4 = u3(), g3(), a3 && h3("Syntax error"), typeof t5 == "function" ? function e6(r5, n3) {
                var o4, s4 = r5[n3];
                return s4 && typeof s4 == "object" && Object.keys(s4).forEach(function(t6) {
                  (o4 = e6(s4, t6)) !== void 0 ? s4[t6] = o4 : delete s4[t6];
                }), t5.call(r5, n3, s4);
              }({ "": r4 }, "") : r4;
            };
          };
        }, 592: (e3, t3, r3) => {
          var n2 = r3(5117), o3 = e3.exports;
          !function() {
            "use strict";
            var e4, t4, r4, s3 = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, i3 = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" };
            function a3(e5) {
              return s3.lastIndex = 0, s3.test(e5) ? '"' + e5.replace(s3, function(e6) {
                var t5 = i3[e6];
                return typeof t5 == "string" ? t5 : "\\u" + ("0000" + e6.charCodeAt(0).toString(16)).slice(-4);
              }) + '"' : '"' + e5 + '"';
            }
            function c3(o4, s4) {
              var i4, u3, l3, h3, p3, f3 = e4, d3 = s4[o4], g3 = d3 != null && (d3 instanceof n2 || n2.isBigNumber(d3));
              switch (d3 && typeof d3 == "object" && typeof d3.toJSON == "function" && (d3 = d3.toJSON(o4)), typeof r4 == "function" && (d3 = r4.call(s4, o4, d3)), typeof d3) {
                case "string":
                  return g3 ? d3 : a3(d3);
                case "number":
                  return isFinite(d3) ? String(d3) : "null";
                case "boolean":
                case "null":
                case "bigint":
                  return String(d3);
                case "object":
                  if (!d3)
                    return "null";
                  if (e4 += t4, p3 = [], Object.prototype.toString.apply(d3) === "[object Array]") {
                    for (h3 = d3.length, i4 = 0; i4 < h3; i4 += 1)
                      p3[i4] = c3(i4, d3) || "null";
                    return l3 = p3.length === 0 ? "[]" : e4 ? "[\n" + e4 + p3.join(",\n" + e4) + "\n" + f3 + "]" : "[" + p3.join(",") + "]", e4 = f3, l3;
                  }
                  if (r4 && typeof r4 == "object")
                    for (h3 = r4.length, i4 = 0; i4 < h3; i4 += 1)
                      typeof r4[i4] == "string" && (l3 = c3(u3 = r4[i4], d3)) && p3.push(a3(u3) + (e4 ? ": " : ":") + l3);
                  else
                    Object.keys(d3).forEach(function(t5) {
                      var r5 = c3(t5, d3);
                      r5 && p3.push(a3(t5) + (e4 ? ": " : ":") + r5);
                    });
                  return l3 = p3.length === 0 ? "{}" : e4 ? "{\n" + e4 + p3.join(",\n" + e4) + "\n" + f3 + "}" : "{" + p3.join(",") + "}", e4 = f3, l3;
              }
            }
            typeof o3.stringify != "function" && (o3.stringify = function(n3, o4, s4) {
              var i4;
              if (e4 = "", t4 = "", typeof s4 == "number")
                for (i4 = 0; i4 < s4; i4 += 1)
                  t4 += " ";
              else
                typeof s4 == "string" && (t4 = s4);
              if (r4 = o4, o4 && typeof o4 != "function" && (typeof o4 != "object" || typeof o4.length != "number"))
                throw new Error("JSON.stringify");
              return c3("", { "": n3 });
            });
          }();
        }, 3126: (e3, t3, r3) => {
          var n2 = typeof Map == "function" && Map.prototype, o3 = Object.getOwnPropertyDescriptor && n2 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, s3 = n2 && o3 && typeof o3.get == "function" ? o3.get : null, i3 = n2 && Map.prototype.forEach, a3 = typeof Set == "function" && Set.prototype, c3 = Object.getOwnPropertyDescriptor && a3 ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, u3 = a3 && c3 && typeof c3.get == "function" ? c3.get : null, l3 = a3 && Set.prototype.forEach, h3 = typeof WeakMap == "function" && WeakMap.prototype ? WeakMap.prototype.has : null, p3 = typeof WeakSet == "function" && WeakSet.prototype ? WeakSet.prototype.has : null, f3 = typeof WeakRef == "function" && WeakRef.prototype ? WeakRef.prototype.deref : null, d3 = Boolean.prototype.valueOf, g3 = Object.prototype.toString, y3 = Function.prototype.toString, m3 = String.prototype.match, b2 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, A4 = Object.getOwnPropertySymbols, w4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, v3 = typeof Symbol == "function" && typeof Symbol.iterator == "object", x3 = Object.prototype.propertyIsEnumerable, S2 = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e4) {
            return e4.__proto__;
          } : null), E4 = r3(4654).custom, T4 = E4 && I3(E4) ? E4 : null, _4 = typeof Symbol == "function" && Symbol.toStringTag !== void 0 ? Symbol.toStringTag : null;
          function B2(e4, t4, r4) {
            var n3 = (r4.quoteStyle || t4) === "double" ? '"' : "'";
            return n3 + e4 + n3;
          }
          function U2(e4) {
            return String(e4).replace(/"/g, "&quot;");
          }
          function k3(e4) {
            return !(O2(e4) !== "[object Array]" || _4 && typeof e4 == "object" && _4 in e4);
          }
          function I3(e4) {
            if (v3)
              return e4 && typeof e4 == "object" && e4 instanceof Symbol;
            if (typeof e4 == "symbol")
              return true;
            if (!e4 || typeof e4 != "object" || !w4)
              return false;
            try {
              return w4.call(e4), true;
            } catch (e5) {
            }
            return false;
          }
          e3.exports = function e4(t4, r4, n3, o4) {
            var a4 = r4 || {};
            if (R2(a4, "quoteStyle") && a4.quoteStyle !== "single" && a4.quoteStyle !== "double")
              throw new TypeError('option "quoteStyle" must be "single" or "double"');
            if (R2(a4, "maxStringLength") && (typeof a4.maxStringLength == "number" ? a4.maxStringLength < 0 && a4.maxStringLength !== 1 / 0 : a4.maxStringLength !== null))
              throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
            var c4 = !R2(a4, "customInspect") || a4.customInspect;
            if (typeof c4 != "boolean")
              throw new TypeError('option "customInspect", if provided, must be `true` or `false`');
            if (R2(a4, "indent") && a4.indent !== null && a4.indent !== "	" && !(parseInt(a4.indent, 10) === a4.indent && a4.indent > 0))
              throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
            if (t4 === void 0)
              return "undefined";
            if (t4 === null)
              return "null";
            if (typeof t4 == "boolean")
              return t4 ? "true" : "false";
            if (typeof t4 == "string")
              return N3(t4, a4);
            if (typeof t4 == "number")
              return t4 === 0 ? 1 / 0 / t4 > 0 ? "0" : "-0" : String(t4);
            if (typeof t4 == "bigint")
              return String(t4) + "n";
            var g4 = a4.depth === void 0 ? 5 : a4.depth;
            if (n3 === void 0 && (n3 = 0), n3 >= g4 && g4 > 0 && typeof t4 == "object")
              return k3(t4) ? "[Array]" : "[Object]";
            var A5, x4 = function(e5, t5) {
              var r5;
              if (e5.indent === "	")
                r5 = "	";
              else {
                if (!(typeof e5.indent == "number" && e5.indent > 0))
                  return null;
                r5 = Array(e5.indent + 1).join(" ");
              }
              return { base: r5, prev: Array(t5 + 1).join(r5) };
            }(a4, n3);
            if (o4 === void 0)
              o4 = [];
            else if (D3(o4, t4) >= 0)
              return "[Circular]";
            function E5(t5, r5, s4) {
              if (r5 && (o4 = o4.slice()).push(r5), s4) {
                var i4 = { depth: a4.depth };
                return R2(a4, "quoteStyle") && (i4.quoteStyle = a4.quoteStyle), e4(t5, i4, n3 + 1, o4);
              }
              return e4(t5, a4, n3 + 1, o4);
            }
            if (typeof t4 == "function") {
              var C4 = function(e5) {
                if (e5.name)
                  return e5.name;
                var t5 = m3.call(y3.call(e5), /^function\s*([\w$]+)/);
                return t5 ? t5[1] : null;
              }(t4), P4 = M3(t4, E5);
              return "[Function" + (C4 ? ": " + C4 : " (anonymous)") + "]" + (P4.length > 0 ? " { " + P4.join(", ") + " }" : "");
            }
            if (I3(t4)) {
              var H3 = v3 ? String(t4).replace(/^(Symbol\(.*\))_[^)]*$/, "$1") : w4.call(t4);
              return typeof t4 != "object" || v3 ? H3 : L3(H3);
            }
            if ((A5 = t4) && typeof A5 == "object" && (typeof HTMLElement != "undefined" && A5 instanceof HTMLElement || typeof A5.nodeName == "string" && typeof A5.getAttribute == "function")) {
              for (var G2 = "<" + String(t4.nodeName).toLowerCase(), K3 = t4.attributes || [], q3 = 0; q3 < K3.length; q3++)
                G2 += " " + K3[q3].name + "=" + B2(U2(K3[q3].value), "double", a4);
              return G2 += ">", t4.childNodes && t4.childNodes.length && (G2 += "..."), G2 + "</" + String(t4.nodeName).toLowerCase() + ">";
            }
            if (k3(t4)) {
              if (t4.length === 0)
                return "[]";
              var V2 = M3(t4, E5);
              return x4 && !function(e5) {
                for (var t5 = 0; t5 < e5.length; t5++)
                  if (D3(e5[t5], "\n") >= 0)
                    return false;
                return true;
              }(V2) ? "[" + j3(V2, x4) + "]" : "[ " + V2.join(", ") + " ]";
            }
            if (function(e5) {
              return !(O2(e5) !== "[object Error]" || _4 && typeof e5 == "object" && _4 in e5);
            }(t4)) {
              var $3 = M3(t4, E5);
              return $3.length === 0 ? "[" + String(t4) + "]" : "{ [" + String(t4) + "] " + $3.join(", ") + " }";
            }
            if (typeof t4 == "object" && c4) {
              if (T4 && typeof t4[T4] == "function")
                return t4[T4]();
              if (typeof t4.inspect == "function")
                return t4.inspect();
            }
            if (function(e5) {
              if (!s3 || !e5 || typeof e5 != "object")
                return false;
              try {
                s3.call(e5);
                try {
                  u3.call(e5);
                } catch (e6) {
                  return true;
                }
                return e5 instanceof Map;
              } catch (e6) {
              }
              return false;
            }(t4)) {
              var W2 = [];
              return i3.call(t4, function(e5, r5) {
                W2.push(E5(r5, t4, true) + " => " + E5(e5, t4));
              }), z3("Map", s3.call(t4), W2, x4);
            }
            if (function(e5) {
              if (!u3 || !e5 || typeof e5 != "object")
                return false;
              try {
                u3.call(e5);
                try {
                  s3.call(e5);
                } catch (e6) {
                  return true;
                }
                return e5 instanceof Set;
              } catch (e6) {
              }
              return false;
            }(t4)) {
              var X2 = [];
              return l3.call(t4, function(e5) {
                X2.push(E5(e5, t4));
              }), z3("Set", u3.call(t4), X2, x4);
            }
            if (function(e5) {
              if (!h3 || !e5 || typeof e5 != "object")
                return false;
              try {
                h3.call(e5, h3);
                try {
                  p3.call(e5, p3);
                } catch (e6) {
                  return true;
                }
                return e5 instanceof WeakMap;
              } catch (e6) {
              }
              return false;
            }(t4))
              return F3("WeakMap");
            if (function(e5) {
              if (!p3 || !e5 || typeof e5 != "object")
                return false;
              try {
                p3.call(e5, p3);
                try {
                  h3.call(e5, h3);
                } catch (e6) {
                  return true;
                }
                return e5 instanceof WeakSet;
              } catch (e6) {
              }
              return false;
            }(t4))
              return F3("WeakSet");
            if (function(e5) {
              if (!f3 || !e5 || typeof e5 != "object")
                return false;
              try {
                return f3.call(e5), true;
              } catch (e6) {
              }
              return false;
            }(t4))
              return F3("WeakRef");
            if (function(e5) {
              return !(O2(e5) !== "[object Number]" || _4 && typeof e5 == "object" && _4 in e5);
            }(t4))
              return L3(E5(Number(t4)));
            if (function(e5) {
              if (!e5 || typeof e5 != "object" || !b2)
                return false;
              try {
                return b2.call(e5), true;
              } catch (e6) {
              }
              return false;
            }(t4))
              return L3(E5(b2.call(t4)));
            if (function(e5) {
              return !(O2(e5) !== "[object Boolean]" || _4 && typeof e5 == "object" && _4 in e5);
            }(t4))
              return L3(d3.call(t4));
            if (function(e5) {
              return !(O2(e5) !== "[object String]" || _4 && typeof e5 == "object" && _4 in e5);
            }(t4))
              return L3(E5(String(t4)));
            if (!function(e5) {
              return !(O2(e5) !== "[object Date]" || _4 && typeof e5 == "object" && _4 in e5);
            }(t4) && !function(e5) {
              return !(O2(e5) !== "[object RegExp]" || _4 && typeof e5 == "object" && _4 in e5);
            }(t4)) {
              var Y2 = M3(t4, E5), J2 = S2 ? S2(t4) === Object.prototype : t4 instanceof Object || t4.constructor === Object, Q2 = t4 instanceof Object ? "" : "null prototype", Z2 = !J2 && _4 && Object(t4) === t4 && _4 in t4 ? O2(t4).slice(8, -1) : Q2 ? "Object" : "", ee = (J2 || typeof t4.constructor != "function" ? "" : t4.constructor.name ? t4.constructor.name + " " : "") + (Z2 || Q2 ? "[" + [].concat(Z2 || [], Q2 || []).join(": ") + "] " : "");
              return Y2.length === 0 ? ee + "{}" : x4 ? ee + "{" + j3(Y2, x4) + "}" : ee + "{ " + Y2.join(", ") + " }";
            }
            return String(t4);
          };
          var C3 = Object.prototype.hasOwnProperty || function(e4) {
            return e4 in this;
          };
          function R2(e4, t4) {
            return C3.call(e4, t4);
          }
          function O2(e4) {
            return g3.call(e4);
          }
          function D3(e4, t4) {
            if (e4.indexOf)
              return e4.indexOf(t4);
            for (var r4 = 0, n3 = e4.length; r4 < n3; r4++)
              if (e4[r4] === t4)
                return r4;
            return -1;
          }
          function N3(e4, t4) {
            if (e4.length > t4.maxStringLength) {
              var r4 = e4.length - t4.maxStringLength, n3 = "... " + r4 + " more character" + (r4 > 1 ? "s" : "");
              return N3(e4.slice(0, t4.maxStringLength), t4) + n3;
            }
            return B2(e4.replace(/(['\\])/g, "\\$1").replace(/[\x00-\x1f]/g, P3), "single", t4);
          }
          function P3(e4) {
            var t4 = e4.charCodeAt(0), r4 = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[t4];
            return r4 ? "\\" + r4 : "\\x" + (t4 < 16 ? "0" : "") + t4.toString(16).toUpperCase();
          }
          function L3(e4) {
            return "Object(" + e4 + ")";
          }
          function F3(e4) {
            return e4 + " { ? }";
          }
          function z3(e4, t4, r4, n3) {
            return e4 + " (" + t4 + ") {" + (n3 ? j3(r4, n3) : r4.join(", ")) + "}";
          }
          function j3(e4, t4) {
            if (e4.length === 0)
              return "";
            var r4 = "\n" + t4.prev + t4.base;
            return r4 + e4.join("," + r4) + "\n" + t4.prev;
          }
          function M3(e4, t4) {
            var r4 = k3(e4), n3 = [];
            if (r4) {
              n3.length = e4.length;
              for (var o4 = 0; o4 < e4.length; o4++)
                n3[o4] = R2(e4, o4) ? t4(e4[o4], e4) : "";
            }
            var s4, i4 = typeof A4 == "function" ? A4(e4) : [];
            if (v3) {
              s4 = {};
              for (var a4 = 0; a4 < i4.length; a4++)
                s4["$" + i4[a4]] = i4[a4];
            }
            for (var c4 in e4)
              R2(e4, c4) && (r4 && String(Number(c4)) === c4 && c4 < e4.length || v3 && s4["$" + c4] instanceof Symbol || (/[^\w$]/.test(c4) ? n3.push(t4(c4, e4) + ": " + t4(e4[c4], e4)) : n3.push(c4 + ": " + t4(e4[c4], e4))));
            if (typeof A4 == "function")
              for (var u4 = 0; u4 < i4.length; u4++)
                x3.call(e4, i4[u4]) && n3.push("[" + t4(i4[u4]) + "]: " + t4(e4[i4[u4]], e4));
            return n3;
          }
        }, 9368: (e3) => {
          "use strict";
          function t3(e4) {
            if (typeof e4 != "string")
              throw new TypeError("Path must be a string. Received " + JSON.stringify(e4));
          }
          function r3(e4, t4) {
            for (var r4, n3 = "", o3 = 0, s3 = -1, i3 = 0, a3 = 0; a3 <= e4.length; ++a3) {
              if (a3 < e4.length)
                r4 = e4.charCodeAt(a3);
              else {
                if (r4 === 47)
                  break;
                r4 = 47;
              }
              if (r4 === 47) {
                if (s3 === a3 - 1 || i3 === 1)
                  ;
                else if (s3 !== a3 - 1 && i3 === 2) {
                  if (n3.length < 2 || o3 !== 2 || n3.charCodeAt(n3.length - 1) !== 46 || n3.charCodeAt(n3.length - 2) !== 46) {
                    if (n3.length > 2) {
                      var c3 = n3.lastIndexOf("/");
                      if (c3 !== n3.length - 1) {
                        c3 === -1 ? (n3 = "", o3 = 0) : o3 = (n3 = n3.slice(0, c3)).length - 1 - n3.lastIndexOf("/"), s3 = a3, i3 = 0;
                        continue;
                      }
                    } else if (n3.length === 2 || n3.length === 1) {
                      n3 = "", o3 = 0, s3 = a3, i3 = 0;
                      continue;
                    }
                  }
                  t4 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o3 = 2);
                } else
                  n3.length > 0 ? n3 += "/" + e4.slice(s3 + 1, a3) : n3 = e4.slice(s3 + 1, a3), o3 = a3 - s3 - 1;
                s3 = a3, i3 = 0;
              } else
                r4 === 46 && i3 !== -1 ? ++i3 : i3 = -1;
            }
            return n3;
          }
          var n2 = { resolve: function() {
            for (var e4, n3 = "", o3 = false, s3 = arguments.length - 1; s3 >= -1 && !o3; s3--) {
              var i3;
              s3 >= 0 ? i3 = arguments[s3] : (e4 === void 0 && (e4 = process.cwd()), i3 = e4), t3(i3), i3.length !== 0 && (n3 = i3 + "/" + n3, o3 = i3.charCodeAt(0) === 47);
            }
            return n3 = r3(n3, !o3), o3 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
          }, normalize: function(e4) {
            if (t3(e4), e4.length === 0)
              return ".";
            var n3 = e4.charCodeAt(0) === 47, o3 = e4.charCodeAt(e4.length - 1) === 47;
            return (e4 = r3(e4, !n3)).length !== 0 || n3 || (e4 = "."), e4.length > 0 && o3 && (e4 += "/"), n3 ? "/" + e4 : e4;
          }, isAbsolute: function(e4) {
            return t3(e4), e4.length > 0 && e4.charCodeAt(0) === 47;
          }, join: function() {
            if (arguments.length === 0)
              return ".";
            for (var e4, r4 = 0; r4 < arguments.length; ++r4) {
              var o3 = arguments[r4];
              t3(o3), o3.length > 0 && (e4 === void 0 ? e4 = o3 : e4 += "/" + o3);
            }
            return e4 === void 0 ? "." : n2.normalize(e4);
          }, relative: function(e4, r4) {
            if (t3(e4), t3(r4), e4 === r4)
              return "";
            if ((e4 = n2.resolve(e4)) === (r4 = n2.resolve(r4)))
              return "";
            for (var o3 = 1; o3 < e4.length && e4.charCodeAt(o3) === 47; ++o3)
              ;
            for (var s3 = e4.length, i3 = s3 - o3, a3 = 1; a3 < r4.length && r4.charCodeAt(a3) === 47; ++a3)
              ;
            for (var c3 = r4.length - a3, u3 = i3 < c3 ? i3 : c3, l3 = -1, h3 = 0; h3 <= u3; ++h3) {
              if (h3 === u3) {
                if (c3 > u3) {
                  if (r4.charCodeAt(a3 + h3) === 47)
                    return r4.slice(a3 + h3 + 1);
                  if (h3 === 0)
                    return r4.slice(a3 + h3);
                } else
                  i3 > u3 && (e4.charCodeAt(o3 + h3) === 47 ? l3 = h3 : h3 === 0 && (l3 = 0));
                break;
              }
              var p3 = e4.charCodeAt(o3 + h3);
              if (p3 !== r4.charCodeAt(a3 + h3))
                break;
              p3 === 47 && (l3 = h3);
            }
            var f3 = "";
            for (h3 = o3 + l3 + 1; h3 <= s3; ++h3)
              h3 !== s3 && e4.charCodeAt(h3) !== 47 || (f3.length === 0 ? f3 += ".." : f3 += "/..");
            return f3.length > 0 ? f3 + r4.slice(a3 + l3) : (a3 += l3, r4.charCodeAt(a3) === 47 && ++a3, r4.slice(a3));
          }, _makeLong: function(e4) {
            return e4;
          }, dirname: function(e4) {
            if (t3(e4), e4.length === 0)
              return ".";
            for (var r4 = e4.charCodeAt(0), n3 = r4 === 47, o3 = -1, s3 = true, i3 = e4.length - 1; i3 >= 1; --i3)
              if ((r4 = e4.charCodeAt(i3)) === 47) {
                if (!s3) {
                  o3 = i3;
                  break;
                }
              } else
                s3 = false;
            return o3 === -1 ? n3 ? "/" : "." : n3 && o3 === 1 ? "//" : e4.slice(0, o3);
          }, basename: function(e4, r4) {
            if (r4 !== void 0 && typeof r4 != "string")
              throw new TypeError('"ext" argument must be a string');
            t3(e4);
            var n3, o3 = 0, s3 = -1, i3 = true;
            if (r4 !== void 0 && r4.length > 0 && r4.length <= e4.length) {
              if (r4.length === e4.length && r4 === e4)
                return "";
              var a3 = r4.length - 1, c3 = -1;
              for (n3 = e4.length - 1; n3 >= 0; --n3) {
                var u3 = e4.charCodeAt(n3);
                if (u3 === 47) {
                  if (!i3) {
                    o3 = n3 + 1;
                    break;
                  }
                } else
                  c3 === -1 && (i3 = false, c3 = n3 + 1), a3 >= 0 && (u3 === r4.charCodeAt(a3) ? --a3 == -1 && (s3 = n3) : (a3 = -1, s3 = c3));
              }
              return o3 === s3 ? s3 = c3 : s3 === -1 && (s3 = e4.length), e4.slice(o3, s3);
            }
            for (n3 = e4.length - 1; n3 >= 0; --n3)
              if (e4.charCodeAt(n3) === 47) {
                if (!i3) {
                  o3 = n3 + 1;
                  break;
                }
              } else
                s3 === -1 && (i3 = false, s3 = n3 + 1);
            return s3 === -1 ? "" : e4.slice(o3, s3);
          }, extname: function(e4) {
            t3(e4);
            for (var r4 = -1, n3 = 0, o3 = -1, s3 = true, i3 = 0, a3 = e4.length - 1; a3 >= 0; --a3) {
              var c3 = e4.charCodeAt(a3);
              if (c3 !== 47)
                o3 === -1 && (s3 = false, o3 = a3 + 1), c3 === 46 ? r4 === -1 ? r4 = a3 : i3 !== 1 && (i3 = 1) : r4 !== -1 && (i3 = -1);
              else if (!s3) {
                n3 = a3 + 1;
                break;
              }
            }
            return r4 === -1 || o3 === -1 || i3 === 0 || i3 === 1 && r4 === o3 - 1 && r4 === n3 + 1 ? "" : e4.slice(r4, o3);
          }, format: function(e4) {
            if (e4 === null || typeof e4 != "object")
              throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e4);
            return function(e5, t4) {
              var r4 = t4.dir || t4.root, n3 = t4.base || (t4.name || "") + (t4.ext || "");
              return r4 ? r4 === t4.root ? r4 + n3 : r4 + "/" + n3 : n3;
            }(0, e4);
          }, parse: function(e4) {
            t3(e4);
            var r4 = { root: "", dir: "", base: "", ext: "", name: "" };
            if (e4.length === 0)
              return r4;
            var n3, o3 = e4.charCodeAt(0), s3 = o3 === 47;
            s3 ? (r4.root = "/", n3 = 1) : n3 = 0;
            for (var i3 = -1, a3 = 0, c3 = -1, u3 = true, l3 = e4.length - 1, h3 = 0; l3 >= n3; --l3)
              if ((o3 = e4.charCodeAt(l3)) !== 47)
                c3 === -1 && (u3 = false, c3 = l3 + 1), o3 === 46 ? i3 === -1 ? i3 = l3 : h3 !== 1 && (h3 = 1) : i3 !== -1 && (h3 = -1);
              else if (!u3) {
                a3 = l3 + 1;
                break;
              }
            return i3 === -1 || c3 === -1 || h3 === 0 || h3 === 1 && i3 === c3 - 1 && i3 === a3 + 1 ? c3 !== -1 && (r4.base = r4.name = a3 === 0 && s3 ? e4.slice(1, c3) : e4.slice(a3, c3)) : (a3 === 0 && s3 ? (r4.name = e4.slice(1, i3), r4.base = e4.slice(1, c3)) : (r4.name = e4.slice(a3, i3), r4.base = e4.slice(a3, c3)), r4.ext = e4.slice(i3, c3)), a3 > 0 ? r4.dir = e4.slice(0, a3 - 1) : s3 && (r4.dir = "/"), r4;
          }, sep: "/", delimiter: ":", win32: null, posix: null };
          n2.posix = n2, e3.exports = n2;
        }, 9370: (e3, t3) => {
          "use strict";
          var r3 = Object.prototype.hasOwnProperty;
          function n2(e4) {
            try {
              return decodeURIComponent(e4.replace(/\+/g, " "));
            } catch (e5) {
              return null;
            }
          }
          function o3(e4) {
            try {
              return encodeURIComponent(e4);
            } catch (e5) {
              return null;
            }
          }
          t3.stringify = function(e4, t4) {
            t4 = t4 || "";
            var n3, s3, i3 = [];
            for (s3 in typeof t4 != "string" && (t4 = "?"), e4)
              if (r3.call(e4, s3)) {
                if ((n3 = e4[s3]) || n3 != null && !isNaN(n3) || (n3 = ""), s3 = o3(s3), n3 = o3(n3), s3 === null || n3 === null)
                  continue;
                i3.push(s3 + "=" + n3);
              }
            return i3.length ? t4 + i3.join("&") : "";
          }, t3.parse = function(e4) {
            for (var t4, r4 = /([^=?#&]+)=?([^&]*)/g, o4 = {}; t4 = r4.exec(e4); ) {
              var s3 = n2(t4[1]), i3 = n2(t4[2]);
              s3 === null || i3 === null || s3 in o4 || (o4[s3] = i3);
            }
            return o4;
          };
        }, 1926: (e3) => {
          "use strict";
          e3.exports = function(e4, t3) {
            if (t3 = t3.split(":")[0], !(e4 = +e4))
              return false;
            switch (t3) {
              case "http":
              case "ws":
                return e4 !== 80;
              case "https":
              case "wss":
                return e4 !== 443;
              case "ftp":
                return e4 !== 21;
              case "gopher":
                return e4 !== 70;
              case "file":
                return false;
            }
            return e4 !== 0;
          };
        }, 3680: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(1801), o3 = r3(7615), s3 = r3(3126), i3 = n2("%TypeError%"), a3 = n2("%WeakMap%", true), c3 = n2("%Map%", true), u3 = o3("WeakMap.prototype.get", true), l3 = o3("WeakMap.prototype.set", true), h3 = o3("WeakMap.prototype.has", true), p3 = o3("Map.prototype.get", true), f3 = o3("Map.prototype.set", true), d3 = o3("Map.prototype.has", true), g3 = function(e4, t4) {
            for (var r4, n3 = e4; (r4 = n3.next) !== null; n3 = r4)
              if (r4.key === t4)
                return n3.next = r4.next, r4.next = e4.next, e4.next = r4, r4;
          };
          e3.exports = function() {
            var e4, t4, r4, n3 = { assert: function(e5) {
              if (!n3.has(e5))
                throw new i3("Side channel does not contain " + s3(e5));
            }, get: function(n4) {
              if (a3 && n4 && (typeof n4 == "object" || typeof n4 == "function")) {
                if (e4)
                  return u3(e4, n4);
              } else if (c3) {
                if (t4)
                  return p3(t4, n4);
              } else if (r4)
                return function(e5, t5) {
                  var r5 = g3(e5, t5);
                  return r5 && r5.value;
                }(r4, n4);
            }, has: function(n4) {
              if (a3 && n4 && (typeof n4 == "object" || typeof n4 == "function")) {
                if (e4)
                  return h3(e4, n4);
              } else if (c3) {
                if (t4)
                  return d3(t4, n4);
              } else if (r4)
                return function(e5, t5) {
                  return !!g3(e5, t5);
                }(r4, n4);
              return false;
            }, set: function(n4, o4) {
              a3 && n4 && (typeof n4 == "object" || typeof n4 == "function") ? (e4 || (e4 = new a3()), l3(e4, n4, o4)) : c3 ? (t4 || (t4 = new c3()), f3(t4, n4, o4)) : (r4 || (r4 = { key: {}, next: null }), function(e5, t5, r5) {
                var n5 = g3(e5, t5);
                n5 ? n5.value = r5 : e5.next = { key: t5, next: e5.next, value: r5 };
              }(r4, n4, o4));
            } };
            return n3;
          };
        }, 2858: (e3) => {
          "use strict";
          function t3(e4, t4) {
            (t4 == null || t4 > e4.length) && (t4 = e4.length);
            for (var r4 = 0, n2 = new Array(t4); r4 < t4; r4++)
              n2[r4] = e4[r4];
            return n2;
          }
          function r3() {
            this._defaults = [];
          }
          ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"].forEach(function(e4) {
            r3.prototype[e4] = function() {
              for (var t4 = arguments.length, r4 = new Array(t4), n2 = 0; n2 < t4; n2++)
                r4[n2] = arguments[n2];
              return this._defaults.push({ fn: e4, args: r4 }), this;
            };
          }), r3.prototype._setDefaults = function(e4) {
            this._defaults.forEach(function(r4) {
              var n2;
              e4[r4.fn].apply(e4, function(e5) {
                if (Array.isArray(e5))
                  return t3(e5);
              }(n2 = r4.args) || function(e5) {
                if (typeof Symbol != "undefined" && Symbol.iterator in Object(e5))
                  return Array.from(e5);
              }(n2) || function(e5, r5) {
                if (e5) {
                  if (typeof e5 == "string")
                    return t3(e5, r5);
                  var n3 = Object.prototype.toString.call(e5).slice(8, -1);
                  return n3 === "Object" && e5.constructor && (n3 = e5.constructor.name), n3 === "Map" || n3 === "Set" ? Array.from(e5) : n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? t3(e5, r5) : void 0;
                }
              }(n2) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }());
            });
          }, e3.exports = r3;
        }, 5391: (e3, t3, r3) => {
          "use strict";
          function n2(e4) {
            return (n2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && typeof Symbol == "function" && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            })(e4);
          }
          var o3;
          typeof window != "undefined" ? o3 = window : typeof self == "undefined" ? (console.warn("Using browser-only version of superagent in non-browser environment"), o3 = void 0) : o3 = self;
          var s3 = r3(1069), i3 = r3(5799), a3 = r3(3065), c3 = r3(4287), u3 = r3(1960), l3 = r3(969), h3 = r3(2858);
          function p3() {
          }
          e3.exports = function(e4, r4) {
            return typeof r4 == "function" ? new t3.Request("GET", e4).end(r4) : arguments.length === 1 ? new t3.Request("GET", e4) : new t3.Request(e4, r4);
          };
          var f3 = t3 = e3.exports;
          t3.Request = w4, f3.getXHR = function() {
            if (o3.XMLHttpRequest && (!o3.location || o3.location.protocol !== "file:" || !o3.ActiveXObject))
              return new XMLHttpRequest();
            try {
              return new ActiveXObject("Microsoft.XMLHTTP");
            } catch (e4) {
            }
            try {
              return new ActiveXObject("Msxml2.XMLHTTP.6.0");
            } catch (e4) {
            }
            try {
              return new ActiveXObject("Msxml2.XMLHTTP.3.0");
            } catch (e4) {
            }
            try {
              return new ActiveXObject("Msxml2.XMLHTTP");
            } catch (e4) {
            }
            throw new Error("Browser-only version of superagent could not find XHR");
          };
          var d3 = "".trim ? function(e4) {
            return e4.trim();
          } : function(e4) {
            return e4.replace(/(^\s*|\s*$)/g, "");
          };
          function g3(e4) {
            if (!u3(e4))
              return e4;
            var t4 = [];
            for (var r4 in e4)
              Object.prototype.hasOwnProperty.call(e4, r4) && y3(t4, r4, e4[r4]);
            return t4.join("&");
          }
          function y3(e4, t4, r4) {
            if (r4 !== void 0)
              if (r4 !== null)
                if (Array.isArray(r4))
                  r4.forEach(function(r5) {
                    y3(e4, t4, r5);
                  });
                else if (u3(r4))
                  for (var n3 in r4)
                    Object.prototype.hasOwnProperty.call(r4, n3) && y3(e4, "".concat(t4, "[").concat(n3, "]"), r4[n3]);
                else
                  e4.push(encodeURI(t4) + "=" + encodeURIComponent(r4));
              else
                e4.push(encodeURI(t4));
          }
          function m3(e4) {
            for (var t4, r4, n3 = {}, o4 = e4.split("&"), s4 = 0, i4 = o4.length; s4 < i4; ++s4)
              (r4 = (t4 = o4[s4]).indexOf("=")) === -1 ? n3[decodeURIComponent(t4)] = "" : n3[decodeURIComponent(t4.slice(0, r4))] = decodeURIComponent(t4.slice(r4 + 1));
            return n3;
          }
          function b2(e4) {
            return /[/+]json($|[^-\w])/i.test(e4);
          }
          function A4(e4) {
            this.req = e4, this.xhr = this.req.xhr, this.text = this.req.method !== "HEAD" && (this.xhr.responseType === "" || this.xhr.responseType === "text") || this.xhr.responseType === void 0 ? this.xhr.responseText : null, this.statusText = this.req.xhr.statusText;
            var t4 = this.xhr.status;
            t4 === 1223 && (t4 = 204), this._setStatusProperties(t4), this.headers = function(e5) {
              for (var t5, r4, n3, o4, s4 = e5.split(/\r?\n/), i4 = {}, a4 = 0, c4 = s4.length; a4 < c4; ++a4)
                (t5 = (r4 = s4[a4]).indexOf(":")) !== -1 && (n3 = r4.slice(0, t5).toLowerCase(), o4 = d3(r4.slice(t5 + 1)), i4[n3] = o4);
              return i4;
            }(this.xhr.getAllResponseHeaders()), this.header = this.headers, this.header["content-type"] = this.xhr.getResponseHeader("content-type"), this._setHeaderProperties(this.header), this.text === null && e4._responseType ? this.body = this.xhr.response : this.body = this.req.method === "HEAD" ? null : this._parseBody(this.text ? this.text : this.xhr.response);
          }
          function w4(e4, t4) {
            var r4 = this;
            this._query = this._query || [], this.method = e4, this.url = t4, this.header = {}, this._header = {}, this.on("end", function() {
              var e5, t5 = null, n3 = null;
              try {
                n3 = new A4(r4);
              } catch (e6) {
                return (t5 = new Error("Parser is unable to parse the response")).parse = true, t5.original = e6, r4.xhr ? (t5.rawResponse = r4.xhr.responseType === void 0 ? r4.xhr.responseText : r4.xhr.response, t5.status = r4.xhr.status ? r4.xhr.status : null, t5.statusCode = t5.status) : (t5.rawResponse = null, t5.status = null), r4.callback(t5);
              }
              r4.emit("response", n3);
              try {
                r4._isResponseOK(n3) || (e5 = new Error(n3.statusText || n3.text || "Unsuccessful HTTP response"));
              } catch (t6) {
                e5 = t6;
              }
              e5 ? (e5.original = t5, e5.response = n3, e5.status = n3.status, r4.callback(e5, n3)) : r4.callback(null, n3);
            });
          }
          function v3(e4, t4, r4) {
            var n3 = f3("DELETE", e4);
            return typeof t4 == "function" && (r4 = t4, t4 = null), t4 && n3.send(t4), r4 && n3.end(r4), n3;
          }
          f3.serializeObject = g3, f3.parseString = m3, f3.types = { html: "text/html", json: "application/json", xml: "text/xml", urlencoded: "application/x-www-form-urlencoded", form: "application/x-www-form-urlencoded", "form-data": "application/x-www-form-urlencoded" }, f3.serialize = { "application/x-www-form-urlencoded": a3.stringify, "application/json": i3 }, f3.parse = { "application/x-www-form-urlencoded": m3, "application/json": JSON.parse }, l3(A4.prototype), A4.prototype._parseBody = function(e4) {
            var t4 = f3.parse[this.type];
            return this.req._parser ? this.req._parser(this, e4) : (!t4 && b2(this.type) && (t4 = f3.parse["application/json"]), t4 && e4 && (e4.length > 0 || e4 instanceof Object) ? t4(e4) : null);
          }, A4.prototype.toError = function() {
            var e4 = this.req, t4 = e4.method, r4 = e4.url, n3 = "cannot ".concat(t4, " ").concat(r4, " (").concat(this.status, ")"), o4 = new Error(n3);
            return o4.status = this.status, o4.method = t4, o4.url = r4, o4;
          }, f3.Response = A4, s3(w4.prototype), c3(w4.prototype), w4.prototype.type = function(e4) {
            return this.set("Content-Type", f3.types[e4] || e4), this;
          }, w4.prototype.accept = function(e4) {
            return this.set("Accept", f3.types[e4] || e4), this;
          }, w4.prototype.auth = function(e4, t4, r4) {
            arguments.length === 1 && (t4 = ""), n2(t4) === "object" && t4 !== null && (r4 = t4, t4 = ""), r4 || (r4 = { type: typeof btoa == "function" ? "basic" : "auto" });
            var o4 = function(e5) {
              if (typeof btoa == "function")
                return btoa(e5);
              throw new Error("Cannot use basic auth, btoa is not a function");
            };
            return this._auth(e4, t4, r4, o4);
          }, w4.prototype.query = function(e4) {
            return typeof e4 != "string" && (e4 = g3(e4)), e4 && this._query.push(e4), this;
          }, w4.prototype.attach = function(e4, t4, r4) {
            if (t4) {
              if (this._data)
                throw new Error("superagent can't mix .send() and .attach()");
              this._getFormData().append(e4, t4, r4 || t4.name);
            }
            return this;
          }, w4.prototype._getFormData = function() {
            return this._formData || (this._formData = new o3.FormData()), this._formData;
          }, w4.prototype.callback = function(e4, t4) {
            if (this._shouldRetry(e4, t4))
              return this._retry();
            var r4 = this._callback;
            this.clearTimeout(), e4 && (this._maxRetries && (e4.retries = this._retries - 1), this.emit("error", e4)), r4(e4, t4);
          }, w4.prototype.crossDomainError = function() {
            var e4 = new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");
            e4.crossDomain = true, e4.status = this.status, e4.method = this.method, e4.url = this.url, this.callback(e4);
          }, w4.prototype.agent = function() {
            return console.warn("This is not supported in browser version of superagent"), this;
          }, w4.prototype.ca = w4.prototype.agent, w4.prototype.buffer = w4.prototype.ca, w4.prototype.write = function() {
            throw new Error("Streaming is not supported in browser version of superagent");
          }, w4.prototype.pipe = w4.prototype.write, w4.prototype._isHost = function(e4) {
            return e4 && n2(e4) === "object" && !Array.isArray(e4) && Object.prototype.toString.call(e4) !== "[object Object]";
          }, w4.prototype.end = function(e4) {
            this._endCalled && console.warn("Warning: .end() was called twice. This is not supported in superagent"), this._endCalled = true, this._callback = e4 || p3, this._finalizeQueryString(), this._end();
          }, w4.prototype._setUploadTimeout = function() {
            var e4 = this;
            this._uploadTimeout && !this._uploadTimeoutTimer && (this._uploadTimeoutTimer = setTimeout(function() {
              e4._timeoutError("Upload timeout of ", e4._uploadTimeout, "ETIMEDOUT");
            }, this._uploadTimeout));
          }, w4.prototype._end = function() {
            if (this._aborted)
              return this.callback(new Error("The request has been aborted even before .end() was called"));
            var e4 = this;
            this.xhr = f3.getXHR();
            var t4 = this.xhr, r4 = this._formData || this._data;
            this._setTimeouts(), t4.onreadystatechange = function() {
              var r5 = t4.readyState;
              if (r5 >= 2 && e4._responseTimeoutTimer && clearTimeout(e4._responseTimeoutTimer), r5 === 4) {
                var n4;
                try {
                  n4 = t4.status;
                } catch (e5) {
                  n4 = 0;
                }
                if (!n4) {
                  if (e4.timedout || e4._aborted)
                    return;
                  return e4.crossDomainError();
                }
                e4.emit("end");
              }
            };
            var n3 = function(t5, r5) {
              r5.total > 0 && (r5.percent = r5.loaded / r5.total * 100, r5.percent === 100 && clearTimeout(e4._uploadTimeoutTimer)), r5.direction = t5, e4.emit("progress", r5);
            };
            if (this.hasListeners("progress"))
              try {
                t4.addEventListener("progress", n3.bind(null, "download")), t4.upload && t4.upload.addEventListener("progress", n3.bind(null, "upload"));
              } catch (e5) {
              }
            t4.upload && this._setUploadTimeout();
            try {
              this.username && this.password ? t4.open(this.method, this.url, true, this.username, this.password) : t4.open(this.method, this.url, true);
            } catch (e5) {
              return this.callback(e5);
            }
            if (this._withCredentials && (t4.withCredentials = true), !this._formData && this.method !== "GET" && this.method !== "HEAD" && typeof r4 != "string" && !this._isHost(r4)) {
              var o4 = this._header["content-type"], s4 = this._serializer || f3.serialize[o4 ? o4.split(";")[0] : ""];
              !s4 && b2(o4) && (s4 = f3.serialize["application/json"]), s4 && (r4 = s4(r4));
            }
            for (var i4 in this.header)
              this.header[i4] !== null && Object.prototype.hasOwnProperty.call(this.header, i4) && t4.setRequestHeader(i4, this.header[i4]);
            this._responseType && (t4.responseType = this._responseType), this.emit("request", this), t4.send(r4 === void 0 ? null : r4);
          }, f3.agent = function() {
            return new h3();
          }, ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(e4) {
            h3.prototype[e4.toLowerCase()] = function(t4, r4) {
              var n3 = new f3.Request(e4, t4);
              return this._setDefaults(n3), r4 && n3.end(r4), n3;
            };
          }), h3.prototype.del = h3.prototype.delete, f3.get = function(e4, t4, r4) {
            var n3 = f3("GET", e4);
            return typeof t4 == "function" && (r4 = t4, t4 = null), t4 && n3.query(t4), r4 && n3.end(r4), n3;
          }, f3.head = function(e4, t4, r4) {
            var n3 = f3("HEAD", e4);
            return typeof t4 == "function" && (r4 = t4, t4 = null), t4 && n3.query(t4), r4 && n3.end(r4), n3;
          }, f3.options = function(e4, t4, r4) {
            var n3 = f3("OPTIONS", e4);
            return typeof t4 == "function" && (r4 = t4, t4 = null), t4 && n3.send(t4), r4 && n3.end(r4), n3;
          }, f3.del = v3, f3.delete = v3, f3.patch = function(e4, t4, r4) {
            var n3 = f3("PATCH", e4);
            return typeof t4 == "function" && (r4 = t4, t4 = null), t4 && n3.send(t4), r4 && n3.end(r4), n3;
          }, f3.post = function(e4, t4, r4) {
            var n3 = f3("POST", e4);
            return typeof t4 == "function" && (r4 = t4, t4 = null), t4 && n3.send(t4), r4 && n3.end(r4), n3;
          }, f3.put = function(e4, t4, r4) {
            var n3 = f3("PUT", e4);
            return typeof t4 == "function" && (r4 = t4, t4 = null), t4 && n3.send(t4), r4 && n3.end(r4), n3;
          };
        }, 1960: (e3) => {
          "use strict";
          function t3(e4) {
            return (t3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && typeof Symbol == "function" && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            })(e4);
          }
          e3.exports = function(e4) {
            return e4 !== null && t3(e4) === "object";
          };
        }, 4287: (e3, t3, r3) => {
          "use strict";
          function n2(e4) {
            return (n2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && typeof Symbol == "function" && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            })(e4);
          }
          var o3 = r3(1960);
          function s3(e4) {
            if (e4)
              return function(e5) {
                for (var t4 in s3.prototype)
                  Object.prototype.hasOwnProperty.call(s3.prototype, t4) && (e5[t4] = s3.prototype[t4]);
                return e5;
              }(e4);
          }
          e3.exports = s3, s3.prototype.clearTimeout = function() {
            return clearTimeout(this._timer), clearTimeout(this._responseTimeoutTimer), clearTimeout(this._uploadTimeoutTimer), delete this._timer, delete this._responseTimeoutTimer, delete this._uploadTimeoutTimer, this;
          }, s3.prototype.parse = function(e4) {
            return this._parser = e4, this;
          }, s3.prototype.responseType = function(e4) {
            return this._responseType = e4, this;
          }, s3.prototype.serialize = function(e4) {
            return this._serializer = e4, this;
          }, s3.prototype.timeout = function(e4) {
            if (!e4 || n2(e4) !== "object")
              return this._timeout = e4, this._responseTimeout = 0, this._uploadTimeout = 0, this;
            for (var t4 in e4)
              if (Object.prototype.hasOwnProperty.call(e4, t4))
                switch (t4) {
                  case "deadline":
                    this._timeout = e4.deadline;
                    break;
                  case "response":
                    this._responseTimeout = e4.response;
                    break;
                  case "upload":
                    this._uploadTimeout = e4.upload;
                    break;
                  default:
                    console.warn("Unknown timeout option", t4);
                }
            return this;
          }, s3.prototype.retry = function(e4, t4) {
            return arguments.length !== 0 && e4 !== true || (e4 = 1), e4 <= 0 && (e4 = 0), this._maxRetries = e4, this._retries = 0, this._retryCallback = t4, this;
          };
          var i3 = /* @__PURE__ */ new Set(["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"]), a3 = /* @__PURE__ */ new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]);
          s3.prototype._shouldRetry = function(e4, t4) {
            if (!this._maxRetries || this._retries++ >= this._maxRetries)
              return false;
            if (this._retryCallback)
              try {
                var r4 = this._retryCallback(e4, t4);
                if (r4 === true)
                  return true;
                if (r4 === false)
                  return false;
              } catch (e5) {
                console.error(e5);
              }
            if (t4 && t4.status && a3.has(t4.status))
              return true;
            if (e4) {
              if (e4.code && i3.has(e4.code))
                return true;
              if (e4.timeout && e4.code === "ECONNABORTED")
                return true;
              if (e4.crossDomain)
                return true;
            }
            return false;
          }, s3.prototype._retry = function() {
            return this.clearTimeout(), this.req && (this.req = null, this.req = this.request()), this._aborted = false, this.timedout = false, this.timedoutError = null, this._end();
          }, s3.prototype.then = function(e4, t4) {
            var r4 = this;
            if (!this._fullfilledPromise) {
              var n3 = this;
              this._endCalled && console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"), this._fullfilledPromise = new Promise(function(e5, t5) {
                n3.on("abort", function() {
                  if (!(r4._maxRetries && r4._maxRetries > r4._retries))
                    if (r4.timedout && r4.timedoutError)
                      t5(r4.timedoutError);
                    else {
                      var e6 = new Error("Aborted");
                      e6.code = "ABORTED", e6.status = r4.status, e6.method = r4.method, e6.url = r4.url, t5(e6);
                    }
                }), n3.end(function(r5, n4) {
                  r5 ? t5(r5) : e5(n4);
                });
              });
            }
            return this._fullfilledPromise.then(e4, t4);
          }, s3.prototype.catch = function(e4) {
            return this.then(void 0, e4);
          }, s3.prototype.use = function(e4) {
            return e4(this), this;
          }, s3.prototype.ok = function(e4) {
            if (typeof e4 != "function")
              throw new Error("Callback required");
            return this._okCallback = e4, this;
          }, s3.prototype._isResponseOK = function(e4) {
            return !!e4 && (this._okCallback ? this._okCallback(e4) : e4.status >= 200 && e4.status < 300);
          }, s3.prototype.get = function(e4) {
            return this._header[e4.toLowerCase()];
          }, s3.prototype.getHeader = s3.prototype.get, s3.prototype.set = function(e4, t4) {
            if (o3(e4)) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && this.set(r4, e4[r4]);
              return this;
            }
            return this._header[e4.toLowerCase()] = t4, this.header[e4] = t4, this;
          }, s3.prototype.unset = function(e4) {
            return delete this._header[e4.toLowerCase()], delete this.header[e4], this;
          }, s3.prototype.field = function(e4, t4) {
            if (e4 == null)
              throw new Error(".field(name, val) name can not be empty");
            if (this._data)
              throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
            if (o3(e4)) {
              for (var r4 in e4)
                Object.prototype.hasOwnProperty.call(e4, r4) && this.field(r4, e4[r4]);
              return this;
            }
            if (Array.isArray(t4)) {
              for (var n3 in t4)
                Object.prototype.hasOwnProperty.call(t4, n3) && this.field(e4, t4[n3]);
              return this;
            }
            if (t4 == null)
              throw new Error(".field(name, val) val can not be empty");
            return typeof t4 == "boolean" && (t4 = String(t4)), this._getFormData().append(e4, t4), this;
          }, s3.prototype.abort = function() {
            return this._aborted || (this._aborted = true, this.xhr && this.xhr.abort(), this.req && this.req.abort(), this.clearTimeout(), this.emit("abort")), this;
          }, s3.prototype._auth = function(e4, t4, r4, n3) {
            switch (r4.type) {
              case "basic":
                this.set("Authorization", "Basic ".concat(n3("".concat(e4, ":").concat(t4))));
                break;
              case "auto":
                this.username = e4, this.password = t4;
                break;
              case "bearer":
                this.set("Authorization", "Bearer ".concat(e4));
            }
            return this;
          }, s3.prototype.withCredentials = function(e4) {
            return e4 === void 0 && (e4 = true), this._withCredentials = e4, this;
          }, s3.prototype.redirects = function(e4) {
            return this._maxRedirects = e4, this;
          }, s3.prototype.maxResponseSize = function(e4) {
            if (typeof e4 != "number")
              throw new TypeError("Invalid argument");
            return this._maxResponseSize = e4, this;
          }, s3.prototype.toJSON = function() {
            return { method: this.method, url: this.url, data: this._data, headers: this._header };
          }, s3.prototype.send = function(e4) {
            var t4 = o3(e4), r4 = this._header["content-type"];
            if (this._formData)
              throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
            if (t4 && !this._data)
              Array.isArray(e4) ? this._data = [] : this._isHost(e4) || (this._data = {});
            else if (e4 && this._data && this._isHost(this._data))
              throw new Error("Can't merge these send calls");
            if (t4 && o3(this._data))
              for (var n3 in e4)
                Object.prototype.hasOwnProperty.call(e4, n3) && (this._data[n3] = e4[n3]);
            else
              typeof e4 == "string" ? (r4 || this.type("form"), (r4 = this._header["content-type"]) && (r4 = r4.toLowerCase().trim()), this._data = r4 === "application/x-www-form-urlencoded" ? this._data ? "".concat(this._data, "&").concat(e4) : e4 : (this._data || "") + e4) : this._data = e4;
            return !t4 || this._isHost(e4) || r4 || this.type("json"), this;
          }, s3.prototype.sortQuery = function(e4) {
            return this._sort = e4 === void 0 || e4, this;
          }, s3.prototype._finalizeQueryString = function() {
            var e4 = this._query.join("&");
            if (e4 && (this.url += (this.url.includes("?") ? "&" : "?") + e4), this._query.length = 0, this._sort) {
              var t4 = this.url.indexOf("?");
              if (t4 >= 0) {
                var r4 = this.url.slice(t4 + 1).split("&");
                typeof this._sort == "function" ? r4.sort(this._sort) : r4.sort(), this.url = this.url.slice(0, t4) + "?" + r4.join("&");
              }
            }
          }, s3.prototype._appendQueryString = function() {
            console.warn("Unsupported");
          }, s3.prototype._timeoutError = function(e4, t4, r4) {
            if (!this._aborted) {
              var n3 = new Error("".concat(e4 + t4, "ms exceeded"));
              n3.timeout = t4, n3.code = "ECONNABORTED", n3.errno = r4, this.timedout = true, this.timedoutError = n3, this.abort(), this.callback(n3);
            }
          }, s3.prototype._setTimeouts = function() {
            var e4 = this;
            this._timeout && !this._timer && (this._timer = setTimeout(function() {
              e4._timeoutError("Timeout of ", e4._timeout, "ETIME");
            }, this._timeout)), this._responseTimeout && !this._responseTimeoutTimer && (this._responseTimeoutTimer = setTimeout(function() {
              e4._timeoutError("Response timeout of ", e4._responseTimeout, "ETIMEDOUT");
            }, this._responseTimeout));
          };
        }, 969: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(3094);
          function o3(e4) {
            if (e4)
              return function(e5) {
                for (var t4 in o3.prototype)
                  Object.prototype.hasOwnProperty.call(o3.prototype, t4) && (e5[t4] = o3.prototype[t4]);
                return e5;
              }(e4);
          }
          e3.exports = o3, o3.prototype.get = function(e4) {
            return this.header[e4.toLowerCase()];
          }, o3.prototype._setHeaderProperties = function(e4) {
            var t4 = e4["content-type"] || "";
            this.type = n2.type(t4);
            var r4 = n2.params(t4);
            for (var o4 in r4)
              Object.prototype.hasOwnProperty.call(r4, o4) && (this[o4] = r4[o4]);
            this.links = {};
            try {
              e4.link && (this.links = n2.parseLinks(e4.link));
            } catch (e5) {
            }
          }, o3.prototype._setStatusProperties = function(e4) {
            var t4 = e4 / 100 | 0;
            this.statusCode = e4, this.status = this.statusCode, this.statusType = t4, this.info = t4 === 1, this.ok = t4 === 2, this.redirect = t4 === 3, this.clientError = t4 === 4, this.serverError = t4 === 5, this.error = (t4 === 4 || t4 === 5) && this.toError(), this.created = e4 === 201, this.accepted = e4 === 202, this.noContent = e4 === 204, this.badRequest = e4 === 400, this.unauthorized = e4 === 401, this.notAcceptable = e4 === 406, this.forbidden = e4 === 403, this.notFound = e4 === 404, this.unprocessableEntity = e4 === 422;
          };
        }, 3094: (e3, t3) => {
          "use strict";
          function r3(e4, t4) {
            var r4;
            if (typeof Symbol == "undefined" || e4[Symbol.iterator] == null) {
              if (Array.isArray(e4) || (r4 = function(e5, t5) {
                if (e5) {
                  if (typeof e5 == "string")
                    return n2(e5, t5);
                  var r5 = Object.prototype.toString.call(e5).slice(8, -1);
                  return r5 === "Object" && e5.constructor && (r5 = e5.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e5) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? n2(e5, t5) : void 0;
                }
              }(e4)) || t4 && e4 && typeof e4.length == "number") {
                r4 && (e4 = r4);
                var o3 = 0, s3 = function() {
                };
                return { s: s3, n: function() {
                  return o3 >= e4.length ? { done: true } : { done: false, value: e4[o3++] };
                }, e: function(e5) {
                  throw e5;
                }, f: s3 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var i3, a3 = true, c3 = false;
            return { s: function() {
              r4 = e4[Symbol.iterator]();
            }, n: function() {
              var e5 = r4.next();
              return a3 = e5.done, e5;
            }, e: function(e5) {
              c3 = true, i3 = e5;
            }, f: function() {
              try {
                a3 || r4.return == null || r4.return();
              } finally {
                if (c3)
                  throw i3;
              }
            } };
          }
          function n2(e4, t4) {
            (t4 == null || t4 > e4.length) && (t4 = e4.length);
            for (var r4 = 0, n3 = new Array(t4); r4 < t4; r4++)
              n3[r4] = e4[r4];
            return n3;
          }
          t3.type = function(e4) {
            return e4.split(/ *; */).shift();
          }, t3.params = function(e4) {
            var t4, n3 = {}, o3 = r3(e4.split(/ *; */));
            try {
              for (o3.s(); !(t4 = o3.n()).done; ) {
                var s3 = t4.value.split(/ *= */), i3 = s3.shift(), a3 = s3.shift();
                i3 && a3 && (n3[i3] = a3);
              }
            } catch (e5) {
              o3.e(e5);
            } finally {
              o3.f();
            }
            return n3;
          }, t3.parseLinks = function(e4) {
            var t4, n3 = {}, o3 = r3(e4.split(/ *, */));
            try {
              for (o3.s(); !(t4 = o3.n()).done; ) {
                var s3 = t4.value.split(/ *; */), i3 = s3[0].slice(1, -1);
                n3[s3[1].split(/ *= */)[1].slice(1, -1)] = i3;
              }
            } catch (e5) {
              o3.e(e5);
            } finally {
              o3.f();
            }
            return n3;
          }, t3.cleanHeader = function(e4, t4) {
            return delete e4["content-type"], delete e4["content-length"], delete e4["transfer-encoding"], delete e4.host, t4 && (delete e4.authorization, delete e4.cookie), e4;
          };
        }, 5335: (e3) => {
          "use strict";
          var t3 = String.prototype.replace, r3 = /%20/g, n2 = "RFC3986";
          e3.exports = { default: n2, formatters: { RFC1738: function(e4) {
            return t3.call(e4, r3, "+");
          }, RFC3986: function(e4) {
            return String(e4);
          } }, RFC1738: "RFC1738", RFC3986: n2 };
        }, 3065: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(4246), o3 = r3(1688), s3 = r3(5335);
          e3.exports = { formats: s3, parse: o3, stringify: n2 };
        }, 1688: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(4562), o3 = Object.prototype.hasOwnProperty, s3 = Array.isArray, i3 = { allowDots: false, allowPrototypes: false, allowSparse: false, arrayLimit: 20, charset: "utf-8", charsetSentinel: false, comma: false, decoder: n2.decode, delimiter: "&", depth: 5, ignoreQueryPrefix: false, interpretNumericEntities: false, parameterLimit: 1e3, parseArrays: true, plainObjects: false, strictNullHandling: false }, a3 = function(e4) {
            return e4.replace(/&#(\d+);/g, function(e5, t4) {
              return String.fromCharCode(parseInt(t4, 10));
            });
          }, c3 = function(e4, t4) {
            return e4 && typeof e4 == "string" && t4.comma && e4.indexOf(",") > -1 ? e4.split(",") : e4;
          }, u3 = function(e4, t4, r4, n3) {
            if (e4) {
              var s4 = r4.allowDots ? e4.replace(/\.([^.[]+)/g, "[$1]") : e4, i4 = /(\[[^[\]]*])/g, a4 = r4.depth > 0 && /(\[[^[\]]*])/.exec(s4), u4 = a4 ? s4.slice(0, a4.index) : s4, l3 = [];
              if (u4) {
                if (!r4.plainObjects && o3.call(Object.prototype, u4) && !r4.allowPrototypes)
                  return;
                l3.push(u4);
              }
              for (var h3 = 0; r4.depth > 0 && (a4 = i4.exec(s4)) !== null && h3 < r4.depth; ) {
                if (h3 += 1, !r4.plainObjects && o3.call(Object.prototype, a4[1].slice(1, -1)) && !r4.allowPrototypes)
                  return;
                l3.push(a4[1]);
              }
              return a4 && l3.push("[" + s4.slice(a4.index) + "]"), function(e5, t5, r5, n4) {
                for (var o4 = n4 ? t5 : c3(t5, r5), s5 = e5.length - 1; s5 >= 0; --s5) {
                  var i5, a5 = e5[s5];
                  if (a5 === "[]" && r5.parseArrays)
                    i5 = [].concat(o4);
                  else {
                    i5 = r5.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
                    var u5 = a5.charAt(0) === "[" && a5.charAt(a5.length - 1) === "]" ? a5.slice(1, -1) : a5, l4 = parseInt(u5, 10);
                    r5.parseArrays || u5 !== "" ? !isNaN(l4) && a5 !== u5 && String(l4) === u5 && l4 >= 0 && r5.parseArrays && l4 <= r5.arrayLimit ? (i5 = [])[l4] = o4 : i5[u5] = o4 : i5 = { 0: o4 };
                  }
                  o4 = i5;
                }
                return o4;
              }(l3, t4, r4, n3);
            }
          };
          e3.exports = function(e4, t4) {
            var r4 = function(e5) {
              if (!e5)
                return i3;
              if (e5.decoder !== null && e5.decoder !== void 0 && typeof e5.decoder != "function")
                throw new TypeError("Decoder has to be a function.");
              if (e5.charset !== void 0 && e5.charset !== "utf-8" && e5.charset !== "iso-8859-1")
                throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
              var t5 = e5.charset === void 0 ? i3.charset : e5.charset;
              return { allowDots: e5.allowDots === void 0 ? i3.allowDots : !!e5.allowDots, allowPrototypes: typeof e5.allowPrototypes == "boolean" ? e5.allowPrototypes : i3.allowPrototypes, allowSparse: typeof e5.allowSparse == "boolean" ? e5.allowSparse : i3.allowSparse, arrayLimit: typeof e5.arrayLimit == "number" ? e5.arrayLimit : i3.arrayLimit, charset: t5, charsetSentinel: typeof e5.charsetSentinel == "boolean" ? e5.charsetSentinel : i3.charsetSentinel, comma: typeof e5.comma == "boolean" ? e5.comma : i3.comma, decoder: typeof e5.decoder == "function" ? e5.decoder : i3.decoder, delimiter: typeof e5.delimiter == "string" || n2.isRegExp(e5.delimiter) ? e5.delimiter : i3.delimiter, depth: typeof e5.depth == "number" || e5.depth === false ? +e5.depth : i3.depth, ignoreQueryPrefix: e5.ignoreQueryPrefix === true, interpretNumericEntities: typeof e5.interpretNumericEntities == "boolean" ? e5.interpretNumericEntities : i3.interpretNumericEntities, parameterLimit: typeof e5.parameterLimit == "number" ? e5.parameterLimit : i3.parameterLimit, parseArrays: e5.parseArrays !== false, plainObjects: typeof e5.plainObjects == "boolean" ? e5.plainObjects : i3.plainObjects, strictNullHandling: typeof e5.strictNullHandling == "boolean" ? e5.strictNullHandling : i3.strictNullHandling };
            }(t4);
            if (e4 === "" || e4 == null)
              return r4.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
            for (var l3 = typeof e4 == "string" ? function(e5, t5) {
              var r5, u4 = {}, l4 = t5.ignoreQueryPrefix ? e5.replace(/^\?/, "") : e5, h4 = t5.parameterLimit === 1 / 0 ? void 0 : t5.parameterLimit, p4 = l4.split(t5.delimiter, h4), f4 = -1, d4 = t5.charset;
              if (t5.charsetSentinel)
                for (r5 = 0; r5 < p4.length; ++r5)
                  p4[r5].indexOf("utf8=") === 0 && (p4[r5] === "utf8=%E2%9C%93" ? d4 = "utf-8" : p4[r5] === "utf8=%26%2310003%3B" && (d4 = "iso-8859-1"), f4 = r5, r5 = p4.length);
              for (r5 = 0; r5 < p4.length; ++r5)
                if (r5 !== f4) {
                  var g4, y3, m3 = p4[r5], b2 = m3.indexOf("]="), A4 = b2 === -1 ? m3.indexOf("=") : b2 + 1;
                  A4 === -1 ? (g4 = t5.decoder(m3, i3.decoder, d4, "key"), y3 = t5.strictNullHandling ? null : "") : (g4 = t5.decoder(m3.slice(0, A4), i3.decoder, d4, "key"), y3 = n2.maybeMap(c3(m3.slice(A4 + 1), t5), function(e6) {
                    return t5.decoder(e6, i3.decoder, d4, "value");
                  })), y3 && t5.interpretNumericEntities && d4 === "iso-8859-1" && (y3 = a3(y3)), m3.indexOf("[]=") > -1 && (y3 = s3(y3) ? [y3] : y3), o3.call(u4, g4) ? u4[g4] = n2.combine(u4[g4], y3) : u4[g4] = y3;
                }
              return u4;
            }(e4, r4) : e4, h3 = r4.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, p3 = Object.keys(l3), f3 = 0; f3 < p3.length; ++f3) {
              var d3 = p3[f3], g3 = u3(d3, l3[d3], r4, typeof e4 == "string");
              h3 = n2.merge(h3, g3, r4);
            }
            return r4.allowSparse === true ? h3 : n2.compact(h3);
          };
        }, 4246: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(3680), o3 = r3(4562), s3 = r3(5335), i3 = Object.prototype.hasOwnProperty, a3 = { brackets: function(e4) {
            return e4 + "[]";
          }, comma: "comma", indices: function(e4, t4) {
            return e4 + "[" + t4 + "]";
          }, repeat: function(e4) {
            return e4;
          } }, c3 = Array.isArray, u3 = Array.prototype.push, l3 = function(e4, t4) {
            u3.apply(e4, c3(t4) ? t4 : [t4]);
          }, h3 = Date.prototype.toISOString, p3 = s3.default, f3 = { addQueryPrefix: false, allowDots: false, charset: "utf-8", charsetSentinel: false, delimiter: "&", encode: true, encoder: o3.encode, encodeValuesOnly: false, format: p3, formatter: s3.formatters[p3], indices: false, serializeDate: function(e4) {
            return h3.call(e4);
          }, skipNulls: false, strictNullHandling: false }, d3 = function e4(t4, r4, s4, i4, a4, u4, h4, p4, d4, g3, y3, m3, b2, A4, w4) {
            var v3, x3 = t4;
            if (w4.has(t4))
              throw new RangeError("Cyclic object value");
            if (typeof h4 == "function" ? x3 = h4(r4, x3) : x3 instanceof Date ? x3 = g3(x3) : s4 === "comma" && c3(x3) && (x3 = o3.maybeMap(x3, function(e5) {
              return e5 instanceof Date ? g3(e5) : e5;
            })), x3 === null) {
              if (i4)
                return u4 && !b2 ? u4(r4, f3.encoder, A4, "key", y3) : r4;
              x3 = "";
            }
            if (typeof (v3 = x3) == "string" || typeof v3 == "number" || typeof v3 == "boolean" || typeof v3 == "symbol" || typeof v3 == "bigint" || o3.isBuffer(x3))
              return u4 ? [m3(b2 ? r4 : u4(r4, f3.encoder, A4, "key", y3)) + "=" + m3(u4(x3, f3.encoder, A4, "value", y3))] : [m3(r4) + "=" + m3(String(x3))];
            var S2, E4 = [];
            if (x3 === void 0)
              return E4;
            if (s4 === "comma" && c3(x3))
              S2 = [{ value: x3.length > 0 ? x3.join(",") || null : void 0 }];
            else if (c3(h4))
              S2 = h4;
            else {
              var T4 = Object.keys(x3);
              S2 = p4 ? T4.sort(p4) : T4;
            }
            for (var _4 = 0; _4 < S2.length; ++_4) {
              var B2 = S2[_4], U2 = typeof B2 == "object" && B2.value !== void 0 ? B2.value : x3[B2];
              if (!a4 || U2 !== null) {
                var k3 = c3(x3) ? typeof s4 == "function" ? s4(r4, B2) : r4 : r4 + (d4 ? "." + B2 : "[" + B2 + "]");
                w4.set(t4, true);
                var I3 = n2();
                l3(E4, e4(U2, k3, s4, i4, a4, u4, h4, p4, d4, g3, y3, m3, b2, A4, I3));
              }
            }
            return E4;
          };
          e3.exports = function(e4, t4) {
            var r4, o4 = e4, u4 = function(e5) {
              if (!e5)
                return f3;
              if (e5.encoder !== null && e5.encoder !== void 0 && typeof e5.encoder != "function")
                throw new TypeError("Encoder has to be a function.");
              var t5 = e5.charset || f3.charset;
              if (e5.charset !== void 0 && e5.charset !== "utf-8" && e5.charset !== "iso-8859-1")
                throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
              var r5 = s3.default;
              if (e5.format !== void 0) {
                if (!i3.call(s3.formatters, e5.format))
                  throw new TypeError("Unknown format option provided.");
                r5 = e5.format;
              }
              var n3 = s3.formatters[r5], o5 = f3.filter;
              return (typeof e5.filter == "function" || c3(e5.filter)) && (o5 = e5.filter), { addQueryPrefix: typeof e5.addQueryPrefix == "boolean" ? e5.addQueryPrefix : f3.addQueryPrefix, allowDots: e5.allowDots === void 0 ? f3.allowDots : !!e5.allowDots, charset: t5, charsetSentinel: typeof e5.charsetSentinel == "boolean" ? e5.charsetSentinel : f3.charsetSentinel, delimiter: e5.delimiter === void 0 ? f3.delimiter : e5.delimiter, encode: typeof e5.encode == "boolean" ? e5.encode : f3.encode, encoder: typeof e5.encoder == "function" ? e5.encoder : f3.encoder, encodeValuesOnly: typeof e5.encodeValuesOnly == "boolean" ? e5.encodeValuesOnly : f3.encodeValuesOnly, filter: o5, format: r5, formatter: n3, serializeDate: typeof e5.serializeDate == "function" ? e5.serializeDate : f3.serializeDate, skipNulls: typeof e5.skipNulls == "boolean" ? e5.skipNulls : f3.skipNulls, sort: typeof e5.sort == "function" ? e5.sort : null, strictNullHandling: typeof e5.strictNullHandling == "boolean" ? e5.strictNullHandling : f3.strictNullHandling };
            }(t4);
            typeof u4.filter == "function" ? o4 = (0, u4.filter)("", o4) : c3(u4.filter) && (r4 = u4.filter);
            var h4, p4 = [];
            if (typeof o4 != "object" || o4 === null)
              return "";
            h4 = t4 && t4.arrayFormat in a3 ? t4.arrayFormat : t4 && "indices" in t4 ? t4.indices ? "indices" : "repeat" : "indices";
            var g3 = a3[h4];
            r4 || (r4 = Object.keys(o4)), u4.sort && r4.sort(u4.sort);
            for (var y3 = n2(), m3 = 0; m3 < r4.length; ++m3) {
              var b2 = r4[m3];
              u4.skipNulls && o4[b2] === null || l3(p4, d3(o4[b2], b2, g3, u4.strictNullHandling, u4.skipNulls, u4.encode ? u4.encoder : null, u4.filter, u4.sort, u4.allowDots, u4.serializeDate, u4.format, u4.formatter, u4.encodeValuesOnly, u4.charset, y3));
            }
            var A4 = p4.join(u4.delimiter), w4 = u4.addQueryPrefix === true ? "?" : "";
            return u4.charsetSentinel && (u4.charset === "iso-8859-1" ? w4 += "utf8=%26%2310003%3B&" : w4 += "utf8=%E2%9C%93&"), A4.length > 0 ? w4 + A4 : "";
          };
        }, 4562: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(5335), o3 = Object.prototype.hasOwnProperty, s3 = Array.isArray, i3 = function() {
            for (var e4 = [], t4 = 0; t4 < 256; ++t4)
              e4.push("%" + ((t4 < 16 ? "0" : "") + t4.toString(16)).toUpperCase());
            return e4;
          }(), a3 = function(e4, t4) {
            for (var r4 = t4 && t4.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, n3 = 0; n3 < e4.length; ++n3)
              e4[n3] !== void 0 && (r4[n3] = e4[n3]);
            return r4;
          };
          e3.exports = { arrayToObject: a3, assign: function(e4, t4) {
            return Object.keys(t4).reduce(function(e5, r4) {
              return e5[r4] = t4[r4], e5;
            }, e4);
          }, combine: function(e4, t4) {
            return [].concat(e4, t4);
          }, compact: function(e4) {
            for (var t4 = [{ obj: { o: e4 }, prop: "o" }], r4 = [], n3 = 0; n3 < t4.length; ++n3)
              for (var o4 = t4[n3], i4 = o4.obj[o4.prop], a4 = Object.keys(i4), c3 = 0; c3 < a4.length; ++c3) {
                var u3 = a4[c3], l3 = i4[u3];
                typeof l3 == "object" && l3 !== null && r4.indexOf(l3) === -1 && (t4.push({ obj: i4, prop: u3 }), r4.push(l3));
              }
            return function(e5) {
              for (; e5.length > 1; ) {
                var t5 = e5.pop(), r5 = t5.obj[t5.prop];
                if (s3(r5)) {
                  for (var n4 = [], o5 = 0; o5 < r5.length; ++o5)
                    r5[o5] !== void 0 && n4.push(r5[o5]);
                  t5.obj[t5.prop] = n4;
                }
              }
            }(t4), e4;
          }, decode: function(e4, t4, r4) {
            var n3 = e4.replace(/\+/g, " ");
            if (r4 === "iso-8859-1")
              return n3.replace(/%[0-9a-f]{2}/gi, unescape);
            try {
              return decodeURIComponent(n3);
            } catch (e5) {
              return n3;
            }
          }, encode: function(e4, t4, r4, o4, s4) {
            if (e4.length === 0)
              return e4;
            var a4 = e4;
            if (typeof e4 == "symbol" ? a4 = Symbol.prototype.toString.call(e4) : typeof e4 != "string" && (a4 = String(e4)), r4 === "iso-8859-1")
              return escape(a4).replace(/%u[0-9a-f]{4}/gi, function(e5) {
                return "%26%23" + parseInt(e5.slice(2), 16) + "%3B";
              });
            for (var c3 = "", u3 = 0; u3 < a4.length; ++u3) {
              var l3 = a4.charCodeAt(u3);
              l3 === 45 || l3 === 46 || l3 === 95 || l3 === 126 || l3 >= 48 && l3 <= 57 || l3 >= 65 && l3 <= 90 || l3 >= 97 && l3 <= 122 || s4 === n2.RFC1738 && (l3 === 40 || l3 === 41) ? c3 += a4.charAt(u3) : l3 < 128 ? c3 += i3[l3] : l3 < 2048 ? c3 += i3[192 | l3 >> 6] + i3[128 | 63 & l3] : l3 < 55296 || l3 >= 57344 ? c3 += i3[224 | l3 >> 12] + i3[128 | l3 >> 6 & 63] + i3[128 | 63 & l3] : (u3 += 1, l3 = 65536 + ((1023 & l3) << 10 | 1023 & a4.charCodeAt(u3)), c3 += i3[240 | l3 >> 18] + i3[128 | l3 >> 12 & 63] + i3[128 | l3 >> 6 & 63] + i3[128 | 63 & l3]);
            }
            return c3;
          }, isBuffer: function(e4) {
            return !(!e4 || typeof e4 != "object" || !(e4.constructor && e4.constructor.isBuffer && e4.constructor.isBuffer(e4)));
          }, isRegExp: function(e4) {
            return Object.prototype.toString.call(e4) === "[object RegExp]";
          }, maybeMap: function(e4, t4) {
            if (s3(e4)) {
              for (var r4 = [], n3 = 0; n3 < e4.length; n3 += 1)
                r4.push(t4(e4[n3]));
              return r4;
            }
            return t4(e4);
          }, merge: function e4(t4, r4, n3) {
            if (!r4)
              return t4;
            if (typeof r4 != "object") {
              if (s3(t4))
                t4.push(r4);
              else {
                if (!t4 || typeof t4 != "object")
                  return [t4, r4];
                (n3 && (n3.plainObjects || n3.allowPrototypes) || !o3.call(Object.prototype, r4)) && (t4[r4] = true);
              }
              return t4;
            }
            if (!t4 || typeof t4 != "object")
              return [t4].concat(r4);
            var i4 = t4;
            return s3(t4) && !s3(r4) && (i4 = a3(t4, n3)), s3(t4) && s3(r4) ? (r4.forEach(function(r5, s4) {
              if (o3.call(t4, s4)) {
                var i5 = t4[s4];
                i5 && typeof i5 == "object" && r5 && typeof r5 == "object" ? t4[s4] = e4(i5, r5, n3) : t4.push(r5);
              } else
                t4[s4] = r5;
            }), t4) : Object.keys(r4).reduce(function(t5, s4) {
              var i5 = r4[s4];
              return o3.call(t5, s4) ? t5[s4] = e4(t5[s4], i5, n3) : t5[s4] = i5, t5;
            }, i4);
          } };
        }, 7765: function(e3, t3) {
          !function(e4) {
            "use strict";
            var t4 = function(e5) {
              var t5, r4 = new Float64Array(16);
              if (e5)
                for (t5 = 0; t5 < e5.length; t5++)
                  r4[t5] = e5[t5];
              return r4;
            }, r3 = function() {
              throw new Error("no PRNG");
            }, n2 = new Uint8Array(16), o3 = new Uint8Array(32);
            o3[0] = 9;
            var s3 = t4(), i3 = t4([1]), a3 = t4([56129, 1]), c3 = t4([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), u3 = t4([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), l3 = t4([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), h3 = t4([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), p3 = t4([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
            function f3(e5, t5, r4, n3) {
              e5[t5] = r4 >> 24 & 255, e5[t5 + 1] = r4 >> 16 & 255, e5[t5 + 2] = r4 >> 8 & 255, e5[t5 + 3] = 255 & r4, e5[t5 + 4] = n3 >> 24 & 255, e5[t5 + 5] = n3 >> 16 & 255, e5[t5 + 6] = n3 >> 8 & 255, e5[t5 + 7] = 255 & n3;
            }
            function d3(e5, t5, r4, n3, o4) {
              var s4, i4 = 0;
              for (s4 = 0; s4 < o4; s4++)
                i4 |= e5[t5 + s4] ^ r4[n3 + s4];
              return (1 & i4 - 1 >>> 8) - 1;
            }
            function g3(e5, t5, r4, n3) {
              return d3(e5, t5, r4, n3, 16);
            }
            function y3(e5, t5, r4, n3) {
              return d3(e5, t5, r4, n3, 32);
            }
            function m3(e5, t5, r4, n3) {
              !function(e6, t6, r5, n4) {
                for (var o4, s4 = 255 & n4[0] | (255 & n4[1]) << 8 | (255 & n4[2]) << 16 | (255 & n4[3]) << 24, i4 = 255 & r5[0] | (255 & r5[1]) << 8 | (255 & r5[2]) << 16 | (255 & r5[3]) << 24, a4 = 255 & r5[4] | (255 & r5[5]) << 8 | (255 & r5[6]) << 16 | (255 & r5[7]) << 24, c4 = 255 & r5[8] | (255 & r5[9]) << 8 | (255 & r5[10]) << 16 | (255 & r5[11]) << 24, u4 = 255 & r5[12] | (255 & r5[13]) << 8 | (255 & r5[14]) << 16 | (255 & r5[15]) << 24, l4 = 255 & n4[4] | (255 & n4[5]) << 8 | (255 & n4[6]) << 16 | (255 & n4[7]) << 24, h4 = 255 & t6[0] | (255 & t6[1]) << 8 | (255 & t6[2]) << 16 | (255 & t6[3]) << 24, p4 = 255 & t6[4] | (255 & t6[5]) << 8 | (255 & t6[6]) << 16 | (255 & t6[7]) << 24, f4 = 255 & t6[8] | (255 & t6[9]) << 8 | (255 & t6[10]) << 16 | (255 & t6[11]) << 24, d4 = 255 & t6[12] | (255 & t6[13]) << 8 | (255 & t6[14]) << 16 | (255 & t6[15]) << 24, g4 = 255 & n4[8] | (255 & n4[9]) << 8 | (255 & n4[10]) << 16 | (255 & n4[11]) << 24, y4 = 255 & r5[16] | (255 & r5[17]) << 8 | (255 & r5[18]) << 16 | (255 & r5[19]) << 24, m4 = 255 & r5[20] | (255 & r5[21]) << 8 | (255 & r5[22]) << 16 | (255 & r5[23]) << 24, b3 = 255 & r5[24] | (255 & r5[25]) << 8 | (255 & r5[26]) << 16 | (255 & r5[27]) << 24, A5 = 255 & r5[28] | (255 & r5[29]) << 8 | (255 & r5[30]) << 16 | (255 & r5[31]) << 24, w5 = 255 & n4[12] | (255 & n4[13]) << 8 | (255 & n4[14]) << 16 | (255 & n4[15]) << 24, v4 = s4, x4 = i4, S3 = a4, E5 = c4, T5 = u4, _5 = l4, B3 = h4, U3 = p4, k4 = f4, I4 = d4, C4 = g4, R3 = y4, O3 = m4, D4 = b3, N4 = A5, P4 = w5, L4 = 0; L4 < 20; L4 += 2)
                  v4 ^= (o4 = (O3 ^= (o4 = (k4 ^= (o4 = (T5 ^= (o4 = v4 + O3 | 0) << 7 | o4 >>> 25) + v4 | 0) << 9 | o4 >>> 23) + T5 | 0) << 13 | o4 >>> 19) + k4 | 0) << 18 | o4 >>> 14, _5 ^= (o4 = (x4 ^= (o4 = (D4 ^= (o4 = (I4 ^= (o4 = _5 + x4 | 0) << 7 | o4 >>> 25) + _5 | 0) << 9 | o4 >>> 23) + I4 | 0) << 13 | o4 >>> 19) + D4 | 0) << 18 | o4 >>> 14, C4 ^= (o4 = (B3 ^= (o4 = (S3 ^= (o4 = (N4 ^= (o4 = C4 + B3 | 0) << 7 | o4 >>> 25) + C4 | 0) << 9 | o4 >>> 23) + N4 | 0) << 13 | o4 >>> 19) + S3 | 0) << 18 | o4 >>> 14, P4 ^= (o4 = (R3 ^= (o4 = (U3 ^= (o4 = (E5 ^= (o4 = P4 + R3 | 0) << 7 | o4 >>> 25) + P4 | 0) << 9 | o4 >>> 23) + E5 | 0) << 13 | o4 >>> 19) + U3 | 0) << 18 | o4 >>> 14, v4 ^= (o4 = (E5 ^= (o4 = (S3 ^= (o4 = (x4 ^= (o4 = v4 + E5 | 0) << 7 | o4 >>> 25) + v4 | 0) << 9 | o4 >>> 23) + x4 | 0) << 13 | o4 >>> 19) + S3 | 0) << 18 | o4 >>> 14, _5 ^= (o4 = (T5 ^= (o4 = (U3 ^= (o4 = (B3 ^= (o4 = _5 + T5 | 0) << 7 | o4 >>> 25) + _5 | 0) << 9 | o4 >>> 23) + B3 | 0) << 13 | o4 >>> 19) + U3 | 0) << 18 | o4 >>> 14, C4 ^= (o4 = (I4 ^= (o4 = (k4 ^= (o4 = (R3 ^= (o4 = C4 + I4 | 0) << 7 | o4 >>> 25) + C4 | 0) << 9 | o4 >>> 23) + R3 | 0) << 13 | o4 >>> 19) + k4 | 0) << 18 | o4 >>> 14, P4 ^= (o4 = (N4 ^= (o4 = (D4 ^= (o4 = (O3 ^= (o4 = P4 + N4 | 0) << 7 | o4 >>> 25) + P4 | 0) << 9 | o4 >>> 23) + O3 | 0) << 13 | o4 >>> 19) + D4 | 0) << 18 | o4 >>> 14;
                v4 = v4 + s4 | 0, x4 = x4 + i4 | 0, S3 = S3 + a4 | 0, E5 = E5 + c4 | 0, T5 = T5 + u4 | 0, _5 = _5 + l4 | 0, B3 = B3 + h4 | 0, U3 = U3 + p4 | 0, k4 = k4 + f4 | 0, I4 = I4 + d4 | 0, C4 = C4 + g4 | 0, R3 = R3 + y4 | 0, O3 = O3 + m4 | 0, D4 = D4 + b3 | 0, N4 = N4 + A5 | 0, P4 = P4 + w5 | 0, e6[0] = v4 >>> 0 & 255, e6[1] = v4 >>> 8 & 255, e6[2] = v4 >>> 16 & 255, e6[3] = v4 >>> 24 & 255, e6[4] = x4 >>> 0 & 255, e6[5] = x4 >>> 8 & 255, e6[6] = x4 >>> 16 & 255, e6[7] = x4 >>> 24 & 255, e6[8] = S3 >>> 0 & 255, e6[9] = S3 >>> 8 & 255, e6[10] = S3 >>> 16 & 255, e6[11] = S3 >>> 24 & 255, e6[12] = E5 >>> 0 & 255, e6[13] = E5 >>> 8 & 255, e6[14] = E5 >>> 16 & 255, e6[15] = E5 >>> 24 & 255, e6[16] = T5 >>> 0 & 255, e6[17] = T5 >>> 8 & 255, e6[18] = T5 >>> 16 & 255, e6[19] = T5 >>> 24 & 255, e6[20] = _5 >>> 0 & 255, e6[21] = _5 >>> 8 & 255, e6[22] = _5 >>> 16 & 255, e6[23] = _5 >>> 24 & 255, e6[24] = B3 >>> 0 & 255, e6[25] = B3 >>> 8 & 255, e6[26] = B3 >>> 16 & 255, e6[27] = B3 >>> 24 & 255, e6[28] = U3 >>> 0 & 255, e6[29] = U3 >>> 8 & 255, e6[30] = U3 >>> 16 & 255, e6[31] = U3 >>> 24 & 255, e6[32] = k4 >>> 0 & 255, e6[33] = k4 >>> 8 & 255, e6[34] = k4 >>> 16 & 255, e6[35] = k4 >>> 24 & 255, e6[36] = I4 >>> 0 & 255, e6[37] = I4 >>> 8 & 255, e6[38] = I4 >>> 16 & 255, e6[39] = I4 >>> 24 & 255, e6[40] = C4 >>> 0 & 255, e6[41] = C4 >>> 8 & 255, e6[42] = C4 >>> 16 & 255, e6[43] = C4 >>> 24 & 255, e6[44] = R3 >>> 0 & 255, e6[45] = R3 >>> 8 & 255, e6[46] = R3 >>> 16 & 255, e6[47] = R3 >>> 24 & 255, e6[48] = O3 >>> 0 & 255, e6[49] = O3 >>> 8 & 255, e6[50] = O3 >>> 16 & 255, e6[51] = O3 >>> 24 & 255, e6[52] = D4 >>> 0 & 255, e6[53] = D4 >>> 8 & 255, e6[54] = D4 >>> 16 & 255, e6[55] = D4 >>> 24 & 255, e6[56] = N4 >>> 0 & 255, e6[57] = N4 >>> 8 & 255, e6[58] = N4 >>> 16 & 255, e6[59] = N4 >>> 24 & 255, e6[60] = P4 >>> 0 & 255, e6[61] = P4 >>> 8 & 255, e6[62] = P4 >>> 16 & 255, e6[63] = P4 >>> 24 & 255;
              }(e5, t5, r4, n3);
            }
            function b2(e5, t5, r4, n3) {
              !function(e6, t6, r5, n4) {
                for (var o4, s4 = 255 & n4[0] | (255 & n4[1]) << 8 | (255 & n4[2]) << 16 | (255 & n4[3]) << 24, i4 = 255 & r5[0] | (255 & r5[1]) << 8 | (255 & r5[2]) << 16 | (255 & r5[3]) << 24, a4 = 255 & r5[4] | (255 & r5[5]) << 8 | (255 & r5[6]) << 16 | (255 & r5[7]) << 24, c4 = 255 & r5[8] | (255 & r5[9]) << 8 | (255 & r5[10]) << 16 | (255 & r5[11]) << 24, u4 = 255 & r5[12] | (255 & r5[13]) << 8 | (255 & r5[14]) << 16 | (255 & r5[15]) << 24, l4 = 255 & n4[4] | (255 & n4[5]) << 8 | (255 & n4[6]) << 16 | (255 & n4[7]) << 24, h4 = 255 & t6[0] | (255 & t6[1]) << 8 | (255 & t6[2]) << 16 | (255 & t6[3]) << 24, p4 = 255 & t6[4] | (255 & t6[5]) << 8 | (255 & t6[6]) << 16 | (255 & t6[7]) << 24, f4 = 255 & t6[8] | (255 & t6[9]) << 8 | (255 & t6[10]) << 16 | (255 & t6[11]) << 24, d4 = 255 & t6[12] | (255 & t6[13]) << 8 | (255 & t6[14]) << 16 | (255 & t6[15]) << 24, g4 = 255 & n4[8] | (255 & n4[9]) << 8 | (255 & n4[10]) << 16 | (255 & n4[11]) << 24, y4 = 255 & r5[16] | (255 & r5[17]) << 8 | (255 & r5[18]) << 16 | (255 & r5[19]) << 24, m4 = 255 & r5[20] | (255 & r5[21]) << 8 | (255 & r5[22]) << 16 | (255 & r5[23]) << 24, b3 = 255 & r5[24] | (255 & r5[25]) << 8 | (255 & r5[26]) << 16 | (255 & r5[27]) << 24, A5 = 255 & r5[28] | (255 & r5[29]) << 8 | (255 & r5[30]) << 16 | (255 & r5[31]) << 24, w5 = 255 & n4[12] | (255 & n4[13]) << 8 | (255 & n4[14]) << 16 | (255 & n4[15]) << 24, v4 = 0; v4 < 20; v4 += 2)
                  s4 ^= (o4 = (m4 ^= (o4 = (f4 ^= (o4 = (u4 ^= (o4 = s4 + m4 | 0) << 7 | o4 >>> 25) + s4 | 0) << 9 | o4 >>> 23) + u4 | 0) << 13 | o4 >>> 19) + f4 | 0) << 18 | o4 >>> 14, l4 ^= (o4 = (i4 ^= (o4 = (b3 ^= (o4 = (d4 ^= (o4 = l4 + i4 | 0) << 7 | o4 >>> 25) + l4 | 0) << 9 | o4 >>> 23) + d4 | 0) << 13 | o4 >>> 19) + b3 | 0) << 18 | o4 >>> 14, g4 ^= (o4 = (h4 ^= (o4 = (a4 ^= (o4 = (A5 ^= (o4 = g4 + h4 | 0) << 7 | o4 >>> 25) + g4 | 0) << 9 | o4 >>> 23) + A5 | 0) << 13 | o4 >>> 19) + a4 | 0) << 18 | o4 >>> 14, w5 ^= (o4 = (y4 ^= (o4 = (p4 ^= (o4 = (c4 ^= (o4 = w5 + y4 | 0) << 7 | o4 >>> 25) + w5 | 0) << 9 | o4 >>> 23) + c4 | 0) << 13 | o4 >>> 19) + p4 | 0) << 18 | o4 >>> 14, s4 ^= (o4 = (c4 ^= (o4 = (a4 ^= (o4 = (i4 ^= (o4 = s4 + c4 | 0) << 7 | o4 >>> 25) + s4 | 0) << 9 | o4 >>> 23) + i4 | 0) << 13 | o4 >>> 19) + a4 | 0) << 18 | o4 >>> 14, l4 ^= (o4 = (u4 ^= (o4 = (p4 ^= (o4 = (h4 ^= (o4 = l4 + u4 | 0) << 7 | o4 >>> 25) + l4 | 0) << 9 | o4 >>> 23) + h4 | 0) << 13 | o4 >>> 19) + p4 | 0) << 18 | o4 >>> 14, g4 ^= (o4 = (d4 ^= (o4 = (f4 ^= (o4 = (y4 ^= (o4 = g4 + d4 | 0) << 7 | o4 >>> 25) + g4 | 0) << 9 | o4 >>> 23) + y4 | 0) << 13 | o4 >>> 19) + f4 | 0) << 18 | o4 >>> 14, w5 ^= (o4 = (A5 ^= (o4 = (b3 ^= (o4 = (m4 ^= (o4 = w5 + A5 | 0) << 7 | o4 >>> 25) + w5 | 0) << 9 | o4 >>> 23) + m4 | 0) << 13 | o4 >>> 19) + b3 | 0) << 18 | o4 >>> 14;
                e6[0] = s4 >>> 0 & 255, e6[1] = s4 >>> 8 & 255, e6[2] = s4 >>> 16 & 255, e6[3] = s4 >>> 24 & 255, e6[4] = l4 >>> 0 & 255, e6[5] = l4 >>> 8 & 255, e6[6] = l4 >>> 16 & 255, e6[7] = l4 >>> 24 & 255, e6[8] = g4 >>> 0 & 255, e6[9] = g4 >>> 8 & 255, e6[10] = g4 >>> 16 & 255, e6[11] = g4 >>> 24 & 255, e6[12] = w5 >>> 0 & 255, e6[13] = w5 >>> 8 & 255, e6[14] = w5 >>> 16 & 255, e6[15] = w5 >>> 24 & 255, e6[16] = h4 >>> 0 & 255, e6[17] = h4 >>> 8 & 255, e6[18] = h4 >>> 16 & 255, e6[19] = h4 >>> 24 & 255, e6[20] = p4 >>> 0 & 255, e6[21] = p4 >>> 8 & 255, e6[22] = p4 >>> 16 & 255, e6[23] = p4 >>> 24 & 255, e6[24] = f4 >>> 0 & 255, e6[25] = f4 >>> 8 & 255, e6[26] = f4 >>> 16 & 255, e6[27] = f4 >>> 24 & 255, e6[28] = d4 >>> 0 & 255, e6[29] = d4 >>> 8 & 255, e6[30] = d4 >>> 16 & 255, e6[31] = d4 >>> 24 & 255;
              }(e5, t5, r4, n3);
            }
            var A4 = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            function w4(e5, t5, r4, n3, o4, s4, i4) {
              var a4, c4, u4 = new Uint8Array(16), l4 = new Uint8Array(64);
              for (c4 = 0; c4 < 16; c4++)
                u4[c4] = 0;
              for (c4 = 0; c4 < 8; c4++)
                u4[c4] = s4[c4];
              for (; o4 >= 64; ) {
                for (m3(l4, u4, i4, A4), c4 = 0; c4 < 64; c4++)
                  e5[t5 + c4] = r4[n3 + c4] ^ l4[c4];
                for (a4 = 1, c4 = 8; c4 < 16; c4++)
                  a4 = a4 + (255 & u4[c4]) | 0, u4[c4] = 255 & a4, a4 >>>= 8;
                o4 -= 64, t5 += 64, n3 += 64;
              }
              if (o4 > 0)
                for (m3(l4, u4, i4, A4), c4 = 0; c4 < o4; c4++)
                  e5[t5 + c4] = r4[n3 + c4] ^ l4[c4];
              return 0;
            }
            function v3(e5, t5, r4, n3, o4) {
              var s4, i4, a4 = new Uint8Array(16), c4 = new Uint8Array(64);
              for (i4 = 0; i4 < 16; i4++)
                a4[i4] = 0;
              for (i4 = 0; i4 < 8; i4++)
                a4[i4] = n3[i4];
              for (; r4 >= 64; ) {
                for (m3(c4, a4, o4, A4), i4 = 0; i4 < 64; i4++)
                  e5[t5 + i4] = c4[i4];
                for (s4 = 1, i4 = 8; i4 < 16; i4++)
                  s4 = s4 + (255 & a4[i4]) | 0, a4[i4] = 255 & s4, s4 >>>= 8;
                r4 -= 64, t5 += 64;
              }
              if (r4 > 0)
                for (m3(c4, a4, o4, A4), i4 = 0; i4 < r4; i4++)
                  e5[t5 + i4] = c4[i4];
              return 0;
            }
            function x3(e5, t5, r4, n3, o4) {
              var s4 = new Uint8Array(32);
              b2(s4, n3, o4, A4);
              for (var i4 = new Uint8Array(8), a4 = 0; a4 < 8; a4++)
                i4[a4] = n3[a4 + 16];
              return v3(e5, t5, r4, i4, s4);
            }
            function S2(e5, t5, r4, n3, o4, s4, i4) {
              var a4 = new Uint8Array(32);
              b2(a4, s4, i4, A4);
              for (var c4 = new Uint8Array(8), u4 = 0; u4 < 8; u4++)
                c4[u4] = s4[u4 + 16];
              return w4(e5, t5, r4, n3, o4, c4, a4);
            }
            var E4 = function(e5) {
              var t5, r4, n3, o4, s4, i4, a4, c4;
              this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0, t5 = 255 & e5[0] | (255 & e5[1]) << 8, this.r[0] = 8191 & t5, r4 = 255 & e5[2] | (255 & e5[3]) << 8, this.r[1] = 8191 & (t5 >>> 13 | r4 << 3), n3 = 255 & e5[4] | (255 & e5[5]) << 8, this.r[2] = 7939 & (r4 >>> 10 | n3 << 6), o4 = 255 & e5[6] | (255 & e5[7]) << 8, this.r[3] = 8191 & (n3 >>> 7 | o4 << 9), s4 = 255 & e5[8] | (255 & e5[9]) << 8, this.r[4] = 255 & (o4 >>> 4 | s4 << 12), this.r[5] = s4 >>> 1 & 8190, i4 = 255 & e5[10] | (255 & e5[11]) << 8, this.r[6] = 8191 & (s4 >>> 14 | i4 << 2), a4 = 255 & e5[12] | (255 & e5[13]) << 8, this.r[7] = 8065 & (i4 >>> 11 | a4 << 5), c4 = 255 & e5[14] | (255 & e5[15]) << 8, this.r[8] = 8191 & (a4 >>> 8 | c4 << 8), this.r[9] = c4 >>> 5 & 127, this.pad[0] = 255 & e5[16] | (255 & e5[17]) << 8, this.pad[1] = 255 & e5[18] | (255 & e5[19]) << 8, this.pad[2] = 255 & e5[20] | (255 & e5[21]) << 8, this.pad[3] = 255 & e5[22] | (255 & e5[23]) << 8, this.pad[4] = 255 & e5[24] | (255 & e5[25]) << 8, this.pad[5] = 255 & e5[26] | (255 & e5[27]) << 8, this.pad[6] = 255 & e5[28] | (255 & e5[29]) << 8, this.pad[7] = 255 & e5[30] | (255 & e5[31]) << 8;
            };
            function T4(e5, t5, r4, n3, o4, s4) {
              var i4 = new E4(s4);
              return i4.update(r4, n3, o4), i4.finish(e5, t5), 0;
            }
            function _4(e5, t5, r4, n3, o4, s4) {
              var i4 = new Uint8Array(16);
              return T4(i4, 0, r4, n3, o4, s4), g3(e5, t5, i4, 0);
            }
            function B2(e5, t5, r4, n3, o4) {
              var s4;
              if (r4 < 32)
                return -1;
              for (S2(e5, 0, t5, 0, r4, n3, o4), T4(e5, 16, e5, 32, r4 - 32, e5), s4 = 0; s4 < 16; s4++)
                e5[s4] = 0;
              return 0;
            }
            function U2(e5, t5, r4, n3, o4) {
              var s4, i4 = new Uint8Array(32);
              if (r4 < 32)
                return -1;
              if (x3(i4, 0, 32, n3, o4), _4(t5, 16, t5, 32, r4 - 32, i4) !== 0)
                return -1;
              for (S2(e5, 0, t5, 0, r4, n3, o4), s4 = 0; s4 < 32; s4++)
                e5[s4] = 0;
              return 0;
            }
            function k3(e5, t5) {
              var r4;
              for (r4 = 0; r4 < 16; r4++)
                e5[r4] = 0 | t5[r4];
            }
            function I3(e5) {
              var t5, r4, n3 = 1;
              for (t5 = 0; t5 < 16; t5++)
                r4 = e5[t5] + n3 + 65535, n3 = Math.floor(r4 / 65536), e5[t5] = r4 - 65536 * n3;
              e5[0] += n3 - 1 + 37 * (n3 - 1);
            }
            function C3(e5, t5, r4) {
              for (var n3, o4 = ~(r4 - 1), s4 = 0; s4 < 16; s4++)
                n3 = o4 & (e5[s4] ^ t5[s4]), e5[s4] ^= n3, t5[s4] ^= n3;
            }
            function R2(e5, r4) {
              var n3, o4, s4, i4 = t4(), a4 = t4();
              for (n3 = 0; n3 < 16; n3++)
                a4[n3] = r4[n3];
              for (I3(a4), I3(a4), I3(a4), o4 = 0; o4 < 2; o4++) {
                for (i4[0] = a4[0] - 65517, n3 = 1; n3 < 15; n3++)
                  i4[n3] = a4[n3] - 65535 - (i4[n3 - 1] >> 16 & 1), i4[n3 - 1] &= 65535;
                i4[15] = a4[15] - 32767 - (i4[14] >> 16 & 1), s4 = i4[15] >> 16 & 1, i4[14] &= 65535, C3(a4, i4, 1 - s4);
              }
              for (n3 = 0; n3 < 16; n3++)
                e5[2 * n3] = 255 & a4[n3], e5[2 * n3 + 1] = a4[n3] >> 8;
            }
            function O2(e5, t5) {
              var r4 = new Uint8Array(32), n3 = new Uint8Array(32);
              return R2(r4, e5), R2(n3, t5), y3(r4, 0, n3, 0);
            }
            function D3(e5) {
              var t5 = new Uint8Array(32);
              return R2(t5, e5), 1 & t5[0];
            }
            function N3(e5, t5) {
              var r4;
              for (r4 = 0; r4 < 16; r4++)
                e5[r4] = t5[2 * r4] + (t5[2 * r4 + 1] << 8);
              e5[15] &= 32767;
            }
            function P3(e5, t5, r4) {
              for (var n3 = 0; n3 < 16; n3++)
                e5[n3] = t5[n3] + r4[n3];
            }
            function L3(e5, t5, r4) {
              for (var n3 = 0; n3 < 16; n3++)
                e5[n3] = t5[n3] - r4[n3];
            }
            function F3(e5, t5, r4) {
              var n3, o4, s4 = 0, i4 = 0, a4 = 0, c4 = 0, u4 = 0, l4 = 0, h4 = 0, p4 = 0, f4 = 0, d4 = 0, g4 = 0, y4 = 0, m4 = 0, b3 = 0, A5 = 0, w5 = 0, v4 = 0, x4 = 0, S3 = 0, E5 = 0, T5 = 0, _5 = 0, B3 = 0, U3 = 0, k4 = 0, I4 = 0, C4 = 0, R3 = 0, O3 = 0, D4 = 0, N4 = 0, P4 = r4[0], L4 = r4[1], F4 = r4[2], z4 = r4[3], j4 = r4[4], M4 = r4[5], H4 = r4[6], G3 = r4[7], K4 = r4[8], q4 = r4[9], V3 = r4[10], $4 = r4[11], W3 = r4[12], X3 = r4[13], Y3 = r4[14], J3 = r4[15];
              s4 += (n3 = t5[0]) * P4, i4 += n3 * L4, a4 += n3 * F4, c4 += n3 * z4, u4 += n3 * j4, l4 += n3 * M4, h4 += n3 * H4, p4 += n3 * G3, f4 += n3 * K4, d4 += n3 * q4, g4 += n3 * V3, y4 += n3 * $4, m4 += n3 * W3, b3 += n3 * X3, A5 += n3 * Y3, w5 += n3 * J3, i4 += (n3 = t5[1]) * P4, a4 += n3 * L4, c4 += n3 * F4, u4 += n3 * z4, l4 += n3 * j4, h4 += n3 * M4, p4 += n3 * H4, f4 += n3 * G3, d4 += n3 * K4, g4 += n3 * q4, y4 += n3 * V3, m4 += n3 * $4, b3 += n3 * W3, A5 += n3 * X3, w5 += n3 * Y3, v4 += n3 * J3, a4 += (n3 = t5[2]) * P4, c4 += n3 * L4, u4 += n3 * F4, l4 += n3 * z4, h4 += n3 * j4, p4 += n3 * M4, f4 += n3 * H4, d4 += n3 * G3, g4 += n3 * K4, y4 += n3 * q4, m4 += n3 * V3, b3 += n3 * $4, A5 += n3 * W3, w5 += n3 * X3, v4 += n3 * Y3, x4 += n3 * J3, c4 += (n3 = t5[3]) * P4, u4 += n3 * L4, l4 += n3 * F4, h4 += n3 * z4, p4 += n3 * j4, f4 += n3 * M4, d4 += n3 * H4, g4 += n3 * G3, y4 += n3 * K4, m4 += n3 * q4, b3 += n3 * V3, A5 += n3 * $4, w5 += n3 * W3, v4 += n3 * X3, x4 += n3 * Y3, S3 += n3 * J3, u4 += (n3 = t5[4]) * P4, l4 += n3 * L4, h4 += n3 * F4, p4 += n3 * z4, f4 += n3 * j4, d4 += n3 * M4, g4 += n3 * H4, y4 += n3 * G3, m4 += n3 * K4, b3 += n3 * q4, A5 += n3 * V3, w5 += n3 * $4, v4 += n3 * W3, x4 += n3 * X3, S3 += n3 * Y3, E5 += n3 * J3, l4 += (n3 = t5[5]) * P4, h4 += n3 * L4, p4 += n3 * F4, f4 += n3 * z4, d4 += n3 * j4, g4 += n3 * M4, y4 += n3 * H4, m4 += n3 * G3, b3 += n3 * K4, A5 += n3 * q4, w5 += n3 * V3, v4 += n3 * $4, x4 += n3 * W3, S3 += n3 * X3, E5 += n3 * Y3, T5 += n3 * J3, h4 += (n3 = t5[6]) * P4, p4 += n3 * L4, f4 += n3 * F4, d4 += n3 * z4, g4 += n3 * j4, y4 += n3 * M4, m4 += n3 * H4, b3 += n3 * G3, A5 += n3 * K4, w5 += n3 * q4, v4 += n3 * V3, x4 += n3 * $4, S3 += n3 * W3, E5 += n3 * X3, T5 += n3 * Y3, _5 += n3 * J3, p4 += (n3 = t5[7]) * P4, f4 += n3 * L4, d4 += n3 * F4, g4 += n3 * z4, y4 += n3 * j4, m4 += n3 * M4, b3 += n3 * H4, A5 += n3 * G3, w5 += n3 * K4, v4 += n3 * q4, x4 += n3 * V3, S3 += n3 * $4, E5 += n3 * W3, T5 += n3 * X3, _5 += n3 * Y3, B3 += n3 * J3, f4 += (n3 = t5[8]) * P4, d4 += n3 * L4, g4 += n3 * F4, y4 += n3 * z4, m4 += n3 * j4, b3 += n3 * M4, A5 += n3 * H4, w5 += n3 * G3, v4 += n3 * K4, x4 += n3 * q4, S3 += n3 * V3, E5 += n3 * $4, T5 += n3 * W3, _5 += n3 * X3, B3 += n3 * Y3, U3 += n3 * J3, d4 += (n3 = t5[9]) * P4, g4 += n3 * L4, y4 += n3 * F4, m4 += n3 * z4, b3 += n3 * j4, A5 += n3 * M4, w5 += n3 * H4, v4 += n3 * G3, x4 += n3 * K4, S3 += n3 * q4, E5 += n3 * V3, T5 += n3 * $4, _5 += n3 * W3, B3 += n3 * X3, U3 += n3 * Y3, k4 += n3 * J3, g4 += (n3 = t5[10]) * P4, y4 += n3 * L4, m4 += n3 * F4, b3 += n3 * z4, A5 += n3 * j4, w5 += n3 * M4, v4 += n3 * H4, x4 += n3 * G3, S3 += n3 * K4, E5 += n3 * q4, T5 += n3 * V3, _5 += n3 * $4, B3 += n3 * W3, U3 += n3 * X3, k4 += n3 * Y3, I4 += n3 * J3, y4 += (n3 = t5[11]) * P4, m4 += n3 * L4, b3 += n3 * F4, A5 += n3 * z4, w5 += n3 * j4, v4 += n3 * M4, x4 += n3 * H4, S3 += n3 * G3, E5 += n3 * K4, T5 += n3 * q4, _5 += n3 * V3, B3 += n3 * $4, U3 += n3 * W3, k4 += n3 * X3, I4 += n3 * Y3, C4 += n3 * J3, m4 += (n3 = t5[12]) * P4, b3 += n3 * L4, A5 += n3 * F4, w5 += n3 * z4, v4 += n3 * j4, x4 += n3 * M4, S3 += n3 * H4, E5 += n3 * G3, T5 += n3 * K4, _5 += n3 * q4, B3 += n3 * V3, U3 += n3 * $4, k4 += n3 * W3, I4 += n3 * X3, C4 += n3 * Y3, R3 += n3 * J3, b3 += (n3 = t5[13]) * P4, A5 += n3 * L4, w5 += n3 * F4, v4 += n3 * z4, x4 += n3 * j4, S3 += n3 * M4, E5 += n3 * H4, T5 += n3 * G3, _5 += n3 * K4, B3 += n3 * q4, U3 += n3 * V3, k4 += n3 * $4, I4 += n3 * W3, C4 += n3 * X3, R3 += n3 * Y3, O3 += n3 * J3, A5 += (n3 = t5[14]) * P4, w5 += n3 * L4, v4 += n3 * F4, x4 += n3 * z4, S3 += n3 * j4, E5 += n3 * M4, T5 += n3 * H4, _5 += n3 * G3, B3 += n3 * K4, U3 += n3 * q4, k4 += n3 * V3, I4 += n3 * $4, C4 += n3 * W3, R3 += n3 * X3, O3 += n3 * Y3, D4 += n3 * J3, w5 += (n3 = t5[15]) * P4, i4 += 38 * (x4 += n3 * F4), a4 += 38 * (S3 += n3 * z4), c4 += 38 * (E5 += n3 * j4), u4 += 38 * (T5 += n3 * M4), l4 += 38 * (_5 += n3 * H4), h4 += 38 * (B3 += n3 * G3), p4 += 38 * (U3 += n3 * K4), f4 += 38 * (k4 += n3 * q4), d4 += 38 * (I4 += n3 * V3), g4 += 38 * (C4 += n3 * $4), y4 += 38 * (R3 += n3 * W3), m4 += 38 * (O3 += n3 * X3), b3 += 38 * (D4 += n3 * Y3), A5 += 38 * (N4 += n3 * J3), s4 = (n3 = (s4 += 38 * (v4 += n3 * L4)) + (o4 = 1) + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), i4 = (n3 = i4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), a4 = (n3 = a4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), c4 = (n3 = c4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), u4 = (n3 = u4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), l4 = (n3 = l4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), h4 = (n3 = h4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), p4 = (n3 = p4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), f4 = (n3 = f4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), d4 = (n3 = d4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), g4 = (n3 = g4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), y4 = (n3 = y4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), m4 = (n3 = m4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), b3 = (n3 = b3 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), A5 = (n3 = A5 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), w5 = (n3 = w5 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), s4 = (n3 = (s4 += o4 - 1 + 37 * (o4 - 1)) + (o4 = 1) + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), i4 = (n3 = i4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), a4 = (n3 = a4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), c4 = (n3 = c4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), u4 = (n3 = u4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), l4 = (n3 = l4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), h4 = (n3 = h4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), p4 = (n3 = p4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), f4 = (n3 = f4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), d4 = (n3 = d4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), g4 = (n3 = g4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), y4 = (n3 = y4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), m4 = (n3 = m4 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), b3 = (n3 = b3 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), A5 = (n3 = A5 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), w5 = (n3 = w5 + o4 + 65535) - 65536 * (o4 = Math.floor(n3 / 65536)), s4 += o4 - 1 + 37 * (o4 - 1), e5[0] = s4, e5[1] = i4, e5[2] = a4, e5[3] = c4, e5[4] = u4, e5[5] = l4, e5[6] = h4, e5[7] = p4, e5[8] = f4, e5[9] = d4, e5[10] = g4, e5[11] = y4, e5[12] = m4, e5[13] = b3, e5[14] = A5, e5[15] = w5;
            }
            function z3(e5, t5) {
              F3(e5, t5, t5);
            }
            function j3(e5, r4) {
              var n3, o4 = t4();
              for (n3 = 0; n3 < 16; n3++)
                o4[n3] = r4[n3];
              for (n3 = 253; n3 >= 0; n3--)
                z3(o4, o4), n3 !== 2 && n3 !== 4 && F3(o4, o4, r4);
              for (n3 = 0; n3 < 16; n3++)
                e5[n3] = o4[n3];
            }
            function M3(e5, r4) {
              var n3, o4 = t4();
              for (n3 = 0; n3 < 16; n3++)
                o4[n3] = r4[n3];
              for (n3 = 250; n3 >= 0; n3--)
                z3(o4, o4), n3 !== 1 && F3(o4, o4, r4);
              for (n3 = 0; n3 < 16; n3++)
                e5[n3] = o4[n3];
            }
            function H3(e5, r4, n3) {
              var o4, s4, i4 = new Uint8Array(32), c4 = new Float64Array(80), u4 = t4(), l4 = t4(), h4 = t4(), p4 = t4(), f4 = t4(), d4 = t4();
              for (s4 = 0; s4 < 31; s4++)
                i4[s4] = r4[s4];
              for (i4[31] = 127 & r4[31] | 64, i4[0] &= 248, N3(c4, n3), s4 = 0; s4 < 16; s4++)
                l4[s4] = c4[s4], p4[s4] = u4[s4] = h4[s4] = 0;
              for (u4[0] = p4[0] = 1, s4 = 254; s4 >= 0; --s4)
                C3(u4, l4, o4 = i4[s4 >>> 3] >>> (7 & s4) & 1), C3(h4, p4, o4), P3(f4, u4, h4), L3(u4, u4, h4), P3(h4, l4, p4), L3(l4, l4, p4), z3(p4, f4), z3(d4, u4), F3(u4, h4, u4), F3(h4, l4, f4), P3(f4, u4, h4), L3(u4, u4, h4), z3(l4, u4), L3(h4, p4, d4), F3(u4, h4, a3), P3(u4, u4, p4), F3(h4, h4, u4), F3(u4, p4, d4), F3(p4, l4, c4), z3(l4, f4), C3(u4, l4, o4), C3(h4, p4, o4);
              for (s4 = 0; s4 < 16; s4++)
                c4[s4 + 16] = u4[s4], c4[s4 + 32] = h4[s4], c4[s4 + 48] = l4[s4], c4[s4 + 64] = p4[s4];
              var g4 = c4.subarray(32), y4 = c4.subarray(16);
              return j3(g4, g4), F3(y4, y4, g4), R2(e5, y4), 0;
            }
            function G2(e5, t5) {
              return H3(e5, t5, o3);
            }
            function K3(e5, t5) {
              return r3(t5, 32), G2(e5, t5);
            }
            function q3(e5, t5, r4) {
              var o4 = new Uint8Array(32);
              return H3(o4, r4, t5), b2(e5, n2, o4, A4);
            }
            E4.prototype.blocks = function(e5, t5, r4) {
              for (var n3, o4, s4, i4, a4, c4, u4, l4, h4, p4, f4, d4, g4, y4, m4, b3, A5, w5, v4, x4 = this.fin ? 0 : 2048, S3 = this.h[0], E5 = this.h[1], T5 = this.h[2], _5 = this.h[3], B3 = this.h[4], U3 = this.h[5], k4 = this.h[6], I4 = this.h[7], C4 = this.h[8], R3 = this.h[9], O3 = this.r[0], D4 = this.r[1], N4 = this.r[2], P4 = this.r[3], L4 = this.r[4], F4 = this.r[5], z4 = this.r[6], j4 = this.r[7], M4 = this.r[8], H4 = this.r[9]; r4 >= 16; )
                p4 = h4 = 0, p4 += (S3 += 8191 & (n3 = 255 & e5[t5 + 0] | (255 & e5[t5 + 1]) << 8)) * O3, p4 += (E5 += 8191 & (n3 >>> 13 | (o4 = 255 & e5[t5 + 2] | (255 & e5[t5 + 3]) << 8) << 3)) * (5 * H4), p4 += (T5 += 8191 & (o4 >>> 10 | (s4 = 255 & e5[t5 + 4] | (255 & e5[t5 + 5]) << 8) << 6)) * (5 * M4), p4 += (_5 += 8191 & (s4 >>> 7 | (i4 = 255 & e5[t5 + 6] | (255 & e5[t5 + 7]) << 8) << 9)) * (5 * j4), h4 = (p4 += (B3 += 8191 & (i4 >>> 4 | (a4 = 255 & e5[t5 + 8] | (255 & e5[t5 + 9]) << 8) << 12)) * (5 * z4)) >>> 13, p4 &= 8191, p4 += (U3 += a4 >>> 1 & 8191) * (5 * F4), p4 += (k4 += 8191 & (a4 >>> 14 | (c4 = 255 & e5[t5 + 10] | (255 & e5[t5 + 11]) << 8) << 2)) * (5 * L4), p4 += (I4 += 8191 & (c4 >>> 11 | (u4 = 255 & e5[t5 + 12] | (255 & e5[t5 + 13]) << 8) << 5)) * (5 * P4), p4 += (C4 += 8191 & (u4 >>> 8 | (l4 = 255 & e5[t5 + 14] | (255 & e5[t5 + 15]) << 8) << 8)) * (5 * N4), f4 = h4 += (p4 += (R3 += l4 >>> 5 | x4) * (5 * D4)) >>> 13, f4 += S3 * D4, f4 += E5 * O3, f4 += T5 * (5 * H4), f4 += _5 * (5 * M4), h4 = (f4 += B3 * (5 * j4)) >>> 13, f4 &= 8191, f4 += U3 * (5 * z4), f4 += k4 * (5 * F4), f4 += I4 * (5 * L4), f4 += C4 * (5 * P4), h4 += (f4 += R3 * (5 * N4)) >>> 13, f4 &= 8191, d4 = h4, d4 += S3 * N4, d4 += E5 * D4, d4 += T5 * O3, d4 += _5 * (5 * H4), h4 = (d4 += B3 * (5 * M4)) >>> 13, d4 &= 8191, d4 += U3 * (5 * j4), d4 += k4 * (5 * z4), d4 += I4 * (5 * F4), d4 += C4 * (5 * L4), g4 = h4 += (d4 += R3 * (5 * P4)) >>> 13, g4 += S3 * P4, g4 += E5 * N4, g4 += T5 * D4, g4 += _5 * O3, h4 = (g4 += B3 * (5 * H4)) >>> 13, g4 &= 8191, g4 += U3 * (5 * M4), g4 += k4 * (5 * j4), g4 += I4 * (5 * z4), g4 += C4 * (5 * F4), y4 = h4 += (g4 += R3 * (5 * L4)) >>> 13, y4 += S3 * L4, y4 += E5 * P4, y4 += T5 * N4, y4 += _5 * D4, h4 = (y4 += B3 * O3) >>> 13, y4 &= 8191, y4 += U3 * (5 * H4), y4 += k4 * (5 * M4), y4 += I4 * (5 * j4), y4 += C4 * (5 * z4), m4 = h4 += (y4 += R3 * (5 * F4)) >>> 13, m4 += S3 * F4, m4 += E5 * L4, m4 += T5 * P4, m4 += _5 * N4, h4 = (m4 += B3 * D4) >>> 13, m4 &= 8191, m4 += U3 * O3, m4 += k4 * (5 * H4), m4 += I4 * (5 * M4), m4 += C4 * (5 * j4), b3 = h4 += (m4 += R3 * (5 * z4)) >>> 13, b3 += S3 * z4, b3 += E5 * F4, b3 += T5 * L4, b3 += _5 * P4, h4 = (b3 += B3 * N4) >>> 13, b3 &= 8191, b3 += U3 * D4, b3 += k4 * O3, b3 += I4 * (5 * H4), b3 += C4 * (5 * M4), A5 = h4 += (b3 += R3 * (5 * j4)) >>> 13, A5 += S3 * j4, A5 += E5 * z4, A5 += T5 * F4, A5 += _5 * L4, h4 = (A5 += B3 * P4) >>> 13, A5 &= 8191, A5 += U3 * N4, A5 += k4 * D4, A5 += I4 * O3, A5 += C4 * (5 * H4), w5 = h4 += (A5 += R3 * (5 * M4)) >>> 13, w5 += S3 * M4, w5 += E5 * j4, w5 += T5 * z4, w5 += _5 * F4, h4 = (w5 += B3 * L4) >>> 13, w5 &= 8191, w5 += U3 * P4, w5 += k4 * N4, w5 += I4 * D4, w5 += C4 * O3, v4 = h4 += (w5 += R3 * (5 * H4)) >>> 13, v4 += S3 * H4, v4 += E5 * M4, v4 += T5 * j4, v4 += _5 * z4, h4 = (v4 += B3 * F4) >>> 13, v4 &= 8191, v4 += U3 * L4, v4 += k4 * P4, v4 += I4 * N4, v4 += C4 * D4, S3 = p4 = 8191 & (h4 = (h4 = ((h4 += (v4 += R3 * O3) >>> 13) << 2) + h4 | 0) + (p4 &= 8191) | 0), E5 = f4 += h4 >>>= 13, T5 = d4 &= 8191, _5 = g4 &= 8191, B3 = y4 &= 8191, U3 = m4 &= 8191, k4 = b3 &= 8191, I4 = A5 &= 8191, C4 = w5 &= 8191, R3 = v4 &= 8191, t5 += 16, r4 -= 16;
              this.h[0] = S3, this.h[1] = E5, this.h[2] = T5, this.h[3] = _5, this.h[4] = B3, this.h[5] = U3, this.h[6] = k4, this.h[7] = I4, this.h[8] = C4, this.h[9] = R3;
            }, E4.prototype.finish = function(e5, t5) {
              var r4, n3, o4, s4, i4 = new Uint16Array(10);
              if (this.leftover) {
                for (s4 = this.leftover, this.buffer[s4++] = 1; s4 < 16; s4++)
                  this.buffer[s4] = 0;
                this.fin = 1, this.blocks(this.buffer, 0, 16);
              }
              for (r4 = this.h[1] >>> 13, this.h[1] &= 8191, s4 = 2; s4 < 10; s4++)
                this.h[s4] += r4, r4 = this.h[s4] >>> 13, this.h[s4] &= 8191;
              for (this.h[0] += 5 * r4, r4 = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += r4, r4 = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += r4, i4[0] = this.h[0] + 5, r4 = i4[0] >>> 13, i4[0] &= 8191, s4 = 1; s4 < 10; s4++)
                i4[s4] = this.h[s4] + r4, r4 = i4[s4] >>> 13, i4[s4] &= 8191;
              for (i4[9] -= 8192, n3 = (1 ^ r4) - 1, s4 = 0; s4 < 10; s4++)
                i4[s4] &= n3;
              for (n3 = ~n3, s4 = 0; s4 < 10; s4++)
                this.h[s4] = this.h[s4] & n3 | i4[s4];
              for (this.h[0] = 65535 & (this.h[0] | this.h[1] << 13), this.h[1] = 65535 & (this.h[1] >>> 3 | this.h[2] << 10), this.h[2] = 65535 & (this.h[2] >>> 6 | this.h[3] << 7), this.h[3] = 65535 & (this.h[3] >>> 9 | this.h[4] << 4), this.h[4] = 65535 & (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14), this.h[5] = 65535 & (this.h[6] >>> 2 | this.h[7] << 11), this.h[6] = 65535 & (this.h[7] >>> 5 | this.h[8] << 8), this.h[7] = 65535 & (this.h[8] >>> 8 | this.h[9] << 5), o4 = this.h[0] + this.pad[0], this.h[0] = 65535 & o4, s4 = 1; s4 < 8; s4++)
                o4 = (this.h[s4] + this.pad[s4] | 0) + (o4 >>> 16) | 0, this.h[s4] = 65535 & o4;
              e5[t5 + 0] = this.h[0] >>> 0 & 255, e5[t5 + 1] = this.h[0] >>> 8 & 255, e5[t5 + 2] = this.h[1] >>> 0 & 255, e5[t5 + 3] = this.h[1] >>> 8 & 255, e5[t5 + 4] = this.h[2] >>> 0 & 255, e5[t5 + 5] = this.h[2] >>> 8 & 255, e5[t5 + 6] = this.h[3] >>> 0 & 255, e5[t5 + 7] = this.h[3] >>> 8 & 255, e5[t5 + 8] = this.h[4] >>> 0 & 255, e5[t5 + 9] = this.h[4] >>> 8 & 255, e5[t5 + 10] = this.h[5] >>> 0 & 255, e5[t5 + 11] = this.h[5] >>> 8 & 255, e5[t5 + 12] = this.h[6] >>> 0 & 255, e5[t5 + 13] = this.h[6] >>> 8 & 255, e5[t5 + 14] = this.h[7] >>> 0 & 255, e5[t5 + 15] = this.h[7] >>> 8 & 255;
            }, E4.prototype.update = function(e5, t5, r4) {
              var n3, o4;
              if (this.leftover) {
                for ((o4 = 16 - this.leftover) > r4 && (o4 = r4), n3 = 0; n3 < o4; n3++)
                  this.buffer[this.leftover + n3] = e5[t5 + n3];
                if (r4 -= o4, t5 += o4, this.leftover += o4, this.leftover < 16)
                  return;
                this.blocks(this.buffer, 0, 16), this.leftover = 0;
              }
              if (r4 >= 16 && (o4 = r4 - r4 % 16, this.blocks(e5, t5, o4), t5 += o4, r4 -= o4), r4) {
                for (n3 = 0; n3 < r4; n3++)
                  this.buffer[this.leftover + n3] = e5[t5 + n3];
                this.leftover += r4;
              }
            };
            var V2 = B2, $3 = U2, W2 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
            function X2(e5, t5, r4, n3) {
              for (var o4, s4, i4, a4, c4, u4, l4, h4, p4, f4, d4, g4, y4, m4, b3, A5, w5, v4, x4, S3, E5, T5, _5, B3, U3, k4, I4 = new Int32Array(16), C4 = new Int32Array(16), R3 = e5[0], O3 = e5[1], D4 = e5[2], N4 = e5[3], P4 = e5[4], L4 = e5[5], F4 = e5[6], z4 = e5[7], j4 = t5[0], M4 = t5[1], H4 = t5[2], G3 = t5[3], K4 = t5[4], q4 = t5[5], V3 = t5[6], $4 = t5[7], X3 = 0; n3 >= 128; ) {
                for (x4 = 0; x4 < 16; x4++)
                  S3 = 8 * x4 + X3, I4[x4] = r4[S3 + 0] << 24 | r4[S3 + 1] << 16 | r4[S3 + 2] << 8 | r4[S3 + 3], C4[x4] = r4[S3 + 4] << 24 | r4[S3 + 5] << 16 | r4[S3 + 6] << 8 | r4[S3 + 7];
                for (x4 = 0; x4 < 80; x4++)
                  if (o4 = R3, s4 = O3, i4 = D4, a4 = N4, c4 = P4, u4 = L4, l4 = F4, p4 = j4, f4 = M4, d4 = H4, g4 = G3, y4 = K4, m4 = q4, b3 = V3, _5 = 65535 & (T5 = $4), B3 = T5 >>> 16, U3 = 65535 & (E5 = z4), k4 = E5 >>> 16, _5 += 65535 & (T5 = (K4 >>> 14 | P4 << 18) ^ (K4 >>> 18 | P4 << 14) ^ (P4 >>> 9 | K4 << 23)), B3 += T5 >>> 16, U3 += 65535 & (E5 = (P4 >>> 14 | K4 << 18) ^ (P4 >>> 18 | K4 << 14) ^ (K4 >>> 9 | P4 << 23)), k4 += E5 >>> 16, _5 += 65535 & (T5 = K4 & q4 ^ ~K4 & V3), B3 += T5 >>> 16, U3 += 65535 & (E5 = P4 & L4 ^ ~P4 & F4), k4 += E5 >>> 16, _5 += 65535 & (T5 = W2[2 * x4 + 1]), B3 += T5 >>> 16, U3 += 65535 & (E5 = W2[2 * x4]), k4 += E5 >>> 16, E5 = I4[x4 % 16], B3 += (T5 = C4[x4 % 16]) >>> 16, U3 += 65535 & E5, k4 += E5 >>> 16, U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16, _5 = 65535 & (T5 = v4 = 65535 & _5 | B3 << 16), B3 = T5 >>> 16, U3 = 65535 & (E5 = w5 = 65535 & U3 | (k4 += U3 >>> 16) << 16), k4 = E5 >>> 16, _5 += 65535 & (T5 = (j4 >>> 28 | R3 << 4) ^ (R3 >>> 2 | j4 << 30) ^ (R3 >>> 7 | j4 << 25)), B3 += T5 >>> 16, U3 += 65535 & (E5 = (R3 >>> 28 | j4 << 4) ^ (j4 >>> 2 | R3 << 30) ^ (j4 >>> 7 | R3 << 25)), k4 += E5 >>> 16, B3 += (T5 = j4 & M4 ^ j4 & H4 ^ M4 & H4) >>> 16, U3 += 65535 & (E5 = R3 & O3 ^ R3 & D4 ^ O3 & D4), k4 += E5 >>> 16, h4 = 65535 & (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) | (k4 += U3 >>> 16) << 16, A5 = 65535 & _5 | B3 << 16, _5 = 65535 & (T5 = g4), B3 = T5 >>> 16, U3 = 65535 & (E5 = a4), k4 = E5 >>> 16, B3 += (T5 = v4) >>> 16, U3 += 65535 & (E5 = w5), k4 += E5 >>> 16, O3 = o4, D4 = s4, N4 = i4, P4 = a4 = 65535 & (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) | (k4 += U3 >>> 16) << 16, L4 = c4, F4 = u4, z4 = l4, R3 = h4, M4 = p4, H4 = f4, G3 = d4, K4 = g4 = 65535 & _5 | B3 << 16, q4 = y4, V3 = m4, $4 = b3, j4 = A5, x4 % 16 == 15)
                    for (S3 = 0; S3 < 16; S3++)
                      E5 = I4[S3], _5 = 65535 & (T5 = C4[S3]), B3 = T5 >>> 16, U3 = 65535 & E5, k4 = E5 >>> 16, E5 = I4[(S3 + 9) % 16], _5 += 65535 & (T5 = C4[(S3 + 9) % 16]), B3 += T5 >>> 16, U3 += 65535 & E5, k4 += E5 >>> 16, w5 = I4[(S3 + 1) % 16], _5 += 65535 & (T5 = ((v4 = C4[(S3 + 1) % 16]) >>> 1 | w5 << 31) ^ (v4 >>> 8 | w5 << 24) ^ (v4 >>> 7 | w5 << 25)), B3 += T5 >>> 16, U3 += 65535 & (E5 = (w5 >>> 1 | v4 << 31) ^ (w5 >>> 8 | v4 << 24) ^ w5 >>> 7), k4 += E5 >>> 16, w5 = I4[(S3 + 14) % 16], B3 += (T5 = ((v4 = C4[(S3 + 14) % 16]) >>> 19 | w5 << 13) ^ (w5 >>> 29 | v4 << 3) ^ (v4 >>> 6 | w5 << 26)) >>> 16, U3 += 65535 & (E5 = (w5 >>> 19 | v4 << 13) ^ (v4 >>> 29 | w5 << 3) ^ w5 >>> 6), k4 += E5 >>> 16, k4 += (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) >>> 16, I4[S3] = 65535 & U3 | k4 << 16, C4[S3] = 65535 & _5 | B3 << 16;
                _5 = 65535 & (T5 = j4), B3 = T5 >>> 16, U3 = 65535 & (E5 = R3), k4 = E5 >>> 16, E5 = e5[0], B3 += (T5 = t5[0]) >>> 16, U3 += 65535 & E5, k4 += E5 >>> 16, k4 += (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) >>> 16, e5[0] = R3 = 65535 & U3 | k4 << 16, t5[0] = j4 = 65535 & _5 | B3 << 16, _5 = 65535 & (T5 = M4), B3 = T5 >>> 16, U3 = 65535 & (E5 = O3), k4 = E5 >>> 16, E5 = e5[1], B3 += (T5 = t5[1]) >>> 16, U3 += 65535 & E5, k4 += E5 >>> 16, k4 += (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) >>> 16, e5[1] = O3 = 65535 & U3 | k4 << 16, t5[1] = M4 = 65535 & _5 | B3 << 16, _5 = 65535 & (T5 = H4), B3 = T5 >>> 16, U3 = 65535 & (E5 = D4), k4 = E5 >>> 16, E5 = e5[2], B3 += (T5 = t5[2]) >>> 16, U3 += 65535 & E5, k4 += E5 >>> 16, k4 += (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) >>> 16, e5[2] = D4 = 65535 & U3 | k4 << 16, t5[2] = H4 = 65535 & _5 | B3 << 16, _5 = 65535 & (T5 = G3), B3 = T5 >>> 16, U3 = 65535 & (E5 = N4), k4 = E5 >>> 16, E5 = e5[3], B3 += (T5 = t5[3]) >>> 16, U3 += 65535 & E5, k4 += E5 >>> 16, k4 += (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) >>> 16, e5[3] = N4 = 65535 & U3 | k4 << 16, t5[3] = G3 = 65535 & _5 | B3 << 16, _5 = 65535 & (T5 = K4), B3 = T5 >>> 16, U3 = 65535 & (E5 = P4), k4 = E5 >>> 16, E5 = e5[4], B3 += (T5 = t5[4]) >>> 16, U3 += 65535 & E5, k4 += E5 >>> 16, k4 += (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) >>> 16, e5[4] = P4 = 65535 & U3 | k4 << 16, t5[4] = K4 = 65535 & _5 | B3 << 16, _5 = 65535 & (T5 = q4), B3 = T5 >>> 16, U3 = 65535 & (E5 = L4), k4 = E5 >>> 16, E5 = e5[5], B3 += (T5 = t5[5]) >>> 16, U3 += 65535 & E5, k4 += E5 >>> 16, k4 += (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) >>> 16, e5[5] = L4 = 65535 & U3 | k4 << 16, t5[5] = q4 = 65535 & _5 | B3 << 16, _5 = 65535 & (T5 = V3), B3 = T5 >>> 16, U3 = 65535 & (E5 = F4), k4 = E5 >>> 16, E5 = e5[6], B3 += (T5 = t5[6]) >>> 16, U3 += 65535 & E5, k4 += E5 >>> 16, k4 += (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) >>> 16, e5[6] = F4 = 65535 & U3 | k4 << 16, t5[6] = V3 = 65535 & _5 | B3 << 16, _5 = 65535 & (T5 = $4), B3 = T5 >>> 16, U3 = 65535 & (E5 = z4), k4 = E5 >>> 16, E5 = e5[7], B3 += (T5 = t5[7]) >>> 16, U3 += 65535 & E5, k4 += E5 >>> 16, k4 += (U3 += (B3 += (_5 += 65535 & T5) >>> 16) >>> 16) >>> 16, e5[7] = z4 = 65535 & U3 | k4 << 16, t5[7] = $4 = 65535 & _5 | B3 << 16, X3 += 128, n3 -= 128;
              }
              return n3;
            }
            function Y2(e5, t5, r4) {
              var n3, o4 = new Int32Array(8), s4 = new Int32Array(8), i4 = new Uint8Array(256), a4 = r4;
              for (o4[0] = 1779033703, o4[1] = 3144134277, o4[2] = 1013904242, o4[3] = 2773480762, o4[4] = 1359893119, o4[5] = 2600822924, o4[6] = 528734635, o4[7] = 1541459225, s4[0] = 4089235720, s4[1] = 2227873595, s4[2] = 4271175723, s4[3] = 1595750129, s4[4] = 2917565137, s4[5] = 725511199, s4[6] = 4215389547, s4[7] = 327033209, X2(o4, s4, t5, r4), r4 %= 128, n3 = 0; n3 < r4; n3++)
                i4[n3] = t5[a4 - r4 + n3];
              for (i4[r4] = 128, i4[(r4 = 256 - 128 * (r4 < 112 ? 1 : 0)) - 9] = 0, f3(i4, r4 - 8, a4 / 536870912 | 0, a4 << 3), X2(o4, s4, i4, r4), n3 = 0; n3 < 8; n3++)
                f3(e5, 8 * n3, o4[n3], s4[n3]);
              return 0;
            }
            function J2(e5, r4) {
              var n3 = t4(), o4 = t4(), s4 = t4(), i4 = t4(), a4 = t4(), c4 = t4(), l4 = t4(), h4 = t4(), p4 = t4();
              L3(n3, e5[1], e5[0]), L3(p4, r4[1], r4[0]), F3(n3, n3, p4), P3(o4, e5[0], e5[1]), P3(p4, r4[0], r4[1]), F3(o4, o4, p4), F3(s4, e5[3], r4[3]), F3(s4, s4, u3), F3(i4, e5[2], r4[2]), P3(i4, i4, i4), L3(a4, o4, n3), L3(c4, i4, s4), P3(l4, i4, s4), P3(h4, o4, n3), F3(e5[0], a4, c4), F3(e5[1], h4, l4), F3(e5[2], l4, c4), F3(e5[3], a4, h4);
            }
            function Q2(e5, t5, r4) {
              var n3;
              for (n3 = 0; n3 < 4; n3++)
                C3(e5[n3], t5[n3], r4);
            }
            function Z2(e5, r4) {
              var n3 = t4(), o4 = t4(), s4 = t4();
              j3(s4, r4[2]), F3(n3, r4[0], s4), F3(o4, r4[1], s4), R2(e5, o4), e5[31] ^= D3(n3) << 7;
            }
            function ee(e5, t5, r4) {
              var n3, o4;
              for (k3(e5[0], s3), k3(e5[1], i3), k3(e5[2], i3), k3(e5[3], s3), o4 = 255; o4 >= 0; --o4)
                Q2(e5, t5, n3 = r4[o4 / 8 | 0] >> (7 & o4) & 1), J2(t5, e5), J2(e5, e5), Q2(e5, t5, n3);
            }
            function te(e5, r4) {
              var n3 = [t4(), t4(), t4(), t4()];
              k3(n3[0], l3), k3(n3[1], h3), k3(n3[2], i3), F3(n3[3], l3, h3), ee(e5, n3, r4);
            }
            function re(e5, n3, o4) {
              var s4, i4 = new Uint8Array(64), a4 = [t4(), t4(), t4(), t4()];
              for (o4 || r3(n3, 32), Y2(i4, n3, 32), i4[0] &= 248, i4[31] &= 127, i4[31] |= 64, te(a4, i4), Z2(e5, a4), s4 = 0; s4 < 32; s4++)
                n3[s4 + 32] = e5[s4];
              return 0;
            }
            var ne = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
            function oe(e5, t5) {
              var r4, n3, o4, s4;
              for (n3 = 63; n3 >= 32; --n3) {
                for (r4 = 0, o4 = n3 - 32, s4 = n3 - 12; o4 < s4; ++o4)
                  t5[o4] += r4 - 16 * t5[n3] * ne[o4 - (n3 - 32)], r4 = Math.floor((t5[o4] + 128) / 256), t5[o4] -= 256 * r4;
                t5[o4] += r4, t5[n3] = 0;
              }
              for (r4 = 0, o4 = 0; o4 < 32; o4++)
                t5[o4] += r4 - (t5[31] >> 4) * ne[o4], r4 = t5[o4] >> 8, t5[o4] &= 255;
              for (o4 = 0; o4 < 32; o4++)
                t5[o4] -= r4 * ne[o4];
              for (n3 = 0; n3 < 32; n3++)
                t5[n3 + 1] += t5[n3] >> 8, e5[n3] = 255 & t5[n3];
            }
            function se(e5) {
              var t5, r4 = new Float64Array(64);
              for (t5 = 0; t5 < 64; t5++)
                r4[t5] = e5[t5];
              for (t5 = 0; t5 < 64; t5++)
                e5[t5] = 0;
              oe(e5, r4);
            }
            function ie(e5, r4, n3, o4) {
              var s4, i4, a4 = new Uint8Array(64), c4 = new Uint8Array(64), u4 = new Uint8Array(64), l4 = new Float64Array(64), h4 = [t4(), t4(), t4(), t4()];
              Y2(a4, o4, 32), a4[0] &= 248, a4[31] &= 127, a4[31] |= 64;
              var p4 = n3 + 64;
              for (s4 = 0; s4 < n3; s4++)
                e5[64 + s4] = r4[s4];
              for (s4 = 0; s4 < 32; s4++)
                e5[32 + s4] = a4[32 + s4];
              for (Y2(u4, e5.subarray(32), n3 + 32), se(u4), te(h4, u4), Z2(e5, h4), s4 = 32; s4 < 64; s4++)
                e5[s4] = o4[s4];
              for (Y2(c4, e5, n3 + 64), se(c4), s4 = 0; s4 < 64; s4++)
                l4[s4] = 0;
              for (s4 = 0; s4 < 32; s4++)
                l4[s4] = u4[s4];
              for (s4 = 0; s4 < 32; s4++)
                for (i4 = 0; i4 < 32; i4++)
                  l4[s4 + i4] += c4[s4] * a4[i4];
              return oe(e5.subarray(32), l4), p4;
            }
            function ae(e5, r4, n3, o4) {
              var a4, u4 = new Uint8Array(32), l4 = new Uint8Array(64), h4 = [t4(), t4(), t4(), t4()], f4 = [t4(), t4(), t4(), t4()];
              if (n3 < 64)
                return -1;
              if (function(e6, r5) {
                var n4 = t4(), o5 = t4(), a5 = t4(), u5 = t4(), l5 = t4(), h5 = t4(), f5 = t4();
                return k3(e6[2], i3), N3(e6[1], r5), z3(a5, e6[1]), F3(u5, a5, c3), L3(a5, a5, e6[2]), P3(u5, e6[2], u5), z3(l5, u5), z3(h5, l5), F3(f5, h5, l5), F3(n4, f5, a5), F3(n4, n4, u5), M3(n4, n4), F3(n4, n4, a5), F3(n4, n4, u5), F3(n4, n4, u5), F3(e6[0], n4, u5), z3(o5, e6[0]), F3(o5, o5, u5), O2(o5, a5) && F3(e6[0], e6[0], p3), z3(o5, e6[0]), F3(o5, o5, u5), O2(o5, a5) ? -1 : (D3(e6[0]) === r5[31] >> 7 && L3(e6[0], s3, e6[0]), F3(e6[3], e6[0], e6[1]), 0);
              }(f4, o4))
                return -1;
              for (a4 = 0; a4 < n3; a4++)
                e5[a4] = r4[a4];
              for (a4 = 0; a4 < 32; a4++)
                e5[a4 + 32] = o4[a4];
              if (Y2(l4, e5, n3), se(l4), ee(h4, f4, l4), te(f4, r4.subarray(32)), J2(h4, f4), Z2(u4, h4), n3 -= 64, y3(r4, 0, u4, 0)) {
                for (a4 = 0; a4 < n3; a4++)
                  e5[a4] = 0;
                return -1;
              }
              for (a4 = 0; a4 < n3; a4++)
                e5[a4] = r4[a4 + 64];
              return n3;
            }
            var ce = 64, ue = 32, le = 64;
            function he(e5, t5) {
              if (e5.length !== 32)
                throw new Error("bad key size");
              if (t5.length !== 24)
                throw new Error("bad nonce size");
            }
            function pe() {
              for (var e5 = 0; e5 < arguments.length; e5++)
                if (!(arguments[e5] instanceof Uint8Array))
                  throw new TypeError("unexpected type, use Uint8Array");
            }
            function fe(e5) {
              for (var t5 = 0; t5 < e5.length; t5++)
                e5[t5] = 0;
            }
            e4.lowlevel = { crypto_core_hsalsa20: b2, crypto_stream_xor: S2, crypto_stream: x3, crypto_stream_salsa20_xor: w4, crypto_stream_salsa20: v3, crypto_onetimeauth: T4, crypto_onetimeauth_verify: _4, crypto_verify_16: g3, crypto_verify_32: y3, crypto_secretbox: B2, crypto_secretbox_open: U2, crypto_scalarmult: H3, crypto_scalarmult_base: G2, crypto_box_beforenm: q3, crypto_box_afternm: V2, crypto_box: function(e5, t5, r4, n3, o4, s4) {
              var i4 = new Uint8Array(32);
              return q3(i4, o4, s4), V2(e5, t5, r4, n3, i4);
            }, crypto_box_open: function(e5, t5, r4, n3, o4, s4) {
              var i4 = new Uint8Array(32);
              return q3(i4, o4, s4), $3(e5, t5, r4, n3, i4);
            }, crypto_box_keypair: K3, crypto_hash: Y2, crypto_sign: ie, crypto_sign_keypair: re, crypto_sign_open: ae, crypto_secretbox_KEYBYTES: 32, crypto_secretbox_NONCEBYTES: 24, crypto_secretbox_ZEROBYTES: 32, crypto_secretbox_BOXZEROBYTES: 16, crypto_scalarmult_BYTES: 32, crypto_scalarmult_SCALARBYTES: 32, crypto_box_PUBLICKEYBYTES: 32, crypto_box_SECRETKEYBYTES: 32, crypto_box_BEFORENMBYTES: 32, crypto_box_NONCEBYTES: 24, crypto_box_ZEROBYTES: 32, crypto_box_BOXZEROBYTES: 16, crypto_sign_BYTES: ce, crypto_sign_PUBLICKEYBYTES: ue, crypto_sign_SECRETKEYBYTES: le, crypto_sign_SEEDBYTES: 32, crypto_hash_BYTES: 64, gf: t4, D: c3, L: ne, pack25519: R2, unpack25519: N3, M: F3, A: P3, S: z3, Z: L3, pow2523: M3, add: J2, set25519: k3, modL: oe, scalarmult: ee, scalarbase: te }, e4.randomBytes = function(e5) {
              var t5 = new Uint8Array(e5);
              return r3(t5, e5), t5;
            }, e4.secretbox = function(e5, t5, r4) {
              pe(e5, t5, r4), he(r4, t5);
              for (var n3 = new Uint8Array(32 + e5.length), o4 = new Uint8Array(n3.length), s4 = 0; s4 < e5.length; s4++)
                n3[s4 + 32] = e5[s4];
              return B2(o4, n3, n3.length, t5, r4), o4.subarray(16);
            }, e4.secretbox.open = function(e5, t5, r4) {
              pe(e5, t5, r4), he(r4, t5);
              for (var n3 = new Uint8Array(16 + e5.length), o4 = new Uint8Array(n3.length), s4 = 0; s4 < e5.length; s4++)
                n3[s4 + 16] = e5[s4];
              return n3.length < 32 || U2(o4, n3, n3.length, t5, r4) !== 0 ? null : o4.subarray(32);
            }, e4.secretbox.keyLength = 32, e4.secretbox.nonceLength = 24, e4.secretbox.overheadLength = 16, e4.scalarMult = function(e5, t5) {
              if (pe(e5, t5), e5.length !== 32)
                throw new Error("bad n size");
              if (t5.length !== 32)
                throw new Error("bad p size");
              var r4 = new Uint8Array(32);
              return H3(r4, e5, t5), r4;
            }, e4.scalarMult.base = function(e5) {
              if (pe(e5), e5.length !== 32)
                throw new Error("bad n size");
              var t5 = new Uint8Array(32);
              return G2(t5, e5), t5;
            }, e4.scalarMult.scalarLength = 32, e4.scalarMult.groupElementLength = 32, e4.box = function(t5, r4, n3, o4) {
              var s4 = e4.box.before(n3, o4);
              return e4.secretbox(t5, r4, s4);
            }, e4.box.before = function(e5, t5) {
              pe(e5, t5), function(e6, t6) {
                if (e6.length !== 32)
                  throw new Error("bad public key size");
                if (t6.length !== 32)
                  throw new Error("bad secret key size");
              }(e5, t5);
              var r4 = new Uint8Array(32);
              return q3(r4, e5, t5), r4;
            }, e4.box.after = e4.secretbox, e4.box.open = function(t5, r4, n3, o4) {
              var s4 = e4.box.before(n3, o4);
              return e4.secretbox.open(t5, r4, s4);
            }, e4.box.open.after = e4.secretbox.open, e4.box.keyPair = function() {
              var e5 = new Uint8Array(32), t5 = new Uint8Array(32);
              return K3(e5, t5), { publicKey: e5, secretKey: t5 };
            }, e4.box.keyPair.fromSecretKey = function(e5) {
              if (pe(e5), e5.length !== 32)
                throw new Error("bad secret key size");
              var t5 = new Uint8Array(32);
              return G2(t5, e5), { publicKey: t5, secretKey: new Uint8Array(e5) };
            }, e4.box.publicKeyLength = 32, e4.box.secretKeyLength = 32, e4.box.sharedKeyLength = 32, e4.box.nonceLength = 24, e4.box.overheadLength = e4.secretbox.overheadLength, e4.sign = function(e5, t5) {
              if (pe(e5, t5), t5.length !== le)
                throw new Error("bad secret key size");
              var r4 = new Uint8Array(ce + e5.length);
              return ie(r4, e5, e5.length, t5), r4;
            }, e4.sign.open = function(e5, t5) {
              if (pe(e5, t5), t5.length !== ue)
                throw new Error("bad public key size");
              var r4 = new Uint8Array(e5.length), n3 = ae(r4, e5, e5.length, t5);
              if (n3 < 0)
                return null;
              for (var o4 = new Uint8Array(n3), s4 = 0; s4 < o4.length; s4++)
                o4[s4] = r4[s4];
              return o4;
            }, e4.sign.detached = function(t5, r4) {
              for (var n3 = e4.sign(t5, r4), o4 = new Uint8Array(ce), s4 = 0; s4 < o4.length; s4++)
                o4[s4] = n3[s4];
              return o4;
            }, e4.sign.detached.verify = function(e5, t5, r4) {
              if (pe(e5, t5, r4), t5.length !== ce)
                throw new Error("bad signature size");
              if (r4.length !== ue)
                throw new Error("bad public key size");
              var n3, o4 = new Uint8Array(ce + e5.length), s4 = new Uint8Array(ce + e5.length);
              for (n3 = 0; n3 < ce; n3++)
                o4[n3] = t5[n3];
              for (n3 = 0; n3 < e5.length; n3++)
                o4[n3 + ce] = e5[n3];
              return ae(s4, o4, o4.length, r4) >= 0;
            }, e4.sign.keyPair = function() {
              var e5 = new Uint8Array(ue), t5 = new Uint8Array(le);
              return re(e5, t5), { publicKey: e5, secretKey: t5 };
            }, e4.sign.keyPair.fromSecretKey = function(e5) {
              if (pe(e5), e5.length !== le)
                throw new Error("bad secret key size");
              for (var t5 = new Uint8Array(ue), r4 = 0; r4 < t5.length; r4++)
                t5[r4] = e5[32 + r4];
              return { publicKey: t5, secretKey: new Uint8Array(e5) };
            }, e4.sign.keyPair.fromSeed = function(e5) {
              if (pe(e5), e5.length !== 32)
                throw new Error("bad seed size");
              for (var t5 = new Uint8Array(ue), r4 = new Uint8Array(le), n3 = 0; n3 < 32; n3++)
                r4[n3] = e5[n3];
              return re(t5, r4, true), { publicKey: t5, secretKey: r4 };
            }, e4.sign.publicKeyLength = ue, e4.sign.secretKeyLength = le, e4.sign.seedLength = 32, e4.sign.signatureLength = ce, e4.hash = function(e5) {
              pe(e5);
              var t5 = new Uint8Array(64);
              return Y2(t5, e5, e5.length), t5;
            }, e4.hash.hashLength = 64, e4.verify = function(e5, t5) {
              return pe(e5, t5), e5.length !== 0 && t5.length !== 0 && e5.length === t5.length && d3(e5, 0, t5, 0, e5.length) === 0;
            }, e4.setPRNG = function(e5) {
              r3 = e5;
            }, function() {
              var t5 = typeof self != "undefined" ? self.crypto || self.msCrypto : null;
              t5 && t5.getRandomValues ? e4.setPRNG(function(e5, r4) {
                var n3, o4 = new Uint8Array(r4);
                for (n3 = 0; n3 < r4; n3 += 65536)
                  t5.getRandomValues(o4.subarray(n3, n3 + Math.min(r4 - n3, 65536)));
                for (n3 = 0; n3 < r4; n3++)
                  e5[n3] = o4[n3];
                fe(o4);
              }) : typeof __require != "undefined" && (t5 = require_crypto_js()) && t5.randomBytes && e4.setPRNG(function(e5, r4) {
                var n3, o4 = t5.randomBytes(r4);
                for (n3 = 0; n3 < r4; n3++)
                  e5[n3] = o4[n3];
                fe(o4);
              });
            }();
          }(e3 !== void 0 && e3.exports ? e3.exports : self.nacl = self.nacl || {});
        }, 1042: (e3, t3, r3) => {
          "use strict";
          var n2 = r3(1926), o3 = r3(9370), s3 = /[\n\r\t]/g, i3 = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, a3 = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, c3 = /^[a-zA-Z]:/, u3 = /^[ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
          function l3(e4) {
            return (e4 || "").toString().replace(u3, "");
          }
          var h3 = [["#", "hash"], ["?", "query"], function(e4, t4) {
            return d3(t4.protocol) ? e4.replace(/\\/g, "/") : e4;
          }, ["/", "pathname"], ["@", "auth", 1], [NaN, "host", void 0, 1, 1], [/:(\d*)$/, "port", void 0, 1], [NaN, "hostname", void 0, 1, 1]], p3 = { hash: 1, query: 1 };
          function f3(e4) {
            var t4, n3 = (typeof window != "undefined" ? window : r3.g !== void 0 ? r3.g : typeof self != "undefined" ? self : {}).location || {}, o4 = {}, s4 = typeof (e4 = e4 || n3);
            if (e4.protocol === "blob:")
              o4 = new y3(unescape(e4.pathname), {});
            else if (s4 === "string")
              for (t4 in o4 = new y3(e4, {}), p3)
                delete o4[t4];
            else if (s4 === "object") {
              for (t4 in e4)
                t4 in p3 || (o4[t4] = e4[t4]);
              o4.slashes === void 0 && (o4.slashes = i3.test(e4.href));
            }
            return o4;
          }
          function d3(e4) {
            return e4 === "file:" || e4 === "ftp:" || e4 === "http:" || e4 === "https:" || e4 === "ws:" || e4 === "wss:";
          }
          function g3(e4, t4) {
            e4 = (e4 = l3(e4)).replace(s3, ""), t4 = t4 || {};
            var r4, n3 = a3.exec(e4), o4 = n3[1] ? n3[1].toLowerCase() : "", i4 = !!n3[2], c4 = !!n3[3], u4 = 0;
            return i4 ? c4 ? (r4 = n3[2] + n3[3] + n3[4], u4 = n3[2].length + n3[3].length) : (r4 = n3[2] + n3[4], u4 = n3[2].length) : c4 ? (r4 = n3[3] + n3[4], u4 = n3[3].length) : r4 = n3[4], o4 === "file:" ? u4 >= 2 && (r4 = r4.slice(2)) : d3(o4) ? r4 = n3[4] : o4 ? i4 && (r4 = r4.slice(2)) : u4 >= 2 && d3(t4.protocol) && (r4 = n3[4]), { protocol: o4, slashes: i4 || d3(o4), slashesCount: u4, rest: r4 };
          }
          function y3(e4, t4, r4) {
            if (e4 = (e4 = l3(e4)).replace(s3, ""), !(this instanceof y3))
              return new y3(e4, t4, r4);
            var i4, a4, u4, p4, m3, b2, A4 = h3.slice(), w4 = typeof t4, v3 = this, x3 = 0;
            for (w4 !== "object" && w4 !== "string" && (r4 = t4, t4 = null), r4 && typeof r4 != "function" && (r4 = o3.parse), i4 = !(a4 = g3(e4 || "", t4 = f3(t4))).protocol && !a4.slashes, v3.slashes = a4.slashes || i4 && t4.slashes, v3.protocol = a4.protocol || t4.protocol || "", e4 = a4.rest, (a4.protocol === "file:" && (a4.slashesCount !== 2 || c3.test(e4)) || !a4.slashes && (a4.protocol || a4.slashesCount < 2 || !d3(v3.protocol))) && (A4[3] = [/(.*)/, "pathname"]); x3 < A4.length; x3++)
              typeof (p4 = A4[x3]) != "function" ? (u4 = p4[0], b2 = p4[1], u4 != u4 ? v3[b2] = e4 : typeof u4 == "string" ? ~(m3 = u4 === "@" ? e4.lastIndexOf(u4) : e4.indexOf(u4)) && (typeof p4[2] == "number" ? (v3[b2] = e4.slice(0, m3), e4 = e4.slice(m3 + p4[2])) : (v3[b2] = e4.slice(m3), e4 = e4.slice(0, m3))) : (m3 = u4.exec(e4)) && (v3[b2] = m3[1], e4 = e4.slice(0, m3.index)), v3[b2] = v3[b2] || i4 && p4[3] && t4[b2] || "", p4[4] && (v3[b2] = v3[b2].toLowerCase())) : e4 = p4(e4, v3);
            r4 && (v3.query = r4(v3.query)), i4 && t4.slashes && v3.pathname.charAt(0) !== "/" && (v3.pathname !== "" || t4.pathname !== "") && (v3.pathname = function(e5, t5) {
              if (e5 === "")
                return t5;
              for (var r5 = (t5 || "/").split("/").slice(0, -1).concat(e5.split("/")), n3 = r5.length, o4 = r5[n3 - 1], s4 = false, i5 = 0; n3--; )
                r5[n3] === "." ? r5.splice(n3, 1) : r5[n3] === ".." ? (r5.splice(n3, 1), i5++) : i5 && (n3 === 0 && (s4 = true), r5.splice(n3, 1), i5--);
              return s4 && r5.unshift(""), o4 !== "." && o4 !== ".." || r5.push(""), r5.join("/");
            }(v3.pathname, t4.pathname)), v3.pathname.charAt(0) !== "/" && d3(v3.protocol) && (v3.pathname = "/" + v3.pathname), n2(v3.port, v3.protocol) || (v3.host = v3.hostname, v3.port = ""), v3.username = v3.password = "", v3.auth && (~(m3 = v3.auth.indexOf(":")) ? (v3.username = v3.auth.slice(0, m3), v3.username = encodeURIComponent(decodeURIComponent(v3.username)), v3.password = v3.auth.slice(m3 + 1), v3.password = encodeURIComponent(decodeURIComponent(v3.password))) : v3.username = encodeURIComponent(decodeURIComponent(v3.auth)), v3.auth = v3.password ? v3.username + ":" + v3.password : v3.username), v3.origin = v3.protocol !== "file:" && d3(v3.protocol) && v3.host ? v3.protocol + "//" + v3.host : "null", v3.href = v3.toString();
          }
          y3.prototype = { set: function(e4, t4, r4) {
            var s4 = this;
            switch (e4) {
              case "query":
                typeof t4 == "string" && t4.length && (t4 = (r4 || o3.parse)(t4)), s4[e4] = t4;
                break;
              case "port":
                s4[e4] = t4, n2(t4, s4.protocol) ? t4 && (s4.host = s4.hostname + ":" + t4) : (s4.host = s4.hostname, s4[e4] = "");
                break;
              case "hostname":
                s4[e4] = t4, s4.port && (t4 += ":" + s4.port), s4.host = t4;
                break;
              case "host":
                s4[e4] = t4, /:\d+$/.test(t4) ? (t4 = t4.split(":"), s4.port = t4.pop(), s4.hostname = t4.join(":")) : (s4.hostname = t4, s4.port = "");
                break;
              case "protocol":
                s4.protocol = t4.toLowerCase(), s4.slashes = !r4;
                break;
              case "pathname":
              case "hash":
                if (t4) {
                  var i4 = e4 === "pathname" ? "/" : "#";
                  s4[e4] = t4.charAt(0) !== i4 ? i4 + t4 : t4;
                } else
                  s4[e4] = t4;
                break;
              case "username":
              case "password":
                s4[e4] = encodeURIComponent(t4);
                break;
              case "auth":
                var a4 = t4.indexOf(":");
                ~a4 ? (s4.username = t4.slice(0, a4), s4.username = encodeURIComponent(decodeURIComponent(s4.username)), s4.password = t4.slice(a4 + 1), s4.password = encodeURIComponent(decodeURIComponent(s4.password))) : s4.username = encodeURIComponent(decodeURIComponent(t4));
            }
            for (var c4 = 0; c4 < h3.length; c4++) {
              var u4 = h3[c4];
              u4[4] && (s4[u4[1]] = s4[u4[1]].toLowerCase());
            }
            return s4.auth = s4.password ? s4.username + ":" + s4.password : s4.username, s4.origin = s4.protocol !== "file:" && d3(s4.protocol) && s4.host ? s4.protocol + "//" + s4.host : "null", s4.href = s4.toString(), s4;
          }, toString: function(e4) {
            e4 && typeof e4 == "function" || (e4 = o3.stringify);
            var t4, r4 = this, n3 = r4.host, s4 = r4.protocol;
            s4 && s4.charAt(s4.length - 1) !== ":" && (s4 += ":");
            var i4 = s4 + (r4.protocol && r4.slashes || d3(r4.protocol) ? "//" : "");
            return r4.username ? (i4 += r4.username, r4.password && (i4 += ":" + r4.password), i4 += "@") : r4.password ? (i4 += ":" + r4.password, i4 += "@") : r4.protocol !== "file:" && d3(r4.protocol) && !n3 && r4.pathname !== "/" && (i4 += "@"), n3[n3.length - 1] === ":" && (n3 += ":"), i4 += n3 + r4.pathname, (t4 = typeof r4.query == "object" ? e4(r4.query) : r4.query) && (i4 += t4.charAt(0) !== "?" ? "?" + t4 : t4), r4.hash && (i4 += r4.hash), i4;
          } }, y3.extractProtocol = g3, y3.location = f3, y3.trimLeft = l3, y3.qs = o3, e3.exports = y3;
        }, 5922: (e3, t3, r3) => {
          var n2 = r3(2486).Buffer;
          const { default: o3 } = r3(1113), { setSendTransactionHeaders: s3 } = r3(5180);
          e3.exports = { Algod: function(e4 = "", t4 = "http://r2.algorand.network", r4 = 4180, i3 = {}) {
            let a3 = e4;
            typeof a3 == "string" && (a3 = { "X-Algo-API-Token": a3 });
            const c3 = new o3(a3, t4, r4, i3);
            function u3(e5) {
              return e5.noteb64 !== void 0 && e5.noteb64 !== null && (e5.note = n2.from(e5.noteb64, "base64")), e5;
            }
            this.status = async (e5 = {}) => (await c3.get("/v1/status", {}, e5)).body, this.healthCheck = async (e5 = {}) => {
              const t5 = await c3.get("/health", {}, e5);
              if (!t5.ok)
                throw new Error(`Health response: ${t5.status}`);
              return {};
            }, this.statusAfterBlock = async (e5, t5 = {}) => {
              if (!Number.isInteger(e5))
                throw Error("roundNumber should be an integer");
              return (await c3.get(`/v1/status/wait-for-block-after/${e5}`, {}, t5)).body;
            }, this.pendingTransactions = async (e5, t5 = {}) => {
              if (!Number.isInteger(e5))
                throw Error("maxTxns should be an integer");
              const r5 = await c3.get("/v1/transactions/pending", { max: e5 }, t5);
              if (r5.statusCode === 200 && r5.body.truncatedTxns.transactions !== void 0)
                for (let e6 = 0; e6 < r5.body.truncatedTxns.transactions.length; e6++)
                  r5.body.truncatedTxns.transactions[e6] = u3(r5.body.truncatedTxns.transactions[e6]);
              return r5.body;
            }, this.versions = async (e5 = {}) => (await c3.get("/versions", {}, e5)).body, this.ledgerSupply = async (e5 = {}) => (await c3.get("/v1/ledger/supply", {}, e5)).body, this.transactionByAddress = async (e5, t5 = null, r5 = null, n3 = null, o4 = {}) => {
              if (t5 !== null && !Number.isInteger(t5))
                throw Error("first round should be an integer");
              if (r5 !== null && !Number.isInteger(r5))
                throw Error("last round should be an integer");
              const s4 = await c3.get(`/v1/account/${e5}/transactions`, { firstRound: t5, lastRound: r5, max: n3 }, o4);
              if (s4.statusCode === 200 && s4.body.transactions !== void 0)
                for (let e6 = 0; e6 < s4.body.transactions.length; e6++)
                  s4.body.transactions[e6] = u3(s4.body.transactions[e6]);
              return s4.body;
            }, this.transactionByAddressAndDate = async (e5, t5, r5, n3 = null, o4 = {}) => {
              const s4 = await c3.get(`/v1/account/${e5}/transactions`, { fromDate: t5, toDate: r5, max: n3 }, o4);
              if (s4.statusCode === 200 && s4.body.transactions !== void 0)
                for (let e6 = 0; e6 < s4.body.transactions.length; e6++)
                  s4.body.transactions[e6] = u3(s4.body.transactions[e6]);
              return s4.body;
            }, this.transactionById = async (e5, t5 = {}) => {
              const r5 = await c3.get(`/v1/transaction/${e5}`, {}, t5);
              return r5.statusCode === 200 && (r5.body = u3(r5.body)), r5.body;
            }, this.transactionInformation = async (e5, t5, r5 = {}) => {
              const n3 = await c3.get(`/v1/account/${e5}/transaction/${t5}`, {}, r5);
              return n3.statusCode === 200 && (n3.body = u3(n3.body)), n3.body;
            }, this.pendingTransactionInformation = async (e5, t5 = {}) => {
              const r5 = await c3.get(`/v1/transactions/pending/${e5}`, {}, t5);
              return r5.statusCode === 200 && (r5.body = u3(r5.body)), r5.body;
            }, this.accountInformation = async (e5, t5 = {}) => (await c3.get(`/v1/account/${e5}`, {}, t5)).body, this.assetInformation = async (e5, t5 = {}) => (await c3.get(`/v1/asset/${e5}`, {}, t5)).body, this.suggestedFee = async (e5 = {}) => (await c3.get("/v1/transactions/fee", {}, e5)).body, this.sendRawTransaction = async (e5, t5 = {}) => {
              const r5 = s3(t5);
              return (await c3.post("/v1/transactions", n2.from(e5), r5)).body;
            }, this.sendRawTransactions = async (e5, t5 = {}) => {
              const r5 = s3(t5), o4 = Array.prototype.concat(...e5.map((e6) => Array.from(e6)));
              return (await c3.post("/v1/transactions", n2.from(o4), r5)).body;
            }, this.getTransactionParams = async (e5 = {}) => (await c3.get("/v1/transactions/params", {}, e5)).body, this.suggestParams = async (e5 = {}) => {
              const t5 = await this.getTransactionParams(e5);
              return { flatFee: false, fee: t5.fee, firstRound: t5.lastRound, lastRound: t5.lastRound + 1e3, genesisID: t5.genesisID, genesisHash: t5.genesishashb64 };
            }, this.block = async (e5, t5 = {}) => {
              if (!Number.isInteger(e5))
                throw Error("roundNumber should be an integer");
              const r5 = await c3.get(`/v1/block/${e5}`, {}, t5);
              if (r5.statusCode === 200 && r5.body.txns.transactions !== void 0)
                for (let e6 = 0; e6 < r5.body.txns.transactions.length; e6++)
                  r5.body.txns.transactions[e6] = u3(r5.body.txns.transactions[e6]);
              return r5.body;
            };
          } };
        }, 1834: (e3, t3, r3) => {
          var n2 = r3(2486).Buffer;
          const o3 = r3(7116), s3 = r3(3033), i3 = r3(1063), a3 = r3(5583), c3 = r3(8800), u3 = r3(9404), l3 = r3(2514), h3 = r3(9417);
          e3.exports = { DynamicFee: class {
            constructor(e4, t4, r4, s4, i4, a4) {
              if (!Number.isSafeInteger(t4) || t4 < 0)
                throw Error("amount must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(r4) || r4 < 0)
                throw Error("firstValid must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(s4) || s4 < 0)
                throw Error("lastValid must be a positive number and smaller than 2^53-1");
              if (i4 === void 0 && (i4 = o3.ALGORAND_ZERO_ADDRESS_STRING), a4 === void 0) {
                const e5 = u3.randomBytes(32);
                a4 = n2.from(e5).toString("base64");
              }
              const h4 = n2.from("ASAFAgEHBgUmAyD+vKC7FEpaTqe0OKRoGsgObKEFvLYH/FZTJclWlfaiEyDmmpYeby1feshmB5JlUr6YI17TM2PKiJGLuck4qRW2+SB/g7Flf/H8U7ktwYFIodZd/C1LH6PWdyhK3dIAEm2QaTIEIhIzABAjEhAzAAcxABIQMwAIMQESEDEWIxIQMRAjEhAxBygSEDEJKRIQMQgkEhAxAiUSEDEEIQQSEDEGKhIQ", "base64"), p3 = [t4, r4, s4, e4, i4, a4], f3 = [l3.valTypes.INT, l3.valTypes.INT, l3.valTypes.INT, l3.valTypes.ADDRESS, l3.valTypes.ADDRESS, l3.valTypes.BASE64], d3 = l3.inject(h4, [5, 6, 7, 11, 44, 76], p3, f3);
              this.programBytes = d3;
              const g3 = new c3.LogicSig(d3, void 0);
              this.address = g3.address();
            }
            getProgram() {
              return this.programBytes;
            }
            getAddress() {
              return this.address;
            }
          }, getDynamicFeeTransactions: function(e4, t4, r4, n3) {
            if (!t4.verify(o3.decodeAddress(e4.from).publicKey))
              throw new Error("invalid signature");
            e4.fee = n3, e4.fee < h3.ALGORAND_MIN_TX_FEE && (e4.fee = h3.ALGORAND_MIN_TX_FEE);
            const a4 = u3.keyPairFromSecretKey(r4), c4 = o3.encodeAddress(a4.publicKey), { lease: l4 } = e4;
            delete e4.lease;
            const p3 = new h3.Transaction(e4);
            p3.addLease(l4, n3);
            const f3 = { from: c4, to: e4.from, fee: n3, amount: p3.fee, firstRound: e4.firstRound, lastRound: e4.lastRound, genesisHash: e4.genesisHash, type: "pay" }, d3 = new h3.Transaction(f3);
            d3.addLease(l4, n3);
            const g3 = i3.assignGroupID([d3, p3], void 0), y3 = g3[0], m3 = g3[1], b2 = { lsig: t4.get_obj_for_encoding(), txn: m3.get_obj_for_encoding() }, A4 = y3.signTxn(r4), w4 = s3.encode(b2), v3 = new Uint8Array(A4.length + w4.length);
            return v3.set(A4), v3.set(w4, A4.length), v3;
          }, signDynamicFee: function(e4, t4, r4) {
            const n3 = a3.readProgram(e4, void 0), s4 = n3[0], i4 = n3[1], l4 = u3.keyPairFromSecretKey(t4), h4 = { from: o3.encodeAddress(l4.publicKey), to: o3.encodeAddress(i4[0]), fee: 0, amount: s4[2], closeRemainderTo: o3.encodeAddress(i4[1]), firstRound: s4[3], lastRound: s4[4], genesisHash: r4, type: "pay", lease: new Uint8Array(i4[2]) }, p3 = new c3.LogicSig(e4, void 0);
            return p3.sign(t4), { txn: h4, lsig: p3 };
          } };
        }, 1786: (e3, t3, r3) => {
          var n2 = r3(2486).Buffer;
          const o3 = r3(3477), { keccak256: s3 } = r3(583), i3 = r3(5583), a3 = r3(8800), c3 = r3(2514), u3 = r3(9417);
          e3.exports = { HTLC: class {
            constructor(e4, t4, r4, o4, s4, i4) {
              if (!Number.isSafeInteger(s4) || s4 < 0)
                throw Error("expiryRound must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(i4) || i4 < 0)
                throw Error("maxFee must be a positive number and smaller than 2^53-1");
              let u4 = "";
              if (r4 === "sha256")
                u4 = "ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQEpEhAxCSoSMQIlDRAREA==";
              else {
                if (r4 !== "keccak256")
                  throw Error("hash function unrecognized");
                u4 = "ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQIpEhAxCSoSMQIlDRAREA==";
              }
              if (n2.from(o4, "base64").length !== 32)
                throw Error("hash image must be 32 bytes");
              const l3 = n2.from(u4, "base64"), h3 = [i4, s4, t4, o4, e4], p3 = [c3.valTypes.INT, c3.valTypes.INT, c3.valTypes.ADDRESS, c3.valTypes.BASE64, c3.valTypes.ADDRESS], f3 = c3.inject(l3, [3, 6, 10, 42, 76], h3, p3);
              this.programBytes = f3;
              const d3 = new a3.LogicSig(f3, void 0);
              this.address = d3.address();
            }
            getProgram() {
              return this.programBytes;
            }
            getAddress() {
              return this.address;
            }
          }, signTransactionWithHTLCUnlock: function(e4, t4, r4) {
            const c4 = n2.from(r4, "base64"), l3 = i3.readProgram(e4, void 0), h3 = l3[0], p3 = l3[1][1], f3 = e4[e4.length - 15];
            if (f3 === 1) {
              const e5 = o3.create();
              if (e5.update(c4), !n2.from(e5.hex(), "hex").equals(p3))
                throw new Error("sha256 hash of preimage did not match stored contract hash");
            } else {
              if (f3 !== 2)
                throw new Error("hash function in contract unrecognized");
              {
                const e5 = s3.create();
                if (e5.update(c4), !n2.from(e5.hex(), "hex").equals(p3))
                  throw new Error("keccak256 hash of preimage did not match stored contract hash");
              }
            }
            const d3 = [c4], g3 = new a3.LogicSig(e4, d3);
            delete t4.to;
            const y3 = h3[0], m3 = new u3.Transaction(t4);
            if (m3.fee > y3)
              throw new Error(`final fee of payment transaction${m3.fee.toString()}greater than transaction max fee${y3.toString()}`);
            return a3.signLogicSigTransaction(t4, g3);
          } };
        }, 8886: (e3, t3, r3) => {
          const n2 = r3(1834), o3 = r3(1786), s3 = r3(4748), i3 = r3(3758), a3 = r3(2200);
          e3.exports = { DynamicFee: n2.DynamicFee, getDynamicFeeTransactions: n2.getDynamicFeeTransactions, signDynamicFee: n2.signDynamicFee, HTLC: o3.HTLC, signTransactionWithHTLCUnlock: o3.signTransactionWithHTLCUnlock, LimitOrder: s3.LimitOrder, getSwapAssetsTransaction: s3.getSwapAssetsTransaction, Split: i3.Split, getSplitFundsTransaction: i3.getSplitFundsTransaction, PeriodicPayment: a3.PeriodicPayment, getPeriodicPaymentWithdrawalTransaction: a3.getPeriodicPaymentWithdrawalTransaction };
        }, 4748: (e3, t3, r3) => {
          var n2 = r3(2486).Buffer;
          const o3 = r3(7116), s3 = r3(1988), i3 = r3(1063), a3 = r3(5583), c3 = r3(8800), u3 = r3(9404), l3 = r3(2514), h3 = r3(413);
          e3.exports = { LimitOrder: class {
            constructor(e4, t4, r4, o4, s4, i4, a4) {
              if (!Number.isSafeInteger(t4) || t4 < 0)
                throw Error("assetid must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(r4) || r4 < 0)
                throw Error("ratn must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(o4) || o4 < 0)
                throw Error("ratd must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(s4) || s4 < 0)
                throw Error("expiryRound must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(i4) || i4 < 0)
                throw Error("minTrade must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(a4) || a4 < 0)
                throw Error("maxFee must be a positive number and smaller than 2^53-1");
              const u4 = n2.from("ASAKAAEFAgYEBwgJCiYBIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMRYiEjEQIxIQMQEkDhAyBCMSQABVMgQlEjEIIQQNEDEJMgMSEDMBECEFEhAzAREhBhIQMwEUKBIQMwETMgMSEDMBEiEHHTUCNQExCCEIHTUENQM0ATQDDUAAJDQBNAMSNAI0BA8QQAAWADEJKBIxAiEJDRAxBzIDEhAxCCISEBA=", "base64"), h4 = [a4, i4, t4, o4, r4, s4, e4], p3 = [l3.valTypes.INT, l3.valTypes.INT, l3.valTypes.INT, l3.valTypes.INT, l3.valTypes.INT, l3.valTypes.INT, l3.valTypes.ADDRESS], f3 = l3.inject(u4, [5, 7, 9, 10, 11, 12, 16], h4, p3);
              this.programBytes = f3;
              const d3 = new c3.LogicSig(f3, void 0);
              this.address = d3.address(), this.owner = e4, this.assetid = t4;
            }
            getProgram() {
              return this.programBytes;
            }
            getAddress() {
              return this.address;
            }
          }, getSwapAssetsTransaction: function(e4, t4, r4, n3, l4, p3, f3, d3) {
            const g3 = u3.keyPairFromSecretKey(n3), y3 = o3.encodeAddress(g3.publicKey), m3 = a3.readProgram(e4, void 0), b2 = m3[0], A4 = m3[1];
            let w4;
            const v3 = b2[6], x3 = o3.encodeAddress(A4[0]), S2 = c3.makeLogicSig(e4, void 0), E4 = S2.address(), T4 = [s3.makePaymentTxn(E4, y3, l4, r4, w4, p3, f3, void 0, d3, void 0), s3.makeAssetTransferTxn(y3, x3, w4, void 0, l4, t4, p3, f3, void 0, d3, void 0, v3)], _4 = i3.assignGroupID(T4), B2 = b2[7], U2 = b2[8];
            if (t4 * B2 < r4 * U2)
              throw new Error(`bad payment ratio, ${t4.toString()}*${B2.toString()} !>= ${r4.toString()}*${U2.toString()}`);
            const k3 = b2[4];
            if (r4 < k3)
              throw new Error(`payment amount ${r4.toString()} less than minimum trade ${k3.toString()}`);
            const I3 = b2[2];
            if (_4[0].fee > I3)
              throw new Error(`final fee of payment transaction ${_4[0].fee.toString()} greater than transaction max fee ${I3.toString()}`);
            if (_4[1].fee > I3)
              throw new Error(`final fee of asset transaction ${_4[1].fee.toString()} greater than transaction max fee ${I3.toString()}`);
            const C3 = c3.signLogicSigTransactionObject(_4[0], S2), R2 = _4[1].signTxn(n3);
            return h3.concatArrays(C3.blob, R2);
          } };
        }, 2200: (e3, t3, r3) => {
          var n2 = r3(2486).Buffer;
          const o3 = r3(7116), s3 = r3(1988), i3 = r3(5583), a3 = r3(8800), c3 = r3(9404), u3 = r3(2514);
          e3.exports = { PeriodicPayment: class {
            constructor(e4, t4, r4, o4, s4, i4, u4) {
              if (this.receiver = e4, !Number.isSafeInteger(t4) || t4 < 0)
                throw Error("amount must be a positive number and smaller than 2^53-1");
              if (this.amount = t4, !Number.isSafeInteger(r4) || r4 < 0)
                throw Error("withdrawalWindow must be a positive number and smaller than 2^53-1");
              if (this.withdrawalWindow = r4, !Number.isSafeInteger(o4) || o4 < 0)
                throw Error("period must be a positive number and smaller than 2^53-1");
              if (this.period = o4, !Number.isSafeInteger(s4) || s4 < 0)
                throw Error("expiryRound must be a positive number and smaller than 2^53-1");
              if (this.expiryRound = s4, !Number.isSafeInteger(i4) || i4 < 0)
                throw Error("maxFee must be a positive number and smaller than 2^53-1");
              if (this.maxFee = i4, u4 === void 0) {
                const e5 = c3.randomBytes(32);
                this.lease = n2.from(e5).toString("base64");
              } else
                this.lease = u4;
              this.programBytes = this.getProgram();
              const l3 = new a3.LogicSig(this.programBytes, void 0);
              this.address = l3.address();
            }
            getProgram() {
              const e4 = n2.from("ASAHAQYFAAQDByYCIAECAwQFBgcIAQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIIJKvkYTkEzwJf2arzJOxERsSogG9nQzKPkpIoc4TzPTFMRAiEjEBIw4QMQIkGCUSEDEEIQQxAggSEDEGKBIQMQkyAxIxBykSEDEIIQUSEDEJKRIxBzIDEhAxAiEGDRAxCCUSEBEQ", "base64"), t4 = [this.maxFee, this.period, this.withdrawalWindow, this.amount, this.expiryRound, this.lease, this.receiver], r4 = [u3.valTypes.INT, u3.valTypes.INT, u3.valTypes.INT, u3.valTypes.INT, u3.valTypes.INT, u3.valTypes.BASE64, u3.valTypes.ADDRESS];
              return u3.inject(e4, [4, 5, 7, 8, 9, 12, 46], t4, r4);
            }
            getAddress() {
              return this.address;
            }
          }, getPeriodicPaymentWithdrawalTransaction: function(e4, t4, r4, n3) {
            const c4 = i3.readProgram(e4, void 0), u4 = c4[0], l3 = c4[1], h3 = u4[2], p3 = u4[4], f3 = u4[5];
            if (r4 % h3 != 0)
              throw new Error(`firstValid round ${r4.toString()} was not a multiple of contract period ${h3.toString()}`);
            const d3 = l3[1], g3 = o3.encodeAddress(d3), y3 = l3[0], m3 = new Uint8Array(y3), b2 = r4 + p3, A4 = g3;
            let w4, v3;
            const x3 = a3.makeLogicSig(e4, void 0), S2 = x3.address(), E4 = { from: S2, to: A4, fee: t4, amount: f3, closeRemainderTo: w4, firstRound: r4, lastRound: b2, note: v3, genesisHash: n3, genesisID: "", type: "pay", lease: m3 }, T4 = s3.makePaymentTxn(S2, A4, t4, f3, w4, r4, b2, v3, n3, "");
            if (T4.fee > u4[1])
              throw new Error(`final fee of payment transaction${T4.fee.toString()}greater than transaction max fee${u4[1].toString()}`);
            return a3.signLogicSigTransaction(E4, x3);
          } };
        }, 3758: (e3, t3, r3) => {
          var n2 = r3(2486).Buffer;
          const o3 = r3(7116), s3 = r3(1988), i3 = r3(1063), a3 = r3(8800), c3 = r3(5583), u3 = r3(2514), l3 = r3(413);
          e3.exports = { Split: class {
            constructor(e4, t4, r4, o4, s4, i4, c4, l4) {
              if (!Number.isSafeInteger(s4) || s4 < 0)
                throw Error("rat2 must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(o4) || o4 < 0)
                throw Error("rat1 must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(i4) || i4 < 0)
                throw Error("expiryRound must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(c4) || c4 < 0)
                throw Error("minPay must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(l4) || l4 < 0)
                throw Error("maxFee must be a positive number and smaller than 2^53-1");
              const h3 = n2.from("ASAIAQUCAAYHCAkmAyCztwQn0+DycN+vsk+vJWcsoz/b7NDS6i33HOkvTpf+YiC3qUpIgHGWE8/1LPh9SGCalSN7IaITeeWSXbfsS5wsXyC4kBQ38Z8zcwWVAym4S8vpFB/c0XC6R4mnPi9EBADsPDEQIhIxASMMEDIEJBJAABkxCSgSMQcyAxIQMQglEhAxAiEEDRAiQAAuMwAAMwEAEjEJMgMSEDMABykSEDMBByoSEDMACCEFCzMBCCEGCxIQMwAIIQcPEBA=", "base64"), p3 = [l4, i4, s4, o4, c4, e4, t4, r4], f3 = [u3.valTypes.INT, u3.valTypes.INT, u3.valTypes.INT, u3.valTypes.INT, u3.valTypes.INT, u3.valTypes.ADDRESS, u3.valTypes.ADDRESS, u3.valTypes.ADDRESS], d3 = u3.inject(h3, [4, 7, 8, 9, 10, 14, 47, 80], p3, f3);
              this.programBytes = d3;
              const g3 = a3.makeLogicSig(d3, void 0);
              this.address = g3.address();
            }
            getProgram() {
              return this.programBytes;
            }
            getAddress() {
              return this.address;
            }
          }, getSplitFundsTransaction: function(e4, t4, r4, n3, u4, h3) {
            const p3 = c3.readProgram(e4, void 0), f3 = p3[0], d3 = p3[1];
            let g3 = f3[6], y3 = f3[5], m3 = 0;
            const b2 = (e5, t5) => {
              if (typeof e5 != "number" || typeof t5 != "number")
                throw new Error("gcd operates only on positive integers");
              return t5 ? b2(t5, e5 % t5) : e5;
            }, A4 = b2(g3, y3);
            g3 = Math.floor(g3 / A4), y3 = Math.floor(y3 / A4);
            const w4 = y3 / g3;
            m3 = Math.round(t4 / (1 + w4));
            const v3 = t4 - m3;
            if (y3 * m3 != g3 * v3)
              throw Error("could not split funds in a way that satisfied the contract ratio");
            const x3 = a3.makeLogicSig(e4, void 0).address(), S2 = o3.encodeAddress(d3[1]), E4 = o3.encodeAddress(d3[2]), T4 = [s3.makePaymentTxn(x3, S2, u4, m3, void 0, r4, n3, void 0, h3), s3.makePaymentTxn(x3, E4, u4, v3, void 0, r4, n3, void 0, h3)], _4 = i3.assignGroupID(T4).map((e5) => a3.signLogicSigTransactionObject(e5, a3).blob);
            return l3.concatArrays(_4[0], _4[1]);
          } };
        }, 2514: (e3, t3, r3) => {
          var n2 = r3(2486).Buffer;
          const o3 = r3(7116);
          function s3(e4, t4) {
            let r4 = 0;
            for (; t4 > 128; )
              e4.push(255 & t4 | 128), t4 >>= 7, r4 += 1;
            return e4.push(255 & t4), r4 + 1;
          }
          const i3 = { INT: 1, ADDRESS: 2, BASE64: 3 };
          e3.exports = { inject: function(e4, t4, r4, a3) {
            if (t4.length !== r4.length || t4.length !== a3.length)
              throw new Error("Lengths do not match");
            let c3 = e4;
            function u3(e5, t5, r5, o4) {
              const s4 = e5.slice(0, r5), i4 = e5.slice(r5 + o4, e5.length), a4 = [s4, n2.from(t5), i4];
              return n2.concat(a4);
            }
            for (let e5 = 0; e5 < t4.length; e5++) {
              let l3 = 0, h3 = r4[e5];
              switch (a3[e5]) {
                case i3.INT:
                  const r5 = [];
                  l3 = s3(r5, h3), c3 = u3(c3, r5, t4[e5], 1);
                  break;
                case i3.ADDRESS:
                  h3 = o3.decodeAddress(h3), c3 = u3(c3, h3.publicKey, t4[e5], 32);
                  break;
                case i3.BASE64:
                  const a4 = [];
                  h3 = n2.from(h3, "base64"), s3(a4, h3.length), h3 = n2.concat([n2.from(a4), h3]), c3 = u3(c3, h3, t4[e5], 33);
                  break;
                default:
                  throw new Error("unrecognized value type");
              }
              if (l3 !== 0)
                for (let e6 = 0; e6 < t4.length; e6++)
                  t4[e6] += l3 - 1;
            }
            return c3;
          }, valTypes: i3 };
        }, 7677: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { JQ: () => m3, _4: () => x3, X3: () => v3, R0: () => b2, jD: () => A4, Yh: () => O2, bL: () => D3, Ls: () => R2, UV: () => B2, Ax: () => w4, A9: () => _4, w1: () => S2, NK: () => d3, RY: () => y3, Pu: () => g3, Vk: () => c3, nh: () => h3, kG: () => a3, qH: () => l3, JH: () => u3, vJ: () => I3, o5: () => C3, AE: () => k3 });
          var n2 = r3(7116), o3 = r3(8922), s3 = r3(413), i3 = r3(2486).Buffer;
          const a3 = 65535, c3 = 32, u3 = 1, l3 = 1, h3 = 2, p3 = /^([a-z\d[\](),]+)\[([1-9][\d]*)]$/, f3 = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/;
          class d3 {
            static from(e4) {
              if (e4.endsWith("[]")) {
                const t4 = d3.from(e4.slice(0, e4.length - 2));
                return new x3(t4);
              }
              if (e4.endsWith("]")) {
                const t4 = e4.match(p3);
                if (t4.length !== 3)
                  throw new Error(`malformed static array string: ${e4}`);
                const r4 = t4[2], n3 = parseInt(r4, 10);
                if (n3 > a3)
                  throw new Error(`array length exceeds limit ${a3}`);
                const o4 = d3.from(t4[1]);
                return new v3(o4, n3);
              }
              if (e4.startsWith("uint")) {
                const t4 = (e5) => [...e5].every((e6) => "0123456789".includes(e6)), r4 = e4.slice(4, e4.length);
                if (!t4(r4))
                  throw new Error(`malformed uint string: ${r4}`);
                const n3 = parseInt(r4, 10);
                if (n3 > a3)
                  throw new Error(`malformed uint string: ${n3}`);
                return new g3(n3);
              }
              if (e4 === "byte")
                return new A4();
              if (e4.startsWith("ufixed")) {
                const t4 = e4.match(f3);
                if (t4.length !== 3)
                  throw new Error(`malformed ufixed type: ${e4}`);
                const r4 = parseInt(t4[1], 10), n3 = parseInt(t4[2], 10);
                return new y3(r4, n3);
              }
              if (e4 === "bool")
                return new b2();
              if (e4 === "address")
                return new m3();
              if (e4 === "string")
                return new w4();
              if (e4.length >= 2 && e4[0] === "(" && e4[e4.length - 1] === ")") {
                const t4 = S2.parseTupleContent(e4.slice(1, e4.length - 1)), r4 = [];
                for (let e5 = 0; e5 < t4.length; e5++) {
                  const n3 = d3.from(t4[e5]);
                  r4.push(n3);
                }
                return new S2(r4);
              }
              throw new Error(`cannot convert a string ${e4} to an ABI type`);
            }
          }
          class g3 extends d3 {
            constructor(e4) {
              if (super(), e4 % 8 != 0 || e4 < 8 || e4 > 512)
                throw new Error(`unsupported uint type bitSize: ${e4}`);
              this.bitSize = e4;
            }
            toString() {
              return `uint${this.bitSize}`;
            }
            equals(e4) {
              return e4 instanceof g3 && this.bitSize === e4.bitSize;
            }
            isDynamic() {
              return false;
            }
            byteLen() {
              return this.bitSize / 8;
            }
            encode(e4) {
              if (typeof e4 != "bigint" && typeof e4 != "number")
                throw new Error(`Cannot encode value as uint${this.bitSize}: ${e4}`);
              if (e4 >= BigInt(2 ** this.bitSize) || e4 < BigInt(0))
                throw new Error(`${e4} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
              if (typeof e4 == "number" && !Number.isSafeInteger(e4))
                throw new Error(`${e4} should be converted into a BigInt before it is encoded`);
              return (0, o3.j)(e4, this.bitSize / 8);
            }
            decode(e4) {
              if (e4.length !== this.bitSize / 8)
                throw new Error(`byte string must correspond to a uint${this.bitSize}`);
              return (0, o3.v)(e4);
            }
          }
          class y3 extends d3 {
            constructor(e4, t4) {
              if (super(), e4 % 8 != 0 || e4 < 8 || e4 > 512)
                throw new Error(`unsupported ufixed type bitSize: ${e4}`);
              if (t4 > 160 || t4 < 1)
                throw new Error(`unsupported ufixed type precision: ${t4}`);
              this.bitSize = e4, this.precision = t4;
            }
            toString() {
              return `ufixed${this.bitSize}x${this.precision}`;
            }
            equals(e4) {
              return e4 instanceof y3 && this.bitSize === e4.bitSize && this.precision === e4.precision;
            }
            isDynamic() {
              return false;
            }
            byteLen() {
              return this.bitSize / 8;
            }
            encode(e4) {
              if (typeof e4 != "bigint" && typeof e4 != "number")
                throw new Error(`Cannot encode value as ${this.toString()}: ${e4}`);
              if (e4 >= BigInt(2 ** this.bitSize) || e4 < BigInt(0))
                throw new Error(`${e4} is not a non-negative int or too big to fit in size ${this.toString()}`);
              if (typeof e4 == "number" && !Number.isSafeInteger(e4))
                throw new Error(`${e4} should be converted into a BigInt before it is encoded`);
              return (0, o3.j)(e4, this.bitSize / 8);
            }
            decode(e4) {
              if (e4.length !== this.bitSize / 8)
                throw new Error(`byte string must correspond to a ${this.toString()}`);
              return (0, o3.v)(e4);
            }
          }
          class m3 extends d3 {
            toString() {
              return "address";
            }
            equals(e4) {
              return e4 instanceof m3;
            }
            isDynamic() {
              return false;
            }
            byteLen() {
              return c3;
            }
            encode(e4) {
              if (typeof e4 != "string" && !(e4 instanceof Uint8Array))
                throw new Error(`Cannot encode value as ${this.toString()}: ${e4}`);
              if (typeof e4 == "string")
                return (0, n2.decodeAddress)(e4).publicKey;
              if (e4.byteLength !== 32)
                throw new Error("byte string must be 32 bytes long for an address");
              return e4;
            }
            decode(e4) {
              if (e4.byteLength !== 32)
                throw new Error("byte string must be 32 bytes long for an address");
              return (0, n2.encodeAddress)(e4);
            }
          }
          class b2 extends d3 {
            toString() {
              return "bool";
            }
            equals(e4) {
              return e4 instanceof b2;
            }
            isDynamic() {
              return false;
            }
            byteLen() {
              return l3;
            }
            encode(e4) {
              if (typeof e4 != "boolean")
                throw new Error(`Cannot encode value as bool: ${e4}`);
              return e4 ? new Uint8Array([128]) : new Uint8Array([0]);
            }
            decode(e4) {
              if (e4.byteLength !== 1)
                throw new Error("bool string must be 1 byte long");
              const t4 = e4[0];
              if (t4 === 128)
                return true;
              if (t4 === 0)
                return false;
              throw new Error("boolean could not be decoded from the byte string");
            }
          }
          class A4 extends d3 {
            toString() {
              return "byte";
            }
            equals(e4) {
              return e4 instanceof A4;
            }
            isDynamic() {
              return false;
            }
            byteLen() {
              return u3;
            }
            encode(e4) {
              if (typeof e4 != "number" && typeof e4 != "bigint")
                throw new Error(`Cannot encode value as byte: ${e4}`);
              if (typeof e4 == "bigint" && (e4 = Number(e4)), e4 < 0 || e4 > 255)
                throw new Error(`${e4} cannot be encoded into a byte`);
              return new Uint8Array([e4]);
            }
            decode(e4) {
              if (e4.byteLength !== 1)
                throw new Error("byte string must be 1 byte long");
              return e4[0];
            }
          }
          class w4 extends d3 {
            toString() {
              return "string";
            }
            equals(e4) {
              return e4 instanceof w4;
            }
            isDynamic() {
              return true;
            }
            byteLen() {
              throw new Error(`${this.toString()} is a dynamic type`);
            }
            encode(e4) {
              if (typeof e4 != "string" && !(e4 instanceof Uint8Array))
                throw new Error(`Cannot encode value as string: ${e4}`);
              const t4 = i3.from(e4), r4 = (0, o3.j)(e4.length, h3), n3 = new Uint8Array(e4.length + h3);
              return n3.set(r4), n3.set(t4, h3), n3;
            }
            decode(e4) {
              if (e4.length < h3)
                throw new Error(`byte string is too short to be decoded. Actual length is ${e4.length}, but expected at least ${h3}`);
              const t4 = i3.from(e4).readUIntBE(0, h3), r4 = e4.slice(h3, e4.length);
              if (t4 !== r4.length)
                throw new Error(`string length bytes do not match the actual length of string. Expected ${t4}, got ${r4.length}`);
              return i3.from(r4).toString("utf-8");
            }
          }
          class v3 extends d3 {
            constructor(e4, t4) {
              if (super(), t4 < 1)
                throw new Error(`static array must have a length greater than 0: ${t4}`);
              this.childType = e4, this.staticLength = t4;
            }
            toString() {
              return `${this.childType.toString()}[${this.staticLength}]`;
            }
            equals(e4) {
              return e4 instanceof v3 && this.staticLength === e4.staticLength && this.childType.equals(e4.childType);
            }
            isDynamic() {
              return this.childType.isDynamic();
            }
            byteLen() {
              return this.childType.constructor === b2 ? Math.ceil(this.staticLength / 8) : this.staticLength * this.childType.byteLen();
            }
            encode(e4) {
              if (!(Array.isArray(e4) || e4 instanceof Uint8Array))
                throw new Error(`Cannot encode value as ${this.toString()}: ${e4}`);
              if (e4.length !== this.staticLength)
                throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${e4.length}`);
              return this.toABITupleType().encode(e4);
            }
            decode(e4) {
              return this.toABITupleType().decode(e4);
            }
            toABITupleType() {
              return new S2(Array(this.staticLength).fill(this.childType));
            }
          }
          class x3 extends d3 {
            constructor(e4) {
              super(), this.childType = e4;
            }
            toString() {
              return `${this.childType.toString()}[]`;
            }
            equals(e4) {
              return e4 instanceof x3 && this.childType.equals(e4.childType);
            }
            isDynamic() {
              return true;
            }
            byteLen() {
              throw new Error(`${this.toString()} is a dynamic type`);
            }
            encode(e4) {
              if (!(Array.isArray(e4) || e4 instanceof Uint8Array))
                throw new Error(`Cannot encode value as ${this.toString()}: ${e4}`);
              const t4 = this.toABITupleType(e4.length), r4 = t4.encode(e4), n3 = (0, o3.j)(t4.childTypes.length, h3);
              return (0, s3.concatArrays)(n3, r4);
            }
            decode(e4) {
              const t4 = i3.from(e4).readUIntBE(0, h3);
              return this.toABITupleType(t4).decode(e4.slice(h3, e4.length));
            }
            toABITupleType(e4) {
              return new S2(Array(e4).fill(this.childType));
            }
          }
          class S2 extends d3 {
            constructor(e4) {
              if (super(), e4.length >= a3)
                throw new Error("tuple type child type number larger than maximum uint16 error");
              this.childTypes = e4;
            }
            toString() {
              const e4 = [];
              for (let t4 = 0; t4 < this.childTypes.length; t4++)
                e4[t4] = this.childTypes[t4].toString();
              return `(${e4.join(",")})`;
            }
            equals(e4) {
              return e4 instanceof S2 && this.childTypes.length === e4.childTypes.length && this.childTypes.every((t4, r4) => t4.equals(e4.childTypes[r4]));
            }
            isDynamic() {
              return this.childTypes.some((e4) => e4.isDynamic());
            }
            byteLen() {
              let e4 = 0;
              for (let t4 = 0; t4 < this.childTypes.length; t4++)
                if (this.childTypes[t4].constructor === b2) {
                  const r4 = T4(this.childTypes, t4, 1), n3 = r4 + 1;
                  t4 += r4, e4 += Math.trunc((n3 + 7) / 8);
                } else
                  e4 += this.childTypes[t4].byteLen();
              return e4;
            }
            encode(e4) {
              if (!(Array.isArray(e4) || e4 instanceof Uint8Array))
                throw new Error(`Cannot encode value as ${this.toString()}: ${e4}`);
              const t4 = Array.from(e4);
              if (e4.length > a3)
                throw new Error("length of tuple array should not exceed a uint16");
              const r4 = this.childTypes, n3 = [], i4 = [], c4 = /* @__PURE__ */ new Map();
              let u4 = 0;
              for (; u4 < r4.length; ) {
                const e5 = r4[u4];
                if (e5.isDynamic())
                  c4.set(n3.length, true), n3.push(new Uint8Array([0, 0])), i4.push(e5.encode(t4[u4]));
                else {
                  if (e5.constructor === b2) {
                    const e6 = T4(r4, u4, -1);
                    let s4 = T4(r4, u4, 1);
                    if (e6 % 8 != 0)
                      throw new Error("expected before index should have number of bool mod 8 equal 0");
                    s4 = Math.min(7, s4);
                    const i5 = E4(t4.slice(u4, u4 + s4 + 1));
                    n3.push((0, o3.j)(i5, 1)), u4 += s4;
                  } else {
                    const r5 = e5.encode(t4[u4]);
                    n3.push(r5);
                  }
                  c4.set(u4, false), i4.push(new Uint8Array());
                }
                u4 += 1;
              }
              let l4 = 0;
              for (const e5 of n3)
                l4 += e5.length;
              let p4 = 0;
              for (let e5 = 0; e5 < n3.length; e5++) {
                if (c4.get(e5)) {
                  const t5 = l4 + p4;
                  if (t5 > a3)
                    throw new Error(`byte length of ${t5} should not exceed a uint16`);
                  n3[e5] = (0, o3.j)(t5, h3);
                }
                p4 += i4[e5].length;
              }
              return (0, s3.concatArrays)(...n3, ...i4);
            }
            decode(e4) {
              const t4 = this.childTypes, r4 = [], n3 = [];
              let o4 = 0, s4 = 0;
              const a4 = i3.from(e4);
              for (; o4 < t4.length; ) {
                const i4 = t4[o4];
                if (i4.isDynamic()) {
                  if (e4.slice(s4, e4.length).length < h3)
                    throw new Error("dynamic type in tuple is too short to be decoded");
                  const t5 = a4.readUIntBE(s4, h3);
                  if (r4.length > 0 && (r4[r4.length - 1].right = t5, t5 < r4[r4.length - 1].left))
                    throw new Error("dynamic index segment miscalculation: left is greater than right index");
                  const o5 = { left: t5, right: -1 };
                  r4.push(o5), n3.push(null), s4 += h3;
                } else if (i4.constructor === b2) {
                  const t5 = T4(this.childTypes, o4, -1);
                  let r5 = T4(this.childTypes, o4, 1);
                  if (t5 % 8 != 0)
                    throw new Error("expected before bool number mod 8 === 0");
                  r5 = Math.min(7, r5);
                  for (let t6 = 0; t6 <= r5; t6++) {
                    const r6 = 128 >> t6;
                    (e4[s4] & r6) > 0 ? n3.push(new Uint8Array([128])) : n3.push(new Uint8Array([0]));
                  }
                  o4 += r5, s4 += 1;
                } else {
                  const t5 = i4.byteLen();
                  n3.push(e4.slice(s4, s4 + t5)), s4 += t5;
                }
                if (o4 !== t4.length - 1 && s4 >= e4.length)
                  throw new Error("input byte not enough to decode");
                o4 += 1;
              }
              if (r4.length > 0 && (r4[r4.length - 1].right = e4.length, s4 = e4.length), s4 < e4.length)
                throw new Error("input byte not fully consumed");
              for (let e5 = 0; e5 < r4.length; e5++) {
                const t5 = r4[e5];
                if (t5.left > t5.right)
                  throw new Error("dynamic segment should display a [l, r] space with l <= r");
                if (e5 !== r4.length - 1 && t5.right !== r4[e5 + 1].left)
                  throw new Error("dynamic segment should be consecutive");
              }
              let c4 = 0;
              for (let o5 = 0; o5 < t4.length; o5++)
                t4[o5].isDynamic() && (n3[o5] = e4.slice(r4[c4].left, r4[c4].right), c4 += 1);
              const u4 = [];
              for (let e5 = 0; e5 < t4.length; e5++) {
                const r5 = t4[e5].decode(n3[e5]);
                u4.push(r5);
              }
              return u4;
            }
            static parseTupleContent(e4) {
              if (e4.length === 0)
                return [];
              if (e4.endsWith(",") || e4.startsWith(","))
                throw new Error("tuple string should not start with comma");
              if (e4.includes(",,"))
                throw new Error("tuple string should not have consecutive commas");
              const t4 = [];
              let r4 = 0, n3 = "";
              for (const o4 of e4)
                n3 += o4, o4 === "(" ? r4 += 1 : o4 === ")" ? r4 -= 1 : o4 === "," && r4 === 0 && (t4.push(n3.slice(0, n3.length - 1)), n3 = "");
              if (n3.length !== 0 && t4.push(n3), r4 !== 0)
                throw new Error("tuple string has mismatched parentheses");
              return t4;
            }
          }
          function E4(e4) {
            let t4 = 0;
            if (e4.length > 8)
              throw new Error("value list passed in should be no greater than length 8");
            for (let r4 = 0; r4 < e4.length; r4++) {
              const n3 = e4[r4];
              if (typeof n3 != "boolean")
                throw new Error("non-boolean values cannot be compressed into a byte");
              n3 && (t4 |= 1 << 7 - r4);
            }
            return t4;
          }
          function T4(e4, t4, r4) {
            let n3 = 0;
            for (; ; ) {
              const o4 = t4 + r4 * n3;
              if (e4[o4].constructor !== b2) {
                n3 -= 1;
                break;
              }
              if (o4 !== e4.length - 1 && r4 === 1)
                n3 += 1;
              else {
                if (!(o4 > 0 && r4 === -1))
                  break;
                n3 += 1;
              }
            }
            return n3;
          }
          var _4, B2, U2 = r3(9404);
          function k3(e4) {
            return e4 === _4.any || e4 === _4.pay || e4 === _4.keyreg || e4 === _4.acfg || e4 === _4.axfer || e4 === _4.afrz || e4 === _4.appl;
          }
          function I3(e4, t4) {
            return e4 === _4.any || t4.type && t4.type.toString() === e4.toString();
          }
          function C3(e4) {
            return e4 === B2.account || e4 === B2.application || e4 === B2.asset;
          }
          !function(e4) {
            e4.any = "txn", e4.pay = "pay", e4.keyreg = "keyreg", e4.acfg = "acfg", e4.axfer = "axfer", e4.afrz = "afrz", e4.appl = "appl";
          }(_4 || (_4 = {})), function(e4) {
            e4.account = "account", e4.application = "application", e4.asset = "asset";
          }(B2 || (B2 = {}));
          class R2 {
            constructor(e4) {
              if (typeof e4.name != "string" || typeof e4.returns != "object" || !Array.isArray(e4.args))
                throw new Error("Invalid ABIMethod parameters");
              this.name = e4.name, this.description = e4.desc, this.args = e4.args.map(({ type: e5, name: t4, desc: r4 }) => k3(e5) || C3(e5) ? { type: e5, name: t4, description: r4 } : { type: d3.from(e5), name: t4, description: r4 }), this.returns = { type: e4.returns.type === "void" ? e4.returns.type : d3.from(e4.returns.type), description: e4.returns.desc };
            }
            getSignature() {
              const e4 = this.args.map((e5) => e5.type.toString()).join(","), t4 = this.returns.type.toString();
              return `${this.name}(${e4})${t4}`;
            }
            getSelector() {
              const e4 = (0, U2.genericHash)(this.getSignature());
              return new Uint8Array(e4.slice(0, 4));
            }
            txnCount() {
              let e4 = 1;
              for (const t4 of this.args)
                typeof t4.type == "string" && k3(t4.type) && (e4 += 1);
              return e4;
            }
            toJSON() {
              return { name: this.name, desc: this.description, args: this.args.map(({ type: e4, name: t4, description: r4 }) => ({ type: e4.toString(), name: t4, desc: r4 })), returns: { type: this.returns.type.toString(), desc: this.returns.description } };
            }
            static fromSignature(e4) {
              const { name: t4, args: r4, returns: n3 } = function(e5) {
                const t5 = e5.indexOf("(");
                if (t5 === -1)
                  throw new Error(`Invalid method signature: ${e5}`);
                let r5 = -1, n4 = 0;
                for (let o4 = t5; o4 < e5.length; o4++) {
                  const t6 = e5[o4];
                  if (t6 === "(")
                    n4 += 1;
                  else if (t6 === ")") {
                    if (n4 === 0)
                      break;
                    if (n4 -= 1, n4 === 0) {
                      r5 = o4;
                      break;
                    }
                  }
                }
                if (r5 === -1)
                  throw new Error(`Invalid method signature: ${e5}`);
                return { name: e5.slice(0, t5), args: S2.parseTupleContent(e5.slice(t5 + 1, r5)), returns: e5.slice(r5 + 1) };
              }(e4);
              return new R2({ name: t4, args: r4.map((e5) => ({ type: e5 })), returns: { type: n3 } });
            }
          }
          class O2 {
            constructor(e4) {
              if (typeof e4.name != "string" || !Array.isArray(e4.methods) || e4.networks && typeof e4.networks != "object")
                throw new Error("Invalid ABIContract parameters");
              this.name = e4.name, this.description = e4.desc, this.networks = e4.networks ? { ...e4.networks } : {}, this.methods = e4.methods.map((e5) => new R2(e5));
            }
            toJSON() {
              return { name: this.name, desc: this.description, networks: this.networks, methods: this.methods.map((e4) => e4.toJSON()) };
            }
          }
          class D3 {
            constructor(e4) {
              if (typeof e4.name != "string" || !Array.isArray(e4.methods))
                throw new Error("Invalid ABIInterface parameters");
              this.name = e4.name, this.description = e4.desc, this.methods = e4.methods.map((e5) => new R2(e5));
            }
            toJSON() {
              return { name: this.name, desc: this.description, methods: this.methods.map((e4) => e4.toJSON()) };
            }
          }
        }, 7988: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { Z: () => s3 });
          var n2 = r3(9404), o3 = r3(7116);
          function s3() {
            const e4 = n2.keyPair();
            return { addr: o3.encodeAddress(e4.publicKey), sk: e4.secretKey };
          }
        }, 2691: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { Z: () => c3 });
          var n2 = r3(7116), o3 = r3(3033), s3 = r3(9404), i3 = r3(413), a3 = r3(2486).Buffer;
          class c3 {
            constructor({ bidderKey: e4, bidAmount: t4, bidID: r4, auctionKey: o4, auctionID: s4, maxPrice: i4 }) {
              this.name = "Bid", this.tag = a3.from([97, 66]);
              const c4 = n2.decodeAddress(e4), u3 = n2.decodeAddress(o4);
              if (!Number.isSafeInteger(t4) || t4 < 0)
                throw Error("Bid amount must be positive and 2^53-1");
              if (!Number.isSafeInteger(r4) || r4 < 0)
                throw Error("BidID must be positive and 2^53-1");
              if (!Number.isSafeInteger(s4) || s4 < 0)
                throw Error("auctionID must be positive");
              Object.assign(this, { bidderKey: c4, bidAmount: t4, bidID: r4, auctionKey: u3, auctionID: s4, maxPrice: i4 });
            }
            get_obj_for_encoding() {
              return { bidder: a3.from(this.bidderKey.publicKey), cur: this.bidAmount, price: this.maxPrice, id: this.bidID, auc: a3.from(this.auctionKey.publicKey), aid: this.auctionID };
            }
            signBid(e4) {
              const t4 = o3.encode(this.get_obj_for_encoding()), r4 = a3.from(i3.concatArrays(this.tag, t4)), n3 = s3.sign(r4, e4), c4 = { t: "b", b: { sig: a3.from(n3), bid: this.get_obj_for_encoding() } };
              return new Uint8Array(o3.encode(c4));
            }
          }
        }, 1113: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { default: () => f3 });
          var n2 = r3(413), o3 = r3(1042), s3 = r3.n(o3), i3 = r3(9368), a3 = r3.n(i3), c3 = r3(5391), u3 = r3(2486).Buffer;
          class l3 {
            constructor(e4, t4, r4, n3 = {}) {
              this.defaultHeaders = n3;
              const o4 = new (s3())(t4, {});
              if (r4 !== void 0 && o4.set("port", r4.toString()), o4.protocol.length === 0)
                throw new Error("Invalid base server URL, protocol must be defined.");
              this.baseURL = o4, this.tokenHeader = e4;
            }
            addressWithPath(e4) {
              return new (s3())(a3().posix.join(this.baseURL.pathname, e4), this.baseURL).toString();
            }
            static superagentToHTTPClientResponse(e4) {
              return e4.body instanceof ArrayBuffer && (e4.body = new Uint8Array(e4.body)), e4;
            }
            static formatSuperagentError(e4) {
              if (e4.response)
                try {
                  const t4 = JSON.parse(u3.from(e4.response.body).toString());
                  e4.message = `Network request error. Received status ${e4.response.status}: ${t4.message}`;
                } catch (e5) {
                }
              return e4;
            }
            async get(e4, t4, r4 = {}) {
              const n3 = c3.get(this.addressWithPath(e4)).set(this.tokenHeader).set(this.defaultHeaders).set(r4).responseType("arraybuffer").query(t4);
              try {
                const e5 = await n3;
                return l3.superagentToHTTPClientResponse(e5);
              } catch (e5) {
                throw l3.formatSuperagentError(e5);
              }
            }
            async post(e4, t4, r4, n3 = {}) {
              const o4 = c3.post(this.addressWithPath(e4)).set(this.tokenHeader).set(this.defaultHeaders).set(n3).query(r4).serialize((e5) => e5).responseType("arraybuffer").send(u3.from(t4));
              try {
                const e5 = await o4;
                return l3.superagentToHTTPClientResponse(e5);
              } catch (e5) {
                throw l3.formatSuperagentError(e5);
              }
            }
            async delete(e4, t4, r4, n3 = {}) {
              const o4 = c3.delete(this.addressWithPath(e4)).set(this.tokenHeader).set(this.defaultHeaders).set(n3).query(r4).serialize((e5) => e5).responseType("arraybuffer").send(u3.from(t4));
              try {
                const e5 = await o4;
                return l3.superagentToHTTPClientResponse(e5);
              } catch (e5) {
                throw l3.formatSuperagentError(e5);
              }
            }
          }
          var h3 = r3(2486).Buffer;
          function p3(e4) {
            return Object.keys(e4).reduce((t4, r4) => (t4[r4.toLowerCase()] = e4[r4], t4), {});
          }
          class f3 {
            constructor(e4, t4, r4, n3 = {}) {
              this.bc = t4 !== void 0 ? new l3(e4, t4, r4, n3) : e4;
            }
            static parseJSON(e4, t4, r4 = {}) {
              try {
                return Object.keys(r4).length === 0 ? e4 && JSON.parse(e4) : e4 && n2.parseJSON(e4, r4);
              } catch (r5) {
                const n3 = r5;
                throw n3.rawResponse = e4 || null, n3.statusCode = t4, n3;
              }
            }
            static serializeData(e4, t4) {
              if (!e4)
                return new Uint8Array(0);
              if (t4["content-type"] === "application/json")
                return new Uint8Array(h3.from(JSON.stringify(e4)));
              if (typeof e4 == "string")
                return new Uint8Array(h3.from(e4));
              if (e4 instanceof Uint8Array)
                return e4;
              throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
            }
            static prepareResponse(e4, t4, r4 = {}) {
              let n3, { body: o4 } = e4;
              return t4 !== "application/msgpack" && (n3 = o4 && h3.from(o4).toString() || ""), t4 === "application/json" && (o4 = f3.parseJSON(n3, e4.status, r4)), { ...e4, body: o4, text: n3, ok: Math.trunc(e4.status / 100) === 2 };
            }
            static prepareResponseError(e4) {
              return e4.response && (e4.response = f3.prepareResponse(e4.response, "application/json"), e4.status = e4.response.status), e4;
            }
            async get(e4, t4, r4 = {}, n3 = {}) {
              const o4 = function(e5) {
                if (e5 === void 0 || !Object.prototype.hasOwnProperty.call(e5, "format"))
                  return "application/json";
                switch (e5.format) {
                  case "msgpack":
                    return "application/msgpack";
                  case "json":
                  default:
                    return "application/json";
                }
              }(t4), s4 = { ...r4, accept: o4 };
              try {
                const r5 = await this.bc.get(e4, function(e5) {
                  for (const t5 in e5)
                    Object.prototype.hasOwnProperty.call(e5, t5) && (e5[t5] && e5[t5].length !== 0 || delete e5[t5]);
                  return e5;
                }(t4), s4);
                return f3.prepareResponse(r5, o4, n3);
              } catch (e5) {
                throw f3.prepareResponseError(e5);
              }
            }
            async post(e4, t4, r4 = {}) {
              const n3 = { "content-type": "application/json", ...p3(r4) };
              try {
                const r5 = await this.bc.post(e4, f3.serializeData(t4, n3), void 0, n3);
                return f3.prepareResponse(r5, "application/json");
              } catch (e5) {
                throw f3.prepareResponseError(e5);
              }
            }
            async delete(e4, t4, r4 = {}) {
              const n3 = { "content-type": "application/json", ...p3(r4) }, o4 = await this.bc.delete(e4, f3.serializeData(t4, n3), void 0, n3);
              return f3.prepareResponse(o4, "application/json");
            }
          }
        }, 6477: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { Z: () => i3 });
          var n2 = r3(3480), o3 = r3(9417), s3 = r3(2486).Buffer;
          class i3 extends n2.Z {
            constructor(e4, t4 = "http://127.0.0.1", r4 = 7833, n3 = {}) {
              super("X-KMD-API-Token", e4, t4, r4, n3);
            }
            async versions() {
              return (await this.c.get("/versions")).body;
            }
            async listWallets() {
              return (await this.c.get("/v1/wallets")).body;
            }
            async createWallet(e4, t4, r4 = "", n3 = "sqlite") {
              const o4 = { wallet_name: e4, wallet_driver_name: n3, wallet_password: t4, master_derivation_key: s3.from(r4).toString("base64") };
              return (await this.c.post("/v1/wallet", o4)).body;
            }
            async initWalletHandle(e4, t4) {
              const r4 = { wallet_id: e4, wallet_password: t4 };
              return (await this.c.post("/v1/wallet/init", r4)).body;
            }
            async releaseWalletHandle(e4) {
              const t4 = { wallet_handle_token: e4 };
              return (await this.c.post("/v1/wallet/release", t4)).body;
            }
            async renewWalletHandle(e4) {
              const t4 = { wallet_handle_token: e4 };
              return (await this.c.post("/v1/wallet/renew", t4)).body;
            }
            async renameWallet(e4, t4, r4) {
              const n3 = { wallet_id: e4, wallet_password: t4, wallet_name: r4 };
              return (await this.c.post("/v1/wallet/rename", n3)).body;
            }
            async getWallet(e4) {
              const t4 = { wallet_handle_token: e4 };
              return (await this.c.post("/v1/wallet/info", t4)).body;
            }
            async exportMasterDerivationKey(e4, t4) {
              const r4 = { wallet_handle_token: e4, wallet_password: t4 }, n3 = await this.c.post("/v1/master-key/export", r4);
              return { master_derivation_key: s3.from(n3.body.master_derivation_key, "base64") };
            }
            async importKey(e4, t4) {
              const r4 = { wallet_handle_token: e4, private_key: s3.from(t4).toString("base64") };
              return (await this.c.post("/v1/key/import", r4)).body;
            }
            async exportKey(e4, t4, r4) {
              const n3 = { wallet_handle_token: e4, address: r4, wallet_password: t4 }, o4 = await this.c.post("/v1/key/export", n3);
              return { private_key: s3.from(o4.body.private_key, "base64") };
            }
            async generateKey(e4) {
              const t4 = { wallet_handle_token: e4, display_mnemonic: false };
              return (await this.c.post("/v1/key", t4)).body;
            }
            async deleteKey(e4, t4, r4) {
              const n3 = { wallet_handle_token: e4, address: r4, wallet_password: t4 };
              return (await this.c.delete("/v1/key", n3)).body;
            }
            async listKeys(e4) {
              const t4 = { wallet_handle_token: e4 };
              return (await this.c.post("/v1/key/list", t4)).body;
            }
            async signTransaction(e4, t4, r4) {
              const n3 = o3.instantiateTxnIfNeeded(r4), i4 = { wallet_handle_token: e4, wallet_password: t4, transaction: s3.from(n3.toByte()).toString("base64") }, a3 = await this.c.post("/v1/transaction/sign", i4);
              return a3.status === 200 ? s3.from(a3.body.signed_transaction, "base64") : a3.body;
            }
            async signTransactionWithSpecificPublicKey(e4, t4, r4, n3) {
              const i4 = o3.instantiateTxnIfNeeded(r4), a3 = { wallet_handle_token: e4, wallet_password: t4, transaction: s3.from(i4.toByte()).toString("base64"), public_key: s3.from(n3).toString("base64") }, c3 = await this.c.post("/v1/transaction/sign", a3);
              return c3.status === 200 ? s3.from(c3.body.signed_transaction, "base64") : c3.body;
            }
            async listMultisig(e4) {
              const t4 = { wallet_handle_token: e4 };
              return (await this.c.post("/v1/multisig/list", t4)).body;
            }
            async importMultisig(e4, t4, r4, n3) {
              const o4 = { wallet_handle_token: e4, multisig_version: t4, threshold: r4, pks: n3 };
              return (await this.c.post("/v1/multisig/import", o4)).body;
            }
            async exportMultisig(e4, t4) {
              const r4 = { wallet_handle_token: e4, address: t4 };
              return (await this.c.post("/v1/multisig/export", r4)).body;
            }
            async signMultisigTransaction(e4, t4, r4, n3, i4) {
              const a3 = o3.instantiateTxnIfNeeded(r4), c3 = { wallet_handle_token: e4, transaction: s3.from(a3.toByte()).toString("base64"), public_key: s3.from(n3).toString("base64"), partial_multisig: i4, wallet_password: t4 };
              return (await this.c.post("/v1/multisig/sign", c3)).body;
            }
            async deleteMultisig(e4, t4, r4) {
              const n3 = { wallet_handle_token: e4, address: r4, wallet_password: t4 };
              return (await this.c.delete("/v1/multisig", n3)).body;
            }
          }
        }, 1663: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { Z: () => k3 });
          var n2 = r3(3480), o3 = r3(8680);
          class s3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.account = r4, this.account = r4;
            }
            path() {
              return `/v2/accounts/${this.account}`;
            }
            exclude(e4) {
              return this.query.exclude = e4, this;
            }
          }
          class i3 extends o3.Z {
            constructor(e4, t4, r4, n3) {
              super(e4, t4), this.account = r4, this.assetID = n3, this.account = r4, this.assetID = n3;
            }
            path() {
              return `/v2/accounts/${this.account}/assets/${this.assetID}`;
            }
          }
          class a3 extends o3.Z {
            constructor(e4, t4, r4, n3) {
              super(e4, t4), this.account = r4, this.applicationID = n3, this.account = r4, this.applicationID = n3;
            }
            path() {
              return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
            }
          }
          var c3 = r3(3033);
          class u3 extends o3.Z {
            constructor(e4, t4) {
              if (super(e4), !Number.isInteger(t4))
                throw Error("roundNumber should be an integer");
              this.round = t4, this.query = { format: "msgpack" };
            }
            path() {
              return `/v2/blocks/${this.round}`;
            }
            prepare(e4) {
              if (e4 && e4.byteLength > 0)
                return c3.decode(e4);
            }
          }
          var l3 = r3(2486).Buffer;
          function h3(e4 = {}) {
            let t4 = e4;
            return Object.keys(t4).every((e5) => e5.toLowerCase() !== "content-type") && (t4 = { ...e4 }, t4["Content-Type"] = "text/plain"), t4;
          }
          class p3 extends o3.Z {
            constructor(e4, t4) {
              super(e4), this.source = t4, this.source = t4;
            }
            path() {
              return "/v2/teal/compile";
            }
            async do(e4 = {}) {
              const t4 = h3(e4);
              return (await this.c.post(this.path(), l3.from(this.source), t4)).body;
            }
          }
          var f3 = r3(2486).Buffer;
          class d3 extends o3.Z {
            constructor(e4, t4) {
              super(e4), this.blob = c3.encode(t4.get_obj_for_encoding(true));
            }
            path() {
              return "/v2/teal/dryrun";
            }
            async do(e4 = {}) {
              const t4 = h3(e4);
              return (await this.c.post(this.path(), f3.from(this.blob), t4)).body;
            }
          }
          class g3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.index = r4, this.index = r4;
            }
            path() {
              return `/v2/assets/${this.index}`;
            }
          }
          class y3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.index = r4, this.index = r4;
            }
            path() {
              return `/v2/applications/${this.index}`;
            }
          }
          class m3 extends o3.Z {
            path() {
              return "/health";
            }
            async do(e4 = {}) {
              const t4 = await this.c.get(this.path(), {}, e4);
              if (!t4.ok)
                throw new Error(`Health response: ${t4.status}`);
              return {};
            }
          }
          class b2 extends o3.Z {
            constructor(e4, t4) {
              super(e4), this.txid = t4, this.txid = t4, this.query.format = "msgpack";
            }
            prepare(e4) {
              if (e4 && e4.byteLength > 0)
                return c3.decode(e4);
            }
            path() {
              return `/v2/transactions/pending/${this.txid}`;
            }
            max(e4) {
              return this.query.max = e4, this;
            }
          }
          class A4 extends o3.Z {
            constructor(e4) {
              super(e4), this.query.format = "msgpack";
            }
            path() {
              return "/v2/transactions/pending";
            }
            prepare(e4) {
              if (e4 && e4.byteLength > 0)
                return c3.decode(e4);
            }
            max(e4) {
              return this.query.max = e4, this;
            }
          }
          class w4 extends o3.Z {
            constructor(e4, t4) {
              super(e4), this.address = t4, this.address = t4, this.query.format = "msgpack";
            }
            prepare(e4) {
              if (e4 && e4.byteLength > 0)
                return c3.decode(e4);
            }
            path() {
              return `/v2/accounts/${this.address}/transactions/pending`;
            }
            max(e4) {
              return this.query.max = e4, this;
            }
          }
          var v3 = r3(5180);
          class x3 extends o3.Z {
            path() {
              return "/v2/status";
            }
          }
          class S2 extends o3.Z {
            constructor(e4, t4, r4) {
              if (super(e4, t4), this.round = r4, !Number.isInteger(r4))
                throw Error("round should be an integer");
              this.round = r4;
            }
            path() {
              return `/v2/status/wait-for-block-after/${this.round}`;
            }
          }
          class E4 extends o3.Z {
            path() {
              return "/v2/transactions/params";
            }
            prepare(e4) {
              return { flatFee: false, fee: e4.fee, firstRound: e4["last-round"], lastRound: e4["last-round"] + 1e3, genesisID: e4["genesis-id"], genesisHash: e4["genesis-hash"] };
            }
          }
          class T4 extends o3.Z {
            path() {
              return "/v2/ledger/supply";
            }
          }
          class _4 extends o3.Z {
            path() {
              return "/versions";
            }
          }
          class B2 extends o3.Z {
            path() {
              return "/genesis";
            }
          }
          class U2 extends o3.Z {
            constructor(e4, t4, r4, n3) {
              super(e4, t4), this.round = r4, this.txID = n3, this.round = r4, this.txID = n3;
            }
            path() {
              return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
            }
          }
          class k3 extends n2.Z {
            constructor(e4, t4 = "http://r2.algorand.network", r4 = 4180, n3 = {}) {
              super("X-Algo-API-Token", e4, t4, r4, n3);
            }
            healthCheck() {
              return new m3(this.c);
            }
            versionsCheck() {
              return new _4(this.c);
            }
            sendRawTransaction(e4) {
              return new v3.default(this.c, e4);
            }
            accountInformation(e4) {
              return new s3(this.c, this.intDecoding, e4);
            }
            accountAssetInformation(e4, t4) {
              return new i3(this.c, this.intDecoding, e4, t4);
            }
            accountApplicationInformation(e4, t4) {
              return new a3(this.c, this.intDecoding, e4, t4);
            }
            block(e4) {
              return new u3(this.c, e4);
            }
            pendingTransactionInformation(e4) {
              return new b2(this.c, e4);
            }
            pendingTransactionsInformation() {
              return new A4(this.c);
            }
            pendingTransactionByAddress(e4) {
              return new w4(this.c, e4);
            }
            status() {
              return new x3(this.c, this.intDecoding);
            }
            statusAfterBlock(e4) {
              return new S2(this.c, this.intDecoding, e4);
            }
            getTransactionParams() {
              return new E4(this.c);
            }
            supply() {
              return new T4(this.c, this.intDecoding);
            }
            compile(e4) {
              return new p3(this.c, e4);
            }
            dryrun(e4) {
              return new d3(this.c, e4);
            }
            getAssetByID(e4) {
              return new g3(this.c, this.intDecoding, e4);
            }
            getApplicationByID(e4) {
              return new y3(this.c, this.intDecoding, e4);
            }
            genesis() {
              return new B2(this.c, this.intDecoding);
            }
            getProof(e4, t4) {
              return new U2(this.c, this.intDecoding, e4, t4);
            }
          }
        }, 227: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { Account: () => a3, AccountApplicationResponse: () => c3, AccountAssetResponse: () => u3, AccountParticipation: () => l3, AccountStateDelta: () => h3, Application: () => p3, ApplicationLocalState: () => f3, ApplicationParams: () => d3, ApplicationStateSchema: () => g3, Asset: () => y3, AssetHolding: () => m3, AssetParams: () => b2, BlockResponse: () => A4, BuildVersion: () => w4, CatchpointAbortResponse: () => v3, CatchpointStartResponse: () => x3, CompileResponse: () => S2, DryrunRequest: () => E4, DryrunResponse: () => T4, DryrunSource: () => _4, DryrunState: () => B2, DryrunTxnResult: () => U2, ErrorResponse: () => k3, EvalDelta: () => I3, EvalDeltaKeyValue: () => C3, NodeStatusResponse: () => R2, PendingTransactionResponse: () => O2, PendingTransactionsResponse: () => D3, PostTransactionsResponse: () => N3, ProofResponse: () => P3, SupplyResponse: () => L3, TealKeyValue: () => F3, TealValue: () => z3, TransactionParametersResponse: () => j3, Version: () => M3 });
          var n2 = r3(2486).Buffer;
          function o3(e4, t4) {
            let r4;
            if (e4 instanceof Uint8Array)
              r4 = t4 ? e4 : n2.from(e4).toString("base64");
            else if (typeof e4.get_obj_for_encoding == "function")
              r4 = e4.get_obj_for_encoding(t4);
            else if (Array.isArray(e4)) {
              r4 = [];
              for (const n3 of e4)
                r4.push(o3(n3, t4));
            } else if (typeof e4 == "object") {
              const n3 = {};
              for (const r5 of Object.keys(e4))
                n3[r5] = o3(e4[r5], t4);
              r4 = n3;
            } else {
              if (!function(e5) {
                return e5 === void 0 || e5 == null || typeof e5 != "object" && typeof e5 != "function";
              }(e4))
                throw new Error(`Unsupported value: ${String(e4)}`);
              r4 = e4;
            }
            return r4;
          }
          class s3 {
            get_obj_for_encoding(e4 = false) {
              const t4 = {};
              for (const r4 of Object.keys(this.attribute_map)) {
                const n3 = this.attribute_map[r4], s4 = this[r4];
                s4 !== void 0 && (t4[n3] = s4 === null ? null : o3(s4, e4));
              }
              return t4;
            }
          }
          var i3 = r3(2486).Buffer;
          class a3 extends s3 {
            constructor({ address: e4, amount: t4, amountWithoutPendingRewards: r4, minBalance: n3, pendingRewards: o4, rewards: s4, round: i4, status: a4, totalAppsOptedIn: c4, totalAssetsOptedIn: u4, totalCreatedApps: l4, totalCreatedAssets: h4, appsLocalState: p4, appsTotalExtraPages: f4, appsTotalSchema: d4, assets: g4, authAddr: y4, createdApps: m4, createdAssets: b3, participation: A5, rewardBase: w5, sigType: v4 }) {
              super(), this.address = e4, this.amount = t4, this.amountWithoutPendingRewards = r4, this.minBalance = n3, this.pendingRewards = o4, this.rewards = s4, this.round = i4, this.status = a4, this.totalAppsOptedIn = c4, this.totalAssetsOptedIn = u4, this.totalCreatedApps = l4, this.totalCreatedAssets = h4, this.appsLocalState = p4, this.appsTotalExtraPages = f4, this.appsTotalSchema = d4, this.assets = g4, this.authAddr = y4, this.createdApps = m4, this.createdAssets = b3, this.participation = A5, this.rewardBase = w5, this.sigType = v4, this.attribute_map = { address: "address", amount: "amount", amountWithoutPendingRewards: "amount-without-pending-rewards", minBalance: "min-balance", pendingRewards: "pending-rewards", rewards: "rewards", round: "round", status: "status", totalAppsOptedIn: "total-apps-opted-in", totalAssetsOptedIn: "total-assets-opted-in", totalCreatedApps: "total-created-apps", totalCreatedAssets: "total-created-assets", appsLocalState: "apps-local-state", appsTotalExtraPages: "apps-total-extra-pages", appsTotalSchema: "apps-total-schema", assets: "assets", authAddr: "auth-addr", createdApps: "created-apps", createdAssets: "created-assets", participation: "participation", rewardBase: "reward-base", sigType: "sig-type" };
            }
          }
          class c3 extends s3 {
            constructor(e4, t4, r4) {
              super(), this.round = e4, this.appLocalState = t4, this.createdApp = r4, this.attribute_map = { round: "round", appLocalState: "app-local-state", createdApp: "created-app" };
            }
          }
          class u3 extends s3 {
            constructor(e4, t4, r4) {
              super(), this.round = e4, this.assetHolding = t4, this.createdAsset = r4, this.attribute_map = { round: "round", assetHolding: "asset-holding", createdAsset: "created-asset" };
            }
          }
          class l3 extends s3 {
            constructor({ selectionParticipationKey: e4, voteFirstValid: t4, voteKeyDilution: r4, voteLastValid: n3, voteParticipationKey: o4, stateProofKey: s4 }) {
              super(), this.selectionParticipationKey = typeof e4 == "string" ? new Uint8Array(i3.from(e4, "base64")) : e4, this.voteFirstValid = t4, this.voteKeyDilution = r4, this.voteLastValid = n3, this.voteParticipationKey = typeof o4 == "string" ? new Uint8Array(i3.from(o4, "base64")) : o4, this.stateProofKey = typeof s4 == "string" ? new Uint8Array(i3.from(s4, "base64")) : s4, this.attribute_map = { selectionParticipationKey: "selection-participation-key", voteFirstValid: "vote-first-valid", voteKeyDilution: "vote-key-dilution", voteLastValid: "vote-last-valid", voteParticipationKey: "vote-participation-key", stateProofKey: "state-proof-key" };
            }
          }
          class h3 extends s3 {
            constructor(e4, t4) {
              super(), this.address = e4, this.delta = t4, this.attribute_map = { address: "address", delta: "delta" };
            }
          }
          class p3 extends s3 {
            constructor(e4, t4) {
              super(), this.id = e4, this.params = t4, this.attribute_map = { id: "id", params: "params" };
            }
          }
          class f3 extends s3 {
            constructor(e4, t4, r4) {
              super(), this.id = e4, this.schema = t4, this.keyValue = r4, this.attribute_map = { id: "id", schema: "schema", keyValue: "key-value" };
            }
          }
          class d3 extends s3 {
            constructor({ approvalProgram: e4, clearStateProgram: t4, creator: r4, extraProgramPages: n3, globalState: o4, globalStateSchema: s4, localStateSchema: a4 }) {
              super(), this.approvalProgram = typeof e4 == "string" ? new Uint8Array(i3.from(e4, "base64")) : e4, this.clearStateProgram = typeof t4 == "string" ? new Uint8Array(i3.from(t4, "base64")) : t4, this.creator = r4, this.extraProgramPages = n3, this.globalState = o4, this.globalStateSchema = s4, this.localStateSchema = a4, this.attribute_map = { approvalProgram: "approval-program", clearStateProgram: "clear-state-program", creator: "creator", extraProgramPages: "extra-program-pages", globalState: "global-state", globalStateSchema: "global-state-schema", localStateSchema: "local-state-schema" };
            }
          }
          class g3 extends s3 {
            constructor(e4, t4) {
              super(), this.numUint = e4, this.numByteSlice = t4, this.attribute_map = { numUint: "num-uint", numByteSlice: "num-byte-slice" };
            }
          }
          class y3 extends s3 {
            constructor(e4, t4) {
              super(), this.index = e4, this.params = t4, this.attribute_map = { index: "index", params: "params" };
            }
          }
          class m3 extends s3 {
            constructor(e4, t4, r4) {
              super(), this.amount = e4, this.assetId = t4, this.isFrozen = r4, this.attribute_map = { amount: "amount", assetId: "asset-id", isFrozen: "is-frozen" };
            }
          }
          class b2 extends s3 {
            constructor({ creator: e4, decimals: t4, total: r4, clawback: n3, defaultFrozen: o4, freeze: s4, manager: a4, metadataHash: c4, name: u4, nameB64: l4, reserve: h4, unitName: p4, unitNameB64: f4, url: d4, urlB64: g4 }) {
              super(), this.creator = e4, this.decimals = t4, this.total = r4, this.clawback = n3, this.defaultFrozen = o4, this.freeze = s4, this.manager = a4, this.metadataHash = typeof c4 == "string" ? new Uint8Array(i3.from(c4, "base64")) : c4, this.name = u4, this.nameB64 = typeof l4 == "string" ? new Uint8Array(i3.from(l4, "base64")) : l4, this.reserve = h4, this.unitName = p4, this.unitNameB64 = typeof f4 == "string" ? new Uint8Array(i3.from(f4, "base64")) : f4, this.url = d4, this.urlB64 = typeof g4 == "string" ? new Uint8Array(i3.from(g4, "base64")) : g4, this.attribute_map = { creator: "creator", decimals: "decimals", total: "total", clawback: "clawback", defaultFrozen: "default-frozen", freeze: "freeze", manager: "manager", metadataHash: "metadata-hash", name: "name", nameB64: "name-b64", reserve: "reserve", unitName: "unit-name", unitNameB64: "unit-name-b64", url: "url", urlB64: "url-b64" };
            }
          }
          class A4 extends s3 {
            constructor(e4, t4) {
              super(), this.block = e4, this.cert = t4, this.attribute_map = { block: "block", cert: "cert" };
            }
          }
          class w4 extends s3 {
            constructor({ branch: e4, buildNumber: t4, channel: r4, commitHash: n3, major: o4, minor: s4 }) {
              super(), this.branch = e4, this.buildNumber = t4, this.channel = r4, this.commitHash = n3, this.major = o4, this.minor = s4, this.attribute_map = { branch: "branch", buildNumber: "build_number", channel: "channel", commitHash: "commit_hash", major: "major", minor: "minor" };
            }
          }
          class v3 extends s3 {
            constructor(e4) {
              super(), this.catchupMessage = e4, this.attribute_map = { catchupMessage: "catchup-message" };
            }
          }
          class x3 extends s3 {
            constructor(e4) {
              super(), this.catchupMessage = e4, this.attribute_map = { catchupMessage: "catchup-message" };
            }
          }
          class S2 extends s3 {
            constructor(e4, t4) {
              super(), this.hash = e4, this.result = t4, this.attribute_map = { hash: "hash", result: "result" };
            }
          }
          class E4 extends s3 {
            constructor({ accounts: e4, apps: t4, latestTimestamp: r4, protocolVersion: n3, round: o4, sources: s4, txns: i4 }) {
              super(), this.accounts = e4, this.apps = t4, this.latestTimestamp = r4, this.protocolVersion = n3, this.round = o4, this.sources = s4, this.txns = i4, this.attribute_map = { accounts: "accounts", apps: "apps", latestTimestamp: "latest-timestamp", protocolVersion: "protocol-version", round: "round", sources: "sources", txns: "txns" };
            }
          }
          class T4 extends s3 {
            constructor(e4, t4, r4) {
              super(), this.error = e4, this.protocolVersion = t4, this.txns = r4, this.attribute_map = { error: "error", protocolVersion: "protocol-version", txns: "txns" };
            }
          }
          class _4 extends s3 {
            constructor(e4, t4, r4, n3) {
              super(), this.fieldName = e4, this.source = t4, this.txnIndex = r4, this.appIndex = n3, this.attribute_map = { fieldName: "field-name", source: "source", txnIndex: "txn-index", appIndex: "app-index" };
            }
          }
          class B2 extends s3 {
            constructor({ line: e4, pc: t4, stack: r4, error: n3, scratch: o4 }) {
              super(), this.line = e4, this.pc = t4, this.stack = r4, this.error = n3, this.scratch = o4, this.attribute_map = { line: "line", pc: "pc", stack: "stack", error: "error", scratch: "scratch" };
            }
          }
          class U2 extends s3 {
            constructor({ disassembly: e4, appCallMessages: t4, appCallTrace: r4, cost: n3, globalDelta: o4, localDeltas: s4, logicSigDisassembly: i4, logicSigMessages: a4, logicSigTrace: c4, logs: u4 }) {
              super(), this.disassembly = e4, this.appCallMessages = t4, this.appCallTrace = r4, this.cost = n3, this.globalDelta = o4, this.localDeltas = s4, this.logicSigDisassembly = i4, this.logicSigMessages = a4, this.logicSigTrace = c4, this.logs = u4, this.attribute_map = { disassembly: "disassembly", appCallMessages: "app-call-messages", appCallTrace: "app-call-trace", cost: "cost", globalDelta: "global-delta", localDeltas: "local-deltas", logicSigDisassembly: "logic-sig-disassembly", logicSigMessages: "logic-sig-messages", logicSigTrace: "logic-sig-trace", logs: "logs" };
            }
          }
          class k3 extends s3 {
            constructor(e4, t4) {
              super(), this.message = e4, this.data = t4, this.attribute_map = { message: "message", data: "data" };
            }
          }
          class I3 extends s3 {
            constructor(e4, t4, r4) {
              super(), this.action = e4, this.bytes = t4, this.uint = r4, this.attribute_map = { action: "action", bytes: "bytes", uint: "uint" };
            }
          }
          class C3 extends s3 {
            constructor(e4, t4) {
              super(), this.key = e4, this.value = t4, this.attribute_map = { key: "key", value: "value" };
            }
          }
          class R2 extends s3 {
            constructor({ catchupTime: e4, lastRound: t4, lastVersion: r4, nextVersion: n3, nextVersionRound: o4, nextVersionSupported: s4, stoppedAtUnsupportedRound: i4, timeSinceLastRound: a4, catchpoint: c4, catchpointAcquiredBlocks: u4, catchpointProcessedAccounts: l4, catchpointTotalAccounts: h4, catchpointTotalBlocks: p4, catchpointVerifiedAccounts: f4, lastCatchpoint: d4 }) {
              super(), this.catchupTime = e4, this.lastRound = t4, this.lastVersion = r4, this.nextVersion = n3, this.nextVersionRound = o4, this.nextVersionSupported = s4, this.stoppedAtUnsupportedRound = i4, this.timeSinceLastRound = a4, this.catchpoint = c4, this.catchpointAcquiredBlocks = u4, this.catchpointProcessedAccounts = l4, this.catchpointTotalAccounts = h4, this.catchpointTotalBlocks = p4, this.catchpointVerifiedAccounts = f4, this.lastCatchpoint = d4, this.attribute_map = { catchupTime: "catchup-time", lastRound: "last-round", lastVersion: "last-version", nextVersion: "next-version", nextVersionRound: "next-version-round", nextVersionSupported: "next-version-supported", stoppedAtUnsupportedRound: "stopped-at-unsupported-round", timeSinceLastRound: "time-since-last-round", catchpoint: "catchpoint", catchpointAcquiredBlocks: "catchpoint-acquired-blocks", catchpointProcessedAccounts: "catchpoint-processed-accounts", catchpointTotalAccounts: "catchpoint-total-accounts", catchpointTotalBlocks: "catchpoint-total-blocks", catchpointVerifiedAccounts: "catchpoint-verified-accounts", lastCatchpoint: "last-catchpoint" };
            }
          }
          class O2 extends s3 {
            constructor({ poolError: e4, txn: t4, applicationIndex: r4, assetClosingAmount: n3, assetIndex: o4, closeRewards: s4, closingAmount: i4, confirmedRound: a4, globalStateDelta: c4, innerTxns: u4, localStateDelta: l4, logs: h4, receiverRewards: p4, senderRewards: f4 }) {
              super(), this.poolError = e4, this.txn = t4, this.applicationIndex = r4, this.assetClosingAmount = n3, this.assetIndex = o4, this.closeRewards = s4, this.closingAmount = i4, this.confirmedRound = a4, this.globalStateDelta = c4, this.innerTxns = u4, this.localStateDelta = l4, this.logs = h4, this.receiverRewards = p4, this.senderRewards = f4, this.attribute_map = { poolError: "pool-error", txn: "txn", applicationIndex: "application-index", assetClosingAmount: "asset-closing-amount", assetIndex: "asset-index", closeRewards: "close-rewards", closingAmount: "closing-amount", confirmedRound: "confirmed-round", globalStateDelta: "global-state-delta", innerTxns: "inner-txns", localStateDelta: "local-state-delta", logs: "logs", receiverRewards: "receiver-rewards", senderRewards: "sender-rewards" };
            }
          }
          class D3 extends s3 {
            constructor(e4, t4) {
              super(), this.topTransactions = e4, this.totalTransactions = t4, this.attribute_map = { topTransactions: "top-transactions", totalTransactions: "total-transactions" };
            }
          }
          class N3 extends s3 {
            constructor(e4) {
              super(), this.txid = e4, this.attribute_map = { txid: "txId" };
            }
          }
          class P3 extends s3 {
            constructor({ idx: e4, proof: t4, stibhash: r4, treedepth: n3, hashtype: o4 }) {
              super(), this.idx = e4, this.proof = typeof t4 == "string" ? new Uint8Array(i3.from(t4, "base64")) : t4, this.stibhash = typeof r4 == "string" ? new Uint8Array(i3.from(r4, "base64")) : r4, this.treedepth = n3, this.hashtype = o4, this.attribute_map = { idx: "idx", proof: "proof", stibhash: "stibhash", treedepth: "treedepth", hashtype: "hashtype" };
            }
          }
          class L3 extends s3 {
            constructor(e4, t4, r4) {
              super(), this.currentRound = e4, this.onlineMoney = t4, this.totalMoney = r4, this.attribute_map = { currentRound: "current_round", onlineMoney: "online-money", totalMoney: "total-money" };
            }
          }
          class F3 extends s3 {
            constructor(e4, t4) {
              super(), this.key = e4, this.value = t4, this.attribute_map = { key: "key", value: "value" };
            }
          }
          class z3 extends s3 {
            constructor(e4, t4, r4) {
              super(), this.type = e4, this.bytes = t4, this.uint = r4, this.attribute_map = { type: "type", bytes: "bytes", uint: "uint" };
            }
          }
          class j3 extends s3 {
            constructor({ consensusVersion: e4, fee: t4, genesisHash: r4, genesisId: n3, lastRound: o4, minFee: s4 }) {
              super(), this.consensusVersion = e4, this.fee = t4, this.genesisHash = typeof r4 == "string" ? new Uint8Array(i3.from(r4, "base64")) : r4, this.genesisId = n3, this.lastRound = o4, this.minFee = s4, this.attribute_map = { consensusVersion: "consensus-version", fee: "fee", genesisHash: "genesis-hash", genesisId: "genesis-id", lastRound: "last-round", minFee: "min-fee" };
            }
          }
          class M3 extends s3 {
            constructor(e4, t4, r4, n3) {
              super(), this.build = e4, this.genesisHashB64 = typeof t4 == "string" ? new Uint8Array(i3.from(t4, "base64")) : t4, this.genesisId = r4, this.versions = n3, this.attribute_map = { build: "build", genesisHashB64: "genesis_hash_b64", genesisId: "genesis_id", versions: "versions" };
            }
          }
        }, 5180: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { setSendTransactionHeaders: () => i3, default: () => c3 });
          var n2 = r3(8680), o3 = r3(413), s3 = r3(2486).Buffer;
          function i3(e4 = {}) {
            let t4 = e4;
            return Object.keys(t4).every((e5) => e5.toLowerCase() !== "content-type") && (t4 = { ...e4 }, t4["Content-Type"] = "application/x-binary"), t4;
          }
          function a3(e4) {
            return e4 && e4.byteLength !== void 0;
          }
          class c3 extends n2.Z {
            constructor(e4, t4) {
              super(e4);
              let r4 = t4;
              if (Array.isArray(t4)) {
                if (!t4.every(a3))
                  throw new TypeError("Array elements must be byte arrays");
                r4 = (0, o3.concatArrays)(...t4);
              } else if (!a3(r4))
                throw new TypeError("Argument must be byte array");
              this.txnBytesToPost = r4;
            }
            path() {
              return "/v2/transactions";
            }
            async do(e4 = {}) {
              const t4 = i3(e4);
              return (await this.c.post(this.path(), s3.from(this.txnBytesToPost), t4)).body;
            }
          }
        }, 9582: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { Z: () => T4 });
          var n2 = r3(3480), o3 = r3(8680);
          class s3 extends o3.Z {
            path() {
              return "/health";
            }
          }
          class i3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.index = r4, this.index = r4;
            }
            path() {
              return `/v2/assets/${this.index}/balances`;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            currencyGreaterThan(e4) {
              return this.query["currency-greater-than"] = e4, this;
            }
            currencyLessThan(e4) {
              return this.query["currency-less-than"] = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
          }
          var a3 = r3(2486).Buffer;
          function c3(e4) {
            return typeof e4 == "string" ? e4 : a3.from(e4).toString("base64");
          }
          class u3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.account = r4, this.account = r4;
            }
            path() {
              return `/v2/accounts/${this.account}/transactions`;
            }
            notePrefix(e4) {
              return this.query["note-prefix"] = c3(e4), this;
            }
            txType(e4) {
              return this.query["tx-type"] = e4, this;
            }
            sigType(e4) {
              return this.query["sig-type"] = e4, this;
            }
            txid(e4) {
              return this.query.txid = e4, this;
            }
            round(e4) {
              return this.query.round = e4, this;
            }
            minRound(e4) {
              return this.query["min-round"] = e4, this;
            }
            maxRound(e4) {
              return this.query["max-round"] = e4, this;
            }
            assetID(e4) {
              return this.query["asset-id"] = e4, this;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            beforeTime(e4) {
              return this.query["before-time"] = e4, this;
            }
            afterTime(e4) {
              return this.query["after-time"] = e4, this;
            }
            currencyGreaterThan(e4) {
              return this.query["currency-greater-than"] = e4, this;
            }
            currencyLessThan(e4) {
              return this.query["currency-less-than"] = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            rekeyTo(e4) {
              return this.query["rekey-to"] = e4, this;
            }
          }
          class l3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.index = r4, this.index = r4;
            }
            path() {
              return `/v2/assets/${this.index}/transactions`;
            }
            notePrefix(e4) {
              return this.query["note-prefix"] = c3(e4), this;
            }
            txType(e4) {
              return this.query["tx-type"] = e4, this;
            }
            sigType(e4) {
              return this.query["sig-type"] = e4, this;
            }
            txid(e4) {
              return this.query.txid = e4, this;
            }
            round(e4) {
              return this.query.round = e4, this;
            }
            minRound(e4) {
              return this.query["min-round"] = e4, this;
            }
            maxRound(e4) {
              return this.query["max-round"] = e4, this;
            }
            assetID(e4) {
              return this.query["asset-id"] = e4, this;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            beforeTime(e4) {
              return this.query["before-time"] = e4, this;
            }
            afterTime(e4) {
              return this.query["after-time"] = e4, this;
            }
            currencyGreaterThan(e4) {
              return this.query["currency-greater-than"] = e4, this;
            }
            currencyLessThan(e4) {
              return this.query["currency-less-than"] = e4, this;
            }
            addressRole(e4) {
              return this.query["address-role"] = e4, this;
            }
            address(e4) {
              return this.query.address = e4, this;
            }
            excludeCloseTo(e4) {
              return this.query["exclude-close-to"] = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            rekeyTo(e4) {
              return this.query["rekey-to"] = e4, this;
            }
          }
          class h3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.round = r4, this.round = r4;
            }
            path() {
              return `/v2/blocks/${this.round}`;
            }
          }
          class p3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.txID = r4, this.txID = r4;
            }
            path() {
              return `/v2/transactions/${this.txID}`;
            }
          }
          class f3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.account = r4, this.account = r4;
            }
            path() {
              return `/v2/accounts/${this.account}`;
            }
            round(e4) {
              return this.query.round = e4, this;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
            exclude(e4) {
              return this.query.exclude = e4, this;
            }
          }
          class d3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.account = r4, this.account = r4;
            }
            path() {
              return `/v2/accounts/${this.account}/assets`;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            round(e4) {
              return this.query.round = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
            assetId(e4) {
              return this.query["asset-id"] = e4, this;
            }
          }
          class g3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.account = r4, this.account = r4;
            }
            path() {
              return `/v2/accounts/${this.account}/created-assets`;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            round(e4) {
              return this.query.round = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
            assetID(e4) {
              return this.query["asset-id"] = e4, this;
            }
          }
          class y3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.account = r4, this.account = r4;
            }
            path() {
              return `/v2/accounts/${this.account}/apps-local-state`;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            round(e4) {
              return this.query.round = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
            applicationID(e4) {
              return this.query["application-id"] = e4, this;
            }
          }
          class m3 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.account = r4, this.account = r4;
            }
            path() {
              return `/v2/accounts/${this.account}/created-applications`;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            round(e4) {
              return this.query.round = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
            applicationID(e4) {
              return this.query["application-id"] = e4, this;
            }
          }
          class b2 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.index = r4, this.index = r4;
            }
            path() {
              return `/v2/assets/${this.index}`;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
          }
          class A4 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.index = r4, this.index = r4;
            }
            path() {
              return `/v2/applications/${this.index}`;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
          }
          class w4 extends o3.Z {
            constructor(e4, t4, r4) {
              super(e4, t4), this.appID = r4, this.appID = r4;
            }
            path() {
              return `/v2/applications/${this.appID}/logs`;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            minRound(e4) {
              return this.query["min-round"] = e4, this;
            }
            maxRound(e4) {
              return this.query["max-round"] = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            sender(e4) {
              return this.query["sender-address"] = e4, this;
            }
            txid(e4) {
              return this.query.txid = e4, this;
            }
          }
          class v3 extends o3.Z {
            path() {
              return "/v2/accounts";
            }
            currencyGreaterThan(e4) {
              return this.query["currency-greater-than"] = e4, this;
            }
            currencyLessThan(e4) {
              return this.query["currency-less-than"] = e4, this;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            assetID(e4) {
              return this.query["asset-id"] = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            round(e4) {
              return this.query.round = e4, this;
            }
            authAddr(e4) {
              return this.query["auth-addr"] = e4, this;
            }
            applicationID(e4) {
              return this.query["application-id"] = e4, this;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
            exclude(e4) {
              return this.query.exclude = e4, this;
            }
          }
          class x3 extends o3.Z {
            path() {
              return "/v2/transactions";
            }
            notePrefix(e4) {
              return this.query["note-prefix"] = c3(e4), this;
            }
            txType(e4) {
              return this.query["tx-type"] = e4, this;
            }
            sigType(e4) {
              return this.query["sig-type"] = e4, this;
            }
            txid(e4) {
              return this.query.txid = e4, this;
            }
            round(e4) {
              return this.query.round = e4, this;
            }
            minRound(e4) {
              return this.query["min-round"] = e4, this;
            }
            maxRound(e4) {
              return this.query["max-round"] = e4, this;
            }
            assetID(e4) {
              return this.query["asset-id"] = e4, this;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            beforeTime(e4) {
              return this.query["before-time"] = e4, this;
            }
            afterTime(e4) {
              return this.query["after-time"] = e4, this;
            }
            currencyGreaterThan(e4) {
              return this.query["currency-greater-than"] = e4, this;
            }
            currencyLessThan(e4) {
              return this.query["currency-less-than"] = e4, this;
            }
            addressRole(e4) {
              return this.query["address-role"] = e4, this;
            }
            address(e4) {
              return this.query.address = e4, this;
            }
            excludeCloseTo(e4) {
              return this.query["exclude-close-to"] = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            rekeyTo(e4) {
              return this.query["rekey-to"] = e4, this;
            }
            applicationID(e4) {
              return this.query["application-id"] = e4, this;
            }
          }
          class S2 extends o3.Z {
            path() {
              return "/v2/assets";
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            creator(e4) {
              return this.query.creator = e4, this;
            }
            name(e4) {
              return this.query.name = e4, this;
            }
            unit(e4) {
              return this.query.unit = e4, this;
            }
            index(e4) {
              return this.query["asset-id"] = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
          }
          class E4 extends o3.Z {
            path() {
              return "/v2/applications";
            }
            index(e4) {
              return this.query["application-id"] = e4, this;
            }
            creator(e4) {
              return this.query.creator = e4, this;
            }
            nextToken(e4) {
              return this.query.next = e4, this;
            }
            limit(e4) {
              return this.query.limit = e4, this;
            }
            includeAll(e4 = true) {
              return this.query["include-all"] = e4, this;
            }
          }
          class T4 extends n2.Z {
            constructor(e4, t4 = "http://127.0.0.1", r4 = 8080, n3 = {}) {
              super("X-Indexer-API-Token", e4, t4, r4, n3);
            }
            makeHealthCheck() {
              return new s3(this.c, this.intDecoding);
            }
            lookupAssetBalances(e4) {
              return new i3(this.c, this.intDecoding, e4);
            }
            lookupAssetTransactions(e4) {
              return new l3(this.c, this.intDecoding, e4);
            }
            lookupAccountTransactions(e4) {
              return new u3(this.c, this.intDecoding, e4);
            }
            lookupBlock(e4) {
              return new h3(this.c, this.intDecoding, e4);
            }
            lookupTransactionByID(e4) {
              return new p3(this.c, this.intDecoding, e4);
            }
            lookupAccountByID(e4) {
              return new f3(this.c, this.intDecoding, e4);
            }
            lookupAccountAssets(e4) {
              return new d3(this.c, this.intDecoding, e4);
            }
            lookupAccountCreatedAssets(e4) {
              return new g3(this.c, this.intDecoding, e4);
            }
            lookupAccountAppLocalStates(e4) {
              return new y3(this.c, this.intDecoding, e4);
            }
            lookupAccountCreatedApplications(e4) {
              return new m3(this.c, this.intDecoding, e4);
            }
            lookupAssetByID(e4) {
              return new b2(this.c, this.intDecoding, e4);
            }
            lookupApplications(e4) {
              return new A4(this.c, this.intDecoding, e4);
            }
            lookupApplicationLogs(e4) {
              return new w4(this.c, this.intDecoding, e4);
            }
            searchAccounts() {
              return new v3(this.c, this.intDecoding);
            }
            searchForTransactions() {
              return new x3(this.c, this.intDecoding);
            }
            searchForAssets() {
              return new S2(this.c, this.intDecoding);
            }
            searchForApplications() {
              return new E4(this.c, this.intDecoding);
            }
          }
        }, 8680: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { Z: () => o3 });
          var n2 = r3(7197);
          class o3 {
            constructor(e4, t4) {
              this.c = e4, this.query = {}, this.intDecoding = t4 || n2.Z.DEFAULT;
            }
            prepare(e4) {
              return e4;
            }
            async do(e4 = {}) {
              const t4 = {};
              this.intDecoding !== "default" && (t4.intDecoding = this.intDecoding);
              const r4 = await this.c.get(this.path(), this.query, e4, t4);
              return this.prepare(r4.body);
            }
            setIntDecoding(e4) {
              if (e4 !== "default" && e4 !== "safe" && e4 !== "mixed" && e4 !== "bigint")
                throw new Error(`Invalid method for int decoding: ${e4}`);
              return this.intDecoding = e4, this;
            }
          }
        }, 3480: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { Z: () => s3 });
          var n2 = r3(1113), o3 = r3(7197);
          class s3 {
            constructor(e4, t4, r4, s4, i3 = {}) {
              if (typeof t4.get == "function")
                this.c = new n2.default(t4);
              else {
                let o4;
                o4 = typeof t4 == "string" ? function(e5 = "", t5) {
                  const r5 = {};
                  return r5[t5] = e5, r5;
                }(t4, e4) : t4, this.c = new n2.default(o4, r4, s4, i3);
              }
              this.intDecoding = o3.Z.DEFAULT;
            }
            setIntEncoding(e4) {
              this.intDecoding = e4;
            }
            getIntEncoding() {
              return this.intDecoding;
            }
          }
        }, 3458: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { b: () => p3, A: () => d3 });
          var n2 = r3(7677), o3 = r3(9417), s3 = r3(1988), i3 = r3(1063), a3 = r3(5062), c3 = r3(834), u3 = r3(1624), l3 = r3(2486).Buffer;
          const h3 = l3.from([21, 31, 124, 117]);
          var p3;
          function f3(e4, t4, r4) {
            if (r4 != null && e4 === r4)
              return 0;
            const n3 = r4 == null ? 0 : 1;
            for (let r5 = 0; r5 < t4.length; r5++)
              if (e4 === t4[r5])
                return r5 + n3;
            return t4.push(e4), t4.length - 1 + n3;
          }
          !function(e4) {
            e4[e4.BUILDING = 0] = "BUILDING", e4[e4.BUILT = 1] = "BUILT", e4[e4.SIGNED = 2] = "SIGNED", e4[e4.SUBMITTED = 3] = "SUBMITTED", e4[e4.COMMITTED = 4] = "COMMITTED";
          }(p3 || (p3 = {}));
          class d3 {
            constructor() {
              this.status = p3.BUILDING, this.transactions = [], this.methodCalls = /* @__PURE__ */ new Map(), this.signedTxns = [], this.txIDs = [];
            }
            getStatus() {
              return this.status;
            }
            count() {
              return this.transactions.length;
            }
            clone() {
              const e4 = new d3();
              return e4.transactions = this.transactions.map(({ txn: e5, signer: t4 }) => ({ txn: o3.Transaction.from_obj_for_encoding({ ...e5.get_obj_for_encoding(), grp: void 0 }), signer: t4 })), e4.methodCalls = new Map(this.methodCalls), e4;
            }
            addTransaction(e4) {
              if (this.status !== p3.BUILDING)
                throw new Error("Cannot add transactions when composer status is not BUILDING");
              if (this.transactions.length === d3.MAX_GROUP_SIZE)
                throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${d3.MAX_GROUP_SIZE}`);
              if (e4.txn.group && e4.txn.group.some((e5) => e5 !== 0))
                throw new Error("Cannot add a transaction with nonzero group ID");
              this.transactions.push(e4);
            }
            addMethodCall({ appID: e4, method: t4, methodArgs: r4, sender: o4, suggestedParams: i4, onComplete: a4, approvalProgram: l4, clearProgram: h4, numGlobalInts: g3, numGlobalByteSlices: y3, numLocalInts: m3, numLocalByteSlices: b2, extraPages: A4, note: w4, lease: v3, rekeyTo: x3, signer: S2 }) {
              if (this.status !== p3.BUILDING)
                throw new Error("Cannot add transactions when composer status is not BUILDING");
              if (this.transactions.length + t4.txnCount() > d3.MAX_GROUP_SIZE)
                throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${d3.MAX_GROUP_SIZE}`);
              if (e4 === 0) {
                if (l4 == null || h4 == null || g3 == null || y3 == null || m3 == null || b2 == null)
                  throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
              } else if (a4 === u3.hq.UpdateApplicationOC) {
                if (l4 == null || h4 == null)
                  throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
                if (g3 != null || y3 != null || m3 != null || b2 != null || A4 != null)
                  throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
              } else if (l4 != null || h4 != null || g3 != null || y3 != null || m3 != null || b2 != null || A4 != null)
                throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
              if (r4 == null && (r4 = []), r4.length !== t4.args.length)
                throw new Error(`Incorrect number of method arguments. Expected ${t4.args.length}, got ${r4.length}`);
              let E4 = [], T4 = [];
              const _4 = [], B2 = [], U2 = [], k3 = /* @__PURE__ */ new Map();
              for (let e5 = 0; e5 < r4.length; e5++) {
                let o5 = t4.args[e5].type;
                const s4 = r4[e5];
                if ((0, n2.AE)(o5)) {
                  if (!(0, c3.Xw)(s4) || !(0, n2.vJ)(o5, s4.txn))
                    throw new Error(`Expected ${o5} transaction for argument at index ${e5}`);
                  if (s4.txn.group && s4.txn.group.some((e6) => e6 !== 0))
                    throw new Error("Cannot add a transaction with nonzero group ID");
                  _4.push(s4);
                } else {
                  if ((0, c3.Xw)(s4))
                    throw new Error(`Expected non-transaction value for argument at index ${e5}`);
                  if ((0, n2.o5)(o5) && (k3.set(B2.length, E4.length), B2.push(o5), U2.push(s4), o5 = new n2.Pu(8)), typeof o5 == "string")
                    throw new Error(`Unknown ABI type: ${o5}`);
                  E4.push(o5), T4.push(s4);
                }
              }
              const I3 = [], C3 = [], R2 = [], O2 = [];
              for (let t5 = 0; t5 < B2.length; t5++) {
                const r5 = B2[t5], s4 = U2[t5];
                let i5 = 0;
                switch (r5) {
                  case n2.UV.account: {
                    const e5 = new n2.JQ();
                    i5 = f3(e5.decode(e5.encode(s4)), C3, o4);
                    break;
                  }
                  case n2.UV.application: {
                    const t6 = new n2.Pu(64), r6 = t6.decode(t6.encode(s4));
                    if (r6 > Number.MAX_SAFE_INTEGER)
                      throw new Error(`Expected safe integer for application value, got ${r6}`);
                    i5 = f3(Number(r6), R2, e4);
                    break;
                  }
                  case n2.UV.asset: {
                    const e5 = new n2.Pu(64), t6 = e5.decode(e5.encode(s4));
                    if (t6 > Number.MAX_SAFE_INTEGER)
                      throw new Error(`Expected safe integer for asset value, got ${t6}`);
                    i5 = f3(Number(t6), O2);
                    break;
                  }
                  default:
                    throw new Error(`Unknown reference type: ${r5}`);
                }
                I3.push(i5);
              }
              for (let e5 = 0; e5 < I3.length; e5++)
                T4[k3.get(e5)] = I3[e5];
              if (E4.length > 15) {
                const e5 = E4.slice(14), t5 = T4.slice(14);
                E4 = E4.slice(0, 14), T4 = T4.slice(0, 14), E4.push(new n2.w1(e5)), T4.push(t5);
              }
              const D3 = [t4.getSelector()];
              for (let e5 = 0; e5 < E4.length; e5++)
                D3.push(E4[e5].encode(T4[e5]));
              const N3 = { txn: (0, s3.makeApplicationCallTxnFromObject)({ from: o4, appIndex: e4, appArgs: D3, accounts: C3, foreignApps: R2, foreignAssets: O2, onComplete: a4 == null ? u3.hq.NoOpOC : a4, approvalProgram: l4, clearProgram: h4, numGlobalInts: g3, numGlobalByteSlices: y3, numLocalInts: m3, numLocalByteSlices: b2, extraPages: A4, lease: v3, note: w4, rekeyTo: x3, suggestedParams: i4 }), signer: S2 };
              this.transactions.push(..._4, N3), this.methodCalls.set(this.transactions.length - 1, t4);
            }
            buildGroup() {
              if (this.status === p3.BUILDING) {
                if (this.transactions.length === 0)
                  throw new Error("Cannot build a group with 0 transactions");
                this.transactions.length > 1 && (0, i3.assignGroupID)(this.transactions.map((e4) => e4.txn)), this.status = p3.BUILT;
              }
              return this.transactions;
            }
            async gatherSignatures() {
              if (this.status >= p3.SIGNED)
                return this.signedTxns;
              const e4 = this.buildGroup(), t4 = e4.map((e5) => e5.txn), r4 = /* @__PURE__ */ new Map();
              for (let t5 = 0; t5 < e4.length; t5++) {
                const { signer: n4 } = e4[t5];
                r4.has(n4) || r4.set(n4, []), r4.get(n4).push(t5);
              }
              const n3 = Array.from(r4), s4 = await Promise.all(n3.map(([e5, r5]) => e5(t4, r5))), i4 = e4.map(() => null);
              for (let e5 = 0; e5 < n3.length; e5++) {
                const t5 = n3[e5][1], r5 = s4[e5];
                for (let e6 = 0; e6 < t5.length; e6++)
                  i4[t5[e6]] = r5[e6];
              }
              if (!i4.every((e5) => e5 != null))
                throw new Error(`Missing signatures. Got ${i4}`);
              const a4 = i4.map((e5, t5) => {
                try {
                  return (0, o3.decodeSignedTransaction)(e5).txn.txID();
                } catch (e6) {
                  throw new Error(`Cannot decode signed transaction at index ${t5}. ${e6}`);
                }
              });
              return this.signedTxns = i4, this.txIDs = a4, this.status = p3.SIGNED, i4;
            }
            async submit(e4) {
              if (this.status > p3.SUBMITTED)
                throw new Error("Transaction group cannot be resubmitted");
              const t4 = await this.gatherSignatures();
              return await e4.sendRawTransaction(t4).do(), this.status = p3.SUBMITTED, this.txIDs;
            }
            async execute(e4, t4) {
              if (this.status === p3.COMMITTED)
                throw new Error("Transaction group has already been executed successfully");
              const r4 = await this.submit(e4);
              this.status = p3.SUBMITTED;
              const n3 = this.transactions.findIndex((e5, t5) => this.methodCalls.has(t5)), o4 = n3 === -1 ? 0 : n3, s4 = await (0, a3.K)(e4, r4[o4], t4);
              this.status = p3.COMMITTED;
              const i4 = s4["confirmed-round"], c4 = [];
              for (const [t5, o5] of this.methodCalls) {
                const i5 = r4[t5], a4 = { txID: i5, rawReturnValue: new Uint8Array() };
                try {
                  const r5 = t5 === n3 ? s4 : await e4.pendingTransactionInformation(i5).do();
                  if (a4.txInfo = r5, o5.returns.type !== "void") {
                    const e5 = r5.logs || [];
                    if (e5.length === 0)
                      throw new Error("App call transaction did not log a return value");
                    const t6 = l3.from(e5[e5.length - 1], "base64");
                    if (t6.byteLength < 4 || !t6.slice(0, 4).equals(h3))
                      throw new Error("App call transaction did not log a return value");
                    a4.rawReturnValue = new Uint8Array(t6.slice(4)), a4.returnValue = o5.returns.type.decode(a4.rawReturnValue);
                  }
                } catch (e5) {
                  a4.decodeError = e5;
                }
                c4.push(a4);
              }
              return { confirmedRound: i4, txIDs: r4, methodResults: c4 };
            }
          }
          d3.MAX_GROUP_SIZE = 16;
        }, 9070: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { rD: () => o3, _: () => s3, HN: () => i3 });
          const n2 = 1e6, o3 = "Microalgos should be positive and less than 2^53 - 1.";
          function s3(e4) {
            if (e4 < 0 || !Number.isSafeInteger(e4))
              throw new Error(o3);
            return e4 / n2;
          }
          function i3(e4) {
            const t4 = e4 * n2;
            return Math.round(t4);
          }
        }, 4383: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { P: () => c3 });
          var n2 = r3(227), o3 = r3(1824), s3 = r3(7116), i3 = r3(2486).Buffer;
          function a3(e4) {
            return e4.params["approval-program"] = i3.from(e4.params["approval-program"].toString(), "base64"), e4.params["clear-state-program"] = i3.from(e4.params["clear-state-program"].toString(), "base64"), e4;
          }
          async function c3({ client: e4, txns: t4, protocolVersion: r4, latestTimestamp: i4, round: c4, sources: u3 }) {
            const l3 = [], h3 = [], p3 = [], f3 = [], d3 = [];
            for (const e5 of t4)
              e5.txn.type === o3.i.appl && (d3.push((0, s3.encodeAddress)(e5.txn.from.publicKey)), e5.txn.appAccounts && d3.push(...e5.txn.appAccounts.map((e6) => (0, s3.encodeAddress)(e6.publicKey))), e5.txn.appForeignApps && p3.push(...e5.txn.appForeignApps), e5.txn.appForeignAssets && f3.push(...e5.txn.appForeignAssets), e5.txn.appIndex === void 0 || e5.txn.appIndex === 0 ? l3.push(new n2.Application(1380011588, new n2.ApplicationParams({ creator: (0, s3.encodeAddress)(e5.txn.from.publicKey), approvalProgram: e5.txn.appApprovalProgram, clearStateProgram: e5.txn.appClearProgram, localStateSchema: new n2.ApplicationStateSchema(e5.txn.appLocalInts, e5.txn.appLocalByteSlices), globalStateSchema: new n2.ApplicationStateSchema(e5.txn.appGlobalInts, e5.txn.appGlobalByteSlices) }))) : (p3.push(e5.txn.appIndex), d3.push((0, s3.getApplicationAddress)(e5.txn.appIndex))));
            const g3 = [];
            for (const t5 of [...new Set(f3)])
              g3.push(e4.getAssetByID(t5).do().then((e5) => {
                d3.push(e5.params.creator);
              }));
            await Promise.all(g3);
            const y3 = [];
            for (const t5 of [...new Set(p3)])
              y3.push(e4.getApplicationByID(t5).do().then((e5) => {
                const t6 = a3(e5);
                l3.push(t6), d3.push(t6.params.creator);
              }));
            await Promise.all(y3);
            const m3 = [];
            for (const t5 of [...new Set(d3)])
              m3.push(e4.accountInformation(t5).do().then((e5) => {
                "created-apps" in e5 && (e5["created-apps"] = e5["created-apps"].map((e6) => a3(e6))), h3.push(e5);
              }));
            return await Promise.all(m3), new n2.DryrunRequest({ txns: t4.map((e5) => ({ ...e5, txn: e5.txn.get_obj_for_encoding() })), accounts: h3, apps: l3, latestTimestamp: i4, round: c4, protocolVersion: r4, sources: u3 });
          }
        }, 7116: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { ALGORAND_ZERO_ADDRESS_STRING: () => u3, MALFORMED_ADDRESS_ERROR_MSG: () => p3, CHECKSUM_ADDRESS_ERROR_MSG: () => f3, INVALID_MSIG_VERSION_ERROR_MSG: () => d3, INVALID_MSIG_THRESHOLD_ERROR_MSG: () => g3, INVALID_MSIG_PK_ERROR_MSG: () => y3, UNEXPECTED_PK_LEN_ERROR_MSG: () => m3, decodeAddress: () => b2, isValidAddress: () => A4, encodeAddress: () => w4, fromMultisigPreImg: () => v3, fromMultisigPreImgAddrs: () => x3, getApplicationAddress: () => S2 });
          var n2 = r3(7267), o3 = r3.n(n2), s3 = r3(9404), i3 = r3(413), a3 = r3(6963), c3 = r3(2486).Buffer;
          const u3 = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ", l3 = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]), h3 = c3.from("appID"), p3 = "address seems to be malformed", f3 = "wrong checksum for address", d3 = "invalid multisig version", g3 = "bad multisig threshold", y3 = "bad multisig public key - wrong length", m3 = "nacl public key length is not 32 bytes";
          function b2(e4) {
            if (typeof e4 != "string" || e4.length !== 58)
              throw new Error(p3);
            const t4 = o3().decode.asBytes(e4.toString());
            if (t4.length !== 36)
              throw new Error(p3);
            const r4 = new Uint8Array(t4.slice(0, 32)), n3 = new Uint8Array(t4.slice(s3.PUBLIC_KEY_LENGTH, 36)), a4 = s3.genericHash(r4).slice(s3.HASH_BYTES_LENGTH - 4, s3.HASH_BYTES_LENGTH);
            if (!i3.arrayEqual(a4, n3))
              throw new Error(f3);
            return { publicKey: r4, checksum: n3 };
          }
          function A4(e4) {
            try {
              b2(e4);
            } catch (e5) {
              return false;
            }
            return true;
          }
          function w4(e4) {
            const t4 = s3.genericHash(e4).slice(s3.PUBLIC_KEY_LENGTH - 4, s3.PUBLIC_KEY_LENGTH);
            return o3().encode(i3.concatArrays(e4, t4)).toString().slice(0, 58);
          }
          function v3({ version: e4, threshold: t4, pks: r4 }) {
            if (e4 !== 1 || e4 > 255 || e4 < 0)
              throw new Error(d3);
            if (t4 === 0 || r4.length === 0 || t4 > r4.length || t4 > 255)
              throw new Error(g3);
            if (s3.PUBLIC_KEY_LENGTH !== 32)
              throw new Error(m3);
            const n3 = new Uint8Array(l3.length + 2 + 32 * r4.length);
            n3.set(l3, 0), n3.set([e4], l3.length), n3.set([t4], l3.length + 1);
            for (let e5 = 0; e5 < r4.length; e5++) {
              if (r4[e5].length !== 32)
                throw new Error(y3);
              n3.set(r4[e5], l3.length + 2 + 32 * e5);
            }
            return new Uint8Array(s3.genericHash(n3));
          }
          function x3({ version: e4, threshold: t4, addrs: r4 }) {
            return w4(v3({ version: e4, threshold: t4, pks: r4.map((e5) => b2(e5).publicKey) }));
          }
          function S2(e4) {
            const t4 = i3.concatArrays(h3, (0, a3.T)(e4)), r4 = s3.genericHash(t4);
            return w4(new Uint8Array(r4));
          }
        }, 8922: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { j: () => o3, v: () => s3 });
          var n2 = r3(2486).Buffer;
          function o3(e4, t4) {
            let r4 = e4.toString(16);
            r4.length !== 2 * t4 && (r4 = r4.padStart(2 * t4, "0"));
            const n3 = new Uint8Array(r4.length / 2);
            for (let e5 = 0, t5 = 0; e5 < r4.length / 2; e5++, t5 += 2)
              n3[e5] = parseInt(r4.slice(t5, t5 + 2), 16);
            return n3;
          }
          function s3(e4) {
            let t4 = BigInt(0);
            const r4 = n2.from(e4);
            for (let n3 = 0; n3 < e4.length; n3++)
              t4 = BigInt(Number(r4.readUIntBE(n3, 1))) + t4 * BigInt(256);
            return t4;
          }
        }, 3033: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { ERROR_CONTAINS_EMPTY_STRING: () => o3, encode: () => s3, decode: () => i3 });
          var n2 = r3(5406);
          const o3 = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
          function s3(e4) {
            const t4 = function(e5) {
              for (const t5 in e5)
                if (Object.prototype.hasOwnProperty.call(e5, t5) && (!e5[t5] || e5[t5].length === 0))
                  return { containsEmpty: true, firstEmptyKey: t5 };
              return { containsEmpty: false, firstEmptyKey: void 0 };
            }(e4);
            if (t4.containsEmpty)
              throw new Error(o3 + t4.firstEmptyKey);
            return n2.encode(e4, { sortKeys: true });
          }
          function i3(e4) {
            return n2.decode(e4);
          }
        }, 6963: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { T: () => o3, u: () => s3 });
          var n2 = r3(2486).Buffer;
          function o3(e4) {
            if (typeof e4 != "bigint" && !Number.isInteger(e4) || e4 < 0 || e4 > BigInt("0xffffffffffffffff"))
              throw new Error("Input is not a 64-bit unsigned integer");
            const t4 = n2.allocUnsafe(8);
            return t4.writeBigUInt64BE(BigInt(e4)), new Uint8Array(t4);
          }
          function s3(e4, t4 = "safe") {
            if (t4 !== "safe" && t4 !== "mixed" && t4 !== "bigint")
              throw new Error(`Unknown decodingMode option: ${t4}`);
            if (e4.byteLength === 0 || e4.byteLength > 8)
              throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${e4.byteLength}`);
            const r4 = n2.allocUnsafe(8 - e4.byteLength);
            r4.fill(0);
            const o4 = n2.concat([r4, n2.from(e4)]).readBigUInt64BE(), s4 = o4 > Number.MAX_SAFE_INTEGER;
            if (t4 === "safe") {
              if (s4)
                throw new Error(`Integer exceeds maximum safe integer: ${o4.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
              return Number(o4);
            }
            return t4 !== "mixed" || s4 ? o4 : Number(o4);
          }
        }, 1063: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { TxGroup: () => u3, computeGroupID: () => l3, assignGroupID: () => h3, default: () => p3 });
          var n2 = r3(9417), o3 = r3(9404), s3 = r3(3033), i3 = r3(7116), a3 = r3(413), c3 = r3(2486).Buffer;
          class u3 {
            constructor(e4) {
              if (this.name = "Transaction group", this.tag = c3.from("TG"), e4.length > 16) {
                const t4 = `${e4.length.toString()} transactions grouped together but max group size is ${16 .toString()}`;
                throw Error(t4);
              }
              this.txGroupHashes = e4;
            }
            get_obj_for_encoding() {
              return { txlist: this.txGroupHashes };
            }
            static from_obj_for_encoding(e4) {
              const t4 = Object.create(this.prototype);
              t4.name = "Transaction group", t4.tag = c3.from("TG"), t4.txGroupHashes = [];
              for (const r4 of e4.txlist)
                t4.txGroupHashes.push(c3.from(r4));
              return t4;
            }
            toByte() {
              return s3.encode(this.get_obj_for_encoding());
            }
          }
          function l3(e4) {
            const t4 = [];
            for (const r5 of e4) {
              const e5 = n2.instantiateTxnIfNeeded(r5);
              t4.push(e5.rawTxID());
            }
            const r4 = new u3(t4), s4 = r4.toByte(), i4 = c3.from(a3.concatArrays(r4.tag, s4)), l4 = o3.genericHash(i4);
            return c3.from(l4);
          }
          function h3(e4, t4) {
            const r4 = l3(e4), o4 = [];
            for (const s4 of e4) {
              const e5 = n2.instantiateTxnIfNeeded(s4);
              t4 && i3.encodeAddress(e5.from.publicKey) !== t4 || (e5.group = r4, o4.push(e5));
            }
            return o4;
          }
          const p3 = u3;
        }, 5583: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { checkByteConstBlock: () => f3, checkIntConstBlock: () => p3, checkProgram: () => h3, checkPushByteOp: () => g3, checkPushIntOp: () => d3, langspecEvalMaxVersion: () => y3, langspecLogicSigVersion: () => m3, parseUvarint: () => s3, readProgram: () => l3 });
          const n2 = JSON.parse('{"z_":6,"BV":5,"AP":[{"Opcode":0,"Name":"err","Cost":1,"Size":1,"Doc":"Fail immediately.","Groups":["Flow Control"]},{"Opcode":1,"Name":"sha256","Args":"B","Returns":"B","Cost":35,"Size":1,"Doc":"SHA256 hash of value A, yields [32]byte","Groups":["Arithmetic"]},{"Opcode":2,"Name":"keccak256","Args":"B","Returns":"B","Cost":130,"Size":1,"Doc":"Keccak256 hash of value A, yields [32]byte","Groups":["Arithmetic"]},{"Opcode":3,"Name":"sha512_256","Args":"B","Returns":"B","Cost":45,"Size":1,"Doc":"SHA512_256 hash of value A, yields [32]byte","Groups":["Arithmetic"]},{"Opcode":4,"Name":"ed25519verify","Args":"BBB","Returns":"U","Cost":1900,"Size":1,"Doc":"for (data A, signature B, pubkey C) verify the signature of (\\"ProgData\\" || program_hash || data) against the pubkey => {0 or 1}","DocExtra":"The 32 byte public key is the last element on the stack, preceded by the 64 byte signature at the second-to-last element on the stack, preceded by the data which was signed at the third-to-last element on the stack.","Groups":["Arithmetic"]},{"Opcode":5,"Name":"ecdsa_verify","Args":"BBBBB","Returns":"U","Cost":1700,"Size":2,"Doc":"for (data A, signature B, C and pubkey D, E) verify the signature of the data against the pubkey => {0 or 1}","DocExtra":"The 32 byte Y-component of a public key is the last element on the stack, preceded by X-component of a pubkey, preceded by S and R components of a signature, preceded by the data that is fifth element on the stack. All values are big-endian encoded. The signed data must be 32 bytes long, and signatures in lower-S form are only accepted.","ImmediateNote":"{uint8 curve index}","Groups":["Arithmetic"]},{"Opcode":6,"Name":"ecdsa_pk_decompress","Args":"B","Returns":"BB","Cost":650,"Size":2,"Doc":"decompress pubkey A into components X, Y","DocExtra":"The 33 byte public key in a compressed form to be decompressed into X and Y (top) components. All values are big-endian encoded.","ImmediateNote":"{uint8 curve index}","Groups":["Arithmetic"]},{"Opcode":7,"Name":"ecdsa_pk_recover","Args":"BUBB","Returns":"BB","Cost":2000,"Size":2,"Doc":"for (data A, recovery id B, signature C, D) recover a public key","DocExtra":"S (top) and R elements of a signature, recovery id and data (bottom) are expected on the stack and used to deriver a public key. All values are big-endian encoded. The signed data must be 32 bytes long.","ImmediateNote":"{uint8 curve index}","Groups":["Arithmetic"]},{"Opcode":8,"Name":"+","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A plus B. Fail on overflow.","DocExtra":"Overflow is an error condition which halts execution and fails the transaction. Full precision is available from `addw`.","Groups":["Arithmetic"]},{"Opcode":9,"Name":"-","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A minus B. Fail if B > A.","Groups":["Arithmetic"]},{"Opcode":10,"Name":"/","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A divided by B (truncated division). Fail if B == 0.","DocExtra":"`divmodw` is available to divide the two-element values produced by `mulw` and `addw`.","Groups":["Arithmetic"]},{"Opcode":11,"Name":"*","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A times B. Fail on overflow.","DocExtra":"Overflow is an error condition which halts execution and fails the transaction. Full precision is available from `mulw`.","Groups":["Arithmetic"]},{"Opcode":12,"Name":"<","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A less than B => {0 or 1}","Groups":["Arithmetic"]},{"Opcode":13,"Name":">","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A greater than B => {0 or 1}","Groups":["Arithmetic"]},{"Opcode":14,"Name":"<=","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A less than or equal to B => {0 or 1}","Groups":["Arithmetic"]},{"Opcode":15,"Name":">=","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A greater than or equal to B => {0 or 1}","Groups":["Arithmetic"]},{"Opcode":16,"Name":"&&","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A is not zero and B is not zero => {0 or 1}","Groups":["Arithmetic"]},{"Opcode":17,"Name":"||","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A is not zero or B is not zero => {0 or 1}","Groups":["Arithmetic"]},{"Opcode":18,"Name":"==","Args":"..","Returns":"U","Cost":1,"Size":1,"Doc":"A is equal to B => {0 or 1}","Groups":["Arithmetic"]},{"Opcode":19,"Name":"!=","Args":"..","Returns":"U","Cost":1,"Size":1,"Doc":"A is not equal to B => {0 or 1}","Groups":["Arithmetic"]},{"Opcode":20,"Name":"!","Args":"U","Returns":"U","Cost":1,"Size":1,"Doc":"A == 0 yields 1; else 0","Groups":["Arithmetic"]},{"Opcode":21,"Name":"len","Args":"B","Returns":"U","Cost":1,"Size":1,"Doc":"yields length of byte value A","Groups":["Arithmetic"]},{"Opcode":22,"Name":"itob","Args":"U","Returns":"B","Cost":1,"Size":1,"Doc":"converts uint64 A to big endian bytes","Groups":["Arithmetic"]},{"Opcode":23,"Name":"btoi","Args":"B","Returns":"U","Cost":1,"Size":1,"Doc":"converts bytes A as big endian to uint64","DocExtra":"`btoi` fails if the input is longer than 8 bytes.","Groups":["Arithmetic"]},{"Opcode":24,"Name":"%","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A modulo B. Fail if B == 0.","Groups":["Arithmetic"]},{"Opcode":25,"Name":"|","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A bitwise-or B","Groups":["Arithmetic"]},{"Opcode":26,"Name":"&","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A bitwise-and B","Groups":["Arithmetic"]},{"Opcode":27,"Name":"^","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A bitwise-xor B","Groups":["Arithmetic"]},{"Opcode":28,"Name":"~","Args":"U","Returns":"U","Cost":1,"Size":1,"Doc":"bitwise invert value A","Groups":["Arithmetic"]},{"Opcode":29,"Name":"mulw","Args":"UU","Returns":"UU","Cost":1,"Size":1,"Doc":"A times B as a 128-bit result in two uint64s. X is the high 64 bits, Y is the low","Groups":["Arithmetic"]},{"Opcode":30,"Name":"addw","Args":"UU","Returns":"UU","Cost":1,"Size":1,"Doc":"A plus B as a 128-bit result. X is the carry-bit, Y is the low-order 64 bits.","Groups":["Arithmetic"]},{"Opcode":31,"Name":"divmodw","Args":"UUUU","Returns":"UUUU","Cost":20,"Size":1,"Doc":"W,X = (A,B / C,D); Y,Z = (A,B modulo C,D)","DocExtra":"The notation J,K indicates that two uint64 values J and K are interpreted as a uint128 value, with J as the high uint64 and K the low.","Groups":["Arithmetic"]},{"Opcode":32,"Name":"intcblock","Cost":1,"Size":0,"Doc":"prepare block of uint64 constants for use by intc","DocExtra":"`intcblock` loads following program bytes into an array of integer constants in the evaluator. These integer constants can be referred to by `intc` and `intc_*` which will push the value onto the stack. Subsequent calls to `intcblock` reset and replace the integer constants available to the script.","ImmediateNote":"{varuint length} [{varuint value}, ...]","Groups":["Loading Values"]},{"Opcode":33,"Name":"intc","Returns":"U","Cost":1,"Size":2,"Doc":"Ith constant from intcblock","ImmediateNote":"{uint8 int constant index}","Groups":["Loading Values"]},{"Opcode":34,"Name":"intc_0","Returns":"U","Cost":1,"Size":1,"Doc":"constant 0 from intcblock","Groups":["Loading Values"]},{"Opcode":35,"Name":"intc_1","Returns":"U","Cost":1,"Size":1,"Doc":"constant 1 from intcblock","Groups":["Loading Values"]},{"Opcode":36,"Name":"intc_2","Returns":"U","Cost":1,"Size":1,"Doc":"constant 2 from intcblock","Groups":["Loading Values"]},{"Opcode":37,"Name":"intc_3","Returns":"U","Cost":1,"Size":1,"Doc":"constant 3 from intcblock","Groups":["Loading Values"]},{"Opcode":38,"Name":"bytecblock","Cost":1,"Size":0,"Doc":"prepare block of byte-array constants for use by bytec","DocExtra":"`bytecblock` loads the following program bytes into an array of byte-array constants in the evaluator. These constants can be referred to by `bytec` and `bytec_*` which will push the value onto the stack. Subsequent calls to `bytecblock` reset and replace the bytes constants available to the script.","ImmediateNote":"{varuint length} [({varuint value length} bytes), ...]","Groups":["Loading Values"]},{"Opcode":39,"Name":"bytec","Returns":"B","Cost":1,"Size":2,"Doc":"Ith constant from bytecblock","ImmediateNote":"{uint8 byte constant index}","Groups":["Loading Values"]},{"Opcode":40,"Name":"bytec_0","Returns":"B","Cost":1,"Size":1,"Doc":"constant 0 from bytecblock","Groups":["Loading Values"]},{"Opcode":41,"Name":"bytec_1","Returns":"B","Cost":1,"Size":1,"Doc":"constant 1 from bytecblock","Groups":["Loading Values"]},{"Opcode":42,"Name":"bytec_2","Returns":"B","Cost":1,"Size":1,"Doc":"constant 2 from bytecblock","Groups":["Loading Values"]},{"Opcode":43,"Name":"bytec_3","Returns":"B","Cost":1,"Size":1,"Doc":"constant 3 from bytecblock","Groups":["Loading Values"]},{"Opcode":44,"Name":"arg","Returns":"B","Cost":1,"Size":2,"Doc":"Nth LogicSig argument","ImmediateNote":"{uint8 arg index N}","Groups":["Loading Values"]},{"Opcode":45,"Name":"arg_0","Returns":"B","Cost":1,"Size":1,"Doc":"LogicSig argument 0","Groups":["Loading Values"]},{"Opcode":46,"Name":"arg_1","Returns":"B","Cost":1,"Size":1,"Doc":"LogicSig argument 1","Groups":["Loading Values"]},{"Opcode":47,"Name":"arg_2","Returns":"B","Cost":1,"Size":1,"Doc":"LogicSig argument 2","Groups":["Loading Values"]},{"Opcode":48,"Name":"arg_3","Returns":"B","Cost":1,"Size":1,"Doc":"LogicSig argument 3","Groups":["Loading Values"]},{"Opcode":49,"Name":"txn","Returns":".","Cost":1,"Size":2,"ArgEnum":["Sender","Fee","FirstValid","FirstValidTime","LastValid","Note","Lease","Receiver","Amount","CloseRemainderTo","VotePK","SelectionPK","VoteFirst","VoteLast","VoteKeyDilution","Type","TypeEnum","XferAsset","AssetAmount","AssetSender","AssetReceiver","AssetCloseTo","GroupIndex","TxID","ApplicationID","OnCompletion","ApplicationArgs","NumAppArgs","Accounts","NumAccounts","ApprovalProgram","ClearStateProgram","RekeyTo","ConfigAsset","ConfigAssetTotal","ConfigAssetDecimals","ConfigAssetDefaultFrozen","ConfigAssetUnitName","ConfigAssetName","ConfigAssetURL","ConfigAssetMetadataHash","ConfigAssetManager","ConfigAssetReserve","ConfigAssetFreeze","ConfigAssetClawback","FreezeAsset","FreezeAssetAccount","FreezeAssetFrozen","Assets","NumAssets","Applications","NumApplications","GlobalNumUint","GlobalNumByteSlice","LocalNumUint","LocalNumByteSlice","ExtraProgramPages","Nonparticipation","Logs","NumLogs","CreatedAssetID","CreatedApplicationID","LastLog","StateProofPK"],"ArgEnumTypes":"BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB","Doc":"field F of current transaction","DocExtra":"FirstValidTime causes the program to fail. The field is reserved for future use.","ImmediateNote":"{uint8 transaction field index}","Groups":["Loading Values"]},{"Opcode":50,"Name":"global","Returns":".","Cost":1,"Size":2,"Doc":"global field F","ImmediateNote":"{uint8 global field index}","Groups":["Loading Values"]},{"Opcode":51,"Name":"gtxn","Returns":".","Cost":1,"Size":3,"ArgEnum":["Sender","Fee","FirstValid","FirstValidTime","LastValid","Note","Lease","Receiver","Amount","CloseRemainderTo","VotePK","SelectionPK","VoteFirst","VoteLast","VoteKeyDilution","Type","TypeEnum","XferAsset","AssetAmount","AssetSender","AssetReceiver","AssetCloseTo","GroupIndex","TxID","ApplicationID","OnCompletion","ApplicationArgs","NumAppArgs","Accounts","NumAccounts","ApprovalProgram","ClearStateProgram","RekeyTo","ConfigAsset","ConfigAssetTotal","ConfigAssetDecimals","ConfigAssetDefaultFrozen","ConfigAssetUnitName","ConfigAssetName","ConfigAssetURL","ConfigAssetMetadataHash","ConfigAssetManager","ConfigAssetReserve","ConfigAssetFreeze","ConfigAssetClawback","FreezeAsset","FreezeAssetAccount","FreezeAssetFrozen","Assets","NumAssets","Applications","NumApplications","GlobalNumUint","GlobalNumByteSlice","LocalNumUint","LocalNumByteSlice","ExtraProgramPages","Nonparticipation","Logs","NumLogs","CreatedAssetID","CreatedApplicationID","LastLog","StateProofPK"],"ArgEnumTypes":"BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB","Doc":"field F of the Tth transaction in the current group","DocExtra":"for notes on transaction fields available, see `txn`. If this transaction is _i_ in the group, `gtxn i field` is equivalent to `txn field`.","ImmediateNote":"{uint8 transaction group index} {uint8 transaction field index}","Groups":["Loading Values"]},{"Opcode":52,"Name":"load","Returns":".","Cost":1,"Size":2,"Doc":"Ith scratch space value. All scratch spaces are 0 at program start.","ImmediateNote":"{uint8 position in scratch space to load from}","Groups":["Loading Values"]},{"Opcode":53,"Name":"store","Args":".","Cost":1,"Size":2,"Doc":"store A to the Ith scratch space","ImmediateNote":"{uint8 position in scratch space to store to}","Groups":["Loading Values"]},{"Opcode":54,"Name":"txna","Returns":".","Cost":1,"Size":3,"ArgEnum":["ApplicationArgs","Accounts","Assets","Applications","Logs"],"ArgEnumTypes":"BBUUB","Doc":"Ith value of the array field F of the current transaction","ImmediateNote":"{uint8 transaction field index} {uint8 transaction field array index}","Groups":["Loading Values"]},{"Opcode":55,"Name":"gtxna","Returns":".","Cost":1,"Size":4,"ArgEnum":["ApplicationArgs","Accounts","Assets","Applications","Logs"],"ArgEnumTypes":"BBUUB","Doc":"Ith value of the array field F from the Tth transaction in the current group","ImmediateNote":"{uint8 transaction group index} {uint8 transaction field index} {uint8 transaction field array index}","Groups":["Loading Values"]},{"Opcode":56,"Name":"gtxns","Args":"U","Returns":".","Cost":1,"Size":2,"ArgEnum":["Sender","Fee","FirstValid","FirstValidTime","LastValid","Note","Lease","Receiver","Amount","CloseRemainderTo","VotePK","SelectionPK","VoteFirst","VoteLast","VoteKeyDilution","Type","TypeEnum","XferAsset","AssetAmount","AssetSender","AssetReceiver","AssetCloseTo","GroupIndex","TxID","ApplicationID","OnCompletion","ApplicationArgs","NumAppArgs","Accounts","NumAccounts","ApprovalProgram","ClearStateProgram","RekeyTo","ConfigAsset","ConfigAssetTotal","ConfigAssetDecimals","ConfigAssetDefaultFrozen","ConfigAssetUnitName","ConfigAssetName","ConfigAssetURL","ConfigAssetMetadataHash","ConfigAssetManager","ConfigAssetReserve","ConfigAssetFreeze","ConfigAssetClawback","FreezeAsset","FreezeAssetAccount","FreezeAssetFrozen","Assets","NumAssets","Applications","NumApplications","GlobalNumUint","GlobalNumByteSlice","LocalNumUint","LocalNumByteSlice","ExtraProgramPages","Nonparticipation","Logs","NumLogs","CreatedAssetID","CreatedApplicationID","LastLog","StateProofPK"],"ArgEnumTypes":"BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB","Doc":"field F of the Ath transaction in the current group","DocExtra":"for notes on transaction fields available, see `txn`. If top of stack is _i_, `gtxns field` is equivalent to `gtxn _i_ field`. gtxns exists so that _i_ can be calculated, often based on the index of the current transaction.","ImmediateNote":"{uint8 transaction field index}","Groups":["Loading Values"]},{"Opcode":57,"Name":"gtxnsa","Args":"U","Returns":".","Cost":1,"Size":3,"ArgEnum":["ApplicationArgs","Accounts","Assets","Applications","Logs"],"ArgEnumTypes":"BBUUB","Doc":"Ith value of the array field F from the Ath transaction in the current group","ImmediateNote":"{uint8 transaction field index} {uint8 transaction field array index}","Groups":["Loading Values"]},{"Opcode":58,"Name":"gload","Returns":".","Cost":1,"Size":3,"Doc":"Ith scratch space value of the Tth transaction in the current group","DocExtra":"`gload` fails unless the requested transaction is an ApplicationCall and T < GroupIndex.","ImmediateNote":"{uint8 transaction group index} {uint8 position in scratch space to load from}","Groups":["Loading Values"]},{"Opcode":59,"Name":"gloads","Args":"U","Returns":".","Cost":1,"Size":2,"Doc":"Ith scratch space value of the Ath transaction in the current group","DocExtra":"`gloads` fails unless the requested transaction is an ApplicationCall and A < GroupIndex.","ImmediateNote":"{uint8 position in scratch space to load from}","Groups":["Loading Values"]},{"Opcode":60,"Name":"gaid","Returns":"U","Cost":1,"Size":2,"Doc":"ID of the asset or application created in the Tth transaction of the current group","DocExtra":"`gaid` fails unless the requested transaction created an asset or application and T < GroupIndex.","ImmediateNote":"{uint8 transaction group index}","Groups":["Loading Values"]},{"Opcode":61,"Name":"gaids","Args":"U","Returns":"U","Cost":1,"Size":1,"Doc":"ID of the asset or application created in the Ath transaction of the current group","DocExtra":"`gaids` fails unless the requested transaction created an asset or application and A < GroupIndex.","Groups":["Loading Values"]},{"Opcode":62,"Name":"loads","Args":"U","Returns":".","Cost":1,"Size":1,"Doc":"Ath scratch space value.  All scratch spaces are 0 at program start.","Groups":["Loading Values"]},{"Opcode":63,"Name":"stores","Args":"U.","Cost":1,"Size":1,"Doc":"store B to the Ath scratch space","Groups":["Loading Values"]},{"Opcode":64,"Name":"bnz","Args":"U","Cost":1,"Size":3,"Doc":"branch to TARGET if value A is not zero","DocExtra":"The `bnz` instruction opcode 0x40 is followed by two immediate data bytes which are a high byte first and low byte second which together form a 16 bit offset which the instruction may branch to. For a bnz instruction at `pc`, if the last element of the stack is not zero then branch to instruction at `pc + 3 + N`, else proceed to next instruction at `pc + 3`. Branch targets must be aligned instructions. (e.g. Branching to the second byte of a 2 byte op will be rejected.) Starting at v4, the offset is treated as a signed 16 bit integer allowing for backward branches and looping. In prior version (v1 to v3), branch offsets are limited to forward branches only, 0-0x7fff.\\n\\nAt v2 it became allowed to branch to the end of the program exactly after the last instruction: bnz to byte N (with 0-indexing) was illegal for a TEAL program with N bytes before v2, and is legal after it. This change eliminates the need for a last instruction of no-op as a branch target at the end. (Branching beyond the end--in other words, to a byte larger than N--is still illegal and will cause the program to fail.)","ImmediateNote":"{int16 branch offset, big endian}","Groups":["Flow Control"]},{"Opcode":65,"Name":"bz","Args":"U","Cost":1,"Size":3,"Doc":"branch to TARGET if value A is zero","DocExtra":"See `bnz` for details on how branches work. `bz` inverts the behavior of `bnz`.","ImmediateNote":"{int16 branch offset, big endian}","Groups":["Flow Control"]},{"Opcode":66,"Name":"b","Cost":1,"Size":3,"Doc":"branch unconditionally to TARGET","DocExtra":"See `bnz` for details on how branches work. `b` always jumps to the offset.","ImmediateNote":"{int16 branch offset, big endian}","Groups":["Flow Control"]},{"Opcode":67,"Name":"return","Args":"U","Cost":1,"Size":1,"Doc":"use A as success value; end","Groups":["Flow Control"]},{"Opcode":68,"Name":"assert","Args":"U","Cost":1,"Size":1,"Doc":"immediately fail unless A is a non-zero number","Groups":["Flow Control"]},{"Opcode":72,"Name":"pop","Args":".","Cost":1,"Size":1,"Doc":"discard A","Groups":["Flow Control"]},{"Opcode":73,"Name":"dup","Args":".","Returns":"..","Cost":1,"Size":1,"Doc":"duplicate A","Groups":["Flow Control"]},{"Opcode":74,"Name":"dup2","Args":"..","Returns":"....","Cost":1,"Size":1,"Doc":"duplicate A and B","Groups":["Flow Control"]},{"Opcode":75,"Name":"dig","Args":".","Returns":"..","Cost":1,"Size":2,"Doc":"Nth value from the top of the stack. dig 0 is equivalent to dup","ImmediateNote":"{uint8 depth}","Groups":["Flow Control"]},{"Opcode":76,"Name":"swap","Args":"..","Returns":"..","Cost":1,"Size":1,"Doc":"swaps A and B on stack","Groups":["Flow Control"]},{"Opcode":77,"Name":"select","Args":"..U","Returns":".","Cost":1,"Size":1,"Doc":"selects one of two values based on top-of-stack: B if C != 0, else A","Groups":["Flow Control"]},{"Opcode":78,"Name":"cover","Args":".","Returns":".","Cost":1,"Size":2,"Doc":"remove top of stack, and place it deeper in the stack such that N elements are above it. Fails if stack depth <= N.","ImmediateNote":"{uint8 depth}","Groups":["Flow Control"]},{"Opcode":79,"Name":"uncover","Args":".","Returns":".","Cost":1,"Size":2,"Doc":"remove the value at depth N in the stack and shift above items down so the Nth deep value is on top of the stack. Fails if stack depth <= N.","ImmediateNote":"{uint8 depth}","Groups":["Flow Control"]},{"Opcode":80,"Name":"concat","Args":"BB","Returns":"B","Cost":1,"Size":1,"Doc":"join A and B","DocExtra":"`concat` fails if the result would be greater than 4096 bytes.","Groups":["Arithmetic"]},{"Opcode":81,"Name":"substring","Args":"B","Returns":"B","Cost":1,"Size":3,"Doc":"A range of bytes from A starting at S up to but not including E. If E < S, or either is larger than the array length, the program fails","ImmediateNote":"{uint8 start position} {uint8 end position}","Groups":["Byte Array Manipulation"]},{"Opcode":82,"Name":"substring3","Args":"BUU","Returns":"B","Cost":1,"Size":1,"Doc":"A range of bytes from A starting at B up to but not including C. If C < B, or either is larger than the array length, the program fails","Groups":["Byte Array Manipulation"]},{"Opcode":83,"Name":"getbit","Args":".U","Returns":"U","Cost":1,"Size":1,"Doc":"Bth bit of (byte-array or integer) A.","DocExtra":"see explanation of bit ordering in setbit","Groups":["Arithmetic"]},{"Opcode":84,"Name":"setbit","Args":".UU","Returns":".","Cost":1,"Size":1,"Doc":"Copy of (byte-array or integer) A, with the Bth bit set to (0 or 1) C","DocExtra":"When A is a uint64, index 0 is the least significant bit. Setting bit 3 to 1 on the integer 0 yields 8, or 2^3. When A is a byte array, index 0 is the leftmost bit of the leftmost byte. Setting bits 0 through 11 to 1 in a 4-byte-array of 0s yields the byte array 0xfff00000. Setting bit 3 to 1 on the 1-byte-array 0x00 yields the byte array 0x10.","Groups":["Arithmetic"]},{"Opcode":85,"Name":"getbyte","Args":"BU","Returns":"U","Cost":1,"Size":1,"Doc":"Bth byte of A, as an integer","Groups":["Arithmetic"]},{"Opcode":86,"Name":"setbyte","Args":"BUU","Returns":"B","Cost":1,"Size":1,"Doc":"Copy of A with the Bth byte set to small integer (between 0..255) C","Groups":["Arithmetic"]},{"Opcode":87,"Name":"extract","Args":"B","Returns":"B","Cost":1,"Size":3,"Doc":"A range of bytes from A starting at S up to but not including S+L. If L is 0, then extract to the end of the string. If S or S+L is larger than the array length, the program fails","ImmediateNote":"{uint8 start position} {uint8 length}","Groups":["Byte Array Manipulation"]},{"Opcode":88,"Name":"extract3","Args":"BUU","Returns":"B","Cost":1,"Size":1,"Doc":"A range of bytes from A starting at B up to but not including B+C. If B+C is larger than the array length, the program fails","Groups":["Byte Array Manipulation"]},{"Opcode":89,"Name":"extract_uint16","Args":"BU","Returns":"U","Cost":1,"Size":1,"Doc":"A uint16 formed from a range of big-endian bytes from A starting at B up to but not including B+2. If B+2 is larger than the array length, the program fails","Groups":["Byte Array Manipulation"]},{"Opcode":90,"Name":"extract_uint32","Args":"BU","Returns":"U","Cost":1,"Size":1,"Doc":"A uint32 formed from a range of big-endian bytes from A starting at B up to but not including B+4. If B+4 is larger than the array length, the program fails","Groups":["Byte Array Manipulation"]},{"Opcode":91,"Name":"extract_uint64","Args":"BU","Returns":"U","Cost":1,"Size":1,"Doc":"A uint64 formed from a range of big-endian bytes from A starting at B up to but not including B+8. If B+8 is larger than the array length, the program fails","Groups":["Byte Array Manipulation"]},{"Opcode":96,"Name":"balance","Args":".","Returns":"U","Cost":1,"Size":1,"Doc":"get balance for account A, in microalgos. The balance is observed after the effects of previous transactions in the group, and after the fee for the current transaction is deducted.","DocExtra":"params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset). Return: value.","Groups":["State Access"]},{"Opcode":97,"Name":"app_opted_in","Args":".U","Returns":"U","Cost":1,"Size":1,"Doc":"1 if account A is opted in to application B, else 0","DocExtra":"params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset). Return: 1 if opted in and 0 otherwise.","Groups":["State Access"]},{"Opcode":98,"Name":"app_local_get","Args":".B","Returns":".","Cost":1,"Size":1,"Doc":"local state of the key B in the current application in account A","DocExtra":"params: Txn.Accounts offset (or, since v4, an _available_ account address), state key. Return: value. The value is zero (of type uint64) if the key does not exist.","Groups":["State Access"]},{"Opcode":99,"Name":"app_local_get_ex","Args":".UB","Returns":".U","Cost":1,"Size":1,"Doc":"X is the local state of application B, key C in account A. Y is 1 if key existed, else 0","DocExtra":"params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset), state key. Return: did_exist flag (top of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.","Groups":["State Access"]},{"Opcode":100,"Name":"app_global_get","Args":"B","Returns":".","Cost":1,"Size":1,"Doc":"global state of the key A in the current application","DocExtra":"params: state key. Return: value. The value is zero (of type uint64) if the key does not exist.","Groups":["State Access"]},{"Opcode":101,"Name":"app_global_get_ex","Args":"UB","Returns":".U","Cost":1,"Size":1,"Doc":"X is the global state of application A, key B. Y is 1 if key existed, else 0","DocExtra":"params: Txn.ForeignApps offset (or, since v4, an _available_ application id), state key. Return: did_exist flag (top of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.","Groups":["State Access"]},{"Opcode":102,"Name":"app_local_put","Args":".B.","Cost":1,"Size":1,"Doc":"write C to key B in account A\'s local state of the current application","DocExtra":"params: Txn.Accounts offset (or, since v4, an _available_ account address), state key, value.","Groups":["State Access"]},{"Opcode":103,"Name":"app_global_put","Args":"B.","Cost":1,"Size":1,"Doc":"write B to key A in the global state of the current application","Groups":["State Access"]},{"Opcode":104,"Name":"app_local_del","Args":".B","Cost":1,"Size":1,"Doc":"delete key B from account A\'s local state of the current application","DocExtra":"params: Txn.Accounts offset (or, since v4, an _available_ account address), state key.\\n\\nDeleting a key which is already absent has no effect on the application local state. (In particular, it does _not_ cause the program to fail.)","Groups":["State Access"]},{"Opcode":105,"Name":"app_global_del","Args":"B","Cost":1,"Size":1,"Doc":"delete key A from the global state of the current application","DocExtra":"params: state key.\\n\\nDeleting a key which is already absent has no effect on the application global state. (In particular, it does _not_ cause the program to fail.)","Groups":["State Access"]},{"Opcode":112,"Name":"asset_holding_get","Args":".U","Returns":".U","Cost":1,"Size":2,"ArgEnum":["AssetBalance","AssetFrozen"],"ArgEnumTypes":"UU","Doc":"X is field F from account A\'s holding of asset B. Y is 1 if A is opted into B, else 0","DocExtra":"params: Txn.Accounts offset (or, since v4, an _available_ address), asset id (or, since v4, a Txn.ForeignAssets offset). Return: did_exist flag (1 if the asset existed and 0 otherwise), value.","ImmediateNote":"{uint8 asset holding field index}","Groups":["State Access"]},{"Opcode":113,"Name":"asset_params_get","Args":"U","Returns":".U","Cost":1,"Size":2,"ArgEnum":["AssetTotal","AssetDecimals","AssetDefaultFrozen","AssetUnitName","AssetName","AssetURL","AssetMetadataHash","AssetManager","AssetReserve","AssetFreeze","AssetClawback","AssetCreator"],"ArgEnumTypes":"UUUBBBBBBBBB","Doc":"X is field F from asset A. Y is 1 if A exists, else 0","DocExtra":"params: Txn.ForeignAssets offset (or, since v4, an _available_ asset id. Return: did_exist flag (1 if the asset existed and 0 otherwise), value.","ImmediateNote":"{uint8 asset params field index}","Groups":["State Access"]},{"Opcode":114,"Name":"app_params_get","Args":"U","Returns":".U","Cost":1,"Size":2,"ArgEnum":["AppApprovalProgram","AppClearStateProgram","AppGlobalNumUint","AppGlobalNumByteSlice","AppLocalNumUint","AppLocalNumByteSlice","AppExtraProgramPages","AppCreator","AppAddress"],"ArgEnumTypes":"BBUUUUUBB","Doc":"X is field F from app A. Y is 1 if A exists, else 0","DocExtra":"params: Txn.ForeignApps offset or an _available_ app id. Return: did_exist flag (1 if the application existed and 0 otherwise), value.","ImmediateNote":"{uint8 app params field index}","Groups":["State Access"]},{"Opcode":115,"Name":"acct_params_get","Args":".","Returns":".U","Cost":1,"Size":2,"Doc":"X is field F from account A. Y is 1 if A owns positive algos, else 0","ImmediateNote":"{uint8 account params field index}","Groups":["State Access"]},{"Opcode":120,"Name":"min_balance","Args":".","Returns":"U","Cost":1,"Size":1,"Doc":"get minimum required balance for account A, in microalgos. Required balance is affected by [ASA](https://developer.algorand.org/docs/features/asa/#assets-overview) and [App](https://developer.algorand.org/docs/features/asc1/stateful/#minimum-balance-requirement-for-a-smart-contract) usage. When creating or opting into an app, the minimum balance grows before the app code runs, therefore the increase is visible there. When deleting or closing out, the minimum balance decreases after the app executes.","DocExtra":"params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset). Return: value.","Groups":["State Access"]},{"Opcode":128,"Name":"pushbytes","Returns":"B","Cost":1,"Size":0,"Doc":"immediate BYTES","DocExtra":"pushbytes args are not added to the bytecblock during assembly processes","ImmediateNote":"{varuint length} {bytes}","Groups":["Loading Values"]},{"Opcode":129,"Name":"pushint","Returns":"U","Cost":1,"Size":0,"Doc":"immediate UINT","DocExtra":"pushint args are not added to the intcblock during assembly processes","ImmediateNote":"{varuint int}","Groups":["Loading Values"]},{"Opcode":136,"Name":"callsub","Cost":1,"Size":3,"Doc":"branch unconditionally to TARGET, saving the next instruction on the call stack","DocExtra":"The call stack is separate from the data stack. Only `callsub` and `retsub` manipulate it.","ImmediateNote":"{int16 branch offset, big endian}","Groups":["Flow Control"]},{"Opcode":137,"Name":"retsub","Cost":1,"Size":1,"Doc":"pop the top instruction from the call stack and branch to it","DocExtra":"The call stack is separate from the data stack. Only `callsub` and `retsub` manipulate it.","Groups":["Flow Control"]},{"Opcode":144,"Name":"shl","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A times 2^B, modulo 2^64","Groups":["Arithmetic"]},{"Opcode":145,"Name":"shr","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A divided by 2^B","Groups":["Arithmetic"]},{"Opcode":146,"Name":"sqrt","Args":"U","Returns":"U","Cost":4,"Size":1,"Doc":"The largest integer I such that I^2 <= A","Groups":["Arithmetic"]},{"Opcode":147,"Name":"bitlen","Args":".","Returns":"U","Cost":1,"Size":1,"Doc":"The highest set bit in A. If A is a byte-array, it is interpreted as a big-endian unsigned integer. bitlen of 0 is 0, bitlen of 8 is 4","DocExtra":"bitlen interprets arrays as big-endian integers, unlike setbit/getbit","Groups":["Arithmetic"]},{"Opcode":148,"Name":"exp","Args":"UU","Returns":"U","Cost":1,"Size":1,"Doc":"A raised to the Bth power. Fail if A == B == 0 and on overflow","Groups":["Arithmetic"]},{"Opcode":149,"Name":"expw","Args":"UU","Returns":"UU","Cost":10,"Size":1,"Doc":"A raised to the Bth power as a 128-bit result in two uint64s. X is the high 64 bits, Y is the low. Fail if A == B == 0 or if the results exceeds 2^128-1","Groups":["Arithmetic"]},{"Opcode":150,"Name":"bsqrt","Args":"B","Returns":"B","Cost":40,"Size":1,"Doc":"The largest integer I such that I^2 <= A. A and I are interpreted as big-endian unsigned integers","Groups":["Byte Array Arithmetic"]},{"Opcode":151,"Name":"divw","Args":"UUU","Returns":"U","Cost":1,"Size":1,"Doc":"A,B / C. Fail if C == 0 or if result overflows.","DocExtra":"The notation A,B indicates that A and B are interpreted as a uint128 value, with A as the high uint64 and B the low.","Groups":["Arithmetic"]},{"Opcode":160,"Name":"b+","Args":"BB","Returns":"B","Cost":10,"Size":1,"Doc":"A plus B. A and B are interpreted as big-endian unsigned integers","Groups":["Byte Array Arithmetic"]},{"Opcode":161,"Name":"b-","Args":"BB","Returns":"B","Cost":10,"Size":1,"Doc":"A minus B. A and B are interpreted as big-endian unsigned integers. Fail on underflow.","Groups":["Byte Array Arithmetic"]},{"Opcode":162,"Name":"b/","Args":"BB","Returns":"B","Cost":20,"Size":1,"Doc":"A divided by B (truncated division). A and B are interpreted as big-endian unsigned integers. Fail if B is zero.","Groups":["Byte Array Arithmetic"]},{"Opcode":163,"Name":"b*","Args":"BB","Returns":"B","Cost":20,"Size":1,"Doc":"A times B. A and B are interpreted as big-endian unsigned integers.","Groups":["Byte Array Arithmetic"]},{"Opcode":164,"Name":"b<","Args":"BB","Returns":"U","Cost":1,"Size":1,"Doc":"1 if A is less than B, else 0. A and B are interpreted as big-endian unsigned integers","Groups":["Byte Array Arithmetic"]},{"Opcode":165,"Name":"b>","Args":"BB","Returns":"U","Cost":1,"Size":1,"Doc":"1 if A is greater than B, else 0. A and B are interpreted as big-endian unsigned integers","Groups":["Byte Array Arithmetic"]},{"Opcode":166,"Name":"b<=","Args":"BB","Returns":"U","Cost":1,"Size":1,"Doc":"1 if A is less than or equal to B, else 0. A and B are interpreted as big-endian unsigned integers","Groups":["Byte Array Arithmetic"]},{"Opcode":167,"Name":"b>=","Args":"BB","Returns":"U","Cost":1,"Size":1,"Doc":"1 if A is greater than or equal to B, else 0. A and B are interpreted as big-endian unsigned integers","Groups":["Byte Array Arithmetic"]},{"Opcode":168,"Name":"b==","Args":"BB","Returns":"U","Cost":1,"Size":1,"Doc":"1 if A is equal to B, else 0. A and B are interpreted as big-endian unsigned integers","Groups":["Byte Array Arithmetic"]},{"Opcode":169,"Name":"b!=","Args":"BB","Returns":"U","Cost":1,"Size":1,"Doc":"0 if A is equal to B, else 1. A and B are interpreted as big-endian unsigned integers","Groups":["Byte Array Arithmetic"]},{"Opcode":170,"Name":"b%","Args":"BB","Returns":"B","Cost":20,"Size":1,"Doc":"A modulo B. A and B are interpreted as big-endian unsigned integers. Fail if B is zero.","Groups":["Byte Array Arithmetic"]},{"Opcode":171,"Name":"b|","Args":"BB","Returns":"B","Cost":6,"Size":1,"Doc":"A bitwise-or B. A and B are zero-left extended to the greater of their lengths","Groups":["Byte Array Logic"]},{"Opcode":172,"Name":"b&","Args":"BB","Returns":"B","Cost":6,"Size":1,"Doc":"A bitwise-and B. A and B are zero-left extended to the greater of their lengths","Groups":["Byte Array Logic"]},{"Opcode":173,"Name":"b^","Args":"BB","Returns":"B","Cost":6,"Size":1,"Doc":"A bitwise-xor B. A and B are zero-left extended to the greater of their lengths","Groups":["Byte Array Logic"]},{"Opcode":174,"Name":"b~","Args":"B","Returns":"B","Cost":4,"Size":1,"Doc":"A with all bits inverted","Groups":["Byte Array Logic"]},{"Opcode":175,"Name":"bzero","Args":"U","Returns":"B","Cost":1,"Size":1,"Doc":"zero filled byte-array of length A","Groups":["Loading Values"]},{"Opcode":176,"Name":"log","Args":"B","Cost":1,"Size":1,"Doc":"write A to log state of the current application","DocExtra":"`log` fails if called more than MaxLogCalls times in a program, or if the sum of logged bytes exceeds 1024 bytes.","Groups":["State Access"]},{"Opcode":177,"Name":"itxn_begin","Cost":1,"Size":1,"Doc":"begin preparation of a new inner transaction in a new transaction group","DocExtra":"`itxn_begin` initializes Sender to the application address; Fee to the minimum allowable, taking into account MinTxnFee and credit from overpaying in earlier transactions; FirstValid/LastValid to the values in the invoking transaction, and all other fields to zero or empty values.","Groups":["Inner Transactions"]},{"Opcode":178,"Name":"itxn_field","Args":".","Cost":1,"Size":2,"ArgEnum":["Sender","Fee","FirstValid","FirstValidTime","LastValid","Note","Lease","Receiver","Amount","CloseRemainderTo","VotePK","SelectionPK","VoteFirst","VoteLast","VoteKeyDilution","Type","TypeEnum","XferAsset","AssetAmount","AssetSender","AssetReceiver","AssetCloseTo","GroupIndex","TxID","ApplicationID","OnCompletion","ApplicationArgs","NumAppArgs","Accounts","NumAccounts","ApprovalProgram","ClearStateProgram","RekeyTo","ConfigAsset","ConfigAssetTotal","ConfigAssetDecimals","ConfigAssetDefaultFrozen","ConfigAssetUnitName","ConfigAssetName","ConfigAssetURL","ConfigAssetMetadataHash","ConfigAssetManager","ConfigAssetReserve","ConfigAssetFreeze","ConfigAssetClawback","FreezeAsset","FreezeAssetAccount","FreezeAssetFrozen","Assets","NumAssets","Applications","NumApplications","GlobalNumUint","GlobalNumByteSlice","LocalNumUint","LocalNumByteSlice","ExtraProgramPages","Nonparticipation","Logs","NumLogs","CreatedAssetID","CreatedApplicationID","LastLog","StateProofPK"],"ArgEnumTypes":"BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB","Doc":"set field F of the current inner transaction to A","DocExtra":"`itxn_field` fails if A is of the wrong type for F, including a byte array of the wrong size for use as an address when F is an address field. `itxn_field` also fails if A is an account, asset, or app that is not _available_, or an attempt is made extend an array field beyond the limit imposed by consensus parameters. (Addresses set into asset params of acfg transactions need not be _available_.)","ImmediateNote":"{uint8 transaction field index}","Groups":["Inner Transactions"]},{"Opcode":179,"Name":"itxn_submit","Cost":1,"Size":1,"Doc":"execute the current inner transaction group. Fail if executing this group would exceed the inner transaction limit, or if any transaction in the group fails.","DocExtra":"`itxn_submit` resets the current transaction so that it can not be resubmitted. A new `itxn_begin` is required to prepare another inner transaction.","Groups":["Inner Transactions"]},{"Opcode":180,"Name":"itxn","Returns":".","Cost":1,"Size":2,"ArgEnum":["Sender","Fee","FirstValid","FirstValidTime","LastValid","Note","Lease","Receiver","Amount","CloseRemainderTo","VotePK","SelectionPK","VoteFirst","VoteLast","VoteKeyDilution","Type","TypeEnum","XferAsset","AssetAmount","AssetSender","AssetReceiver","AssetCloseTo","GroupIndex","TxID","ApplicationID","OnCompletion","ApplicationArgs","NumAppArgs","Accounts","NumAccounts","ApprovalProgram","ClearStateProgram","RekeyTo","ConfigAsset","ConfigAssetTotal","ConfigAssetDecimals","ConfigAssetDefaultFrozen","ConfigAssetUnitName","ConfigAssetName","ConfigAssetURL","ConfigAssetMetadataHash","ConfigAssetManager","ConfigAssetReserve","ConfigAssetFreeze","ConfigAssetClawback","FreezeAsset","FreezeAssetAccount","FreezeAssetFrozen","Assets","NumAssets","Applications","NumApplications","GlobalNumUint","GlobalNumByteSlice","LocalNumUint","LocalNumByteSlice","ExtraProgramPages","Nonparticipation","Logs","NumLogs","CreatedAssetID","CreatedApplicationID","LastLog","StateProofPK"],"ArgEnumTypes":"BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB","Doc":"field F of the last inner transaction","ImmediateNote":"{uint8 transaction field index}","Groups":["Inner Transactions"]},{"Opcode":181,"Name":"itxna","Returns":".","Cost":1,"Size":3,"ArgEnum":["ApplicationArgs","Accounts","Assets","Applications","Logs"],"ArgEnumTypes":"BBUUB","Doc":"Ith value of the array field F of the last inner transaction","ImmediateNote":"{uint8 transaction field index} {uint8 transaction field array index}","Groups":["Inner Transactions"]},{"Opcode":182,"Name":"itxn_next","Cost":1,"Size":1,"Doc":"begin preparation of a new inner transaction in the same transaction group","DocExtra":"`itxn_next` initializes the transaction exactly as `itxn_begin` does","Groups":["Inner Transactions"]},{"Opcode":183,"Name":"gitxn","Returns":".","Cost":1,"Size":3,"ArgEnum":["Sender","Fee","FirstValid","FirstValidTime","LastValid","Note","Lease","Receiver","Amount","CloseRemainderTo","VotePK","SelectionPK","VoteFirst","VoteLast","VoteKeyDilution","Type","TypeEnum","XferAsset","AssetAmount","AssetSender","AssetReceiver","AssetCloseTo","GroupIndex","TxID","ApplicationID","OnCompletion","ApplicationArgs","NumAppArgs","Accounts","NumAccounts","ApprovalProgram","ClearStateProgram","RekeyTo","ConfigAsset","ConfigAssetTotal","ConfigAssetDecimals","ConfigAssetDefaultFrozen","ConfigAssetUnitName","ConfigAssetName","ConfigAssetURL","ConfigAssetMetadataHash","ConfigAssetManager","ConfigAssetReserve","ConfigAssetFreeze","ConfigAssetClawback","FreezeAsset","FreezeAssetAccount","FreezeAssetFrozen","Assets","NumAssets","Applications","NumApplications","GlobalNumUint","GlobalNumByteSlice","LocalNumUint","LocalNumByteSlice","ExtraProgramPages","Nonparticipation","Logs","NumLogs","CreatedAssetID","CreatedApplicationID","LastLog","StateProofPK"],"ArgEnumTypes":"BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB","Doc":"field F of the Tth transaction in the last inner group submitted","ImmediateNote":"{uint8 transaction group index} {uint8 transaction field index}","Groups":["Inner Transactions"]},{"Opcode":184,"Name":"gitxna","Returns":".","Cost":1,"Size":4,"ArgEnum":["ApplicationArgs","Accounts","Assets","Applications","Logs"],"ArgEnumTypes":"BBUUB","Doc":"Ith value of the array field F from the Tth transaction in the last inner group submitted","ImmediateNote":"{uint8 transaction group index} {uint8 transaction field index} {uint8 transaction field array index}","Groups":["Inner Transactions"]},{"Opcode":192,"Name":"txnas","Args":"U","Returns":".","Cost":1,"Size":2,"ArgEnum":["ApplicationArgs","Accounts","Assets","Applications","Logs"],"ArgEnumTypes":"BBUUB","Doc":"Ath value of the array field F of the current transaction","ImmediateNote":"{uint8 transaction field index}","Groups":["Loading Values"]},{"Opcode":193,"Name":"gtxnas","Args":"U","Returns":".","Cost":1,"Size":3,"ArgEnum":["ApplicationArgs","Accounts","Assets","Applications","Logs"],"ArgEnumTypes":"BBUUB","Doc":"Ath value of the array field F from the Tth transaction in the current group","ImmediateNote":"{uint8 transaction group index} {uint8 transaction field index}","Groups":["Loading Values"]},{"Opcode":194,"Name":"gtxnsas","Args":"UU","Returns":".","Cost":1,"Size":2,"ArgEnum":["ApplicationArgs","Accounts","Assets","Applications","Logs"],"ArgEnumTypes":"BBUUB","Doc":"Bth value of the array field F from the Ath transaction in the current group","ImmediateNote":"{uint8 transaction field index}","Groups":["Loading Values"]},{"Opcode":195,"Name":"args","Args":"U","Returns":"B","Cost":1,"Size":1,"Doc":"Ath LogicSig argument","Groups":["Loading Values"]},{"Opcode":196,"Name":"gloadss","Args":"UU","Returns":".","Cost":1,"Size":1,"Doc":"Bth scratch space value of the Ath transaction in the current group","Groups":["Loading Values"]},{"Opcode":197,"Name":"itxnas","Args":"U","Returns":".","Cost":1,"Size":2,"Doc":"Ath value of the array field F of the last inner transaction","ImmediateNote":"{uint8 transaction field index}","Groups":["Inner Transactions"]},{"Opcode":198,"Name":"gitxnas","Args":"U","Returns":".","Cost":1,"Size":3,"Doc":"Ath value of the array field F from the Tth transaction in the last inner group submitted","ImmediateNote":"{uint8 transaction group index} {uint8 transaction field index}","Groups":["Inner Transactions"]}]}');
          let o3;
          function s3(e4) {
            let t4 = 0, r4 = 0;
            for (let n3 = 0; n3 < e4.length; n3++) {
              const o4 = e4[n3];
              if (o4 < 128)
                return n3 > 9 || n3 === 9 && o4 > 1 ? [0, -(n3 + 1)] : [t4 | o4 << r4, n3 + 1];
              t4 += (127 & o4) << r4, r4 += 7;
            }
            return [0, 0];
          }
          function i3(e4, t4) {
            let r4 = 1;
            const n3 = s3(e4.slice(t4 + r4)), o4 = n3[0];
            let i4 = n3[1];
            if (i4 <= 0)
              throw new Error(`could not decode int const block size at pc=${t4 + r4}`);
            const a4 = [];
            r4 += i4;
            for (let n4 = 0; n4 < o4; n4++) {
              if (t4 + r4 >= e4.length)
                throw new Error("intcblock ran past end of program");
              let o5;
              if ([o5, i4] = s3(e4.slice(t4 + r4)), i4 <= 0)
                throw new Error(`could not decode int const[${n4}] block size at pc=${t4 + r4}`);
              a4.push(o5), r4 += i4;
            }
            return [r4, a4];
          }
          function a3(e4, t4) {
            let r4 = 1;
            const n3 = s3(e4.slice(t4 + r4)), o4 = n3[0];
            let i4 = n3[1];
            if (i4 <= 0)
              throw new Error(`could not decode []byte const block size at pc=${t4 + r4}`);
            const a4 = [];
            r4 += i4;
            for (let n4 = 0; n4 < o4; n4++) {
              if (t4 + r4 >= e4.length)
                throw new Error("bytecblock ran past end of program");
              let o5;
              if ([o5, i4] = s3(e4.slice(t4 + r4)), i4 <= 0)
                throw new Error(`could not decode []byte] const[${n4}] block size at pc=${t4 + r4}`);
              if (r4 += i4, t4 + r4 + o5 > e4.length)
                throw new Error("bytecblock ran past end of program");
              const c4 = e4.slice(t4 + r4, t4 + r4 + o5);
              a4.push(c4), r4 += o5;
            }
            return [r4, a4];
          }
          function c3(e4, t4) {
            let r4 = 1;
            const [n3, o4] = s3(e4.slice(t4 + r4));
            if (o4 <= 0)
              throw new Error(`could not decode push int const at pc=${t4 + r4}`);
            return r4 += o4, [r4, n3];
          }
          function u3(e4, t4) {
            let r4 = 1;
            const [n3, o4] = s3(e4.slice(t4 + r4));
            if (o4 <= 0)
              throw new Error(`could not decode push []byte const size at pc=${t4 + r4}`);
            if (r4 += o4, t4 + r4 + n3 > e4.length)
              throw new Error("pushbytes ran past end of program");
            const i4 = e4.slice(t4 + r4, t4 + r4 + n3);
            return r4 += n3, [r4, i4];
          }
          function l3(e4, t4) {
            if (!e4)
              throw new Error("empty program");
            if (t4 === void 0 && (t4 = []), !Array.isArray(t4))
              throw new Error("invalid arguments");
            const [r4, l4] = s3(e4);
            if (l4 <= 0)
              throw new Error("version parsing error");
            if (r4 > n2.z_)
              throw new Error("unsupported version");
            let h4 = 0, { length: p4 } = e4;
            for (const e5 of t4)
              p4 += e5.length;
            if (p4 > 1e3)
              throw new Error("program too long");
            if (!o3) {
              o3 = {};
              for (const e5 of n2.AP)
                o3[e5.Opcode] = e5;
            }
            let f4 = l4, d4 = [], g4 = [];
            for (; f4 < e4.length; ) {
              const t5 = o3[e4[f4]];
              if (t5 === void 0)
                throw new Error("invalid instruction");
              h4 += t5.Cost;
              let r5 = t5.Size;
              if (r5 === 0)
                switch (t5.Opcode) {
                  case 32: {
                    let t6;
                    [r5, t6] = i3(e4, f4), d4 = d4.concat(t6);
                    break;
                  }
                  case 38: {
                    let t6;
                    [r5, t6] = a3(e4, f4), g4 = g4.concat(t6);
                    break;
                  }
                  case 129: {
                    let t6;
                    [r5, t6] = c3(e4, f4), d4.push(t6);
                    break;
                  }
                  case 128: {
                    let t6;
                    [r5, t6] = u3(e4, f4), g4.push(t6);
                    break;
                  }
                  default:
                    throw new Error("invalid instruction");
                }
              f4 += r5;
            }
            if (r4 < 4 && h4 > 2e4)
              throw new Error("program too costly for Teal version < 4. consider using v4.");
            return [d4, g4, true];
          }
          function h3(e4, t4) {
            const [, , r4] = l3(e4, t4);
            return r4;
          }
          function p3(e4, t4) {
            const [r4] = i3(e4, t4);
            return r4;
          }
          function f3(e4, t4) {
            const [r4] = a3(e4, t4);
            return r4;
          }
          function d3(e4, t4) {
            const [r4] = c3(e4, t4);
            return r4;
          }
          function g3(e4, t4) {
            const [r4] = u3(e4, t4);
            return r4;
          }
          const y3 = n2.z_, m3 = n2.BV;
        }, 8800: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { LogicSig: () => h3, LogicSigAccount: () => p3, makeLogicSig: () => f3, signLogicSigTransactionObject: () => d3, signLogicSigTransaction: () => g3, logicSigFromByte: () => y3, tealSign: () => b2, tealSignFromProgram: () => A4 });
          var n2 = r3(9404), o3 = r3(7116), s3 = r3(3033), i3 = r3(5583), a3 = r3(4158), c3 = r3(413), u3 = r3(9417), l3 = r3(2486).Buffer;
          class h3 {
            constructor(e4, t4) {
              if (this.tag = l3.from("Program"), t4 && (!Array.isArray(t4) || !t4.every((e5) => e5.constructor === Uint8Array || l3.isBuffer(e5))))
                throw new TypeError("Invalid arguments");
              let r4;
              if (t4 != null && (r4 = t4.map((e5) => new Uint8Array(e5))), !i3.checkProgram(e4, r4))
                throw new Error("Invalid program");
              this.logic = e4, this.args = r4, this.sig = void 0, this.msig = void 0;
            }
            get_obj_for_encoding() {
              const e4 = { l: this.logic };
              return this.args && (e4.arg = this.args), this.sig ? e4.sig = this.sig : this.msig && (e4.msig = this.msig), e4;
            }
            static from_obj_for_encoding(e4) {
              const t4 = new h3(e4.l, e4.arg);
              return t4.sig = e4.sig, t4.msig = e4.msig, t4;
            }
            verify(e4) {
              if (this.sig && this.msig)
                return false;
              try {
                i3.checkProgram(this.logic, this.args);
              } catch (e5) {
                return false;
              }
              const t4 = c3.concatArrays(this.tag, this.logic);
              if (!this.sig && !this.msig) {
                const r4 = n2.genericHash(t4);
                return c3.arrayEqual(r4, e4);
              }
              return this.sig ? n2.verify(t4, this.sig, e4) : (0, a3.F2)(t4, this.msig, e4);
            }
            address() {
              const e4 = c3.concatArrays(this.tag, this.logic), t4 = n2.genericHash(e4);
              return o3.encodeAddress(new Uint8Array(t4));
            }
            sign(e4, t4) {
              if (t4 == null)
                this.sig = this.signProgram(e4);
              else {
                const r4 = t4.addrs.map((e5) => ({ pk: o3.decodeAddress(e5).publicKey }));
                this.msig = { v: t4.version, thr: t4.threshold, subsig: r4 };
                const [n3, s4] = this.singleSignMultisig(e4, this.msig);
                this.msig.subsig[s4].s = n3;
              }
            }
            appendToMultisig(e4) {
              if (this.msig === void 0)
                throw new Error("no multisig present");
              const [t4, r4] = this.singleSignMultisig(e4, this.msig);
              this.msig.subsig[r4].s = t4;
            }
            signProgram(e4) {
              const t4 = c3.concatArrays(this.tag, this.logic);
              return n2.sign(t4, e4);
            }
            singleSignMultisig(e4, t4) {
              let r4 = -1;
              const o4 = n2.keyPairFromSecretKey(e4).publicKey;
              for (let e5 = 0; e5 < t4.subsig.length; e5++) {
                const { pk: n3 } = t4.subsig[e5];
                if (c3.arrayEqual(n3, o4)) {
                  r4 = e5;
                  break;
                }
              }
              if (r4 === -1)
                throw new Error("invalid secret key");
              return [this.signProgram(e4), r4];
            }
            toByte() {
              return s3.encode(this.get_obj_for_encoding());
            }
            static fromByte(e4) {
              const t4 = s3.decode(e4);
              return h3.from_obj_for_encoding(t4);
            }
          }
          class p3 {
            constructor(e4, t4) {
              this.lsig = new h3(e4, t4), this.sigkey = void 0;
            }
            get_obj_for_encoding() {
              const e4 = { lsig: this.lsig.get_obj_for_encoding() };
              return this.sigkey && (e4.sigkey = this.sigkey), e4;
            }
            static from_obj_for_encoding(e4) {
              const t4 = new p3(e4.lsig.l, e4.lsig.arg);
              return t4.lsig = h3.from_obj_for_encoding(e4.lsig), t4.sigkey = e4.sigkey, t4;
            }
            toByte() {
              return s3.encode(this.get_obj_for_encoding());
            }
            static fromByte(e4) {
              const t4 = s3.decode(e4);
              return p3.from_obj_for_encoding(t4);
            }
            isDelegated() {
              return !(!this.lsig.sig && !this.lsig.msig);
            }
            verify() {
              const e4 = this.address();
              return this.lsig.verify(o3.decodeAddress(e4).publicKey);
            }
            address() {
              if (this.lsig.sig && this.lsig.msig)
                throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
              if (this.lsig.sig) {
                if (!this.sigkey)
                  throw new Error("Signing key for delegated account is missing");
                return o3.encodeAddress(this.sigkey);
              }
              if (this.lsig.msig) {
                const e4 = { version: this.lsig.msig.v, threshold: this.lsig.msig.thr, pks: this.lsig.msig.subsig.map((e5) => e5.pk) };
                return o3.encodeAddress(o3.fromMultisigPreImg(e4));
              }
              return this.lsig.address();
            }
            signMultisig(e4, t4) {
              this.lsig.sign(t4, e4);
            }
            appendToMultisig(e4) {
              this.lsig.appendToMultisig(e4);
            }
            sign(e4) {
              this.lsig.sign(e4), this.sigkey = n2.keyPairFromSecretKey(e4).publicKey;
            }
          }
          function f3(e4, t4) {
            return new h3(e4, t4);
          }
          function d3(e4, t4) {
            let r4, i4;
            if (t4 instanceof p3)
              r4 = t4.lsig, i4 = o3.decodeAddress(t4.address()).publicKey;
            else if (r4 = t4, r4.sig)
              i4 = e4.from.publicKey;
            else if (r4.msig) {
              const e5 = { version: r4.msig.v, threshold: r4.msig.thr, pks: r4.msig.subsig.map((e6) => e6.pk) };
              i4 = o3.fromMultisigPreImg(e5);
            } else
              i4 = o3.decodeAddress(r4.address()).publicKey;
            return function(e5, t5, r5) {
              if (!t5.verify(r5))
                throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
              const o4 = { lsig: t5.get_obj_for_encoding(), txn: e5.get_obj_for_encoding() };
              return n2.bytesEqual(r5, e5.from.publicKey) || (o4.sgnr = l3.from(r5)), { txID: e5.txID().toString(), blob: s3.encode(o4) };
            }(e4, r4, i4);
          }
          function g3(e4, t4) {
            return d3(u3.instantiateTxnIfNeeded(e4), t4);
          }
          function y3(e4) {
            return h3.fromByte(e4);
          }
          const m3 = l3.from("ProgData");
          function b2(e4, t4, r4) {
            const s4 = c3.concatArrays(o3.decodeAddress(r4).publicKey, t4), i4 = l3.from(c3.concatArrays(m3, s4));
            return n2.sign(i4, e4);
          }
          function A4(e4, t4, r4) {
            return b2(e4, t4, new h3(r4).address());
          }
        }, 6608: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { MULTISIG_BAD_SENDER_ERROR_MSG: () => N3, signTransaction: () => P3, signBid: () => L3, signBytes: () => F3, verifyBytes: () => z3, encodeObj: () => j3, decodeObj: () => M3, ERROR_MULTISIG_BAD_SENDER: () => H3, ERROR_INVALID_MICROALGOS: () => G2, Algodv2: () => d3.Z, Kmd: () => g3.Z, IntDecoding: () => y3.Z, Indexer: () => m3.Z, waitForConfirmation: () => b2.K, isValidAddress: () => o3.isValidAddress, encodeAddress: () => o3.encodeAddress, decodeAddress: () => o3.decodeAddress, getApplicationAddress: () => o3.getApplicationAddress, bytesToBigInt: () => A4.v, bigIntToBytes: () => A4.j, encodeUint64: () => w4.T, decodeUint64: () => w4.u, generateAccount: () => v3.Z, modelsv2: () => x3, mnemonicToMasterDerivationKey: () => S2.OF, masterDerivationKeyToMnemonic: () => S2.vC, secretKeyToMnemonic: () => S2.QX, mnemonicToSecretKey: () => S2.Ch, seedFromMnemonic: () => S2.mE, mnemonicFromSeed: () => S2.w3, microalgosToAlgos: () => l3._, algosToMicroalgos: () => l3.HN, INVALID_MICROALGOS_ERROR_MSG: () => l3.rD, computeGroupID: () => E4.computeGroupID, assignGroupID: () => E4.assignGroupID, LogicSigAccount: () => T4.LogicSigAccount, makeLogicSig: () => T4.makeLogicSig, signLogicSigTransaction: () => T4.signLogicSigTransaction, signLogicSigTransactionObject: () => T4.signLogicSigTransactionObject, logicSigFromByte: () => T4.logicSigFromByte, tealSign: () => T4.tealSign, tealSignFromProgram: () => T4.tealSignFromProgram, signMultisigTransaction: () => _4.PU, mergeMultisigTransactions: () => _4.J6, appendSignMultisigTransaction: () => _4.PO, multisigAddress: () => _4.vH, LogicTemplates: () => K3, createDryrun: () => B2.P, OnApplicationComplete: () => U2.OnApplicationComplete, makeApplicationCallTxnFromObject: () => U2.makeApplicationCallTxnFromObject, makeApplicationClearStateTxn: () => U2.makeApplicationClearStateTxn, makeApplicationClearStateTxnFromObject: () => U2.makeApplicationClearStateTxnFromObject, makeApplicationCloseOutTxn: () => U2.makeApplicationCloseOutTxn, makeApplicationCloseOutTxnFromObject: () => U2.makeApplicationCloseOutTxnFromObject, makeApplicationCreateTxn: () => U2.makeApplicationCreateTxn, makeApplicationCreateTxnFromObject: () => U2.makeApplicationCreateTxnFromObject, makeApplicationDeleteTxn: () => U2.makeApplicationDeleteTxn, makeApplicationDeleteTxnFromObject: () => U2.makeApplicationDeleteTxnFromObject, makeApplicationNoOpTxn: () => U2.makeApplicationNoOpTxn, makeApplicationNoOpTxnFromObject: () => U2.makeApplicationNoOpTxnFromObject, makeApplicationOptInTxn: () => U2.makeApplicationOptInTxn, makeApplicationOptInTxnFromObject: () => U2.makeApplicationOptInTxnFromObject, makeApplicationUpdateTxn: () => U2.makeApplicationUpdateTxn, makeApplicationUpdateTxnFromObject: () => U2.makeApplicationUpdateTxnFromObject, makeAssetConfigTxn: () => U2.makeAssetConfigTxn, makeAssetConfigTxnWithSuggestedParams: () => U2.makeAssetConfigTxnWithSuggestedParams, makeAssetConfigTxnWithSuggestedParamsFromObject: () => U2.makeAssetConfigTxnWithSuggestedParamsFromObject, makeAssetCreateTxn: () => U2.makeAssetCreateTxn, makeAssetCreateTxnWithSuggestedParams: () => U2.makeAssetCreateTxnWithSuggestedParams, makeAssetCreateTxnWithSuggestedParamsFromObject: () => U2.makeAssetCreateTxnWithSuggestedParamsFromObject, makeAssetDestroyTxn: () => U2.makeAssetDestroyTxn, makeAssetDestroyTxnWithSuggestedParams: () => U2.makeAssetDestroyTxnWithSuggestedParams, makeAssetDestroyTxnWithSuggestedParamsFromObject: () => U2.makeAssetDestroyTxnWithSuggestedParamsFromObject, makeAssetFreezeTxn: () => U2.makeAssetFreezeTxn, makeAssetFreezeTxnWithSuggestedParams: () => U2.makeAssetFreezeTxnWithSuggestedParams, makeAssetFreezeTxnWithSuggestedParamsFromObject: () => U2.makeAssetFreezeTxnWithSuggestedParamsFromObject, makeAssetTransferTxn: () => U2.makeAssetTransferTxn, makeAssetTransferTxnWithSuggestedParams: () => U2.makeAssetTransferTxnWithSuggestedParams, makeAssetTransferTxnWithSuggestedParamsFromObject: () => U2.makeAssetTransferTxnWithSuggestedParamsFromObject, makeKeyRegistrationTxn: () => U2.makeKeyRegistrationTxn, makeKeyRegistrationTxnWithSuggestedParams: () => U2.makeKeyRegistrationTxnWithSuggestedParams, makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => U2.makeKeyRegistrationTxnWithSuggestedParamsFromObject, makePaymentTxn: () => U2.makePaymentTxn, makePaymentTxnWithSuggestedParams: () => U2.makePaymentTxnWithSuggestedParams, makePaymentTxnWithSuggestedParamsFromObject: () => U2.makePaymentTxnWithSuggestedParamsFromObject, ALGORAND_MIN_TX_FEE: () => i3.ALGORAND_MIN_TX_FEE, Transaction: () => i3.Transaction, decodeSignedTransaction: () => i3.decodeSignedTransaction, decodeUnsignedTransaction: () => i3.decodeUnsignedTransaction, encodeUnsignedTransaction: () => i3.encodeUnsignedTransaction, instantiateTxnIfNeeded: () => i3.instantiateTxnIfNeeded, isTransactionWithSigner: () => k3.Xw, makeBasicAccountTransactionSigner: () => k3.x7, makeLogicSigAccountTransactionSigner: () => k3.i1, makeMultiSigAccountTransactionSigner: () => k3.Vj, AtomicTransactionComposer: () => I3.A, AtomicTransactionComposerStatus: () => I3.b, TransactionType: () => C3.i, ABIAddressType: () => R2.JQ, ABIArrayDynamicType: () => R2._4, ABIArrayStaticType: () => R2.X3, ABIBoolType: () => R2.R0, ABIByteType: () => R2.jD, ABIContract: () => R2.Yh, ABIInterface: () => R2.bL, ABIMethod: () => R2.Ls, ABIReferenceType: () => R2.UV, ABIStringType: () => R2.Ax, ABITransactionType: () => R2.A9, ABITupleType: () => R2.w1, ABIType: () => R2.NK, ABIUfixedType: () => R2.RY, ABIUintType: () => R2.Pu, ADDR_BYTE_SIZE: () => R2.Vk, LENGTH_ENCODE_BYTE_SIZE: () => R2.nh, MAX_LEN: () => R2.kG, SINGLE_BOOL_SIZE: () => R2.qH, SINGLE_BYTE_SIZE: () => R2.JH, abiCheckTransactionType: () => R2.vJ, abiTypeIsReference: () => R2.o5, abiTypeIsTransaction: () => R2.AE });
          var n2 = r3(9404), o3 = r3(7116), s3 = r3(3033), i3 = r3(9417), a3 = r3(8886), c3 = r3.n(a3), u3 = r3(2691), l3 = r3(9070), h3 = r3(413), p3 = r3(5922), f3 = {};
          for (const e4 in p3)
            ["default", "MULTISIG_BAD_SENDER_ERROR_MSG", "signTransaction", "signBid", "signBytes", "verifyBytes", "encodeObj", "decodeObj", "ERROR_MULTISIG_BAD_SENDER", "ERROR_INVALID_MICROALGOS", "Algodv2", "Kmd", "IntDecoding", "Indexer", "waitForConfirmation", "isValidAddress", "encodeAddress", "decodeAddress", "getApplicationAddress", "bytesToBigInt", "bigIntToBytes", "encodeUint64", "decodeUint64", "generateAccount", "modelsv2", "mnemonicToMasterDerivationKey", "masterDerivationKeyToMnemonic", "secretKeyToMnemonic", "mnemonicToSecretKey", "seedFromMnemonic", "mnemonicFromSeed", "microalgosToAlgos", "algosToMicroalgos", "INVALID_MICROALGOS_ERROR_MSG", "computeGroupID", "assignGroupID", "LogicSigAccount", "makeLogicSig", "signLogicSigTransaction", "signLogicSigTransactionObject", "logicSigFromByte", "tealSign", "tealSignFromProgram", "signMultisigTransaction", "mergeMultisigTransactions", "appendSignMultisigTransaction", "multisigAddress", "LogicTemplates"].indexOf(e4) < 0 && (f3[e4] = () => p3[e4]);
          r3.d(t3, f3);
          var d3 = r3(1663), g3 = r3(6477), y3 = r3(7197), m3 = r3(9582), b2 = r3(5062), A4 = r3(8922), w4 = r3(6963), v3 = r3(7988), x3 = r3(227), S2 = r3(3510), E4 = r3(1063), T4 = r3(8800), _4 = r3(4158), B2 = r3(4383), U2 = r3(1988), k3 = r3(834), I3 = r3(3458), C3 = r3(2380), R2 = r3(7677), O2 = r3(2486).Buffer;
          const D3 = O2.from([77, 88]), N3 = "The transaction sender address and multisig preimage do not match.";
          function P3(e4, t4) {
            if (e4.from === void 0) {
              const r5 = n2.keyPairFromSecretKey(t4);
              e4.from = o3.encodeAddress(r5.publicKey);
            }
            const r4 = i3.instantiateTxnIfNeeded(e4);
            return { txID: r4.txID().toString(), blob: r4.signTxn(t4) };
          }
          function L3(e4, t4) {
            return new u3.Z(e4).signBid(t4);
          }
          function F3(e4, t4) {
            const r4 = O2.from(h3.concatArrays(D3, e4));
            return n2.sign(r4, t4);
          }
          function z3(e4, t4, r4) {
            const s4 = O2.from(h3.concatArrays(D3, e4)), i4 = o3.decodeAddress(r4).publicKey;
            return n2.verify(s4, t4, i4);
          }
          function j3(e4) {
            return new Uint8Array(s3.encode(e4));
          }
          function M3(e4) {
            return s3.decode(e4);
          }
          const H3 = new Error(N3), G2 = new Error(l3.rD), K3 = c3();
        }, 1988: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { makePaymentTxnWithSuggestedParams: () => i3, makePaymentTxn: () => a3, makePaymentTxnWithSuggestedParamsFromObject: () => c3, makeKeyRegistrationTxnWithSuggestedParams: () => u3, makeKeyRegistrationTxn: () => l3, makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => h3, makeAssetCreateTxnWithSuggestedParams: () => p3, makeAssetCreateTxn: () => f3, makeAssetCreateTxnWithSuggestedParamsFromObject: () => d3, makeAssetConfigTxnWithSuggestedParams: () => g3, makeAssetConfigTxn: () => y3, makeAssetConfigTxnWithSuggestedParamsFromObject: () => m3, makeAssetDestroyTxnWithSuggestedParams: () => b2, makeAssetDestroyTxn: () => A4, makeAssetDestroyTxnWithSuggestedParamsFromObject: () => w4, makeAssetFreezeTxnWithSuggestedParams: () => v3, makeAssetFreezeTxn: () => x3, makeAssetFreezeTxnWithSuggestedParamsFromObject: () => S2, makeAssetTransferTxnWithSuggestedParams: () => E4, makeAssetTransferTxn: () => T4, makeAssetTransferTxnWithSuggestedParamsFromObject: () => _4, makeApplicationCreateTxn: () => B2, makeApplicationCreateTxnFromObject: () => U2, makeApplicationUpdateTxn: () => k3, makeApplicationUpdateTxnFromObject: () => I3, makeApplicationDeleteTxn: () => C3, makeApplicationDeleteTxnFromObject: () => R2, makeApplicationOptInTxn: () => O2, makeApplicationOptInTxnFromObject: () => D3, makeApplicationCloseOutTxn: () => N3, makeApplicationCloseOutTxnFromObject: () => P3, makeApplicationClearStateTxn: () => L3, makeApplicationClearStateTxnFromObject: () => F3, makeApplicationNoOpTxn: () => z3, makeApplicationNoOpTxnFromObject: () => j3, OnApplicationComplete: () => o3.hq, makeApplicationCallTxnFromObject: () => M3 });
          var n2 = r3(9417), o3 = r3(1624), s3 = r3(1824);
          function i3(e4, t4, r4, o4, i4, a4, c4) {
            const u4 = { from: e4, to: t4, amount: r4, closeRemainderTo: o4, note: i4, suggestedParams: a4, type: s3.i.pay, reKeyTo: c4 };
            return new n2.Transaction(u4);
          }
          function a3(e4, t4, r4, n3, o4, s4, a4, c4, u4, l4, h4) {
            return i3(e4, t4, n3, o4, c4, { genesisHash: u4, genesisID: l4, firstRound: s4, lastRound: a4, fee: r4 }, h4);
          }
          function c3(e4) {
            return i3(e4.from, e4.to, e4.amount, e4.closeRemainderTo, e4.note, e4.suggestedParams, e4.rekeyTo);
          }
          function u3(e4, t4, r4, o4, i4, a4, c4, u4, l4, h4 = false, p4) {
            const f4 = { from: e4, note: t4, voteKey: r4, selectionKey: o4, voteFirst: i4, voteLast: a4, voteKeyDilution: c4, suggestedParams: u4, type: s3.i.keyreg, reKeyTo: l4, nonParticipation: h4, stateProofKey: p4 };
            return new n2.Transaction(f4);
          }
          function l3(e4, t4, r4, n3, o4, s4, i4, a4, c4, l4, h4, p4, f4, d4 = false, g4) {
            return u3(e4, o4, a4, c4, l4, h4, p4, { genesisHash: s4, genesisID: i4, firstRound: r4, lastRound: n3, fee: t4 }, f4, d4, g4);
          }
          function h3(e4) {
            return u3(e4.from, e4.note, e4.voteKey, e4.selectionKey, e4.voteFirst, e4.voteLast, e4.voteKeyDilution, e4.suggestedParams, e4.rekeyTo, e4.nonParticipation, e4.stateProofKey);
          }
          function p3(e4, t4, r4, o4, i4, a4, c4, u4, l4, h4, p4, f4, d4, g4, y4) {
            const m4 = { from: e4, note: t4, suggestedParams: g4, assetTotal: r4, assetDecimals: o4, assetDefaultFrozen: i4, assetUnitName: h4, assetName: p4, assetURL: f4, assetMetadataHash: d4, assetManager: a4, assetReserve: c4, assetFreeze: u4, assetClawback: l4, type: s3.i.acfg, reKeyTo: y4 };
            return new n2.Transaction(m4);
          }
          function f3(e4, t4, r4, n3, o4, s4, i4, a4, c4, u4, l4, h4, f4, d4, g4, y4, m4, b3, A5) {
            return p3(e4, o4, a4, c4, u4, l4, h4, f4, d4, g4, y4, m4, b3, { genesisHash: s4, genesisID: i4, firstRound: r4, lastRound: n3, fee: t4 }, A5);
          }
          function d3(e4) {
            return p3(e4.from, e4.note, e4.total, e4.decimals, e4.defaultFrozen, e4.manager, e4.reserve, e4.freeze, e4.clawback, e4.unitName, e4.assetName, e4.assetURL, e4.assetMetadataHash, e4.suggestedParams, e4.rekeyTo);
          }
          function g3(e4, t4, r4, o4, i4, a4, c4, u4, l4 = true, h4) {
            if (l4 && (o4 === void 0 || i4 === void 0 || a4 === void 0 || c4 === void 0))
              throw Error("strict empty address checking was turned on, but at least one empty address was provided");
            const p4 = { from: e4, suggestedParams: u4, assetIndex: r4, assetManager: o4, assetReserve: i4, assetFreeze: a4, assetClawback: c4, type: s3.i.acfg, note: t4, reKeyTo: h4 };
            return new n2.Transaction(p4);
          }
          function y3(e4, t4, r4, n3, o4, s4, i4, a4, c4, u4, l4, h4, p4 = true, f4) {
            return g3(e4, o4, a4, c4, u4, l4, h4, { genesisHash: s4, genesisID: i4, firstRound: r4, lastRound: n3, fee: t4 }, p4, f4);
          }
          function m3(e4) {
            return g3(e4.from, e4.note, e4.assetIndex, e4.manager, e4.reserve, e4.freeze, e4.clawback, e4.suggestedParams, e4.strictEmptyAddressChecking, e4.rekeyTo);
          }
          function b2(e4, t4, r4, o4, i4) {
            const a4 = { from: e4, suggestedParams: o4, assetIndex: r4, type: s3.i.acfg, note: t4, reKeyTo: i4 };
            return new n2.Transaction(a4);
          }
          function A4(e4, t4, r4, n3, o4, s4, i4, a4, c4) {
            return b2(e4, o4, a4, { genesisHash: s4, genesisID: i4, firstRound: r4, lastRound: n3, fee: t4 }, c4);
          }
          function w4(e4) {
            return b2(e4.from, e4.note, e4.assetIndex, e4.suggestedParams, e4.rekeyTo);
          }
          function v3(e4, t4, r4, o4, i4, a4, c4) {
            const u4 = { from: e4, type: s3.i.afrz, freezeAccount: o4, assetIndex: r4, freezeState: i4, note: t4, suggestedParams: a4, reKeyTo: c4 };
            return new n2.Transaction(u4);
          }
          function x3(e4, t4, r4, n3, o4, s4, i4, a4, c4, u4, l4) {
            return v3(e4, o4, a4, c4, u4, { genesisHash: s4, genesisID: i4, firstRound: r4, lastRound: n3, fee: t4 }, l4);
          }
          function S2(e4) {
            return v3(e4.from, e4.note, e4.assetIndex, e4.freezeTarget, e4.freezeState, e4.suggestedParams, e4.rekeyTo);
          }
          function E4(e4, t4, r4, o4, i4, a4, c4, u4, l4) {
            const h4 = { type: s3.i.axfer, from: e4, to: t4, amount: i4, suggestedParams: u4, assetIndex: c4, note: a4, assetRevocationTarget: o4, closeRemainderTo: r4, reKeyTo: l4 };
            return new n2.Transaction(h4);
          }
          function T4(e4, t4, r4, n3, o4, s4, i4, a4, c4, u4, l4, h4, p4) {
            return E4(e4, t4, r4, n3, s4, c4, h4, { genesisHash: u4, genesisID: l4, firstRound: i4, lastRound: a4, fee: o4 }, p4);
          }
          function _4(e4) {
            return E4(e4.from, e4.to, e4.closeRemainderTo, e4.revocationTarget, e4.amount, e4.note, e4.assetIndex, e4.suggestedParams, e4.rekeyTo);
          }
          function B2(e4, t4, r4, o4, i4, a4, c4, u4, l4, h4, p4, f4, d4, g4, y4, m4, b3) {
            const A5 = { type: s3.i.appl, from: e4, suggestedParams: t4, appIndex: 0, appOnComplete: r4, appLocalInts: a4, appLocalByteSlices: c4, appGlobalInts: u4, appGlobalByteSlices: l4, appApprovalProgram: o4, appClearProgram: i4, appArgs: h4, appAccounts: p4, appForeignApps: f4, appForeignAssets: d4, note: g4, lease: y4, reKeyTo: m4, extraPages: b3 };
            return new n2.Transaction(A5);
          }
          function U2(e4) {
            return B2(e4.from, e4.suggestedParams, e4.onComplete, e4.approvalProgram, e4.clearProgram, e4.numLocalInts, e4.numLocalByteSlices, e4.numGlobalInts, e4.numGlobalByteSlices, e4.appArgs, e4.accounts, e4.foreignApps, e4.foreignAssets, e4.note, e4.lease, e4.rekeyTo, e4.extraPages);
          }
          function k3(e4, t4, r4, i4, a4, c4, u4, l4, h4, p4, f4, d4) {
            const g4 = { type: s3.i.appl, from: e4, suggestedParams: t4, appIndex: r4, appApprovalProgram: i4, appOnComplete: o3.hq.UpdateApplicationOC, appClearProgram: a4, appArgs: c4, appAccounts: u4, appForeignApps: l4, appForeignAssets: h4, note: p4, lease: f4, reKeyTo: d4 };
            return new n2.Transaction(g4);
          }
          function I3(e4) {
            return k3(e4.from, e4.suggestedParams, e4.appIndex, e4.approvalProgram, e4.clearProgram, e4.appArgs, e4.accounts, e4.foreignApps, e4.foreignAssets, e4.note, e4.lease, e4.rekeyTo);
          }
          function C3(e4, t4, r4, i4, a4, c4, u4, l4, h4, p4) {
            const f4 = { type: s3.i.appl, from: e4, suggestedParams: t4, appIndex: r4, appOnComplete: o3.hq.DeleteApplicationOC, appArgs: i4, appAccounts: a4, appForeignApps: c4, appForeignAssets: u4, note: l4, lease: h4, reKeyTo: p4 };
            return new n2.Transaction(f4);
          }
          function R2(e4) {
            return C3(e4.from, e4.suggestedParams, e4.appIndex, e4.appArgs, e4.accounts, e4.foreignApps, e4.foreignAssets, e4.note, e4.lease, e4.rekeyTo);
          }
          function O2(e4, t4, r4, i4, a4, c4, u4, l4, h4, p4) {
            const f4 = { type: s3.i.appl, from: e4, suggestedParams: t4, appIndex: r4, appOnComplete: o3.hq.OptInOC, appArgs: i4, appAccounts: a4, appForeignApps: c4, appForeignAssets: u4, note: l4, lease: h4, reKeyTo: p4 };
            return new n2.Transaction(f4);
          }
          function D3(e4) {
            return O2(e4.from, e4.suggestedParams, e4.appIndex, e4.appArgs, e4.accounts, e4.foreignApps, e4.foreignAssets, e4.note, e4.lease, e4.rekeyTo);
          }
          function N3(e4, t4, r4, i4, a4, c4, u4, l4, h4, p4) {
            const f4 = { type: s3.i.appl, from: e4, suggestedParams: t4, appIndex: r4, appOnComplete: o3.hq.CloseOutOC, appArgs: i4, appAccounts: a4, appForeignApps: c4, appForeignAssets: u4, note: l4, lease: h4, reKeyTo: p4 };
            return new n2.Transaction(f4);
          }
          function P3(e4) {
            return N3(e4.from, e4.suggestedParams, e4.appIndex, e4.appArgs, e4.accounts, e4.foreignApps, e4.foreignAssets, e4.note, e4.lease, e4.rekeyTo);
          }
          function L3(e4, t4, r4, i4, a4, c4, u4, l4, h4, p4) {
            const f4 = { type: s3.i.appl, from: e4, suggestedParams: t4, appIndex: r4, appOnComplete: o3.hq.ClearStateOC, appArgs: i4, appAccounts: a4, appForeignApps: c4, appForeignAssets: u4, note: l4, lease: h4, reKeyTo: p4 };
            return new n2.Transaction(f4);
          }
          function F3(e4) {
            return L3(e4.from, e4.suggestedParams, e4.appIndex, e4.appArgs, e4.accounts, e4.foreignApps, e4.foreignAssets, e4.note, e4.lease, e4.rekeyTo);
          }
          function z3(e4, t4, r4, i4, a4, c4, u4, l4, h4, p4) {
            const f4 = { type: s3.i.appl, from: e4, suggestedParams: t4, appIndex: r4, appOnComplete: o3.hq.NoOpOC, appArgs: i4, appAccounts: a4, appForeignApps: c4, appForeignAssets: u4, note: l4, lease: h4, reKeyTo: p4 };
            return new n2.Transaction(f4);
          }
          function j3(e4) {
            return z3(e4.from, e4.suggestedParams, e4.appIndex, e4.appArgs, e4.accounts, e4.foreignApps, e4.foreignAssets, e4.note, e4.lease, e4.rekeyTo);
          }
          function M3(e4) {
            const t4 = { type: s3.i.appl, from: e4.from, suggestedParams: e4.suggestedParams, appIndex: e4.appIndex, appOnComplete: e4.onComplete, appLocalInts: e4.numLocalInts, appLocalByteSlices: e4.numLocalByteSlices, appGlobalInts: e4.numGlobalInts, appGlobalByteSlices: e4.numGlobalByteSlices, appApprovalProgram: e4.approvalProgram, appClearProgram: e4.clearProgram, appArgs: e4.appArgs, appAccounts: e4.accounts, appForeignApps: e4.foreignApps, appForeignAssets: e4.foreignAssets, note: e4.note, lease: e4.lease, reKeyTo: e4.rekeyTo, extraPages: e4.extraPages };
            return new n2.Transaction(t4);
          }
        }, 3510: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { vC: () => g3, w3: () => l3, OF: () => d3, Ch: () => p3, QX: () => f3, mE: () => h3 });
          const n2 = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];
          var o3 = r3(9404), s3 = r3(7116);
          const i3 = "failed to decode mnemonic";
          function a3(e4) {
            const t4 = [];
            let r4 = 0, n3 = 0;
            return e4.forEach(function(e5) {
              r4 |= e5 << n3, n3 += 8, n3 >= 11 && (t4.push(2047 & r4), r4 >>= 11, n3 -= 11);
            }), n3 && t4.push(r4), t4;
          }
          function c3(e4) {
            return e4.map((e5) => n2[e5]);
          }
          function u3(e4) {
            return c3(a3(o3.genericHash(e4)))[0];
          }
          function l3(e4) {
            if (e4.length !== o3.SEED_BTYES_LENGTH)
              throw new RangeError(`Seed length must be ${o3.SEED_BTYES_LENGTH}`);
            const t4 = c3(a3(e4)), r4 = u3(e4);
            return `${t4.join(" ")} ${r4}`;
          }
          function h3(e4) {
            const t4 = e4.split(" "), r4 = t4.slice(0, 24);
            for (const e5 of r4)
              if (n2.indexOf(e5) === -1)
                throw new Error("the mnemonic contains a word that is not in the wordlist");
            const o4 = t4[t4.length - 1];
            let s4 = function(e5) {
              const t5 = [];
              let r5 = 0, n3 = 0;
              return e5.forEach(function(e6) {
                for (r5 |= e6 << n3, n3 += 11; n3 >= 8; )
                  t5.push(255 & r5), r5 >>= 8, n3 -= 8;
              }), n3 && t5.push(r5), new Uint8Array(t5);
            }(r4.map((e5) => n2.indexOf(e5)));
            if (s4.length !== 33)
              throw new Error(i3);
            if (s4[s4.length - 1] !== 0)
              throw new Error(i3);
            if (s4 = s4.slice(0, s4.length - 1), u3(s4) === o4)
              return s4;
            throw new Error(i3);
          }
          function p3(e4) {
            const t4 = h3(e4), r4 = o3.keyPairFromSeed(t4);
            return { addr: s3.encodeAddress(r4.publicKey), sk: r4.secretKey };
          }
          function f3(e4) {
            return l3(e4.slice(0, o3.SEED_BTYES_LENGTH));
          }
          function d3(e4) {
            return h3(e4);
          }
          function g3(e4) {
            return l3(e4);
          }
        }, 4158: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { J6: () => p3, F2: () => f3, PU: () => d3, PO: () => g3, vH: () => y3 });
          var n2 = r3(9404), o3 = r3(7116), s3 = r3(3033), i3 = r3(9417), a3 = r3(413), c3 = r3(2486).Buffer;
          const u3 = "Cannot merge txs. Multisig preimages differ", l3 = "Cannot mutate a multisig field as it would invalidate all existing signatures.";
          class h3 extends i3.Transaction {
            addLease() {
              throw new Error(l3);
            }
            addRekey() {
              throw new Error(l3);
            }
            signTxn(e4) {
              throw new Error("Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.");
            }
            partialSignTxn({ version: e4, threshold: t4, pks: r4 }, i4) {
              const a4 = n2.keyPairFromSecretKey(i4).publicKey;
              return function(e5, { rawSig: t5, myPk: r5 }, { version: i5, threshold: a5, pks: u4 }) {
                let l4 = false;
                const h4 = u4.map((e6) => n2.bytesEqual(e6, r5) ? (l4 = true, { pk: c3.from(e6), s: t5 }) : { pk: c3.from(e6) });
                if (l4 === false)
                  throw new Error("Key does not exist");
                const p4 = { msig: { v: i5, thr: a5, subsig: h4 }, txn: e5 }, f4 = o3.fromMultisigPreImg({ version: i5, threshold: a5, pks: u4 });
                return o3.encodeAddress(e5.snd) !== o3.encodeAddress(f4) && (p4.sgnr = c3.from(f4)), new Uint8Array(s3.encode(p4));
              }(this.get_obj_for_encoding(), { rawSig: this.rawSignTxn(i4), myPk: a4 }, { version: e4, threshold: t4, pks: r4 });
            }
            static from_obj_for_encoding(e4) {
              return super.from_obj_for_encoding(e4);
            }
          }
          function p3(e4) {
            if (e4.length < 2)
              throw new Error("Not enough multisig transactions to merge. Need at least two");
            const t4 = s3.decode(e4[0]), r4 = h3.from_obj_for_encoding(t4.txn).txID(), n3 = t4.sgnr ? o3.encodeAddress(t4.sgnr) : void 0, i4 = { version: t4.msig.v, threshold: t4.msig.thr, pks: t4.msig.subsig.map((e5) => e5.pk) }, a4 = o3.encodeAddress(o3.fromMultisigPreImg(i4));
            let l4 = t4.msig.subsig;
            for (let i5 = 0; i5 < e4.length; i5++) {
              const p5 = s3.decode(e4[i5]);
              if (h3.from_obj_for_encoding(p5.txn).txID() !== r4)
                throw new Error("Cannot merge txs. txIDs differ");
              if (n3 !== (p5.sgnr ? o3.encodeAddress(p5.sgnr) : void 0))
                throw new Error("Cannot merge txs. Auth addrs differ");
              if (p5.msig.subsig.length !== t4.msig.subsig.length)
                throw new Error(u3);
              const f4 = { version: p5.msig.v, threshold: p5.msig.thr, pks: p5.msig.subsig.map((e5) => e5.pk) };
              if (a4 !== o3.encodeAddress(o3.fromMultisigPreImg(f4)))
                throw new Error(u3);
              l4 = p5.msig.subsig.map((e5, r5) => {
                const n4 = t4.msig.subsig[r5];
                if (n4.s) {
                  if (e5.s && c3.compare(c3.from(e5.s), c3.from(n4.s)) !== 0)
                    throw new Error("Cannot merge txs. subsigs are mismatched.");
                  return { pk: n4.pk, s: n4.s };
                }
                return e5.s ? { pk: n4.pk, s: e5.s } : n4;
              });
            }
            const p4 = { msig: { v: t4.msig.v, thr: t4.msig.thr, subsig: l4 }, txn: t4.txn };
            return n3 !== void 0 && (p4.sgnr = c3.from(o3.decodeAddress(n3).publicKey)), new Uint8Array(s3.encode(p4));
          }
          function f3(e4, t4, r4) {
            const s4 = t4.v, i4 = t4.thr, c4 = t4.subsig, u4 = c4.map((e5) => e5.pk);
            if (t4.subsig.length < i4)
              return false;
            let l4;
            try {
              l4 = o3.fromMultisigPreImg({ version: s4, threshold: i4, pks: u4 });
            } catch (e5) {
              return false;
            }
            if (!a3.arrayEqual(l4, r4))
              return false;
            let h4 = 0;
            for (const e5 of c4)
              e5.s !== void 0 && (h4 += 1);
            if (h4 < i4)
              return false;
            let p4 = 0;
            for (const t5 of c4)
              t5.s !== void 0 && n2.verify(e4, t5.s, t5.pk) && (p4 += 1);
            return !(p4 < i4);
          }
          function d3(e4, { version: t4, threshold: r4, addrs: n3 }, s4) {
            const a4 = o3.fromMultisigPreImgAddrs({ version: t4, threshold: r4, addrs: n3 });
            Object.prototype.hasOwnProperty.call(e4, "from") || (e4.from = a4);
            const c4 = n3.map((e5) => o3.decodeAddress(e5).publicKey);
            let u4, l4;
            return e4 instanceof i3.Transaction ? (u4 = e4, l4 = h3.prototype.partialSignTxn.call(u4, { version: t4, threshold: r4, pks: c4 }, s4)) : (u4 = new h3(e4), l4 = u4.partialSignTxn({ version: t4, threshold: r4, pks: c4 }, s4)), { txID: u4.txID().toString(), blob: l4 };
          }
          function g3(e4, { version: t4, threshold: r4, addrs: n3 }, i4) {
            const a4 = n3.map((e5) => o3.decodeAddress(e5).publicKey), c4 = s3.decode(e4), u4 = h3.from_obj_for_encoding(c4.txn), l4 = u4.partialSignTxn({ version: t4, threshold: r4, pks: a4 }, i4);
            return { txID: u4.txID().toString(), blob: p3([e4, l4]) };
          }
          function y3({ version: e4, threshold: t4, addrs: r4 }) {
            return o3.fromMultisigPreImgAddrs({ version: e4, threshold: t4, addrs: r4 });
          }
        }, 9404: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { genericHash: () => a3, randomBytes: () => c3, keyPairFromSeed: () => u3, keyPair: () => l3, keyPairFromSecretKey: () => h3, sign: () => p3, bytesEqual: () => f3, verify: () => d3, PUBLIC_KEY_LENGTH: () => g3, SECRET_KEY_LENGTH: () => y3, HASH_BYTES_LENGTH: () => m3, SEED_BTYES_LENGTH: () => b2 });
          var n2 = r3(7765), o3 = r3.n(n2), s3 = r3(9757), i3 = r3.n(s3);
          function a3(e4) {
            return i3().sha512_256.array(e4);
          }
          function c3(e4) {
            return o3().randomBytes(e4);
          }
          function u3(e4) {
            return o3().sign.keyPair.fromSeed(e4);
          }
          function l3() {
            return u3(c3(o3().box.secretKeyLength));
          }
          function h3(e4) {
            return o3().sign.keyPair.fromSecretKey(e4);
          }
          function p3(e4, t4) {
            return o3().sign.detached(e4, t4);
          }
          function f3(e4, t4) {
            return o3().verify(e4, t4);
          }
          function d3(e4, t4, r4) {
            return o3().sign.detached.verify(e4, t4, r4);
          }
          const g3 = o3().sign.publicKeyLength, y3 = o3().sign.secretKeyLength, m3 = 32, b2 = 32;
        }, 834: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { x7: () => s3, i1: () => i3, Vj: () => a3, Xw: () => c3 });
          var n2 = r3(8800), o3 = r3(4158);
          function s3(e4) {
            return (t4, r4) => {
              const n3 = [];
              for (const o4 of r4)
                n3.push(t4[o4].signTxn(e4.sk));
              return Promise.resolve(n3);
            };
          }
          function i3(e4) {
            return (t4, r4) => {
              const o4 = [];
              for (const s4 of r4) {
                const { blob: r5 } = (0, n2.signLogicSigTransactionObject)(t4[s4], e4);
                o4.push(r5);
              }
              return Promise.resolve(o4);
            };
          }
          function a3(e4, t4) {
            return (r4, n3) => {
              const s4 = [];
              for (const i4 of n3) {
                const n4 = r4[i4], a4 = [];
                for (const r5 of t4) {
                  const { blob: t5 } = (0, o3.PU)(n4, e4, r5);
                  a4.push(t5);
                }
                s4.push((0, o3.J6)(a4));
              }
              return Promise.resolve(s4);
            };
          }
          function c3(e4) {
            return typeof e4 == "object" && Object.keys(e4).length === 2 && typeof e4.txn == "object" && typeof e4.signer == "function";
          }
        }, 9417: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { ALGORAND_MIN_TX_FEE: () => h3, Transaction: () => f3, encodeUnsignedTransaction: () => d3, decodeUnsignedTransaction: () => g3, decodeSignedTransaction: () => y3, instantiateTxnIfNeeded: () => m3, default: () => b2 });
          var n2 = r3(7267), o3 = r3.n(n2), s3 = r3(7116), i3 = r3(3033), a3 = r3(9404), c3 = r3(413), u3 = r3(1624), l3 = r3(2486).Buffer;
          const h3 = 1e3;
          function p3(e4, t4, r4) {
            if (e4 == null)
              return;
            let n3;
            if (typeof e4 == "string" ? n3 = l3.from(e4, "base64") : e4.constructor === Uint8Array ? n3 = l3.from(e4) : l3.isBuffer(e4) && (n3 = e4), n3 == null || n3.byteLength !== r4)
              throw Error(`${t4} must be a ${r4} byte Uint8Array or Buffer or base64 string.`);
            return n3;
          }
          class f3 {
            constructor({ ...e4 }) {
              this.name = "Transaction", this.tag = l3.from("TX");
              const t4 = { type: u3.iU.pay, flatFee: false, nonParticipation: false };
              if (e4.type === void 0 && (e4.type = t4.type), e4.flatFee === void 0 && (e4.flatFee = t4.flatFee), e4.type === u3.iU.keyreg && e4.voteKey !== void 0 && e4.nonParticipation === void 0 && (e4.nonParticipation = t4.nonParticipation), e4.suggestedParams !== void 0) {
                const t5 = e4;
                t5.genesisHash = t5.suggestedParams.genesisHash, t5.fee = t5.suggestedParams.fee, t5.suggestedParams.flatFee !== void 0 && (t5.flatFee = t5.suggestedParams.flatFee), t5.firstRound = t5.suggestedParams.firstRound, t5.lastRound = t5.suggestedParams.lastRound, t5.genesisID = t5.suggestedParams.genesisID;
              }
              const r4 = e4;
              if (r4.from = s3.decodeAddress(r4.from), r4.to !== void 0 && (r4.to = s3.decodeAddress(r4.to)), r4.closeRemainderTo !== void 0 && (r4.closeRemainderTo = s3.decodeAddress(r4.closeRemainderTo)), r4.assetManager !== void 0 && (r4.assetManager = s3.decodeAddress(r4.assetManager)), r4.assetReserve !== void 0 && (r4.assetReserve = s3.decodeAddress(r4.assetReserve)), r4.assetFreeze !== void 0 && (r4.assetFreeze = s3.decodeAddress(r4.assetFreeze)), r4.assetClawback !== void 0 && (r4.assetClawback = s3.decodeAddress(r4.assetClawback)), r4.assetRevocationTarget !== void 0 && (r4.assetRevocationTarget = s3.decodeAddress(r4.assetRevocationTarget)), r4.freezeAccount !== void 0 && (r4.freezeAccount = s3.decodeAddress(r4.freezeAccount)), r4.reKeyTo !== void 0 && (r4.reKeyTo = s3.decodeAddress(r4.reKeyTo)), r4.genesisHash === void 0)
                throw Error("genesis hash must be specified and in a base64 string.");
              if (r4.genesisHash = l3.from(r4.genesisHash, "base64"), r4.amount !== void 0 && (!(Number.isSafeInteger(r4.amount) || typeof r4.amount == "bigint" && r4.amount <= BigInt("0xffffffffffffffff")) || r4.amount < 0))
                throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
              if (!Number.isSafeInteger(r4.fee) || r4.fee < 0)
                throw Error("fee must be a positive number and smaller than 2^53-1");
              if (!Number.isSafeInteger(r4.firstRound) || r4.firstRound < 0)
                throw Error("firstRound must be a positive number");
              if (!Number.isSafeInteger(r4.lastRound) || r4.lastRound < 0)
                throw Error("lastRound must be a positive number");
              if (r4.extraPages !== void 0 && (!Number.isInteger(r4.extraPages) || r4.extraPages < 0 || r4.extraPages > 3))
                throw Error("extraPages must be an Integer between and including 0 to 3");
              if (r4.assetTotal !== void 0 && (!(Number.isSafeInteger(r4.assetTotal) || typeof r4.assetTotal == "bigint" && r4.assetTotal <= BigInt("0xffffffffffffffff")) || r4.assetTotal < 0))
                throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
              if (r4.assetDecimals !== void 0 && (!Number.isSafeInteger(r4.assetDecimals) || r4.assetDecimals < 0 || r4.assetDecimals > 19))
                throw Error(`assetDecimals must be a positive number and smaller than ${19 .toString()}`);
              if (r4.assetIndex !== void 0 && (!Number.isSafeInteger(r4.assetIndex) || r4.assetIndex < 0))
                throw Error("Asset index must be a positive number and smaller than 2^53-1");
              if (r4.appIndex !== void 0 && (!Number.isSafeInteger(r4.appIndex) || r4.appIndex < 0))
                throw Error("Application index must be a positive number and smaller than 2^53-1");
              if (r4.appLocalInts !== void 0 && (!Number.isSafeInteger(r4.appLocalInts) || r4.appLocalInts < 0))
                throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
              if (r4.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(r4.appLocalByteSlices) || r4.appLocalByteSlices < 0))
                throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
              if (r4.appGlobalInts !== void 0 && (!Number.isSafeInteger(r4.appGlobalInts) || r4.appGlobalInts < 0))
                throw Error("Application global ints count must be a positive number and smaller than 2^53-1");
              if (r4.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(r4.appGlobalByteSlices) || r4.appGlobalByteSlices < 0))
                throw Error("Application global byte slices count must be a positive number and smaller than 2^53-1");
              if (r4.appApprovalProgram !== void 0 && r4.appApprovalProgram.constructor !== Uint8Array)
                throw Error("appApprovalProgram must be a Uint8Array.");
              if (r4.appClearProgram !== void 0 && r4.appClearProgram.constructor !== Uint8Array)
                throw Error("appClearProgram must be a Uint8Array.");
              if (r4.appArgs !== void 0) {
                if (!Array.isArray(r4.appArgs))
                  throw Error("appArgs must be an Array of Uint8Array.");
                r4.appArgs = r4.appArgs.slice(), r4.appArgs.forEach((e5) => {
                  if (e5.constructor !== Uint8Array)
                    throw Error("each element of AppArgs must be a Uint8Array.");
                });
              } else
                r4.appArgs = [];
              if (r4.appAccounts !== void 0) {
                if (!Array.isArray(r4.appAccounts))
                  throw Error("appAccounts must be an Array of addresses.");
                r4.appAccounts = r4.appAccounts.map((e5) => s3.decodeAddress(e5));
              }
              if (r4.appForeignApps !== void 0) {
                if (!Array.isArray(r4.appForeignApps))
                  throw Error("appForeignApps must be an Array of integers.");
                r4.appForeignApps = r4.appForeignApps.slice(), r4.appForeignApps.forEach((e5) => {
                  if (!Number.isSafeInteger(e5) || e5 < 0)
                    throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
                });
              }
              if (r4.appForeignAssets !== void 0) {
                if (!Array.isArray(r4.appForeignAssets))
                  throw Error("appForeignAssets must be an Array of integers.");
                r4.appForeignAssets = r4.appForeignAssets.slice(), r4.appForeignAssets.forEach((e5) => {
                  if (!Number.isSafeInteger(e5) || e5 < 0)
                    throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
                });
              }
              if (r4.assetMetadataHash !== void 0 && r4.assetMetadataHash.length !== 0) {
                if (typeof r4.assetMetadataHash == "string" && (r4.assetMetadataHash = new Uint8Array(l3.from(r4.assetMetadataHash))), r4.assetMetadataHash.constructor !== Uint8Array || r4.assetMetadataHash.byteLength !== 32)
                  throw Error("assetMetadataHash must be a 32 byte Uint8Array or string.");
                r4.assetMetadataHash.every((e5) => e5 === 0) && (r4.assetMetadataHash = void 0);
              } else
                r4.assetMetadataHash = void 0;
              if (r4.note !== void 0) {
                if (r4.note.constructor !== Uint8Array)
                  throw Error("note must be a Uint8Array.");
              } else
                r4.note = new Uint8Array(0);
              if (r4.lease !== void 0) {
                if (r4.lease.constructor !== Uint8Array)
                  throw Error("lease must be a Uint8Array.");
                if (r4.lease.length !== 32)
                  throw Error(`lease must be of length ${32 .toString()}.`);
                r4.lease.every((e5) => e5 === 0) && (r4.lease = new Uint8Array(0));
              } else
                r4.lease = new Uint8Array(0);
              if (r4.voteKey = p3(r4.voteKey, "voteKey", 32), r4.selectionKey = p3(r4.selectionKey, "selectionKey", 32), r4.stateProofKey = p3(r4.stateProofKey, "stateProofKey", 64), r4.nonParticipation && (r4.voteKey || r4.selectionKey || r4.voteFirst || r4.stateProofKey || r4.voteLast || r4.voteKeyDilution))
                throw new Error("nonParticipation is true but participation params are present.");
              if (!r4.nonParticipation && (r4.voteKey || r4.selectionKey || r4.stateProofKey || r4.voteFirst || r4.voteLast || r4.voteKeyDilution) && !(r4.voteKey && r4.selectionKey && r4.voteFirst && r4.voteLast && r4.voteKeyDilution))
                throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
              delete r4.suggestedParams, Object.assign(this, c3.removeUndefinedProperties(r4)), r4.flatFee || (this.fee *= this.estimateSize(), this.fee < h3 && (this.fee = h3)), this.group = void 0;
            }
            get_obj_for_encoding() {
              if (this.type === "pay") {
                const e4 = { amt: this.amount, fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: l3.from(this.note), snd: l3.from(this.from.publicKey), type: "pay", gen: this.genesisID, gh: this.genesisHash, lx: l3.from(this.lease), grp: this.group };
                return this.closeRemainderTo !== void 0 && s3.encodeAddress(this.closeRemainderTo.publicKey) !== s3.ALGORAND_ZERO_ADDRESS_STRING && (e4.close = l3.from(this.closeRemainderTo.publicKey)), this.reKeyTo !== void 0 && (e4.rekey = l3.from(this.reKeyTo.publicKey)), this.to !== void 0 && (e4.rcv = l3.from(this.to.publicKey)), e4.note.length || delete e4.note, e4.amt || delete e4.amt, e4.fee || delete e4.fee, e4.fv || delete e4.fv, e4.gen || delete e4.gen, e4.grp === void 0 && delete e4.grp, e4.lx.length || delete e4.lx, e4.rekey || delete e4.rekey, e4;
              }
              if (this.type === "keyreg") {
                const e4 = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: l3.from(this.note), snd: l3.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: l3.from(this.lease), grp: this.group, votekey: this.voteKey, selkey: this.selectionKey, sprfkey: this.stateProofKey, votefst: this.voteFirst, votelst: this.voteLast, votekd: this.voteKeyDilution };
                return e4.note.length || delete e4.note, e4.lx.length || delete e4.lx, e4.fee || delete e4.fee, e4.fv || delete e4.fv, e4.gen || delete e4.gen, e4.grp === void 0 && delete e4.grp, this.reKeyTo !== void 0 && (e4.rekey = l3.from(this.reKeyTo.publicKey)), this.nonParticipation && (e4.nonpart = true), e4.selkey || delete e4.selkey, e4.votekey || delete e4.votekey, e4.sprfkey || delete e4.sprfkey, e4.votefst || delete e4.votefst, e4.votelst || delete e4.votelst, e4.votekd || delete e4.votekd, e4;
              }
              if (this.type === "acfg") {
                const e4 = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: l3.from(this.note), snd: l3.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: l3.from(this.lease), grp: this.group, caid: this.assetIndex, apar: { t: this.assetTotal, df: this.assetDefaultFrozen, dc: this.assetDecimals } };
                return this.assetManager !== void 0 && (e4.apar.m = l3.from(this.assetManager.publicKey)), this.assetReserve !== void 0 && (e4.apar.r = l3.from(this.assetReserve.publicKey)), this.assetFreeze !== void 0 && (e4.apar.f = l3.from(this.assetFreeze.publicKey)), this.assetClawback !== void 0 && (e4.apar.c = l3.from(this.assetClawback.publicKey)), this.assetName !== void 0 && (e4.apar.an = this.assetName), this.assetUnitName !== void 0 && (e4.apar.un = this.assetUnitName), this.assetURL !== void 0 && (e4.apar.au = this.assetURL), this.assetMetadataHash !== void 0 && (e4.apar.am = l3.from(this.assetMetadataHash)), e4.note.length || delete e4.note, e4.lx.length || delete e4.lx, e4.amt || delete e4.amt, e4.fee || delete e4.fee, e4.fv || delete e4.fv, e4.gen || delete e4.gen, this.reKeyTo !== void 0 && (e4.rekey = l3.from(this.reKeyTo.publicKey)), e4.caid || delete e4.caid, e4.apar.t || e4.apar.un || e4.apar.an || e4.apar.df || e4.apar.m || e4.apar.r || e4.apar.f || e4.apar.c || e4.apar.au || e4.apar.am || e4.apar.dc ? (e4.apar.t || delete e4.apar.t, e4.apar.dc || delete e4.apar.dc, e4.apar.un || delete e4.apar.un, e4.apar.an || delete e4.apar.an, e4.apar.df || delete e4.apar.df, e4.apar.m || delete e4.apar.m, e4.apar.r || delete e4.apar.r, e4.apar.f || delete e4.apar.f, e4.apar.c || delete e4.apar.c, e4.apar.au || delete e4.apar.au, e4.apar.am || delete e4.apar.am) : delete e4.apar, e4.grp === void 0 && delete e4.grp, e4;
              }
              if (this.type === "axfer") {
                const e4 = { aamt: this.amount, fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: l3.from(this.note), snd: l3.from(this.from.publicKey), arcv: l3.from(this.to.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: l3.from(this.lease), grp: this.group, xaid: this.assetIndex };
                return this.closeRemainderTo !== void 0 && (e4.aclose = l3.from(this.closeRemainderTo.publicKey)), this.assetRevocationTarget !== void 0 && (e4.asnd = l3.from(this.assetRevocationTarget.publicKey)), e4.note.length || delete e4.note, e4.lx.length || delete e4.lx, e4.aamt || delete e4.aamt, e4.amt || delete e4.amt, e4.fee || delete e4.fee, e4.fv || delete e4.fv, e4.gen || delete e4.gen, e4.grp === void 0 && delete e4.grp, e4.aclose || delete e4.aclose, e4.asnd || delete e4.asnd, e4.rekey || delete e4.rekey, this.reKeyTo !== void 0 && (e4.rekey = l3.from(this.reKeyTo.publicKey)), e4;
              }
              if (this.type === "afrz") {
                const e4 = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: l3.from(this.note), snd: l3.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: l3.from(this.lease), grp: this.group, faid: this.assetIndex, afrz: this.freezeState };
                return this.freezeAccount !== void 0 && (e4.fadd = l3.from(this.freezeAccount.publicKey)), e4.note.length || delete e4.note, e4.lx.length || delete e4.lx, e4.amt || delete e4.amt, e4.fee || delete e4.fee, e4.fv || delete e4.fv, e4.gen || delete e4.gen, e4.afrz || delete e4.afrz, e4.grp === void 0 && delete e4.grp, this.reKeyTo !== void 0 && (e4.rekey = l3.from(this.reKeyTo.publicKey)), e4;
              }
              if (this.type === "appl") {
                const e4 = { fee: this.fee, fv: this.firstRound, lv: this.lastRound, note: l3.from(this.note), snd: l3.from(this.from.publicKey), type: this.type, gen: this.genesisID, gh: this.genesisHash, lx: l3.from(this.lease), grp: this.group, apid: this.appIndex, apan: this.appOnComplete, apls: { nui: this.appLocalInts, nbs: this.appLocalByteSlices }, apgs: { nui: this.appGlobalInts, nbs: this.appGlobalByteSlices }, apfa: this.appForeignApps, apas: this.appForeignAssets, apep: this.extraPages };
                return this.reKeyTo !== void 0 && (e4.rekey = l3.from(this.reKeyTo.publicKey)), this.appApprovalProgram !== void 0 && (e4.apap = l3.from(this.appApprovalProgram)), this.appClearProgram !== void 0 && (e4.apsu = l3.from(this.appClearProgram)), this.appArgs !== void 0 && (e4.apaa = this.appArgs.map((e5) => l3.from(e5))), this.appAccounts !== void 0 && (e4.apat = this.appAccounts.map((e5) => l3.from(e5.publicKey))), e4.note.length || delete e4.note, e4.lx.length || delete e4.lx, e4.amt || delete e4.amt, e4.fee || delete e4.fee, e4.fv || delete e4.fv, e4.gen || delete e4.gen, e4.apid || delete e4.apid, e4.apls.nui || delete e4.apls.nui, e4.apls.nbs || delete e4.apls.nbs, e4.apls.nui || e4.apls.nbs || delete e4.apls, e4.apgs.nui || delete e4.apgs.nui, e4.apgs.nbs || delete e4.apgs.nbs, e4.apaa && e4.apaa.length || delete e4.apaa, e4.apgs.nui || e4.apgs.nbs || delete e4.apgs, e4.apap || delete e4.apap, e4.apsu || delete e4.apsu, e4.apan || delete e4.apan, e4.apfa && e4.apfa.length || delete e4.apfa, e4.apas && e4.apas.length || delete e4.apas, e4.apat && e4.apat.length || delete e4.apat, e4.apep || delete e4.apep, e4.grp === void 0 && delete e4.grp, e4;
              }
            }
            static from_obj_for_encoding(e4) {
              const t4 = Object.create(this.prototype);
              if (t4.name = "Transaction", t4.tag = l3.from("TX"), t4.genesisID = e4.gen, t4.genesisHash = l3.from(e4.gh), !(0, u3.v8)(e4.type))
                throw new Error(`Unrecognized transaction type: ${e4.type}`);
              return t4.type = e4.type, t4.fee = e4.fee, t4.firstRound = e4.fv, t4.lastRound = e4.lv, t4.note = new Uint8Array(e4.note), t4.lease = new Uint8Array(e4.lx), t4.from = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.snd))), e4.grp !== void 0 && (t4.group = l3.from(e4.grp)), e4.rekey !== void 0 && (t4.reKeyTo = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.rekey)))), e4.type === "pay" ? (t4.amount = e4.amt, t4.to = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.rcv))), e4.close !== void 0 && (t4.closeRemainderTo = s3.decodeAddress(s3.encodeAddress(e4.close)))) : e4.type === "keyreg" ? (e4.votekey !== void 0 && (t4.voteKey = l3.from(e4.votekey)), e4.selkey !== void 0 && (t4.selectionKey = l3.from(e4.selkey)), e4.sprfkey !== void 0 && (t4.stateProofKey = l3.from(e4.sprfkey)), e4.votekd !== void 0 && (t4.voteKeyDilution = e4.votekd), e4.votefst !== void 0 && (t4.voteFirst = e4.votefst), e4.votelst !== void 0 && (t4.voteLast = e4.votelst), e4.nonpart !== void 0 && (t4.nonParticipation = e4.nonpart)) : e4.type === "acfg" ? (e4.caid !== void 0 && (t4.assetIndex = e4.caid), e4.apar !== void 0 && (t4.assetTotal = e4.apar.t, t4.assetDefaultFrozen = e4.apar.df, e4.apar.dc !== void 0 && (t4.assetDecimals = e4.apar.dc), e4.apar.m !== void 0 && (t4.assetManager = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.apar.m)))), e4.apar.r !== void 0 && (t4.assetReserve = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.apar.r)))), e4.apar.f !== void 0 && (t4.assetFreeze = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.apar.f)))), e4.apar.c !== void 0 && (t4.assetClawback = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.apar.c)))), e4.apar.un !== void 0 && (t4.assetUnitName = e4.apar.un), e4.apar.an !== void 0 && (t4.assetName = e4.apar.an), e4.apar.au !== void 0 && (t4.assetURL = e4.apar.au), e4.apar.am !== void 0 && (t4.assetMetadataHash = e4.apar.am))) : e4.type === "axfer" ? (e4.xaid !== void 0 && (t4.assetIndex = e4.xaid), e4.aamt !== void 0 && (t4.amount = e4.aamt), e4.aclose !== void 0 && (t4.closeRemainderTo = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.aclose)))), e4.asnd !== void 0 && (t4.assetRevocationTarget = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.asnd)))), t4.to = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.arcv)))) : e4.type === "afrz" ? (e4.afrz !== void 0 && (t4.freezeState = e4.afrz), e4.faid !== void 0 && (t4.assetIndex = e4.faid), t4.freezeAccount = s3.decodeAddress(s3.encodeAddress(new Uint8Array(e4.fadd)))) : e4.type === "appl" && (e4.apid !== void 0 && (t4.appIndex = e4.apid), e4.apan !== void 0 && (t4.appOnComplete = e4.apan), e4.apls !== void 0 && (e4.apls.nui !== void 0 && (t4.appLocalInts = e4.apls.nui), e4.apls.nbs !== void 0 && (t4.appLocalByteSlices = e4.apls.nbs)), e4.apgs !== void 0 && (e4.apgs.nui !== void 0 && (t4.appGlobalInts = e4.apgs.nui), e4.apgs.nbs !== void 0 && (t4.appGlobalByteSlices = e4.apgs.nbs)), e4.apep !== void 0 && (t4.extraPages = e4.apep), e4.apap !== void 0 && (t4.appApprovalProgram = new Uint8Array(e4.apap)), e4.apsu !== void 0 && (t4.appClearProgram = new Uint8Array(e4.apsu)), e4.apaa !== void 0 && (t4.appArgs = e4.apaa.map((e5) => new Uint8Array(e5))), e4.apat !== void 0 && (t4.appAccounts = e4.apat.map((e5) => s3.decodeAddress(s3.encodeAddress(new Uint8Array(e5))))), e4.apfa !== void 0 && (t4.appForeignApps = e4.apfa), e4.apas !== void 0 && (t4.appForeignAssets = e4.apas)), t4;
            }
            estimateSize() {
              return this.toByte().length + 75;
            }
            bytesToSign() {
              const e4 = this.toByte();
              return l3.from(c3.concatArrays(this.tag, e4));
            }
            toByte() {
              return i3.encode(this.get_obj_for_encoding());
            }
            rawSignTxn(e4) {
              const t4 = this.bytesToSign(), r4 = a3.sign(t4, e4);
              return l3.from(r4);
            }
            signTxn(e4) {
              const t4 = { sig: this.rawSignTxn(e4), txn: this.get_obj_for_encoding() }, r4 = a3.keyPairFromSecretKey(e4).publicKey;
              return s3.encodeAddress(r4) !== s3.encodeAddress(this.from.publicKey) && (t4.sgnr = l3.from(r4)), new Uint8Array(i3.encode(t4));
            }
            rawTxID() {
              const e4 = this.toByte(), t4 = l3.from(c3.concatArrays(this.tag, e4));
              return l3.from(a3.genericHash(t4));
            }
            txID() {
              const e4 = this.rawTxID();
              return o3().encode(e4).slice(0, 52);
            }
            addLease(e4, t4 = 0) {
              let r4;
              if (e4 !== void 0) {
                if (e4.constructor !== Uint8Array)
                  throw Error("lease must be a Uint8Array.");
                if (e4.length !== 32)
                  throw Error(`lease must be of length ${32 .toString()}.`);
                r4 = new Uint8Array(e4);
              } else
                r4 = new Uint8Array(0);
              this.lease = r4, t4 !== 0 && (this.fee += 37 * t4);
            }
            addRekey(e4, t4 = 0) {
              e4 !== void 0 && (this.reKeyTo = s3.decodeAddress(e4)), t4 !== 0 && (this.fee += 37 * t4);
            }
            _getDictForDisplay() {
              const e4 = { ...this };
              return e4.tag = e4.tag.toString(), e4.from = s3.encodeAddress(e4.from.publicKey), e4.to !== void 0 && (e4.to = s3.encodeAddress(e4.to.publicKey)), e4.freezeAccount !== void 0 && (e4.freezeAccount = s3.encodeAddress(e4.freezeAccount.publicKey)), e4.closeRemainderTo !== void 0 && (e4.closeRemainderTo = s3.encodeAddress(e4.closeRemainderTo.publicKey)), e4.assetManager !== void 0 && (e4.assetManager = s3.encodeAddress(e4.assetManager.publicKey)), e4.assetReserve !== void 0 && (e4.assetReserve = s3.encodeAddress(e4.assetReserve.publicKey)), e4.assetFreeze !== void 0 && (e4.assetFreeze = s3.encodeAddress(e4.assetFreeze.publicKey)), e4.assetClawback !== void 0 && (e4.assetClawback = s3.encodeAddress(e4.assetClawback.publicKey)), e4.assetRevocationTarget !== void 0 && (e4.assetRevocationTarget = s3.encodeAddress(e4.assetRevocationTarget.publicKey)), e4.reKeyTo !== void 0 && (e4.reKeyTo = s3.encodeAddress(e4.reKeyTo.publicKey)), e4.genesisHash = e4.genesisHash.toString("base64"), e4;
            }
            prettyPrint() {
              console.log(this._getDictForDisplay());
            }
            toString() {
              return JSON.stringify(this._getDictForDisplay());
            }
          }
          function d3(e4) {
            const t4 = e4.get_obj_for_encoding();
            return i3.encode(t4);
          }
          function g3(e4) {
            const t4 = i3.decode(e4);
            return f3.from_obj_for_encoding(t4);
          }
          function y3(e4) {
            const t4 = i3.decode(e4);
            return { ...t4, txn: f3.from_obj_for_encoding(t4.txn) };
          }
          function m3(e4) {
            return e4 instanceof f3 ? e4 : new f3(e4);
          }
          const b2 = f3;
        }, 2380: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { i: () => n2.i });
          var n2 = r3(1824);
        }, 7197: (e3, t3, r3) => {
          "use strict";
          var n2;
          r3.d(t3, { Z: () => o3 }), function(e4) {
            e4.DEFAULT = "default", e4.SAFE = "safe", e4.MIXED = "mixed", e4.BIGINT = "bigint";
          }(n2 || (n2 = {}));
          const o3 = n2;
        }, 1624: (e3, t3, r3) => {
          "use strict";
          var n2, o3;
          function s3(e4) {
            return e4 === n2.pay || e4 === n2.keyreg || e4 === n2.acfg || e4 === n2.axfer || e4 === n2.afrz || e4 === n2.appl;
          }
          r3.d(t3, { iU: () => n2, v8: () => s3, hq: () => o3 }), function(e4) {
            e4.pay = "pay", e4.keyreg = "keyreg", e4.acfg = "acfg", e4.axfer = "axfer", e4.afrz = "afrz", e4.appl = "appl";
          }(n2 || (n2 = {})), function(e4) {
            e4[e4.NoOpOC = 0] = "NoOpOC", e4[e4.OptInOC = 1] = "OptInOC", e4[e4.CloseOutOC = 2] = "CloseOutOC", e4[e4.ClearStateOC = 3] = "ClearStateOC", e4[e4.UpdateApplicationOC = 4] = "UpdateApplicationOC", e4[e4.DeleteApplicationOC = 5] = "DeleteApplicationOC";
          }(o3 || (o3 = {}));
        }, 1824: (e3, t3, r3) => {
          "use strict";
          r3.d(t3, { i: () => n2.iU });
          var n2 = r3(1624);
        }, 413: (e3, t3, r3) => {
          "use strict";
          r3.r(t3), r3.d(t3, { parseJSON: () => a3, arrayEqual: () => c3, concatArrays: () => u3, removeUndefinedProperties: () => l3, isNode: () => h3 });
          var n2 = r3(4360), o3 = r3.n(n2), s3 = r3(7197);
          const i3 = o3()({ useNativeBigInt: true, strict: true });
          function a3(e4, t4) {
            const r4 = t4 && t4.intDecoding ? t4.intDecoding : s3.Z.DEFAULT;
            return i3.parse(e4, (e5, t5) => {
              if (t5 != null && typeof t5 == "object" && Object.getPrototypeOf(t5) == null && Object.setPrototypeOf(t5, Object.prototype), typeof t5 == "bigint") {
                if (r4 === "bigint" || r4 === "mixed" && t5 > Number.MAX_SAFE_INTEGER)
                  return t5;
                if (r4 === "default" || r4 === "mixed")
                  return Number(t5);
                throw new Error(`Integer exceeds maximum safe integer: ${t5.toString()}. Try parsing with a different intDecoding option.`);
              }
              return typeof t5 == "number" && r4 === "bigint" && Number.isInteger(t5) ? BigInt(t5) : t5;
            });
          }
          function c3(e4, t4) {
            return e4.length === t4.length && Array.from(e4).every((e5, r4) => e5 === t4[r4]);
          }
          function u3(...e4) {
            const t4 = e4.reduce((e5, t5) => e5 + t5.length, 0), r4 = new Uint8Array(t4);
            let n3 = 0;
            for (let t5 = 0; t5 < e4.length; t5++)
              r4.set(e4[t5], n3), n3 += e4[t5].length;
            return r4;
          }
          function l3(e4) {
            const t4 = { ...e4 };
            return Object.keys(t4).forEach((e5) => {
              t4[e5] === void 0 && delete t4[e5];
            }), t4;
          }
          function h3() {
            return typeof process == "object" && typeof process.versions == "object" && process.versions.node !== void 0;
          }
        }, 5062: (e3, t3, r3) => {
          "use strict";
          async function n2(e4, t4, r4) {
            const n3 = await e4.status().do();
            if (n3 === void 0)
              throw new Error("Unable to get node status");
            const o3 = n3["last-round"] + 1;
            let s3 = o3;
            for (; s3 < o3 + r4; ) {
              let r5 = false;
              try {
                const n4 = await e4.pendingTransactionInformation(t4).do();
                if (n4["confirmed-round"])
                  return n4;
                if (n4["pool-error"])
                  throw r5 = true, new Error(`Transaction Rejected: ${n4["pool-error"]}`);
              } catch (e5) {
                if (r5)
                  throw e5;
              }
              await e4.statusAfterBlock(s3).do(), s3 += 1;
            }
            throw new Error(`Transaction not confirmed after ${r4} rounds`);
          }
          r3.d(t3, { K: () => n2 });
        }, 4654: () => {
        } }, __webpack_module_cache__ = {};
        function __webpack_require__(e3) {
          var t3 = __webpack_module_cache__[e3];
          if (t3 !== void 0)
            return t3.exports;
          var r3 = __webpack_module_cache__[e3] = { exports: {} };
          return __webpack_modules__[e3].call(r3.exports, r3, r3.exports, __webpack_require__), r3.exports;
        }
        __webpack_require__.amdO = {}, __webpack_require__.n = (e3) => {
          var t3 = e3 && e3.__esModule ? () => e3.default : () => e3;
          return __webpack_require__.d(t3, { a: t3 }), t3;
        }, __webpack_require__.d = (e3, t3) => {
          for (var r3 in t3)
            __webpack_require__.o(t3, r3) && !__webpack_require__.o(e3, r3) && Object.defineProperty(e3, r3, { enumerable: true, get: t3[r3] });
        }, __webpack_require__.g = function() {
          if (typeof globalThis == "object")
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (e3) {
            if (typeof window == "object")
              return window;
          }
        }(), __webpack_require__.o = (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3), __webpack_require__.r = (e3) => {
          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        };
        var __webpack_exports__ = {};
        return (() => {
          "use strict";
          __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, { default: () => r3 });
          var e3 = __webpack_require__(6608), t3 = {};
          for (const r4 in e3)
            r4 !== "default" && (t3[r4] = () => e3[r4]);
          __webpack_require__.d(__webpack_exports__, t3);
          const r3 = e3;
        })(), __webpack_exports__;
      })();
    });
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLocalStorage = exports2.getLocalStorageOrThrow = exports2.getCrypto = exports2.getCryptoOrThrow = exports2.getLocation = exports2.getLocationOrThrow = exports2.getNavigator = exports2.getNavigatorOrThrow = exports2.getDocument = exports2.getDocumentOrThrow = exports2.getFromWindowOrThrow = exports2.getFromWindow = void 0;
    function getFromWindow3(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports2.getFromWindow = getFromWindow3;
    function getFromWindowOrThrow3(name) {
      const res = getFromWindow3(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports2.getFromWindowOrThrow = getFromWindowOrThrow3;
    function getDocumentOrThrow3() {
      return getFromWindowOrThrow3("document");
    }
    exports2.getDocumentOrThrow = getDocumentOrThrow3;
    function getDocument3() {
      return getFromWindow3("document");
    }
    exports2.getDocument = getDocument3;
    function getNavigatorOrThrow3() {
      return getFromWindowOrThrow3("navigator");
    }
    exports2.getNavigatorOrThrow = getNavigatorOrThrow3;
    function getNavigator3() {
      return getFromWindow3("navigator");
    }
    exports2.getNavigator = getNavigator3;
    function getLocationOrThrow3() {
      return getFromWindowOrThrow3("location");
    }
    exports2.getLocationOrThrow = getLocationOrThrow3;
    function getLocation3() {
      return getFromWindow3("location");
    }
    exports2.getLocation = getLocation3;
    function getCryptoOrThrow3() {
      return getFromWindowOrThrow3("crypto");
    }
    exports2.getCryptoOrThrow = getCryptoOrThrow3;
    function getCrypto3() {
      return getFromWindow3("crypto");
    }
    exports2.getCrypto = getCrypto3;
    function getLocalStorageOrThrow3() {
      return getFromWindowOrThrow3("localStorage");
    }
    exports2.getLocalStorageOrThrow = getLocalStorageOrThrow3;
    function getLocalStorage3() {
      return getFromWindow3("localStorage");
    }
    exports2.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e3) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i3 = 0; i3 < links.length; i3++) {
          const link = links[i3];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i3 = 0; i3 < metaTags.length; i3++) {
          const tag = metaTags[i3];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name
      };
      return meta;
    }
    exports2.getWindowMetadata = getWindowMetadata2;
  }
});

// (disabled):node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "(disabled):node_modules/buffer/index.js"() {
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports3.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer3;
      try {
        Buffer3 = require_buffer2().Buffer;
      } catch (e3) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert3(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert3(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j3, w4;
        var off = 0;
        if (endian === "be") {
          for (i3 = number.length - 1, j3 = 0; i3 >= 0; i3 -= 3) {
            w4 = number[i3] | number[i3 - 1] << 8 | number[i3 - 2] << 16;
            this.words[j3] |= w4 << off & 67108863;
            this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j3 = 0; i3 < number.length; i3 += 3) {
            w4 = number[i3] | number[i3 + 1] << 8 | number[i3 + 2] << 16;
            this.words[j3] |= w4 << off & 67108863;
            this.words[j3 + 1] = w4 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r3 <<= 4;
          if (c3 >= 49 && c3 <= 54) {
            r3 |= c3 - 49 + 10;
          } else if (c3 >= 17 && c3 <= 22) {
            r3 |= c3 - 17 + 10;
          } else {
            r3 |= c3 & 15;
          }
        }
        return r3;
      }
      BN2.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j3, w4;
        var off = 0;
        for (i3 = number.length - 6, j3 = 0; i3 >= start; i3 -= 6) {
          w4 = parseHex(number, i3, i3 + 6);
          this.words[j3] |= w4 << off & 67108863;
          this.words[j3 + 1] |= w4 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j3++;
          }
        }
        if (i3 + 6 !== start) {
          w4 = parseHex(number, start, i3 + 6);
          this.words[j3] |= w4 << off & 67108863;
          this.words[j3 + 1] |= w4 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i3 = start; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r3 *= mul;
          if (c3 >= 49) {
            r3 += c3 - 49 + 10;
          } else if (c3 >= 17) {
            r3 += c3 - 17 + 10;
          } else {
            r3 += c3;
          }
        }
        return r3;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i3 = start; i3 < end; i3 += limbLen) {
          word = parseBase(number, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i3, number.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN2.prototype.copy = function copy2(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r3 = new BN2(null);
        this.copy(r3);
        return r3;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w4 = this.words[i3];
            var word = ((w4 << off | carry) & 16777215).toString(16);
            carry = w4 >>> 24 - off & 16777215;
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r3 = c3.modn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i3;
        var q3 = this.clone();
        if (!littleEndian) {
          for (i3 = 0; i3 < reqLength - byteLength; i3++) {
            res[i3] = 0;
          }
          for (i3 = 0; !q3.isZero(); i3++) {
            b2 = q3.andln(255);
            q3.iushrn(8);
            res[reqLength - i3 - 1] = b2;
          }
        } else {
          for (i3 = 0; !q3.isZero(); i3++) {
            b2 = q3.andln(255);
            q3.iushrn(8);
            res[i3] = b2;
          }
          for (; i3 < reqLength; i3++) {
            res[i3] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w4) {
          return 32 - Math.clz32(w4);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w4) {
          var t3 = w4;
          var r3 = 0;
          if (t3 >= 4096) {
            r3 += 13;
            t3 >>>= 13;
          }
          if (t3 >= 64) {
            r3 += 7;
            t3 >>>= 7;
          }
          if (t3 >= 8) {
            r3 += 4;
            t3 >>>= 4;
          }
          if (t3 >= 2) {
            r3 += 2;
            t3 >>>= 2;
          }
          return r3 + t3;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w4) {
        if (w4 === 0)
          return 26;
        var t3 = w4;
        var r3 = 0;
        if ((t3 & 8191) === 0) {
          r3 += 13;
          t3 >>>= 13;
        }
        if ((t3 & 127) === 0) {
          r3 += 7;
          t3 >>>= 7;
        }
        if ((t3 & 15) === 0) {
          r3 += 4;
          t3 >>>= 4;
        }
        if ((t3 & 3) === 0) {
          r3 += 2;
          t3 >>>= 2;
        }
        if ((t3 & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w4 = this.words[this.length - 1];
        var hi = this._countBits(w4);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w4 = new Array(num.bitLength());
        for (var bit = 0; bit < w4.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w4[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w4;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r3 = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b2 = this._zeroBits(this.words[i3]);
          r3 += b2;
          if (b2 !== 26)
            break;
        }
        return r3;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i3 = 0; i3 < b2.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b2.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a3;
        var b2;
        if (this.length > num.length) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        for (var i3 = 0; i3 < b2.length; i3++) {
          this.words[i3] = a3.words[i3] ^ b2.words[i3];
        }
        if (this !== a3) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = a3.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a3, b2;
        if (this.length > num.length) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b2.length; i3++) {
          r3 = (a3.words[i3] | 0) + (b2.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r3 = (a3.words[i3] | 0) + carry;
          this.words[i3] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a3.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a3, b2;
        if (cmp > 0) {
          a3 = this;
          b2 = num;
        } else {
          a3 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b2.length; i3++) {
          r3 = (a3.words[i3] | 0) - (b2.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        for (; carry !== 0 && i3 < a3.length; i3++) {
          r3 = (a3.words[i3] | 0) + carry;
          carry = r3 >> 26;
          this.words[i3] = r3 & 67108863;
        }
        if (carry === 0 && i3 < a3.length && a3 !== this) {
          for (; i3 < a3.length; i3++) {
            this.words[i3] = a3.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a3 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a3 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r3 = a3 * b2;
        var lo = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo;
        for (var k3 = 1; k3 < len; k3++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
            var i3 = k3 - j3 | 0;
            a3 = self2.words[i3] | 0;
            b2 = num.words[j3] | 0;
            r3 = a3 * b2 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k3] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k3] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a3 = self2.words;
        var b2 = num.words;
        var o3 = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a3[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a3[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a3[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a3[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a4 = a3[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a3[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a3[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a3[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a3[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a3[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o3[0] = w0;
        o3[1] = w1;
        o3[2] = w22;
        o3[3] = w32;
        o3[4] = w4;
        o3[5] = w5;
        o3[6] = w6;
        o3[7] = w7;
        o3[8] = w8;
        o3[9] = w9;
        o3[10] = w10;
        o3[11] = w11;
        o3[12] = w12;
        o3[13] = w13;
        o3[14] = w14;
        o3[15] = w15;
        o3[16] = w16;
        o3[17] = w17;
        o3[18] = w18;
        if (c3 !== 0) {
          o3[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k3 = 0; k3 < out.length - 1; k3++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num.length - 1);
          for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
            var i3 = k3 - j3;
            var a3 = self2.words[i3] | 0;
            var b2 = num.words[j3] | 0;
            var r3 = a3 * b2;
            var lo = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k3] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k3] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x3, y3) {
        this.x = x3;
        this.y = y3;
      }
      FFTM.prototype.makeRBT = function makeRBT(N3) {
        var t3 = new Array(N3);
        var l3 = BN2.prototype._countBits(N3) - 1;
        for (var i3 = 0; i3 < N3; i3++) {
          t3[i3] = this.revBin(i3, l3, N3);
        }
        return t3;
      };
      FFTM.prototype.revBin = function revBin(x3, l3, N3) {
        if (x3 === 0 || x3 === N3 - 1)
          return x3;
        var rb = 0;
        for (var i3 = 0; i3 < l3; i3++) {
          rb |= (x3 & 1) << l3 - i3 - 1;
          x3 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
        for (var i3 = 0; i3 < N3; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N3);
        for (var s3 = 1; s3 < N3; s3 <<= 1) {
          var l3 = s3 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l3);
          var itwdf = Math.sin(2 * Math.PI / l3);
          for (var p3 = 0; p3 < N3; p3 += l3) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j3 = 0; j3 < s3; j3++) {
              var re = rtws[p3 + j3];
              var ie = itws[p3 + j3];
              var ro = rtws[p3 + j3 + s3];
              var io = itws[p3 + j3 + s3];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p3 + j3] = re + ro;
              itws[p3 + j3] = ie + io;
              rtws[p3 + j3 + s3] = re - ro;
              itws[p3 + j3 + s3] = ie - io;
              if (j3 !== l3) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m3) {
        var N3 = Math.max(m3, n2) | 1;
        var odd = N3 & 1;
        var i3 = 0;
        for (N3 = N3 / 2 | 0; N3; N3 = N3 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
        if (N3 <= 1)
          return;
        for (var i3 = 0; i3 < N3 / 2; i3++) {
          var t3 = rws[i3];
          rws[i3] = rws[N3 - i3 - 1];
          rws[N3 - i3 - 1] = t3;
          t3 = iws[i3];
          iws[i3] = -iws[N3 - i3 - 1];
          iws[N3 - i3 - 1] = -t3;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N3) {
        var carry = 0;
        for (var i3 = 0; i3 < N3 / 2; i3++) {
          var w4 = Math.round(ws[2 * i3 + 1] / N3) * 8192 + Math.round(ws[2 * i3] / N3) + carry;
          ws[i3] = w4 & 67108863;
          if (w4 < 67108864) {
            carry = 0;
          } else {
            carry = w4 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N3) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N3; ++i3) {
          rws[i3] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N3) {
        var ph = new Array(N3);
        for (var i3 = 0; i3 < N3; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x3, y3, out) {
        var N3 = 2 * this.guessLen13b(x3.length, y3.length);
        var rbt = this.makeRBT(N3);
        var _4 = this.stub(N3);
        var rws = new Array(N3);
        var rwst = new Array(N3);
        var iwst = new Array(N3);
        var nrws = new Array(N3);
        var nrwst = new Array(N3);
        var niwst = new Array(N3);
        var rmws = out.words;
        rmws.length = N3;
        this.convert13b(x3.words, x3.length, rws, N3);
        this.convert13b(y3.words, y3.length, nrws, N3);
        this.transform(rws, _4, rwst, iwst, N3, rbt);
        this.transform(nrws, _4, nrwst, niwst, N3, rbt);
        for (var i3 = 0; i3 < N3; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N3);
        this.transform(rwst, iwst, rmws, _4, N3, rbt);
        this.conjugate(rmws, _4, N3);
        this.normalize13b(rmws, N3);
        out.negative = x3.negative ^ y3.negative;
        out.length = x3.length + y3.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w4 = (this.words[i3] | 0) * num;
          var lo = (w4 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w4 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w4 = toBitArray(num);
        if (w4.length === 0)
          return new BN2(1);
        var res = this;
        for (var i3 = 0; i3 < w4.length; i3++, res = res.sqr()) {
          if (w4[i3] !== 0)
            break;
        }
        if (++i3 < w4.length) {
          for (var q3 = res.sqr(); i3 < w4.length; i3++, q3 = q3.sqr()) {
            if (w4[i3] === 0)
              continue;
            res = res.mul(q3);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s3 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i3;
        if (r3 !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c3 = (this.words[i3] | 0) - newCarry << r3;
            this.words[i3] = c3 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s3 !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s3] = this.words[i3];
          }
          for (i3 = 0; i3 < s3; i3++) {
            this.words[i3] = 0;
          }
          this.length += s3;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h3;
        if (hint) {
          h3 = (hint - hint % 26) / 26;
        } else {
          h3 = 0;
        }
        var r3 = bits % 26;
        var s3 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h3 -= s3;
        h3 = Math.max(0, h3);
        if (maskedWords) {
          for (var i3 = 0; i3 < s3; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s3;
        }
        if (s3 === 0) {
        } else if (this.length > s3) {
          this.length -= s3;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s3];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h3); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s3 = (bit - r3) / 26;
        var q3 = 1 << r3;
        if (this.length <= s3)
          return false;
        var w4 = this.words[s3];
        return !!(w4 & q3);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s3 = (bits - r3) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s3) {
          return this;
        }
        if (r3 !== 0) {
          s3++;
        }
        this.length = Math.min(s3, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i3;
        this._expand(len);
        var w4;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w4 = (this.words[i3 + shift] | 0) + carry;
          var right = (num.words[i3] | 0) * mul;
          w4 -= right & 67108863;
          carry = (w4 >> 26) - (right / 67108864 | 0);
          this.words[i3 + shift] = w4 & 67108863;
        }
        for (; i3 < this.length - shift; i3++) {
          w4 = (this.words[i3 + shift] | 0) + carry;
          carry = w4 >> 26;
          this.words[i3 + shift] = w4 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w4 = -(this.words[i3] | 0) + carry;
          carry = w4 >> 26;
          this.words[i3] = w4 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a3 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a3.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m3 = a3.length - b2.length;
        var q3;
        if (mode !== "mod") {
          q3 = new BN2(null);
          q3.length = m3 + 1;
          q3.words = new Array(q3.length);
          for (var i3 = 0; i3 < q3.length; i3++) {
            q3.words[i3] = 0;
          }
        }
        var diff = a3.clone()._ishlnsubmul(b2, 1, m3);
        if (diff.negative === 0) {
          a3 = diff;
          if (q3) {
            q3.words[m3] = 1;
          }
        }
        for (var j3 = m3 - 1; j3 >= 0; j3--) {
          var qj = (a3.words[b2.length + j3] | 0) * 67108864 + (a3.words[b2.length + j3 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a3._ishlnsubmul(b2, qj, j3);
          while (a3.negative !== 0) {
            qj--;
            a3.negative = 0;
            a3._ishlnsubmul(b2, 1, j3);
            if (!a3.isZero()) {
              a3.negative ^= 1;
            }
          }
          if (q3) {
            q3.words[j3] = qj;
          }
        }
        if (q3) {
          q3.strip();
        }
        a3.strip();
        if (mode !== "div" && shift !== 0) {
          a3.iushrn(shift);
        }
        return {
          div: q3 || null,
          mod: a3
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p3 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p3 * acc + (this.words[i3] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w4 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w4 / num | 0;
          carry = w4 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p3) {
        assert3(p3.negative === 0);
        assert3(!p3.isZero());
        var x3 = this;
        var y3 = p3.clone();
        if (x3.negative !== 0) {
          x3 = x3.umod(p3);
        } else {
          x3 = x3.clone();
        }
        var A4 = new BN2(1);
        var B2 = new BN2(0);
        var C3 = new BN2(0);
        var D3 = new BN2(1);
        var g3 = 0;
        while (x3.isEven() && y3.isEven()) {
          x3.iushrn(1);
          y3.iushrn(1);
          ++g3;
        }
        var yp = y3.clone();
        var xp = x3.clone();
        while (!x3.isZero()) {
          for (var i3 = 0, im = 1; (x3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x3.iushrn(i3);
            while (i3-- > 0) {
              if (A4.isOdd() || B2.isOdd()) {
                A4.iadd(yp);
                B2.isub(xp);
              }
              A4.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1; (y3.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            y3.iushrn(j3);
            while (j3-- > 0) {
              if (C3.isOdd() || D3.isOdd()) {
                C3.iadd(yp);
                D3.isub(xp);
              }
              C3.iushrn(1);
              D3.iushrn(1);
            }
          }
          if (x3.cmp(y3) >= 0) {
            x3.isub(y3);
            A4.isub(C3);
            B2.isub(D3);
          } else {
            y3.isub(x3);
            C3.isub(A4);
            D3.isub(B2);
          }
        }
        return {
          a: C3,
          b: D3,
          gcd: y3.iushln(g3)
        };
      };
      BN2.prototype._invmp = function _invmp(p3) {
        assert3(p3.negative === 0);
        assert3(!p3.isZero());
        var a3 = this;
        var b2 = p3.clone();
        if (a3.negative !== 0) {
          a3 = a3.umod(p3);
        } else {
          a3 = a3.clone();
        }
        var x1 = new BN2(1);
        var x22 = new BN2(0);
        var delta = b2.clone();
        while (a3.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a3.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a3.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j3 = 0, jm = 1; (b2.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
            ;
          if (j3 > 0) {
            b2.iushrn(j3);
            while (j3-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a3.cmp(b2) >= 0) {
            a3.isub(b2);
            x1.isub(x22);
          } else {
            b2.isub(a3);
            x22.isub(x1);
          }
        }
        var res;
        if (a3.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p3);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a3 = this.clone();
        var b2 = num.clone();
        a3.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a3.isEven() && b2.isEven(); shift++) {
          a3.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a3.isEven()) {
            a3.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r3 = a3.cmp(b2);
          if (r3 < 0) {
            var t3 = a3;
            a3 = b2;
            b2 = t3;
          } else if (r3 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a3.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r3 = bit % 26;
        var s3 = (bit - r3) / 26;
        var q3 = 1 << r3;
        if (this.length <= s3) {
          this._expand(s3 + 1);
          this.words[s3] |= q3;
          return this;
        }
        var carry = q3;
        for (var i3 = s3; carry !== 0 && i3 < this.length; i3++) {
          var w4 = this.words[i3] | 0;
          w4 += carry;
          carry = w4 >>> 26;
          w4 &= 67108863;
          this.words[i3] = w4;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w4 = this.words[0] | 0;
          res = w4 === num ? 0 : w4 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a3 = this.words[i3] | 0;
          var b2 = num.words[i3] | 0;
          if (a3 === b2)
            continue;
          if (a3 < b2) {
            res = -1;
          } else if (a3 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p3) {
        this.name = name;
        this.p = new BN2(p3, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          r3.strip();
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next = input.words[i3] | 0;
          input.words[i3 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w4 = num.words[i3] | 0;
          lo += w4 * 977;
          num.words[i3] = lo & 67108863;
          lo = w4 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m3) {
        if (typeof m3 === "string") {
          var prime = BN2._prime(m3);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m3.gtn(1), "modulus must be greater than 1");
          this.m = m3;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a3) {
        assert3(a3.negative === 0, "red works only with positives");
        assert3(a3.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a3, b2) {
        assert3((a3.negative | b2.negative) === 0, "red works only with positives");
        assert3(a3.red && a3.red === b2.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a3) {
        if (this.prime)
          return this.prime.ireduce(a3)._forceRed(this);
        return a3.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a3) {
        if (a3.isZero()) {
          return a3.clone();
        }
        return this.m.sub(a3)._forceRed(this);
      };
      Red.prototype.add = function add(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a3, b2) {
        this._verify2(a3, b2);
        var res = a3.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a3, num) {
        this._verify1(a3);
        return this.imod(a3.ushln(num));
      };
      Red.prototype.imul = function imul(a3, b2) {
        this._verify2(a3, b2);
        return this.imod(a3.imul(b2));
      };
      Red.prototype.mul = function mul(a3, b2) {
        this._verify2(a3, b2);
        return this.imod(a3.mul(b2));
      };
      Red.prototype.isqr = function isqr(a3) {
        return this.imul(a3, a3.clone());
      };
      Red.prototype.sqr = function sqr(a3) {
        return this.mul(a3, a3);
      };
      Red.prototype.sqrt = function sqrt(a3) {
        if (a3.isZero())
          return a3.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a3, pow);
        }
        var q3 = this.m.subn(1);
        var s3 = 0;
        while (!q3.isZero() && q3.andln(1) === 0) {
          s3++;
          q3.iushrn(1);
        }
        assert3(!q3.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z3 = this.m.bitLength();
        z3 = new BN2(2 * z3 * z3).toRed(this);
        while (this.pow(z3, lpow).cmp(nOne) !== 0) {
          z3.redIAdd(nOne);
        }
        var c3 = this.pow(z3, q3);
        var r3 = this.pow(a3, q3.addn(1).iushrn(1));
        var t3 = this.pow(a3, q3);
        var m3 = s3;
        while (t3.cmp(one) !== 0) {
          var tmp = t3;
          for (var i3 = 0; tmp.cmp(one) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert3(i3 < m3);
          var b2 = this.pow(c3, new BN2(1).iushln(m3 - i3 - 1));
          r3 = r3.redMul(b2);
          c3 = b2.redSqr();
          t3 = t3.redMul(c3);
          m3 = i3;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a3) {
        var inv = a3._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a3, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a3.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a3;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a3);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j3 = start - 1; j3 >= 0; j3--) {
            var bit = word >> j3 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j3 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m3) {
        Red.call(this, m3);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a3, b2) {
        if (a3.isZero() || b2.isZero()) {
          a3.words[0] = 0;
          a3.length = 1;
          return a3;
        }
        var t3 = a3.imul(b2);
        var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t3.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a3, b2) {
        if (a3.isZero() || b2.isZero())
          return new BN2(0)._forceRed(this);
        var t3 = a3.mul(b2);
        var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t3.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a3) {
        var res = this.imod(a3._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports2, module2) {
    module2.exports = isTypedArray3;
    isTypedArray3.strict = isStrictTypedArray;
    isTypedArray3.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray3(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports2, module2) {
    var isTypedArray3 = require_is_typedarray().strict;
    module2.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray3(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha32 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW2 = typeof window === "object";
      var root2 = WINDOW2 ? window : {};
      if (root2.JS_SHA3_NO_WINDOW) {
        WINDOW2 = false;
      }
      var WEB_WORKER2 = !WINDOW2 && typeof self === "object";
      var NODE_JS2 = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS2) {
        root2 = global;
      } else if (WEB_WORKER2) {
        root2 = self;
      }
      var COMMON_JS2 = !root2.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD2 = typeof define === "function" && define.amd;
      var ARRAY_BUFFER2 = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS2 = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING2 = [6, 1536, 393216, 100663296];
      var SHIFT2 = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES2 = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER2 && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod2 = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n2, s3) {
          return methods["cshake" + bits2].update(message, outputBits, n2, s3)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s3) {
          return methods["kmac" + bits2].update(key, message, outputBits, s3)[outputType]();
        };
      };
      var createOutputMethods = function(method2, createMethod3, bits2, padding) {
        for (var i4 = 0; i4 < OUTPUT_TYPES2.length; ++i4) {
          var type = OUTPUT_TYPES2[i4];
          method2[type] = createMethod3(bits2, padding, type);
        }
        return method2;
      };
      var createMethod2 = function(bits2, padding) {
        var method2 = createOutputMethod2(bits2, padding, "hex");
        method2.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        return createOutputMethods(method2, createOutputMethod2, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method2 = createShakeOutputMethod(bits2, padding, "hex");
        method2.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method2.update = function(message, outputBits) {
          return method2.create(outputBits).update(message);
        };
        return createOutputMethods(method2, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w4 = CSHAKE_BYTEPAD[bits2];
        var method2 = createCshakeOutputMethod(bits2, padding, "hex");
        method2.create = function(outputBits, n2, s3) {
          if (!n2 && !s3) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n2, s3], w4);
          }
        };
        method2.update = function(message, outputBits, n2, s3) {
          return method2.create(outputBits, n2, s3).update(message);
        };
        return createOutputMethods(method2, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w4 = CSHAKE_BYTEPAD[bits2];
        var method2 = createKmacOutputMethod(bits2, padding, "hex");
        method2.create = function(key, outputBits, s3) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s3], w4).bytepad([key], w4);
        };
        method2.update = function(key, message, outputBits, s3) {
          return method2.create(key, outputBits, s3).update(message);
        };
        return createOutputMethods(method2, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod2 },
        { name: "sha3", padding: PADDING2, bits: BITS, createMethod: createMethod2 },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i3 = 0; i3 < algorithms.length; ++i3) {
        var algorithm2 = algorithms[i3];
        var bits = algorithm2.bits;
        for (var j3 = 0; j3 < bits.length; ++j3) {
          var methodName = algorithm2.name + "_" + bits[j3];
          methodNames.push(methodName);
          methods[methodName] = algorithm2.createMethod(bits[j3], algorithm2.padding);
          if (algorithm2.name !== "sha3") {
            var newMethodName = algorithm2.name + bits[j3];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i4 = 0; i4 < 50; ++i4) {
          this.s[i4] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks2 = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index2 = 0, s3 = this.s, i4, code;
        while (index2 < length) {
          if (this.reset) {
            this.reset = false;
            blocks2[0] = this.block;
            for (i4 = 1; i4 < blockCount + 1; ++i4) {
              blocks2[i4] = 0;
            }
          }
          if (notString) {
            for (i4 = this.start; index2 < length && i4 < byteCount; ++index2) {
              blocks2[i4 >> 2] |= message[index2] << SHIFT2[i4++ & 3];
            }
          } else {
            for (i4 = this.start; index2 < length && i4 < byteCount; ++index2) {
              code = message.charCodeAt(index2);
              if (code < 128) {
                blocks2[i4 >> 2] |= code << SHIFT2[i4++ & 3];
              } else if (code < 2048) {
                blocks2[i4 >> 2] |= (192 | code >> 6) << SHIFT2[i4++ & 3];
                blocks2[i4 >> 2] |= (128 | code & 63) << SHIFT2[i4++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i4 >> 2] |= (224 | code >> 12) << SHIFT2[i4++ & 3];
                blocks2[i4 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i4++ & 3];
                blocks2[i4 >> 2] |= (128 | code & 63) << SHIFT2[i4++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                blocks2[i4 >> 2] |= (240 | code >> 18) << SHIFT2[i4++ & 3];
                blocks2[i4 >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i4++ & 3];
                blocks2[i4 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i4++ & 3];
                blocks2[i4 >> 2] |= (128 | code & 63) << SHIFT2[i4++ & 3];
              }
            }
          }
          this.lastByteIndex = i4;
          if (i4 >= byteCount) {
            this.start = i4 - byteCount;
            this.block = blocks2[blockCount];
            for (i4 = 0; i4 < blockCount; ++i4) {
              s3[i4] ^= blocks2[i4];
            }
            f3(s3);
            this.reset = true;
          } else {
            this.start = i4;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x3, right) {
        var o3 = x3 & 255, n2 = 1;
        var bytes = [o3];
        x3 = x3 >> 8;
        o3 = x3 & 255;
        while (o3 > 0) {
          bytes.unshift(o3);
          x3 = x3 >> 8;
          o3 = x3 & 255;
          ++n2;
        }
        if (right) {
          bytes.push(n2);
        } else {
          bytes.unshift(n2);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i4 = 0; i4 < str.length; ++i4) {
            var code = str.charCodeAt(i4);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i4) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w4) {
        var bytes = this.encode(w4);
        for (var i4 = 0; i4 < strs.length; ++i4) {
          bytes += this.encodeString(strs[i4]);
        }
        var paddingBytes = w4 - bytes % w4;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i4 = this.lastByteIndex, blockCount = this.blockCount, s3 = this.s;
        blocks2[i4 >> 2] |= this.padding[i4 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks2[0] = blocks2[blockCount];
          for (i4 = 1; i4 < blockCount + 1; ++i4) {
            blocks2[i4] = 0;
          }
        }
        blocks2[blockCount - 1] |= 2147483648;
        for (i4 = 0; i4 < blockCount; ++i4) {
          s3[i4] ^= blocks2[i4];
        }
        f3(s3);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j4 = 0;
        var hex = "", block;
        while (j4 < outputBlocks) {
          for (i4 = 0; i4 < blockCount && j4 < outputBlocks; ++i4, ++j4) {
            block = s3[i4];
            hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15] + HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15] + HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15] + HEX_CHARS2[block >> 28 & 15] + HEX_CHARS2[block >> 24 & 15];
          }
          if (j4 % blockCount === 0) {
            f3(s3);
            i4 = 0;
          }
        }
        if (extraBytes) {
          block = s3[i4];
          hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j4 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j4 < outputBlocks) {
          for (i4 = 0; i4 < blockCount && j4 < outputBlocks; ++i4, ++j4) {
            array[j4] = s3[i4];
          }
          if (j4 % blockCount === 0) {
            f3(s3);
          }
        }
        if (extraBytes) {
          array[i4] = s3[i4];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i4 = 0, j4 = 0;
        var array = [], offset, block;
        while (j4 < outputBlocks) {
          for (i4 = 0; i4 < blockCount && j4 < outputBlocks; ++i4, ++j4) {
            offset = j4 << 2;
            block = s3[i4];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j4 % blockCount === 0) {
            f3(s3);
          }
        }
        if (extraBytes) {
          offset = j4 << 2;
          block = s3[i4];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f3 = function(s3) {
        var h3, l3, n2, c0, c1, c22, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n2 = 0; n2 < 48; n2 += 2) {
          c0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
          c1 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
          c22 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
          c3 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
          c4 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
          c5 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
          c6 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
          c7 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
          c8 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
          c9 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
          h3 = c8 ^ (c22 << 1 | c3 >>> 31);
          l3 = c9 ^ (c3 << 1 | c22 >>> 31);
          s3[0] ^= h3;
          s3[1] ^= l3;
          s3[10] ^= h3;
          s3[11] ^= l3;
          s3[20] ^= h3;
          s3[21] ^= l3;
          s3[30] ^= h3;
          s3[31] ^= l3;
          s3[40] ^= h3;
          s3[41] ^= l3;
          h3 = c0 ^ (c4 << 1 | c5 >>> 31);
          l3 = c1 ^ (c5 << 1 | c4 >>> 31);
          s3[2] ^= h3;
          s3[3] ^= l3;
          s3[12] ^= h3;
          s3[13] ^= l3;
          s3[22] ^= h3;
          s3[23] ^= l3;
          s3[32] ^= h3;
          s3[33] ^= l3;
          s3[42] ^= h3;
          s3[43] ^= l3;
          h3 = c22 ^ (c6 << 1 | c7 >>> 31);
          l3 = c3 ^ (c7 << 1 | c6 >>> 31);
          s3[4] ^= h3;
          s3[5] ^= l3;
          s3[14] ^= h3;
          s3[15] ^= l3;
          s3[24] ^= h3;
          s3[25] ^= l3;
          s3[34] ^= h3;
          s3[35] ^= l3;
          s3[44] ^= h3;
          s3[45] ^= l3;
          h3 = c4 ^ (c8 << 1 | c9 >>> 31);
          l3 = c5 ^ (c9 << 1 | c8 >>> 31);
          s3[6] ^= h3;
          s3[7] ^= l3;
          s3[16] ^= h3;
          s3[17] ^= l3;
          s3[26] ^= h3;
          s3[27] ^= l3;
          s3[36] ^= h3;
          s3[37] ^= l3;
          s3[46] ^= h3;
          s3[47] ^= l3;
          h3 = c6 ^ (c0 << 1 | c1 >>> 31);
          l3 = c7 ^ (c1 << 1 | c0 >>> 31);
          s3[8] ^= h3;
          s3[9] ^= l3;
          s3[18] ^= h3;
          s3[19] ^= l3;
          s3[28] ^= h3;
          s3[29] ^= l3;
          s3[38] ^= h3;
          s3[39] ^= l3;
          s3[48] ^= h3;
          s3[49] ^= l3;
          b0 = s3[0];
          b1 = s3[1];
          b32 = s3[11] << 4 | s3[10] >>> 28;
          b33 = s3[10] << 4 | s3[11] >>> 28;
          b14 = s3[20] << 3 | s3[21] >>> 29;
          b15 = s3[21] << 3 | s3[20] >>> 29;
          b46 = s3[31] << 9 | s3[30] >>> 23;
          b47 = s3[30] << 9 | s3[31] >>> 23;
          b28 = s3[40] << 18 | s3[41] >>> 14;
          b29 = s3[41] << 18 | s3[40] >>> 14;
          b20 = s3[2] << 1 | s3[3] >>> 31;
          b21 = s3[3] << 1 | s3[2] >>> 31;
          b2 = s3[13] << 12 | s3[12] >>> 20;
          b3 = s3[12] << 12 | s3[13] >>> 20;
          b34 = s3[22] << 10 | s3[23] >>> 22;
          b35 = s3[23] << 10 | s3[22] >>> 22;
          b16 = s3[33] << 13 | s3[32] >>> 19;
          b17 = s3[32] << 13 | s3[33] >>> 19;
          b48 = s3[42] << 2 | s3[43] >>> 30;
          b49 = s3[43] << 2 | s3[42] >>> 30;
          b40 = s3[5] << 30 | s3[4] >>> 2;
          b41 = s3[4] << 30 | s3[5] >>> 2;
          b22 = s3[14] << 6 | s3[15] >>> 26;
          b23 = s3[15] << 6 | s3[14] >>> 26;
          b4 = s3[25] << 11 | s3[24] >>> 21;
          b5 = s3[24] << 11 | s3[25] >>> 21;
          b36 = s3[34] << 15 | s3[35] >>> 17;
          b37 = s3[35] << 15 | s3[34] >>> 17;
          b18 = s3[45] << 29 | s3[44] >>> 3;
          b19 = s3[44] << 29 | s3[45] >>> 3;
          b10 = s3[6] << 28 | s3[7] >>> 4;
          b11 = s3[7] << 28 | s3[6] >>> 4;
          b42 = s3[17] << 23 | s3[16] >>> 9;
          b43 = s3[16] << 23 | s3[17] >>> 9;
          b24 = s3[26] << 25 | s3[27] >>> 7;
          b25 = s3[27] << 25 | s3[26] >>> 7;
          b6 = s3[36] << 21 | s3[37] >>> 11;
          b7 = s3[37] << 21 | s3[36] >>> 11;
          b38 = s3[47] << 24 | s3[46] >>> 8;
          b39 = s3[46] << 24 | s3[47] >>> 8;
          b30 = s3[8] << 27 | s3[9] >>> 5;
          b31 = s3[9] << 27 | s3[8] >>> 5;
          b12 = s3[18] << 20 | s3[19] >>> 12;
          b13 = s3[19] << 20 | s3[18] >>> 12;
          b44 = s3[29] << 7 | s3[28] >>> 25;
          b45 = s3[28] << 7 | s3[29] >>> 25;
          b26 = s3[38] << 8 | s3[39] >>> 24;
          b27 = s3[39] << 8 | s3[38] >>> 24;
          b8 = s3[48] << 14 | s3[49] >>> 18;
          b9 = s3[49] << 14 | s3[48] >>> 18;
          s3[0] = b0 ^ ~b2 & b4;
          s3[1] = b1 ^ ~b3 & b5;
          s3[10] = b10 ^ ~b12 & b14;
          s3[11] = b11 ^ ~b13 & b15;
          s3[20] = b20 ^ ~b22 & b24;
          s3[21] = b21 ^ ~b23 & b25;
          s3[30] = b30 ^ ~b32 & b34;
          s3[31] = b31 ^ ~b33 & b35;
          s3[40] = b40 ^ ~b42 & b44;
          s3[41] = b41 ^ ~b43 & b45;
          s3[2] = b2 ^ ~b4 & b6;
          s3[3] = b3 ^ ~b5 & b7;
          s3[12] = b12 ^ ~b14 & b16;
          s3[13] = b13 ^ ~b15 & b17;
          s3[22] = b22 ^ ~b24 & b26;
          s3[23] = b23 ^ ~b25 & b27;
          s3[32] = b32 ^ ~b34 & b36;
          s3[33] = b33 ^ ~b35 & b37;
          s3[42] = b42 ^ ~b44 & b46;
          s3[43] = b43 ^ ~b45 & b47;
          s3[4] = b4 ^ ~b6 & b8;
          s3[5] = b5 ^ ~b7 & b9;
          s3[14] = b14 ^ ~b16 & b18;
          s3[15] = b15 ^ ~b17 & b19;
          s3[24] = b24 ^ ~b26 & b28;
          s3[25] = b25 ^ ~b27 & b29;
          s3[34] = b34 ^ ~b36 & b38;
          s3[35] = b35 ^ ~b37 & b39;
          s3[44] = b44 ^ ~b46 & b48;
          s3[45] = b45 ^ ~b47 & b49;
          s3[6] = b6 ^ ~b8 & b0;
          s3[7] = b7 ^ ~b9 & b1;
          s3[16] = b16 ^ ~b18 & b10;
          s3[17] = b17 ^ ~b19 & b11;
          s3[26] = b26 ^ ~b28 & b20;
          s3[27] = b27 ^ ~b29 & b21;
          s3[36] = b36 ^ ~b38 & b30;
          s3[37] = b37 ^ ~b39 & b31;
          s3[46] = b46 ^ ~b48 & b40;
          s3[47] = b47 ^ ~b49 & b41;
          s3[8] = b8 ^ ~b0 & b2;
          s3[9] = b9 ^ ~b1 & b3;
          s3[18] = b18 ^ ~b10 & b12;
          s3[19] = b19 ^ ~b11 & b13;
          s3[28] = b28 ^ ~b20 & b22;
          s3[29] = b29 ^ ~b21 & b23;
          s3[38] = b38 ^ ~b30 & b32;
          s3[39] = b39 ^ ~b31 & b33;
          s3[48] = b48 ^ ~b40 & b42;
          s3[49] = b49 ^ ~b41 & b43;
          s3[0] ^= RC[n2];
          s3[1] ^= RC[n2 + 1];
        }
      };
      if (COMMON_JS2) {
        module2.exports = methods;
      } else {
        for (i3 = 0; i3 < methodNames.length; ++i3) {
          root2[methodNames[i3]] = methods[methodNames[i3]];
        }
        if (AMD2) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowserCryptoAvailable = exports2.getSubtleCrypto = exports2.getBrowerCrypto = void 0;
    function getBrowerCrypto2() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports2.getBrowerCrypto = getBrowerCrypto2;
    function getSubtleCrypto2() {
      const browserCrypto = getBrowerCrypto2();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports2.getSubtleCrypto = getSubtleCrypto2;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto2() && !!getSubtleCrypto2();
    }
    exports2.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowser = exports2.isNode = exports2.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports2.isReactNative = isReactNative;
    function isNode4() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports2.isNode = isNode4;
    function isBrowser2() {
      return !isReactNative() && !isNode4();
    }
    exports2.isBrowser = isBrowser2;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !exports3.hasOwnProperty(p3))
          __createBinding(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_crypto2(), exports2);
    __exportStar(require_env(), exports2);
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x3) => `%${x3.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp(token, "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return decodeURIComponent(components.join(""));
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode2(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i3 = 1; i3 < tokens.length; i3++) {
          input = decodeComponents(tokens, i3).join("");
          tokens = input.match(singleMatcher);
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode2(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i3 = 0; i3 < entries.length; i3++) {
        var key = entries[i3];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module2.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports2) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index2 = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index2, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index2, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a3, b2) => Number(a3) - Number(b2)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k3 of Object.keys(value)) {
            value[k3] = parseValue(value[k3], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports2.extract = extract;
    exports2.parse = parse2;
    exports2.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x3) => x3.length > 0).join("&");
    };
    exports2.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash] = splitOnFirst(input, "#");
      return Object.assign({
        url: url.split("?")[0] || "",
        query: parse2(extract(input), options)
      }, options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode2(hash, options) } : {});
    };
    exports2.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports2.extract(input.url);
      const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports2.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash = `#${encode2(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
    };
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports2, module2) {
    module2.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/qrcode/lib/utils/typedarray-buffer.js
var require_typedarray_buffer = __commonJS({
  "node_modules/qrcode/lib/utils/typedarray-buffer.js"(exports2, module2) {
    "use strict";
    var isArray = require_isarray();
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } };
        return arr.foo() === 42;
      } catch (e3) {
        return false;
      }
    }
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    var K_MAX_LENGTH = Buffer3.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    function Buffer3(arg, offset, length) {
      if (!Buffer3.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer3)) {
        return new Buffer3(arg, offset, length);
      }
      if (typeof arg === "number") {
        return allocUnsafe(this, arg);
      }
      return from(this, arg, offset, length);
    }
    if (Buffer3.TYPED_ARRAY_SUPPORT) {
      Buffer3.prototype.__proto__ = Uint8Array.prototype;
      Buffer3.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer3[Symbol.species] === Buffer3) {
        Object.defineProperty(Buffer3, Symbol.species, {
          value: null,
          configurable: true,
          enumerable: false,
          writable: false
        });
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function isnan(val) {
      return val !== val;
    }
    function createBuffer(that, length) {
      var buf;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        buf = new Uint8Array(length);
        buf.__proto__ = Buffer3.prototype;
      } else {
        buf = that;
        if (buf === null) {
          buf = new Buffer3(length);
        }
        buf.length = length;
      }
      return buf;
    }
    function allocUnsafe(that, size) {
      var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer3.TYPED_ARRAY_SUPPORT) {
        for (var i3 = 0; i3 < size; ++i3) {
          buf[i3] = 0;
        }
      }
      return buf;
    }
    function fromString(that, string) {
      var length = byteLength(string) | 0;
      var buf = createBuffer(that, length);
      var actual = buf.write(string);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(that, length);
      for (var i3 = 0; i3 < length; i3 += 1) {
        buf[i3] = array[i3] & 255;
      }
      return buf;
    }
    function fromArrayBuffer(that, array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError("'length' is out of bounds");
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        buf.__proto__ = Buffer3.prototype;
      } else {
        buf = fromArrayLike(that, buf);
      }
      return buf;
    }
    function fromObject(that, obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(that, len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj) {
        if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
          if (typeof obj.length !== "number" || isnan(obj.length)) {
            return createBuffer(that, 0);
          }
          return fromArrayLike(that, obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i3 = 0; i3 < length; ++i3) {
        codePoint = string.charCodeAt(i3);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i3 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function byteLength(string) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        string = "" + string;
      }
      var len = string.length;
      if (len === 0)
        return 0;
      return utf8ToBytes(string).length;
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i3 = 0; i3 < length; ++i3) {
        if (i3 + offset >= dst.length || i3 >= src.length)
          break;
        dst[i3 + offset] = src[i3];
      }
      return i3;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function from(that, value, offset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, offset, length);
      }
      if (typeof value === "string") {
        return fromString(that, value, offset);
      }
      return fromObject(that, value);
    }
    Buffer3.prototype.write = function write(string, offset, length) {
      if (offset === void 0) {
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
        } else {
          length = void 0;
        }
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      return utf8Write(this, string, offset, length);
    };
    Buffer3.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer3.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer3.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer3(sliceLen, void 0);
        for (var i3 = 0; i3 < sliceLen; ++i3) {
          newBuf[i3] = this[i3 + start];
        }
      }
      return newBuf;
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i3;
      if (this === target && start < targetStart && targetStart < end) {
        for (i3 = len - 1; i3 >= 0; --i3) {
          target[i3 + targetStart] = this[i3 + start];
        }
      } else if (len < 1e3 || !Buffer3.TYPED_ARRAY_SUPPORT) {
        for (i3 = 0; i3 < len; ++i3) {
          target[i3 + targetStart] = this[i3 + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i3;
      if (typeof val === "number") {
        for (i3 = start; i3 < end; ++i3) {
          this[i3] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : new Buffer3(val);
        var len = bytes.length;
        for (i3 = 0; i3 < end - start; ++i3) {
          this[i3 + start] = bytes[i3 % len];
        }
      }
      return this;
    };
    Buffer3.concat = function concat(list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return createBuffer(null, 0);
      }
      var i3;
      if (length === void 0) {
        length = 0;
        for (i3 = 0; i3 < list.length; ++i3) {
          length += list[i3].length;
        }
      }
      var buffer = allocUnsafe(null, length);
      var pos = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        var buf = list[i3];
        if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer3.byteLength = byteLength;
    Buffer3.prototype._isBuffer = true;
    Buffer3.isBuffer = function isBuffer3(b2) {
      return !!(b2 != null && b2._isBuffer);
    };
    module2.exports.alloc = function(size) {
      var buffer = new Buffer3(size);
      buffer.fill(0);
      return buffer;
    };
    module2.exports.from = function(data) {
      return new Buffer3(data);
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports2) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports2.getSymbolSize = function getSymbolSize(version) {
      if (!version)
        throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    exports2.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    exports2.getBCHDigit = function(data) {
      var digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports2.setToSJISFunction = function setToSJISFunction(f3) {
      if (typeof f3 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f3;
    };
    exports2.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports2.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports2) {
    exports2.L = { bit: 1 };
    exports2.M = { bit: 0 };
    exports2.Q = { bit: 3 };
    exports2.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports2.L;
        case "m":
        case "medium":
          return exports2.M;
        case "q":
        case "quartile":
          return exports2.Q;
        case "h":
        case "high":
          return exports2.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports2.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports2.from = function from(value, defaultValue) {
      if (exports2.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e3) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports2, module2) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index2) {
        var bufIndex = Math.floor(index2 / 8);
        return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (var i3 = 0; i3 < length; i3++) {
          this.putBit((num >>> length - i3 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module2.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports2, module2) {
    var BufferUtil = require_typedarray_buffer();
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = BufferUtil.alloc(size * size);
      this.reservedBit = BufferUtil.alloc(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      var index2 = row * this.size + col;
      this.data[index2] = value;
      if (reserved)
        this.reservedBit[index2] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module2.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports2) {
    var getSymbolSize = require_utils().getSymbolSize;
    exports2.getRowColCoords = function getRowColCoords(version) {
      if (version === 1)
        return [];
      var posCount = Math.floor(version / 7) + 2;
      var size = getSymbolSize(version);
      var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      var positions = [size - 7];
      for (var i3 = 1; i3 < posCount - 1; i3++) {
        positions[i3] = positions[i3 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports2.getPositions = function getPositions(version) {
      var coords = [];
      var pos = exports2.getRowColCoords(version);
      var posLength = pos.length;
      for (var i3 = 0; i3 < posLength; i3++) {
        for (var j3 = 0; j3 < posLength; j3++) {
          if (i3 === 0 && j3 === 0 || i3 === 0 && j3 === posLength - 1 || i3 === posLength - 1 && j3 === 0) {
            continue;
          }
          coords.push([pos[i3], pos[j3]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports2) {
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports2.getPositions = function getPositions(version) {
      var size = getSymbolSize(version);
      return [
        [0, 0],
        [size - FINDER_PATTERN_SIZE, 0],
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports2) {
    exports2.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports2.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports2.from = function from(value) {
      return exports2.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports2.getPenaltyN1 = function getPenaltyN1(data) {
      var size = data.size;
      var points = 0;
      var sameCountCol = 0;
      var sameCountRow = 0;
      var lastCol = null;
      var lastRow = null;
      for (var row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (var col = 0; col < size; col++) {
          var module3 = data.get(row, col);
          if (module3 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module3;
            sameCountCol = 1;
          }
          module3 = data.get(col, row);
          if (module3 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module3;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports2.getPenaltyN2 = function getPenaltyN2(data) {
      var size = data.size;
      var points = 0;
      for (var row = 0; row < size - 1; row++) {
        for (var col = 0; col < size - 1; col++) {
          var last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports2.getPenaltyN3 = function getPenaltyN3(data) {
      var size = data.size;
      var points = 0;
      var bitsCol = 0;
      var bitsRow = 0;
      for (var row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (var col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports2.getPenaltyN4 = function getPenaltyN4(data) {
      var darkCount = 0;
      var modulesCount = data.data.length;
      for (var i3 = 0; i3 < modulesCount; i3++)
        darkCount += data.data[i3];
      var k3 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k3 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i3, j3) {
      switch (maskPattern) {
        case exports2.Patterns.PATTERN000:
          return (i3 + j3) % 2 === 0;
        case exports2.Patterns.PATTERN001:
          return i3 % 2 === 0;
        case exports2.Patterns.PATTERN010:
          return j3 % 3 === 0;
        case exports2.Patterns.PATTERN011:
          return (i3 + j3) % 3 === 0;
        case exports2.Patterns.PATTERN100:
          return (Math.floor(i3 / 2) + Math.floor(j3 / 3)) % 2 === 0;
        case exports2.Patterns.PATTERN101:
          return i3 * j3 % 2 + i3 * j3 % 3 === 0;
        case exports2.Patterns.PATTERN110:
          return (i3 * j3 % 2 + i3 * j3 % 3) % 2 === 0;
        case exports2.Patterns.PATTERN111:
          return (i3 * j3 % 3 + (i3 + j3) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports2.applyMask = function applyMask(pattern, data) {
      var size = data.size;
      for (var col = 0; col < size; col++) {
        for (var row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports2.getBestMask = function getBestMask(data, setupFormatFunc) {
      var numPatterns = Object.keys(exports2.Patterns).length;
      var bestPattern = 0;
      var lowerPenalty = Infinity;
      for (var p3 = 0; p3 < numPatterns; p3++) {
        setupFormatFunc(p3);
        exports2.applyMask(p3, data);
        var penalty = exports2.getPenaltyN1(data) + exports2.getPenaltyN2(data) + exports2.getPenaltyN3(data) + exports2.getPenaltyN4(data);
        exports2.applyMask(p3, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p3;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports2) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports2.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports2.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports2) {
    var BufferUtil = require_typedarray_buffer();
    var EXP_TABLE = BufferUtil.alloc(512);
    var LOG_TABLE = BufferUtil.alloc(256);
    (function initTables() {
      var x3 = 1;
      for (var i3 = 0; i3 < 255; i3++) {
        EXP_TABLE[i3] = x3;
        LOG_TABLE[x3] = i3;
        x3 <<= 1;
        if (x3 & 256) {
          x3 ^= 285;
        }
      }
      for (i3 = 255; i3 < 512; i3++) {
        EXP_TABLE[i3] = EXP_TABLE[i3 - 255];
      }
    })();
    exports2.log = function log(n2) {
      if (n2 < 1)
        throw new Error("log(" + n2 + ")");
      return LOG_TABLE[n2];
    };
    exports2.exp = function exp(n2) {
      return EXP_TABLE[n2];
    };
    exports2.mul = function mul(x3, y3) {
      if (x3 === 0 || y3 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x3] + LOG_TABLE[y3]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports2) {
    var BufferUtil = require_typedarray_buffer();
    var GF = require_galois_field();
    exports2.mul = function mul(p1, p22) {
      var coeff = BufferUtil.alloc(p1.length + p22.length - 1);
      for (var i3 = 0; i3 < p1.length; i3++) {
        for (var j3 = 0; j3 < p22.length; j3++) {
          coeff[i3 + j3] ^= GF.mul(p1[i3], p22[j3]);
        }
      }
      return coeff;
    };
    exports2.mod = function mod(divident, divisor) {
      var result = BufferUtil.from(divident);
      while (result.length - divisor.length >= 0) {
        var coeff = result[0];
        for (var i3 = 0; i3 < divisor.length; i3++) {
          result[i3] ^= GF.mul(divisor[i3], coeff);
        }
        var offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports2.generateECPolynomial = function generateECPolynomial(degree) {
      var poly = BufferUtil.from([1]);
      for (var i3 = 0; i3 < degree; i3++) {
        poly = exports2.mul(poly, [1, GF.exp(i3)]);
      }
      return poly;
    };
  }
});

// node_modules/qrcode/node_modules/buffer/index.js
var require_buffer3 = __commonJS({
  "node_modules/qrcode/node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer3;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e3) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      var b2 = fromObject(value);
      if (b2)
        return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i3 = 0; i3 < length; i3 += 1) {
        buf[i3] = array[i3] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer3(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a3, b2) {
      if (isInstance(a3, Uint8Array))
        a3 = Buffer3.from(a3, a3.offset, a3.byteLength);
      if (isInstance(b2, Uint8Array))
        b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
      if (!Buffer3.isBuffer(a3) || !Buffer3.isBuffer(b2)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a3 === b2)
        return 0;
      var x3 = a3.length;
      var y3 = b2.length;
      for (var i3 = 0, len = Math.min(x3, y3); i3 < len; ++i3) {
        if (a3[i3] !== b2[i3]) {
          x3 = a3[i3];
          y3 = b2[i3];
          break;
        }
      }
      if (x3 < y3)
        return -1;
      if (y3 < x3)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      var i3;
      if (length === void 0) {
        length = 0;
        for (i3 = 0; i3 < list.length; ++i3) {
          length += list[i3].length;
        }
      }
      var buffer = Buffer3.allocUnsafe(length);
      var pos = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        var buf = list[i3];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer3.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b2, n2, m3) {
      var i3 = b2[n2];
      b2[n2] = b2[m3];
      b2[m3] = i3;
    }
    Buffer3.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i3 = 0; i3 < len; i3 += 2) {
        swap(this, i3, i3 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i3 = 0; i3 < len; i3 += 4) {
        swap(this, i3, i3 + 3);
        swap(this, i3 + 1, i3 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i3 = 0; i3 < len; i3 += 8) {
        swap(this, i3, i3 + 7);
        swap(this, i3 + 1, i3 + 6);
        swap(this, i3 + 2, i3 + 5);
        swap(this, i3 + 3, i3 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b2) {
      if (!Buffer3.isBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer3.compare(this, b2) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      var str = "";
      var max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x3 = thisEnd - thisStart;
      var y3 = end - start;
      var len = Math.min(x3, y3);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i3 = 0; i3 < len; ++i3) {
        if (thisCopy[i3] !== targetCopy[i3]) {
          x3 = thisCopy[i3];
          y3 = targetCopy[i3];
          break;
        }
      }
      if (x3 < y3)
        return -1;
      if (y3 < x3)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i4) {
        if (indexSize === 1) {
          return buf[i4];
        } else {
          return buf.readUInt16BE(i4 * indexSize);
        }
      }
      var i3;
      if (dir) {
        var foundIndex = -1;
        for (i3 = byteOffset; i3 < arrLength; i3++) {
          if (read(arr, i3) === read(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i3;
            if (i3 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i3 -= i3 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i3 = byteOffset; i3 >= 0; i3--) {
          var found = true;
          for (var j3 = 0; j3 < valLength; j3++) {
            if (read(arr, i3 + j3) !== read(val, j3)) {
              found = false;
              break;
            }
          }
          if (found)
            return i3;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i3 = 0; i3 < length; ++i3) {
        var parsed = parseInt(string.substr(i3 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i3;
        buf[offset + i3] = parsed;
      }
      return i3;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i3 = start;
      while (i3 < end) {
        var firstByte = buf[i3];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i3 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i3 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i3 + 1];
              thirdByte = buf[i3 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i3 + 1];
              thirdByte = buf[i3 + 2];
              fourthByte = buf[i3 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i3 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i3 = 0;
      while (i3 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i3 = start; i3 < end; ++i3) {
        ret += String.fromCharCode(buf[i3] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i3 = start; i3 < end; ++i3) {
        ret += String.fromCharCode(buf[i3]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i3 = start; i3 < end; ++i3) {
        out += hexSliceLookupTable[buf[i3]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i3 = 0; i3 < bytes.length - 1; i3 += 2) {
        res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i3 = 0;
      while (++i3 < byteLength2 && (mul *= 256)) {
        val += this[offset + i3] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i3 = 0;
      while (++i3 < byteLength2 && (mul *= 256)) {
        val += this[offset + i3] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i3 = byteLength2;
      var mul = 1;
      var val = this[offset + --i3];
      while (i3 > 0 && (mul *= 256)) {
        val += this[offset + --i3] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i3 = 0;
      this[offset] = value & 255;
      while (++i3 < byteLength2 && (mul *= 256)) {
        this[offset + i3] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i3 = byteLength2 - 1;
      var mul = 1;
      this[offset + i3] = value & 255;
      while (--i3 >= 0 && (mul *= 256)) {
        this[offset + i3] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i3 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i3 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i3] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i3 = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i3] = value & 255;
      while (--i3 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i3] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i3;
      if (typeof val === "number") {
        for (i3 = start; i3 < end; ++i3) {
          this[i3] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i3 = 0; i3 < end - start; ++i3) {
          this[i3 + start] = bytes[i3 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i3 = 0; i3 < length; ++i3) {
        codePoint = string.charCodeAt(i3);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i3 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i3 = 0; i3 < str.length; ++i3) {
        byteArray.push(str.charCodeAt(i3) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c3, hi, lo;
      var byteArray = [];
      for (var i3 = 0; i3 < str.length; ++i3) {
        if ((units -= 2) < 0)
          break;
        c3 = str.charCodeAt(i3);
        hi = c3 >> 8;
        lo = c3 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i3 = 0; i3 < length; ++i3) {
        if (i3 + offset >= dst.length || i3 >= src.length)
          break;
        dst[i3 + offset] = src[i3];
      }
      return i3;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i3 = 0; i3 < 16; ++i3) {
        var i16 = i3 * 16;
        for (var j3 = 0; j3 < 16; ++j3) {
          table[i16 + j3] = alphabet[i3] + alphabet[j3];
        }
      }
      return table;
    }();
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports2, module2) {
    var BufferUtil = require_typedarray_buffer();
    var Polynomial = require_polynomial();
    var Buffer3 = require_buffer3().Buffer;
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode2(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      var pad = BufferUtil.alloc(this.degree);
      var paddedData = Buffer3.concat([data, pad], data.length + this.degree);
      var remainder = Polynomial.mod(paddedData, this.genPoly);
      var start = this.degree - remainder.length;
      if (start > 0) {
        var buff = BufferUtil.alloc(this.degree);
        remainder.copy(buff, start);
        return buff;
      }
      return remainder;
    };
    module2.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports2) {
    exports2.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports2) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports2.KANJI = new RegExp(kanji, "g");
    exports2.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports2.BYTE = new RegExp(byte, "g");
    exports2.NUMERIC = new RegExp(numeric, "g");
    exports2.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports2.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports2.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports2.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports2) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports2.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports2.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports2.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports2.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports2.MIXED = {
      bit: -1
    };
    exports2.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid version: " + version);
      }
      if (version >= 1 && version < 10)
        return mode.ccBits[0];
      else if (version < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports2.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports2.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports2.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports2.KANJI;
      else
        return exports2.BYTE;
    };
    exports2.toString = function toString(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports2.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports2.NUMERIC;
        case "alphanumeric":
          return exports2.ALPHANUMERIC;
        case "kanji":
          return exports2.KANJI;
        case "byte":
          return exports2.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports2.from = function from(value, defaultValue) {
      if (exports2.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e3) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports2) {
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var isArray = require_isarray();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version) {
      return Mode.getCharCountIndicator(mode, version) + 4;
    }
    function getTotalBitsFromDataArray(segments, version) {
      var totalBits = 0;
      segments.forEach(function(data) {
        var reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        var length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports2.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports2.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      var totalCodewords = Utils.getSymbolTotalCodewords(version);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports2.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      var seg;
      var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports2.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error("Invalid QR Code version");
      }
      var d3 = version << 12;
      while (Utils.getBCHDigit(d3) - G18_BCH >= 0) {
        d3 ^= G18 << Utils.getBCHDigit(d3) - G18_BCH;
      }
      return version << 12 | d3;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports2) {
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports2.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      var data = errorCorrectionLevel.bit << 3 | mask;
      var d3 = data << 10;
      while (Utils.getBCHDigit(d3) - G15_BCH >= 0) {
        d3 ^= G15 << Utils.getBCHDigit(d3) - G15_BCH;
      }
      return (data << 10 | d3) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports2, module2) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      var i3, group, value;
      for (i3 = 0; i3 + 3 <= this.data.length; i3 += 3) {
        group = this.data.substr(i3, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      var remainingNum = this.data.length - i3;
      if (remainingNum > 0) {
        group = this.data.substr(i3);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module2.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports2, module2) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      var i3;
      for (i3 = 0; i3 + 2 <= this.data.length; i3 += 2) {
        var value = ALPHA_NUM_CHARS.indexOf(this.data[i3]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i3 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i3]), 6);
      }
    };
    module2.exports = AlphanumericData;
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports2, module2) {
    var BufferUtil = require_typedarray_buffer();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      this.data = BufferUtil.from(data);
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (var i3 = 0, l3 = this.data.length; i3 < l3; i3++) {
        bitBuffer.put(this.data[i3], 8);
      }
    };
    module2.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports2, module2) {
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      var i3;
      for (i3 = 0; i3 < this.data.length; i3++) {
        var value = Utils.toSJIS(this.data[i3]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error("Invalid SJIS character: " + this.data[i3] + "\nMake sure your charset is UTF-8");
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module2.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports2, module2) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s3, d3) {
        var predecessors = {};
        var costs = {};
        costs[s3] = 0;
        var open2 = dijkstra.PriorityQueue.make();
        open2.push(s3, 0);
        var closest, u3, v3, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open2.empty()) {
          closest = open2.pop();
          u3 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u3] || {};
          for (v3 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v3)) {
              cost_of_e = adjacent_nodes[v3];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v3];
              first_visit = typeof costs[v3] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v3] = cost_of_s_to_u_plus_cost_of_e;
                open2.push(v3, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v3] = u3;
              }
            }
          }
        }
        if (typeof d3 !== "undefined" && typeof costs[d3] === "undefined") {
          var msg = ["Could not find a path from ", s3, " to ", d3, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d3) {
        var nodes = [];
        var u3 = d3;
        var predecessor;
        while (u3) {
          nodes.push(u3);
          predecessor = predecessors[u3];
          u3 = predecessors[u3];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s3, d3) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s3, d3);
        return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d3);
      },
      PriorityQueue: {
        make: function(opts) {
          var T4 = dijkstra.PriorityQueue, t3 = {}, key;
          opts = opts || {};
          for (key in T4) {
            if (T4.hasOwnProperty(key)) {
              t3[key] = T4[key];
            }
          }
          t3.queue = [];
          t3.sorter = opts.sorter || T4.default_sorter;
          return t3;
        },
        default_sorter: function(a3, b2) {
          return a3.cost - b2.cost;
        },
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module2 !== "undefined") {
      module2.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports2) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      var segments = [];
      var result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      var byteSegs;
      var kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      var nodes = [];
      for (var i3 = 0; i3 < segs.length; i3++) {
        var seg = segs[i3];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version) {
      var table = {};
      var graph = { "start": {} };
      var prevNodeIds = ["start"];
      for (var i3 = 0; i3 < nodes.length; i3++) {
        var nodeGroup = nodes[i3];
        var currentNodeIds = [];
        for (var j3 = 0; j3 < nodeGroup.length; j3++) {
          var node = nodeGroup[j3];
          var key = "" + i3 + j3;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (var n2 = 0; n2 < prevNodeIds.length; n2++) {
            var prevNodeId = prevNodeIds[n2];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (n2 = 0; n2 < prevNodeIds.length; n2++) {
        graph[prevNodeIds[n2]]["end"] = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      var mode;
      var bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports2.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports2.fromString = function fromString(data, version) {
      var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      var nodes = buildNodes(segs);
      var graph = buildGraph(nodes, version);
      var path = dijkstra.find_path(graph.map, "start", "end");
      var optimizedSegs = [];
      for (var i3 = 1; i3 < path.length - 1; i3++) {
        optimizedSegs.push(graph.table[path[i3]].node);
      }
      return exports2.fromArray(mergeSegments(optimizedSegs));
    };
    exports2.rawSplit = function rawSplit(data) {
      return exports2.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports2) {
    var BufferUtil = require_typedarray_buffer();
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    var isArray = require_isarray();
    function setupFinderPattern(matrix, version) {
      var size = matrix.size;
      var pos = FinderPattern.getPositions(version);
      for (var i3 = 0; i3 < pos.length; i3++) {
        var row = pos[i3][0];
        var col = pos[i3][1];
        for (var r3 = -1; r3 <= 7; r3++) {
          if (row + r3 <= -1 || size <= row + r3)
            continue;
          for (var c3 = -1; c3 <= 7; c3++) {
            if (col + c3 <= -1 || size <= col + c3)
              continue;
            if (r3 >= 0 && r3 <= 6 && (c3 === 0 || c3 === 6) || c3 >= 0 && c3 <= 6 && (r3 === 0 || r3 === 6) || r3 >= 2 && r3 <= 4 && c3 >= 2 && c3 <= 4) {
              matrix.set(row + r3, col + c3, true, true);
            } else {
              matrix.set(row + r3, col + c3, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      var size = matrix.size;
      for (var r3 = 8; r3 < size - 8; r3++) {
        var value = r3 % 2 === 0;
        matrix.set(r3, 6, value, true);
        matrix.set(6, r3, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version) {
      var pos = AlignmentPattern.getPositions(version);
      for (var i3 = 0; i3 < pos.length; i3++) {
        var row = pos[i3][0];
        var col = pos[i3][1];
        for (var r3 = -2; r3 <= 2; r3++) {
          for (var c3 = -2; c3 <= 2; c3++) {
            if (r3 === -2 || r3 === 2 || c3 === -2 || c3 === 2 || r3 === 0 && c3 === 0) {
              matrix.set(row + r3, col + c3, true, true);
            } else {
              matrix.set(row + r3, col + c3, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version) {
      var size = matrix.size;
      var bits = Version.getEncodedBits(version);
      var row, col, mod;
      for (var i3 = 0; i3 < 18; i3++) {
        row = Math.floor(i3 / 3);
        col = i3 % 3 + size - 8 - 3;
        mod = (bits >> i3 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      var size = matrix.size;
      var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      var i3, mod;
      for (i3 = 0; i3 < 15; i3++) {
        mod = (bits >> i3 & 1) === 1;
        if (i3 < 6) {
          matrix.set(i3, 8, mod, true);
        } else if (i3 < 8) {
          matrix.set(i3 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i3, 8, mod, true);
        }
        if (i3 < 8) {
          matrix.set(8, size - i3 - 1, mod, true);
        } else if (i3 < 9) {
          matrix.set(8, 15 - i3 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i3 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      var size = matrix.size;
      var inc = -1;
      var row = size - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (var c3 = 0; c3 < 2; c3++) {
            if (!matrix.isReserved(row, col - c3)) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c3, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version, errorCorrectionLevel, segments) {
      var buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        data.write(buffer);
      });
      var totalCodewords = Utils.getSymbolTotalCodewords(version);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (var i3 = 0; i3 < remainingByte; i3++) {
        buffer.put(i3 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      var totalCodewords = Utils.getSymbolTotalCodewords(version);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      var dataTotalCodewords = totalCodewords - ecTotalCodewords;
      var ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
      var blocksInGroup2 = totalCodewords % ecTotalBlocks;
      var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      var rs = new ReedSolomonEncoder(ecCount);
      var offset = 0;
      var dcData = new Array(ecTotalBlocks);
      var ecData = new Array(ecTotalBlocks);
      var maxDataSize = 0;
      var buffer = BufferUtil.from(bitBuffer.buffer);
      for (var b2 = 0; b2 < ecTotalBlocks; b2++) {
        var dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b2] = buffer.slice(offset, offset + dataSize);
        ecData[b2] = rs.encode(dcData[b2]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      var data = BufferUtil.alloc(totalCodewords);
      var index2 = 0;
      var i3, r3;
      for (i3 = 0; i3 < maxDataSize; i3++) {
        for (r3 = 0; r3 < ecTotalBlocks; r3++) {
          if (i3 < dcData[r3].length) {
            data[index2++] = dcData[r3][i3];
          }
        }
      }
      for (i3 = 0; i3 < ecCount; i3++) {
        for (r3 = 0; r3 < ecTotalBlocks; r3++) {
          data[index2++] = ecData[r3][i3];
        }
      }
      return data;
    }
    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      var segments;
      if (isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        var estimatedVersion = version;
        if (!estimatedVersion) {
          var rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      var bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version) {
        version = bestVersion;
      } else if (version < bestVersion) {
        throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
      }
      var dataBits = createData(version, errorCorrectionLevel, segments);
      var moduleCount = Utils.getSymbolSize(version);
      var modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version >= 7) {
        setupVersionInfo(modules, version);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports2.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      var errorCorrectionLevel = ECLevel.M;
      var version;
      var mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports2) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      var hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c3) {
          return [c3, c3];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      var hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports2.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      var width = options.width && options.width >= 21 ? options.width : void 0;
      var scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports2.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports2.getImageWidth = function getImageWidth(qrSize, opts) {
      var scale = exports2.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
      var size = qr.modules.size;
      var data = qr.modules.data;
      var scale = exports2.getScale(size, opts);
      var symbolSize = Math.floor((size + opts.margin * 2) * scale);
      var scaledMargin = opts.margin * scale;
      var palette = [opts.color.light, opts.color.dark];
      for (var i3 = 0; i3 < symbolSize; i3++) {
        for (var j3 = 0; j3 < symbolSize; j3++) {
          var posDst = (i3 * symbolSize + j3) * 4;
          var pxColor = opts.color.light;
          if (i3 >= scaledMargin && j3 >= scaledMargin && i3 < symbolSize - scaledMargin && j3 < symbolSize - scaledMargin) {
            var iSrc = Math.floor((i3 - scaledMargin) / scale);
            var jSrc = Math.floor((j3 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports2) {
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e3) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports2.render = function render(qrData, canvas, options) {
      var opts = options;
      var canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      var ctx = canvasEl.getContext("2d");
      var image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports2.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      var opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      var canvasEl = exports2.render(qrData, canvas, opts);
      var type = opts.type || "image/png";
      var rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports2) {
    var Utils = require_utils2();
    function getColorAttrib(color, attrib) {
      var alpha = color.a / 255;
      var str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x3, y3) {
      var str = cmd + x3;
      if (typeof y3 !== "undefined")
        str += " " + y3;
      return str;
    }
    function qrToPath(data, size, margin) {
      var path = "";
      var moveBy = 0;
      var newRow = false;
      var lineLength = 0;
      for (var i3 = 0; i3 < data.length; i3++) {
        var col = Math.floor(i3 % size);
        var row = Math.floor(i3 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i3]) {
          lineLength++;
          if (!(i3 > 0 && col > 0 && data[i3 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i3 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports2.render = function render(qrData, options, cb) {
      var opts = Utils.getOptions(options);
      var size = qrData.modules.size;
      var data = qrData.modules.data;
      var qrcodesize = size + opts.margin * 2;
      var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      var path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser2 = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports2) {
    var canPromise = require_can_promise();
    var QRCode2 = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      var args = [].slice.call(arguments, 1);
      var argsNum = args.length;
      var isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            var data2 = QRCode2.create(text, opts);
            resolve(renderFunc(data2, canvas, opts));
          } catch (e3) {
            reject(e3);
          }
        });
      }
      try {
        var data = QRCode2.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e3) {
        cb(e3);
      }
    }
    exports2.create = QRCode2.create;
    exports2.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports2.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports2.toString = renderCanvas.bind(null, function(data, _4, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports2, module2) {
    module2.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i3 = 0; i3 < selection.rangeCount; i3++) {
        ranges.push(selection.getRangeAt(i3));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports2, module2) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy2(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e3) {
          e3.stopPropagation();
          if (options.format) {
            e3.preventDefault();
            if (typeof e3.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e3.clipboardData.clearData();
              e3.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e3.preventDefault();
            options.onCopy(e3.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module2.exports = copy2;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports2, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values2;
    var __read;
    var __spread;
    var __spreadArrays2;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root2, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root2, createExporter(module2.exports)));
      } else {
        factory(createExporter(root2));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root2) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v3) {
          return exports3[id] = previous ? previous(id, v3) : v3;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
        d3.__proto__ = b2;
      } || function(d3, b2) {
        for (var p3 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p3))
            d3[p3] = b2[p3];
      };
      __extends = function(d3, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t3) {
        for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
          s3 = arguments[i3];
          for (var p3 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p3))
              t3[p3] = s3[p3];
        }
        return t3;
      };
      __rest = function(s3, e3) {
        var t3 = {};
        for (var p3 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
            t3[p3] = s3[p3];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
            if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
              t3[p3[i3]] = s3[p3[i3]];
          }
        return t3;
      };
      __decorate = function(decorators, target, key, desc) {
        var c3 = arguments.length, r3 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r3 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i3 = decorators.length - 1; i3 >= 0; i3--)
            if (d3 = decorators[i3])
              r3 = (c3 < 3 ? d3(r3) : c3 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
        return c3 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _4 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f3, y3, t3, g3;
        return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
          return this;
        }), g3;
        function verb(n2) {
          return function(v3) {
            return step([n2, v3]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_4)
            try {
              if (f3 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
                return t3;
              if (y3 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _4.label++;
                  return { value: op[1], done: false };
                case 5:
                  _4.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _4.ops.pop();
                  _4.trys.pop();
                  continue;
                default:
                  if (!(t3 = _4.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _4 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _4.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _4.label < t3[1]) {
                    _4.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _4.label < t3[2]) {
                    _4.label = t3[2];
                    _4.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _4.ops.pop();
                  _4.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _4);
            } catch (e3) {
              op = [6, e3];
              y3 = 0;
            } finally {
              f3 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m3, o3) {
        for (var p3 in m3)
          if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o3, p3))
            __createBinding(o3, m3, p3);
      };
      __createBinding = Object.create ? function(o3, m3, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        Object.defineProperty(o3, k22, { enumerable: true, get: function() {
          return m3[k3];
        } });
      } : function(o3, m3, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m3[k3];
      };
      __values2 = function(o3) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o3[s3], i3 = 0;
        if (m3)
          return m3.call(o3);
        if (o3 && typeof o3.length === "number")
          return {
            next: function() {
              if (o3 && i3 >= o3.length)
                o3 = void 0;
              return { value: o3 && o3[i3++], done: !o3 };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o3, n2) {
        var m3 = typeof Symbol === "function" && o3[Symbol.iterator];
        if (!m3)
          return o3;
        var i3 = m3.call(o3), r3, ar = [], e3;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r3 = i3.next()).done)
            ar.push(r3.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r3 && !r3.done && (m3 = i3["return"]))
              m3.call(i3);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i3 = 0; i3 < arguments.length; i3++)
          ar = ar.concat(__read(arguments[i3]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
          s3 += arguments[i3].length;
        for (var r3 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
          for (var a3 = arguments[i3], j3 = 0, jl = a3.length; j3 < jl; j3++, k3++)
            r3[k3] = a3[j3];
        return r3;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
            if (ar || !(i3 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i3);
              ar[i3] = from[i3];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await = function(v3) {
        return this instanceof __await ? (this.v = v3, this) : new __await(v3);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g3 = generator.apply(thisArg, _arguments || []), i3, q3 = [];
        return i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3;
        function verb(n2) {
          if (g3[n2])
            i3[n2] = function(v3) {
              return new Promise(function(a3, b2) {
                q3.push([n2, v3, a3, b2]) > 1 || resume(n2, v3);
              });
            };
        }
        function resume(n2, v3) {
          try {
            step(g3[n2](v3));
          } catch (e3) {
            settle(q3[0][3], e3);
          }
        }
        function step(r3) {
          r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q3[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v3) {
          if (f3(v3), q3.shift(), q3.length)
            resume(q3[0][0], q3[0][1]);
        }
      };
      __asyncDelegator = function(o3) {
        var i3, p3;
        return i3 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i3[Symbol.iterator] = function() {
          return this;
        }, i3;
        function verb(n2, f3) {
          i3[n2] = o3[n2] ? function(v3) {
            return (p3 = !p3) ? { value: __await(o3[n2](v3)), done: n2 === "return" } : f3 ? f3(v3) : v3;
          } : f3;
        }
      };
      __asyncValues = function(o3) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o3[Symbol.asyncIterator], i3;
        return m3 ? m3.call(o3) : (o3 = typeof __values2 === "function" ? __values2(o3) : o3[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
          return this;
        }, i3);
        function verb(n2) {
          i3[n2] = o3[n2] && function(v3) {
            return new Promise(function(resolve, reject) {
              v3 = o3[n2](v3), settle(resolve, reject, v3.done, v3.value);
            });
          };
        }
        function settle(resolve, reject, d3, v3) {
          Promise.resolve(v3).then(function(v4) {
            resolve({ value: v4, done: d3 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o3, v3) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v3 });
      } : function(o3, v3) {
        o3["default"] = v3;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
              __createBinding(result, mod, k3);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f3) {
        if (kind === "a" && !f3)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f3) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f3)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values2);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/constants.js
var require_constants = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.STANDARD_ERROR_MAP = exports2.SERVER_ERROR_CODE_RANGE = exports2.RESERVED_ERROR_CODES = exports2.SERVER_ERROR = exports2.INTERNAL_ERROR = exports2.INVALID_PARAMS = exports2.METHOD_NOT_FOUND = exports2.INVALID_REQUEST = exports2.PARSE_ERROR = void 0;
    exports2.PARSE_ERROR = "PARSE_ERROR";
    exports2.INVALID_REQUEST = "INVALID_REQUEST";
    exports2.METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
    exports2.INVALID_PARAMS = "INVALID_PARAMS";
    exports2.INTERNAL_ERROR = "INTERNAL_ERROR";
    exports2.SERVER_ERROR = "SERVER_ERROR";
    exports2.RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
    exports2.SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
    exports2.STANDARD_ERROR_MAP = {
      [exports2.PARSE_ERROR]: { code: -32700, message: "Parse error" },
      [exports2.INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
      [exports2.METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
      [exports2.INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
      [exports2.INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
      [exports2.SERVER_ERROR]: { code: -32e3, message: "Server error" }
    };
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/error.js
var require_error = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateJsonRpcError = exports2.getErrorByCode = exports2.getError = exports2.isValidErrorCode = exports2.isReservedErrorCode = exports2.isServerErrorCode = void 0;
    var constants_1 = require_constants();
    function isServerErrorCode2(code) {
      return code <= constants_1.SERVER_ERROR_CODE_RANGE[0] && code >= constants_1.SERVER_ERROR_CODE_RANGE[1];
    }
    exports2.isServerErrorCode = isServerErrorCode2;
    function isReservedErrorCode2(code) {
      return constants_1.RESERVED_ERROR_CODES.includes(code);
    }
    exports2.isReservedErrorCode = isReservedErrorCode2;
    function isValidErrorCode2(code) {
      return typeof code === "number";
    }
    exports2.isValidErrorCode = isValidErrorCode2;
    function getError2(type) {
      if (!Object.keys(constants_1.STANDARD_ERROR_MAP).includes(type)) {
        return constants_1.STANDARD_ERROR_MAP[constants_1.INTERNAL_ERROR];
      }
      return constants_1.STANDARD_ERROR_MAP[type];
    }
    exports2.getError = getError2;
    function getErrorByCode2(code) {
      const match = Object.values(constants_1.STANDARD_ERROR_MAP).find((e3) => e3.code === code);
      if (!match) {
        return constants_1.STANDARD_ERROR_MAP[constants_1.INTERNAL_ERROR];
      }
      return match;
    }
    exports2.getErrorByCode = getErrorByCode2;
    function validateJsonRpcError2(response) {
      if (typeof response.error.code === "undefined") {
        return { valid: false, error: "Missing code for JSON-RPC error" };
      }
      if (typeof response.error.message === "undefined") {
        return { valid: false, error: "Missing message for JSON-RPC error" };
      }
      if (!isValidErrorCode2(response.error.code)) {
        return {
          valid: false,
          error: `Invalid error code type for JSON-RPC: ${response.error.code}`
        };
      }
      if (isReservedErrorCode2(response.error.code)) {
        const error = getErrorByCode2(response.error.code);
        if (error.message !== constants_1.STANDARD_ERROR_MAP[constants_1.INTERNAL_ERROR].message && response.error.message === error.message) {
          return {
            valid: false,
            error: `Invalid error code message for JSON-RPC: ${response.error.code}`
          };
        }
      }
      return { valid: true };
    }
    exports2.validateJsonRpcError = validateJsonRpcError2;
  }
});

// node_modules/@pedrouid/environment/dist/cjs/crypto.js
var require_crypto3 = __commonJS({
  "node_modules/@pedrouid/environment/dist/cjs/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowserCryptoAvailable = exports2.getSubtleCrypto = exports2.getBrowerCrypto = void 0;
    function getBrowerCrypto2() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports2.getBrowerCrypto = getBrowerCrypto2;
    function getSubtleCrypto2() {
      const browserCrypto = getBrowerCrypto2();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports2.getSubtleCrypto = getSubtleCrypto2;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto2() && !!getSubtleCrypto2();
    }
    exports2.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@pedrouid/environment/dist/cjs/env.js
var require_env2 = __commonJS({
  "node_modules/@pedrouid/environment/dist/cjs/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowser = exports2.isNode = exports2.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports2.isReactNative = isReactNative;
    function isNode4() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports2.isNode = isNode4;
    function isBrowser2() {
      return !isReactNative() && !isNode4();
    }
    exports2.isBrowser = isBrowser2;
  }
});

// node_modules/@pedrouid/environment/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@pedrouid/environment/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m3[k3];
      } });
    } : function(o3, m3, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o3[k22] = m3[k3];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m3, exports3) {
      for (var p3 in m3)
        if (p3 !== "default" && !exports3.hasOwnProperty(p3))
          __createBinding(exports3, m3, p3);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_crypto3(), exports2);
    __exportStar(require_env2(), exports2);
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/env.js
var require_env3 = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNodeJs = void 0;
    var tslib_1 = require_tslib();
    var environment_1 = require_cjs4();
    exports2.isNodeJs = environment_1.isNode;
    tslib_1.__exportStar(require_cjs4(), exports2);
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/format.js
var require_format = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatErrorMessage = exports2.formatJsonRpcError = exports2.formatJsonRpcResult = exports2.formatJsonRpcRequest = exports2.payloadId = void 0;
    var error_1 = require_error();
    var constants_1 = require_constants();
    function payloadId3() {
      const date = Date.now() * Math.pow(10, 3);
      const extra = Math.floor(Math.random() * Math.pow(10, 3));
      return date + extra;
    }
    exports2.payloadId = payloadId3;
    function formatJsonRpcRequest3(method2, params, id) {
      return {
        id: id || payloadId3(),
        jsonrpc: "2.0",
        method: method2,
        params
      };
    }
    exports2.formatJsonRpcRequest = formatJsonRpcRequest3;
    function formatJsonRpcResult2(id, result) {
      return {
        id,
        jsonrpc: "2.0",
        result
      };
    }
    exports2.formatJsonRpcResult = formatJsonRpcResult2;
    function formatJsonRpcError2(id, error) {
      return {
        id,
        jsonrpc: "2.0",
        error: formatErrorMessage2(error)
      };
    }
    exports2.formatJsonRpcError = formatJsonRpcError2;
    function formatErrorMessage2(error) {
      if (typeof error === "undefined") {
        return error_1.getError(constants_1.INTERNAL_ERROR);
      }
      if (typeof error === "string") {
        error = Object.assign(Object.assign({}, error_1.getError(constants_1.SERVER_ERROR)), { message: error });
      }
      if (error_1.isReservedErrorCode(error.code)) {
        error = error_1.getErrorByCode(error.code);
      }
      if (!error_1.isServerErrorCode(error.code)) {
        throw new Error("Error code is not in server code range");
      }
      return error;
    }
    exports2.formatErrorMessage = formatErrorMessage2;
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/routing.js
var require_routing = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/routing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidTrailingWildcardRoute = exports2.isValidLeadingWildcardRoute = exports2.isValidWildcardRoute = exports2.isValidDefaultRoute = exports2.isValidRoute = void 0;
    function isValidRoute2(route) {
      if (route.includes("*")) {
        return isValidWildcardRoute2(route);
      }
      if (/\W/g.test(route)) {
        return false;
      }
      return true;
    }
    exports2.isValidRoute = isValidRoute2;
    function isValidDefaultRoute2(route) {
      return route === "*";
    }
    exports2.isValidDefaultRoute = isValidDefaultRoute2;
    function isValidWildcardRoute2(route) {
      if (isValidDefaultRoute2(route)) {
        return true;
      }
      if (!route.includes("*")) {
        return false;
      }
      if (route.split("*").length !== 2) {
        return false;
      }
      if (route.split("*").filter((x3) => x3.trim() === "").length !== 1) {
        return false;
      }
      return true;
    }
    exports2.isValidWildcardRoute = isValidWildcardRoute2;
    function isValidLeadingWildcardRoute2(route) {
      return !isValidDefaultRoute2(route) && isValidWildcardRoute2(route) && !route.split("*")[0].trim();
    }
    exports2.isValidLeadingWildcardRoute = isValidLeadingWildcardRoute2;
    function isValidTrailingWildcardRoute2(route) {
      return !isValidDefaultRoute2(route) && isValidWildcardRoute2(route) && !route.split("*")[1].trim();
    }
    exports2.isValidTrailingWildcardRoute = isValidTrailingWildcardRoute2;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/misc.js
var require_misc = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/misc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IEvents = void 0;
    var IEvents2 = class {
    };
    exports2.IEvents = IEvents2;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/provider.js
var require_provider = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IJsonRpcProvider = exports2.IBaseJsonRpcProvider = exports2.IJsonRpcConnection = void 0;
    var misc_1 = require_misc();
    var IJsonRpcConnection2 = class extends misc_1.IEvents {
      constructor(opts) {
        super();
      }
    };
    exports2.IJsonRpcConnection = IJsonRpcConnection2;
    var IBaseJsonRpcProvider2 = class extends misc_1.IEvents {
      constructor() {
        super();
      }
    };
    exports2.IBaseJsonRpcProvider = IBaseJsonRpcProvider2;
    var IJsonRpcProvider2 = class extends IBaseJsonRpcProvider2 {
      constructor(connection) {
        super();
      }
    };
    exports2.IJsonRpcProvider = IJsonRpcProvider2;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/blockchain.js
var require_blockchain = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/blockchain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IBlockchainProvider = exports2.IBlockchainAuthenticator = exports2.IPendingRequests = void 0;
    var misc_1 = require_misc();
    var provider_1 = require_provider();
    var IPendingRequests = class {
      constructor(storage) {
        this.storage = storage;
      }
    };
    exports2.IPendingRequests = IPendingRequests;
    var IBlockchainAuthenticator = class extends misc_1.IEvents {
      constructor(config) {
        super();
        this.config = config;
      }
    };
    exports2.IBlockchainAuthenticator = IBlockchainAuthenticator;
    var IBlockchainProvider = class extends provider_1.IJsonRpcProvider {
      constructor(connection, config) {
        super(connection);
      }
    };
    exports2.IBlockchainProvider = IBlockchainProvider;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/jsonrpc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/multi.js
var require_multi = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/multi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IMultiServiceProvider = void 0;
    var provider_1 = require_provider();
    var IMultiServiceProvider = class extends provider_1.IBaseJsonRpcProvider {
      constructor(config) {
        super();
        this.config = config;
      }
    };
    exports2.IMultiServiceProvider = IMultiServiceProvider;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/router.js
var require_router = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/router.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IJsonRpcRouter = void 0;
    var IJsonRpcRouter = class {
      constructor(routes) {
        this.routes = routes;
      }
    };
    exports2.IJsonRpcRouter = IJsonRpcRouter;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/schema.js
var require_schema = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/validator.js
var require_validator = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IJsonRpcValidator = void 0;
    var IJsonRpcValidator = class {
      constructor(schemas) {
        this.schemas = schemas;
      }
    };
    exports2.IJsonRpcValidator = IJsonRpcValidator;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_blockchain(), exports2);
    tslib_1.__exportStar(require_jsonrpc(), exports2);
    tslib_1.__exportStar(require_misc(), exports2);
    tslib_1.__exportStar(require_multi(), exports2);
    tslib_1.__exportStar(require_provider(), exports2);
    tslib_1.__exportStar(require_router(), exports2);
    tslib_1.__exportStar(require_schema(), exports2);
    tslib_1.__exportStar(require_validator(), exports2);
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/types.js
var require_types = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_cjs5(), exports2);
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/validators.js
var require_validators = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isJsonRpcValidationInvalid = exports2.isJsonRpcError = exports2.isJsonRpcResult = exports2.isJsonRpcResponse = exports2.isJsonRpcRequest = exports2.isJsonRpcPayload = void 0;
    function isJsonRpcPayload2(payload) {
      return "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
    }
    exports2.isJsonRpcPayload = isJsonRpcPayload2;
    function isJsonRpcRequest3(payload) {
      return isJsonRpcPayload2(payload) && "method" in payload;
    }
    exports2.isJsonRpcRequest = isJsonRpcRequest3;
    function isJsonRpcResponse2(payload) {
      return isJsonRpcPayload2(payload) && (isJsonRpcResult2(payload) || isJsonRpcError2(payload));
    }
    exports2.isJsonRpcResponse = isJsonRpcResponse2;
    function isJsonRpcResult2(payload) {
      return "result" in payload;
    }
    exports2.isJsonRpcResult = isJsonRpcResult2;
    function isJsonRpcError2(payload) {
      return "error" in payload;
    }
    exports2.isJsonRpcError = isJsonRpcError2;
    function isJsonRpcValidationInvalid2(validation) {
      return "error" in validation && validation.valid === false;
    }
    exports2.isJsonRpcValidationInvalid = isJsonRpcValidationInvalid2;
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_constants(), exports2);
    tslib_1.__exportStar(require_error(), exports2);
    tslib_1.__exportStar(require_env3(), exports2);
    tslib_1.__exportStar(require_format(), exports2);
    tslib_1.__exportStar(require_routing(), exports2);
    tslib_1.__exportStar(require_types(), exports2);
    tslib_1.__exportStar(require_validators(), exports2);
  }
});

// node_modules/detect-browser/es/index.js
var __spreadArrays = function() {
  for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
    s3 += arguments[i3].length;
  for (var r3 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
    for (var a3 = arguments[i3], j3 = 0, jl = a3.length; j3 < jl; j3++, k3++)
      r3[k3] = a3[j3];
  return r3;
};
var BrowserInfo = function() {
  function BrowserInfo2(name, version, os) {
    this.name = name;
    this.version = version;
    this.os = os;
    this.type = "browser";
  }
  return BrowserInfo2;
}();
var NodeInfo = function() {
  function NodeInfo2(version) {
    this.version = version;
    this.type = "node";
    this.name = "node";
    this.os = process.platform;
  }
  return NodeInfo2;
}();
var SearchBotDeviceInfo = function() {
  function SearchBotDeviceInfo2(name, version, os, bot) {
    this.name = name;
    this.version = version;
    this.os = os;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo2;
}();
var BotInfo = function() {
  function BotInfo2() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo2;
}();
var ReactNativeInfo = function() {
  function ReactNativeInfo2() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo2;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FBAV\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function browserName(ua) {
  var data = matchUserAgent(ua);
  return data ? data[0] : null;
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode4 = typeof process !== "undefined" && process.version;
  return isNode4 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
var windowMetadata = __toESM(require_cjs2());
var windowGetters = __toESM(require_cjs());
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS2() {
  const env3 = detectEnv();
  return env3 && env3.os ? env3.os : void 0;
}
function isAndroid() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os = detectOS2();
  return os ? isAndroid() || isIOS() : false;
}
function isNode() {
  const env3 = detectEnv();
  const result = env3 && env3.name ? env3.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode() && !!getNavigator();
  return result;
}
var getFromWindow = windowGetters.getFromWindow;
var getFromWindowOrThrow = windowGetters.getFromWindowOrThrow;
var getDocumentOrThrow = windowGetters.getDocumentOrThrow;
var getDocument = windowGetters.getDocument;
var getNavigatorOrThrow = windowGetters.getNavigatorOrThrow;
var getNavigator = windowGetters.getNavigator;
var getLocationOrThrow = windowGetters.getLocationOrThrow;
var getLocation = windowGetters.getLocation;
var getCryptoOrThrow = windowGetters.getCryptoOrThrow;
var getCrypto = windowGetters.getCrypto;
var getLocalStorageOrThrow = windowGetters.getLocalStorageOrThrow;
var getLocalStorage = windowGetters.getLocalStorage;
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse2 = safeJsonParse;
var safeJsonStringify2 = safeJsonStringify;

// node_modules/@walletconnect/browser-utils/dist/esm/local.js
function setLocal(key, data) {
  const raw = safeJsonStringify2(data);
  const local = getLocalStorage();
  if (local) {
    local.setItem(key, raw);
  }
}
function getLocal(key) {
  let data = null;
  let raw = null;
  const local = getLocalStorage();
  if (local) {
    raw = local.getItem(key);
  }
  data = raw ? safeJsonParse2(raw) : raw;
  return data;
}
function removeLocal(key) {
  const local = getLocalStorage();
  if (local) {
    local.removeItem(key);
  }
}

// node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
var mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name) => getMobileRegistryEntry(registry, name)).filter(Boolean);
  }
  return links;
}

// node_modules/@walletconnect/browser-utils/dist/esm/registry.js
var API_URL = "https://registry.walletconnect.com";
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform = "mobile") {
  var _a;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a = entry.image_url.sm) !== null && _a !== void 0 ? _a : "",
    universalLink: entry[platform].universal || "",
    deepLink: entry[platform].native || ""
  };
}
function formatMobileRegistry(registry, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
}

// node_modules/@walletconnect/utils/dist/esm/constants.js
var reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
var signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];
var stateMethods = ["eth_accounts", "eth_chainId", "net_version"];
var infuraNetworks = {
  1: "mainnet",
  3: "ropsten",
  4: "rinkeby",
  5: "goerli",
  42: "kovan"
};

// node_modules/@walletconnect/encoding/dist/esm/index.js
var import_is_typedarray = __toESM(require_is_typedarray());
var import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
var ENC_HEX = "hex";
var ENC_UTF8 = "utf8";
var ENC_BIN = "binary";
var TYPE_BUFFER = "buffer";
var TYPE_ARRAY = "array";
var TYPE_TYPED_ARRAY = "typed-array";
var TYPE_ARRAY_BUFFER = "array-buffer";
var STRING_ZERO = "0";
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex) : hex;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function bufferToNumber(buf) {
  return buf.readUIntBE(0, buf.length);
}
function bufferToBinary(buf) {
  return arrayToBinary(bufferToArray(buf));
}
function arrayToBuffer(arr) {
  return (0, import_typedarray_to_buffer.default)(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function arrayToNumber(arr) {
  return bufferToNumber(arrayToBuffer(arr));
}
function arrayToBinary(arr) {
  return Array.from(arr).map(numberToBinary).join("");
}
function hexToBuffer(hex) {
  return Buffer.from(removeHexPrefix(hex), ENC_HEX);
}
function hexToArray(hex) {
  return bufferToArray(hexToBuffer(hex));
}
function hexToUtf8(hex) {
  return bufferToUtf8(hexToBuffer(hex));
}
function hexToNumber(hex) {
  return arrayToNumber(hexToArray(hex));
}
function hexToBinary(hex) {
  return arrayToBinary(hexToArray(hex));
}
function utf8ToBuffer(utf8) {
  return Buffer.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function utf8ToNumber(utf8) {
  const num = parseInt(utf8, 10);
  assert(isDefined(num), "Number can only safely store up to 53 bits");
  return num;
}
function utf8ToBinary(utf8) {
  return arrayToBinary(utf8ToArray(utf8));
}
function numberToBuffer(num) {
  return binaryToBuffer(numberToBinary(num));
}
function numberToArray(num) {
  return binaryToArray(numberToBinary(num));
}
function numberToHex(num, prefixed) {
  return binaryToHex(numberToBinary(num), prefixed);
}
function numberToUtf8(num) {
  return `${num}`;
}
function numberToBinary(num) {
  const bin = (num >>> 0).toString(2);
  return sanitizeBytes(bin);
}
function binaryToBuffer(bin) {
  return arrayToBuffer(binaryToArray(bin));
}
function binaryToArray(bin) {
  return new Uint8Array(splitBytes(bin).map((x3) => parseInt(x3, 2)));
}
function binaryToHex(bin, prefixed) {
  return arrayToHex(binaryToArray(bin), prefixed);
}
function binaryToUtf8(bin) {
  return arrayToUtf8(binaryToArray(bin));
}
function binaryToNumber(bin) {
  return arrayToNumber(binaryToArray(bin));
}
function isBinaryString(str) {
  if (typeof str !== "string" || !new RegExp(/^[01]+$/).test(str)) {
    return false;
  }
  if (str.length % 8 !== 0) {
    return false;
  }
  return true;
}
function isHexString(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function isBuffer(val) {
  return Buffer.isBuffer(val);
}
function isTypedArray(val) {
  return import_is_typedarray.default.strict(val) && !isBuffer(val);
}
function isArrayBuffer(val) {
  return !isTypedArray(val) && !isBuffer(val) && typeof val.byteLength !== "undefined";
}
function getType(val) {
  if (isBuffer(val)) {
    return TYPE_BUFFER;
  } else if (isTypedArray(val)) {
    return TYPE_TYPED_ARRAY;
  } else if (isArrayBuffer(val)) {
    return TYPE_ARRAY_BUFFER;
  } else if (Array.isArray(val)) {
    return TYPE_ARRAY;
  } else {
    return typeof val;
  }
}
function getEncoding(str) {
  if (isBinaryString(str)) {
    return ENC_BIN;
  }
  if (isHexString(str)) {
    return ENC_HEX;
  }
  return ENC_UTF8;
}
function concatBuffers(...args) {
  const result = Buffer.concat(args);
  return result;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function trimLeft(data, length) {
  const diff = data.length - length;
  if (diff > 0) {
    data = data.slice(diff);
  }
  return data;
}
function trimRight(data, length) {
  return data.slice(0, length);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function splitBytes(str, byteSize = 8) {
  const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, "gi"));
  return Array.from(bytes || []);
}
function swapBytes(str) {
  return splitBytes(str).map(reverseString).join("");
}
function swapHex(str) {
  return binaryToHex(swapBytes(hexToBinary(str)));
}
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
function padLeft(str, length, padding = STRING_ZERO) {
  return padString(str, length, true, padding);
}
function padRight(str, length, padding = STRING_ZERO) {
  return padString(str, length, false, padding);
}
function removeHexPrefix(hex) {
  return hex.replace(/^0x/, "");
}
function addHexPrefix(hex) {
  return hex.startsWith("0x") ? hex : `0x${hex}`;
}
function sanitizeHex(hex) {
  hex = removeHexPrefix(hex);
  hex = sanitizeBytes(hex, 2);
  if (hex) {
    hex = addHexPrefix(hex);
  }
  return hex;
}
function removeHexLeadingZeros(hex) {
  const prefixed = hex.startsWith("0x");
  hex = removeHexPrefix(hex);
  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
  return prefixed ? addHexPrefix(hex) : hex;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isDefined(value) {
  return !isUndefined(value);
}
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
function reverseString(str) {
  return str.split("").reverse().join("");
}
function padString(str, length, left, padding = STRING_ZERO) {
  const diff = length - str.length;
  let result = str;
  if (diff > 0) {
    const pad = padding.repeat(diff);
    result = left ? pad + str : str + pad;
  }
  return result;
}

// node_modules/@walletconnect/utils/dist/esm/encoding.js
var import_bn = __toESM(require_bn());
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToUtf8(arrBuf) {
  return arrayToUtf8(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertArrayBufferToNumber(arrBuf) {
  return arrayToNumber(new Uint8Array(arrBuf));
}
function concatArrayBuffers(...args) {
  return hexToArray(args.map((b2) => arrayToHex(new Uint8Array(b2))).join("")).buffer;
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}
function convertBufferToUtf8(buf) {
  return bufferToUtf8(buf);
}
function convertBufferToHex(buf, noPrefix) {
  return bufferToHex(buf, !noPrefix);
}
function convertBufferToNumber(buf) {
  return bufferToNumber(buf);
}
function concatBuffers2(...args) {
  return concatBuffers(...args);
}
function convertUtf8ToArrayBuffer(utf8) {
  return utf8ToArray(utf8).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertUtf8ToNumber(utf8) {
  return new import_bn.default(utf8, 10).toNumber();
}
function convertHexToBuffer(hex) {
  return hexToBuffer(hex);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray(hex).buffer;
}
function convertHexToUtf8(hex) {
  return hexToUtf8(hex);
}
function convertHexToNumber(hex) {
  return new import_bn.default(removeHexPrefix(hex), "hex").toNumber();
}
function convertNumberToBuffer(num) {
  return numberToBuffer(num);
}
function convertNumberToArrayBuffer(num) {
  return numberToArray(num).buffer;
}
function convertNumberToUtf8(num) {
  return new import_bn.default(num).toString();
}
function convertNumberToHex(num, noPrefix) {
  const hex = removeHexPrefix(sanitizeHex(new import_bn.default(num).toString(16)));
  return noPrefix ? hex : addHexPrefix(hex);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[INTERNAL_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e3) => e3.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[INTERNAL_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[INTERNAL_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e3, url, type) {
  return e3.message.includes("getaddrinfo ENOTFOUND") || e3.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e3;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs3());
__reExport(env_exports, __toESM(require_cjs3()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function formatJsonRpcRequest(method2, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method: method2,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error)
  };
}
function formatErrorMessage(error) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x3) => x3.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
var IEvents = class {
};

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
var IJsonRpcConnection = class extends IEvents {
  constructor(opts) {
    super();
  }
};
var IBaseJsonRpcProvider = class extends IEvents {
  constructor() {
    super();
  }
};
var IJsonRpcProvider = class extends IBaseJsonRpcProvider {
  constructor(connection) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports3, env_exports);

// node_modules/@walletconnect/utils/dist/esm/misc.js
function sanitizeHex2(hex) {
  return sanitizeHex(hex);
}
function addHexPrefix2(hex) {
  return addHexPrefix(hex);
}
function removeHexPrefix2(hex) {
  return removeHexPrefix(hex);
}
function removeHexLeadingZeros2(hex) {
  return removeHexLeadingZeros(addHexPrefix(hex));
}
var payloadId2 = payloadId;
function uuid() {
  const result = ((a3, b2) => {
    for (b2 = a3 = ""; a3++ < 36; b2 += a3 * 51 & 52 ? (a3 ^ 15 ? 8 ^ Math.random() * (a3 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b2;
  })();
  return result;
}
function logDeprecationWarning() {
  console.warn("DEPRECATION WARNING: This WalletConnect client library will be deprecated in favor of @walletconnect/client. Please check docs.walletconnect.org to learn more about this migration!");
}
function getInfuraRpcUrl(chainId, infuraId) {
  let rpcUrl;
  const network = infuraNetworks[chainId];
  if (network) {
    rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
  }
  return rpcUrl;
}
function getRpcUrl(chainId, rpc) {
  let rpcUrl;
  const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
  if (rpc.custom && rpc.custom[chainId]) {
    rpcUrl = rpc.custom[chainId];
  } else if (infuraUrl) {
    rpcUrl = infuraUrl;
  }
  return rpcUrl;
}

// node_modules/@walletconnect/utils/dist/esm/validators.js
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isBuffer2(val) {
  return isBuffer(val);
}
function isTypedArray2(val) {
  return isTypedArray(val);
}
function isArrayBuffer2(val) {
  return isArrayBuffer(val);
}
function getType2(val) {
  return getType(val);
}
function getEncoding2(val) {
  return getEncoding(val);
}
function isHexString2(value, length) {
  return isHexString(value, length);
}
function isJsonRpcSubscription(object) {
  return typeof object.params === "object";
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request.method)) {
    return false;
  }
  return true;
}

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
var import_js_sha3 = __toESM(require_sha32());
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash = removeHexPrefix((0, import_js_sha3.keccak_256)(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i3 = 0; i3 < address.length; i3++) {
    if (parseInt(hash[i3], 16) > 7) {
      checksum += address[i3].toUpperCase();
    } else {
      checksum += address[i3];
    }
  }
  return addHexPrefix(checksum);
}
var isValidAddress = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString2(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString2(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex2(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros2(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex2(txData.from),
    to: typeof txData.to === "undefined" ? "" : sanitizeHex2(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key) => {
    if (!txDataRPC[key].trim().length && prunable.includes(key)) {
      delete txDataRPC[key];
    }
  });
  return txDataRPC;
}

// node_modules/@walletconnect/utils/dist/esm/payload.js
function promisify(originalFn, thisArg) {
  const promisifiedFunction = async (...callArgs) => {
    return new Promise((resolve, reject) => {
      const callback = (err, data) => {
        if (err === null || typeof err === "undefined") {
          reject(err);
        }
        resolve(data);
      };
      originalFn.apply(thisArg, [...callArgs, callback]);
    });
  };
  return promisifiedFunction;
}
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code = -32700;
        break;
      case "Invalid request":
        code = -32600;
        break;
      case "Method not found":
        code = -32601;
        break;
      case "Invalid params":
        code = -32602;
        break;
      case "Internal error":
        code = -32603;
        break;
      default:
        code = -32e3;
        break;
    }
  }
  const result = {
    code,
    message
  };
  return result;
}

// node_modules/@walletconnect/utils/dist/esm/url.js
var queryStringUtils = __toESM(require_query_string());
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils.stringify(queryParams);
}

// node_modules/@walletconnect/utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}

// node_modules/@walletconnect/socket-transport/dist/esm/network.js
var NetworkMonitor = class {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
};
var network_default = NetworkMonitor;

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
var WS = typeof global.WebSocket !== "undefined" ? global.WebSocket : require_browser();
var SocketTransport = class {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new network_default();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events = this._events.filter((event2) => event2.event === "message");
      if (events && events.length) {
        events.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e3) {
    const events = this._events.filter((event) => event.event === "error");
    if (events && events.length) {
      events.forEach((event) => event.callback(e3));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue = this._queue;
    queue.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
};
function getWebSocketUrl(_url, protocol, version) {
  var _a, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version,
    env: "browser",
    host: ((_a = getLocation()) === null || _a === void 0 ? void 0 : _a.host) || ""
  } : {
    protocol,
    version,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var esm_default = SocketTransport;

// node_modules/@walletconnect/core/dist/esm/errors.js
var ERROR_SESSION_CONNECTED = "Session currently connected";
var ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
var ERROR_SESSION_REJECTED = "Session Rejected";
var ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
var ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
var ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
var ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
var ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
var ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
var ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
var ERROR_INVALID_URI = "URI format is invalid";
var ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
var ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

// node_modules/@walletconnect/core/dist/esm/events.js
var EventManager = class {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x3) => x3.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest2(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error = new Error(payload.error.message);
        eventEmitter.callback(error, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
};
var events_default = EventManager;

// node_modules/@walletconnect/core/dist/esm/storage.js
var SessionStorage = class {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json = getLocal(this.storageId);
    if (json && isWalletConnectSession(json)) {
      session = json;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
};
var storage_default = SessionStorage;

// node_modules/@walletconnect/core/dist/esm/url.js
var domain = "walletconnect.org";
var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
var bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}

// node_modules/@walletconnect/core/dist/esm/index.js
var Connector = class {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new events_default();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new esm_default({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value) {
    if (!value) {
      return;
    }
    this._bridge = value;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value) {
    if (!value) {
      return;
    }
    const key = convertHexToArrayBuffer(value);
    this._key = key;
  }
  get key() {
    if (this._key) {
      const key = convertArrayBufferToHex(this._key, true);
      return key;
    }
    return "";
  }
  set clientId(value) {
    if (!value) {
      return;
    }
    this._clientId = value;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value) {
    if (!value) {
      return;
    }
    this._peerId = value;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value) {
    this._peerMeta = value;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value) {
    if (!value) {
      return;
    }
    this._handshakeTopic = value;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value) {
    if (!value) {
      return;
    }
    this._handshakeId = value;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value) {
    if (!value) {
      return;
    }
    const { handshakeTopic, bridge, key } = this._parseUri(value);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key;
  }
  set chainId(value) {
    this._chainId = value;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value) {
    this._networkId = value;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value) {
    this._accounts = value;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value) {
    this._rpcUrl = value;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value) {
    if (!value) {
      return;
    }
    this._connected = value.connected;
    this.accounts = value.accounts;
    this.chainId = value.chainId;
    this.bridge = value.bridge;
    this.key = value.key;
    this.clientId = value.clientId;
    this.clientMeta = value.clientMeta;
    this.peerId = value.peerId;
    this.peerMeta = value.peerMeta;
    this.handshakeId = value.handshakeId;
    this.handshakeTopic = value.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error) {
      endInstantRequest();
      throw error;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error, payload) => {
        if (error) {
          return reject(error);
        }
        resolve(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  unsafeSend(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(request.id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve(payload);
      });
    });
  }
  async sendCustomRequest(request, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request.params) {
          request.params[0] = parseTransactionData(request.params[0]);
        }
        break;
      case "personal_sign":
        if (request.params) {
          request.params = parsePersonalSign(request.params);
        }
        break;
      default:
        break;
    }
    const formattedRequest = this._formatRequest(request);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request, options) {
    const callRequest = this._formatRequest(request);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request, errorMsg, options) {
    this._sendRequest(request, options);
    this._subscribeToSessionResponse(request.id, errorMsg);
  }
  _sendCallRequest(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return this._subscribeToCallResponse(request.id);
  }
  _formatRequest(request) {
    if (typeof request.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request.id === "undefined" ? payloadId2() : request.id,
      jsonrpc: "2.0",
      method: request.method,
      params: typeof request.params === "undefined" ? [] : request.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id, callback) {
    this.on(`response:${id}`, callback);
  }
  _subscribeToSessionResponse(id, errorMsg) {
    this._subscribeToResponse(id, (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
        return;
      }
      if (payload.result) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id) {
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (payload.result) {
          resolve(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(new Error(payload.error.message));
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error, payload) => {
      const { request } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error, payload) => {
      if (error) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key = result.key;
      return { handshakeTopic, bridge, key };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.encrypt(data, key);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.decrypt(payload, key);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error, payload) => {
      if (error) {
        throw error;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json = await response.json();
        if (!json.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error2) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
};
var esm_default2 = Connector;

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
  AES_LENGTH: () => AES_LENGTH,
  AES_NODE_ALGO: () => AES_NODE_ALGO,
  DECRYPT_OP: () => DECRYPT_OP,
  ENCRYPT_OP: () => ENCRYPT_OP,
  ERROR_BAD_MAC: () => ERROR_BAD_MAC,
  HEX_ENC: () => HEX_ENC,
  HMAC_BROWSER: () => HMAC_BROWSER,
  HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
  HMAC_LENGTH: () => HMAC_LENGTH,
  HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
  IV_LENGTH: () => IV_LENGTH,
  KEY_LENGTH: () => KEY_LENGTH,
  LENGTH_0: () => LENGTH_0,
  LENGTH_1: () => LENGTH_1,
  LENGTH_1024: () => LENGTH_1024,
  LENGTH_128: () => LENGTH_128,
  LENGTH_16: () => LENGTH_16,
  LENGTH_256: () => LENGTH_256,
  LENGTH_32: () => LENGTH_32,
  LENGTH_512: () => LENGTH_512,
  LENGTH_64: () => LENGTH_64,
  MAC_LENGTH: () => MAC_LENGTH,
  PREFIX_LENGTH: () => PREFIX_LENGTH,
  RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
  SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
  SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
  SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
  SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
  SIGN_OP: () => SIGN_OP,
  UTF8_ENC: () => UTF8_ENC,
  VERIFY_OP: () => VERIFY_OP,
  aesCbcDecrypt: () => aesCbcDecrypt,
  aesCbcEncrypt: () => aesCbcEncrypt,
  assert: () => assert2,
  hmacSha256Sign: () => hmacSha256Sign,
  hmacSha256Verify: () => hmacSha256Verify,
  hmacSha512Sign: () => hmacSha512Sign,
  hmacSha512Verify: () => hmacSha512Verify,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7,
  randomBytes: () => randomBytes,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});

// node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
var env = __toESM(require_cjs3());
function randomBytes(length) {
  const browserCrypto = env.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}

// node_modules/@walletconnect/crypto/dist/esm/constants/length.js
var LENGTH_0 = 0;
var LENGTH_1 = 1;
var LENGTH_16 = 16;
var LENGTH_32 = 32;
var LENGTH_64 = 64;
var LENGTH_128 = 128;
var LENGTH_256 = 256;
var LENGTH_512 = 512;
var LENGTH_1024 = 1024;

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
var AES_LENGTH = LENGTH_256;
var HMAC_LENGTH = LENGTH_256;
var AES_BROWSER_ALGO = "AES-CBC";
var HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
var HMAC_BROWSER = "HMAC";
var SHA256_BROWSER_ALGO = "SHA-256";
var SHA512_BROWSER_ALGO = "SHA-512";
var AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
var HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
var SHA256_NODE_ALGO = "sha256";
var SHA512_NODE_ALGO = "sha512";
var RIPEMD160_NODE_ALGO = "ripemd160";
var PREFIX_LENGTH = LENGTH_1;
var KEY_LENGTH = LENGTH_32;
var IV_LENGTH = LENGTH_16;
var MAC_LENGTH = LENGTH_32;

// node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
var HEX_ENC = "hex";
var UTF8_ENC = "utf8";

// node_modules/@walletconnect/crypto/dist/esm/constants/error.js
var ERROR_BAD_MAC = "Bad MAC";

// node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
var ENCRYPT_OP = "encrypt";
var DECRYPT_OP = "decrypt";
var SIGN_OP = "sign";
var VERIFY_OP = "verify";

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
var env2 = __toESM(require_cjs3());
function getAlgo(type) {
  return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type) {
  return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserExportKey(cryptoKey, type = AES_BROWSER_ALGO) {
  const subtle = env2.getSubtleCrypto();
  return new Uint8Array(await subtle.exportKey("raw", cryptoKey));
}
async function browserImportKey(buffer, type = AES_BROWSER_ALGO) {
  return env2.getSubtleCrypto().importKey("raw", buffer, getAlgo(type), true, getOps(type));
}
async function browserAesEncrypt(iv, key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserHmacSha512Sign(key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: LENGTH_512,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserSha256(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA256_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}
async function browserSha512(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA512_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
function aesCbcEncrypt(iv, key, data) {
  return browserAesEncrypt(iv, key, data);
}
function aesCbcDecrypt(iv, key, data) {
  return browserAesDecrypt(iv, key, data);
}

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  assert: () => assert2,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
var env_exports2 = {};
__reExport(env_exports2, __toESM(require_cjs3()));

// node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
var PADDING = [
  [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
  [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
  [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
  [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
  [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
  [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
  [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
  [9, 9, 9, 9, 9, 9, 9, 9, 9],
  [8, 8, 8, 8, 8, 8, 8, 8],
  [7, 7, 7, 7, 7, 7, 7],
  [6, 6, 6, 6, 6, 6],
  [5, 5, 5, 5, 5],
  [4, 4, 4, 4],
  [3, 3, 3],
  [2, 2],
  [1]
];
var pkcs7 = {
  pad(plaintext) {
    const padding = PADDING[plaintext.byteLength % 16 || 0];
    const result = new Uint8Array(plaintext.byteLength + padding.length);
    result.set(plaintext);
    result.set(padding, plaintext.byteLength);
    return result;
  },
  unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
};

// node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isConstantTime(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let res = 0;
  for (let i3 = 0; i3 < arr1.length; i3++) {
    res |= arr1[i3] ^ arr2[i3];
  }
  return res === 0;
}

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
__reExport(helpers_exports, env_exports2);

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
async function hmacSha256Sign(key, msg) {
  const result = await browserHmacSha256Sign(key, msg);
  return result;
}
async function hmacSha256Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha256Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
async function hmacSha512Sign(key, msg) {
  const result = await browserHmacSha512Sign(key, msg);
  return result;
}
async function hmacSha512Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha512Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
async function sha256(msg) {
  const result = await browserSha256(msg);
  return result;
}
async function sha512(msg) {
  const result = await browserSha512(msg);
  return result;
}
async function ripemd160(msg) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
__reExport(browser_exports, helpers_exports);

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt(data, key, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt(payload, key) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data;
}

// node_modules/@walletconnect/client/dist/esm/index.js
var WalletConnect = class extends esm_default2 {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib: esm_exports4,
      connectorOpts,
      pushServerOpts
    });
  }
};
var esm_default3 = WalletConnect;

// node_modules/preact/dist/preact.module.js
var n, l, u, i, t, r, o, f, e = {}, c = [], s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function a(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function v(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function h(n2, l3, u3) {
  var i3, t3 = arguments, r3 = {};
  for (i3 in l3)
    i3 !== "key" && i3 !== "ref" && (r3[i3] = l3[i3]);
  if (arguments.length > 3)
    for (u3 = [u3], i3 = 3; i3 < arguments.length; i3++)
      u3.push(t3[i3]);
  if (u3 != null && (r3.children = u3), typeof n2 == "function" && n2.defaultProps != null)
    for (i3 in n2.defaultProps)
      r3[i3] === void 0 && (r3[i3] = n2.defaultProps[i3]);
  return p(n2, r3, l3 && l3.key, l3 && l3.ref, null);
}
function p(l3, u3, i3, t3, r3) {
  var o3 = { type: l3, props: u3, key: i3, ref: t3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r3 };
  return r3 == null && (o3.__v = o3), n.vnode && n.vnode(o3), o3;
}
function y() {
  return {};
}
function d(n2) {
  return n2.children;
}
function m(n2, l3) {
  this.props = n2, this.context = l3;
}
function w(n2, l3) {
  if (l3 == null)
    return n2.__ ? w(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if ((u3 = n2.__k[l3]) != null && u3.__e != null)
      return u3.__e;
  return typeof n2.type == "function" ? w(n2) : null;
}
function k(n2) {
  var l3, u3;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if ((u3 = n2.__k[l3]) != null && u3.__e != null) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return k(n2);
  }
}
function g(l3) {
  (!l3.__d && (l3.__d = true) && u.push(l3) && !i++ || r !== n.debounceRendering) && ((r = n.debounceRendering) || t)(_);
}
function _() {
  for (var n2; i = u.length; )
    n2 = u.sort(function(n3, l3) {
      return n3.__v.__b - l3.__v.__b;
    }), u = [], n2.some(function(n3) {
      var l3, u3, i3, t3, r3, o3, f3;
      n3.__d && (o3 = (r3 = (l3 = n3).__v).__e, (f3 = l3.__P) && (u3 = [], (i3 = a({}, r3)).__v = i3, t3 = A(f3, r3, i3, l3.__n, f3.ownerSVGElement !== void 0, null, u3, o3 == null ? w(r3) : o3), T(u3, r3), t3 != o3 && k(r3)));
    });
}
function b(n2, l3, u3, i3, t3, r3, o3, f3, s3) {
  var a3, h3, p3, y3, d3, m3, k3, g3 = u3 && u3.__k || c, _4 = g3.length;
  if (f3 == e && (f3 = r3 != null ? r3[0] : _4 ? w(u3, 0) : null), a3 = 0, l3.__k = x(l3.__k, function(u4) {
    if (u4 != null) {
      if (u4.__ = l3, u4.__b = l3.__b + 1, (p3 = g3[a3]) === null || p3 && u4.key == p3.key && u4.type === p3.type)
        g3[a3] = void 0;
      else
        for (h3 = 0; h3 < _4; h3++) {
          if ((p3 = g3[h3]) && u4.key == p3.key && u4.type === p3.type) {
            g3[h3] = void 0;
            break;
          }
          p3 = null;
        }
      if (y3 = A(n2, u4, p3 = p3 || e, i3, t3, r3, o3, f3, s3), (h3 = u4.ref) && p3.ref != h3 && (k3 || (k3 = []), p3.ref && k3.push(p3.ref, null, u4), k3.push(h3, u4.__c || y3, u4)), y3 != null) {
        var c3;
        if (m3 == null && (m3 = y3), u4.__d !== void 0)
          c3 = u4.__d, u4.__d = void 0;
        else if (r3 == p3 || y3 != f3 || y3.parentNode == null) {
          n:
            if (f3 == null || f3.parentNode !== n2)
              n2.appendChild(y3), c3 = null;
            else {
              for (d3 = f3, h3 = 0; (d3 = d3.nextSibling) && h3 < _4; h3 += 2)
                if (d3 == y3)
                  break n;
              n2.insertBefore(y3, f3), c3 = f3;
            }
          l3.type == "option" && (n2.value = "");
        }
        f3 = c3 !== void 0 ? c3 : y3.nextSibling, typeof l3.type == "function" && (l3.__d = f3);
      } else
        f3 && p3.__e == f3 && f3.parentNode != n2 && (f3 = w(p3));
    }
    return a3++, u4;
  }), l3.__e = m3, r3 != null && typeof l3.type != "function")
    for (a3 = r3.length; a3--; )
      r3[a3] != null && v(r3[a3]);
  for (a3 = _4; a3--; )
    g3[a3] != null && D(g3[a3], g3[a3]);
  if (k3)
    for (a3 = 0; a3 < k3.length; a3++)
      j(k3[a3], k3[++a3], k3[++a3]);
}
function x(n2, l3, u3) {
  if (u3 == null && (u3 = []), n2 == null || typeof n2 == "boolean")
    l3 && u3.push(l3(null));
  else if (Array.isArray(n2))
    for (var i3 = 0; i3 < n2.length; i3++)
      x(n2[i3], l3, u3);
  else
    u3.push(l3 ? l3(typeof n2 == "string" || typeof n2 == "number" ? p(null, n2, null, null, n2) : n2.__e != null || n2.__c != null ? p(n2.type, n2.props, n2.key, null, n2.__v) : n2) : n2);
  return u3;
}
function P(n2, l3, u3, i3, t3) {
  var r3;
  for (r3 in u3)
    r3 === "children" || r3 === "key" || r3 in l3 || N(n2, r3, null, u3[r3], i3);
  for (r3 in l3)
    t3 && typeof l3[r3] != "function" || r3 === "children" || r3 === "key" || r3 === "value" || r3 === "checked" || u3[r3] === l3[r3] || N(n2, r3, l3[r3], u3[r3], i3);
}
function C(n2, l3, u3) {
  l3[0] === "-" ? n2.setProperty(l3, u3) : n2[l3] = typeof u3 == "number" && s.test(l3) === false ? u3 + "px" : u3 == null ? "" : u3;
}
function N(n2, l3, u3, i3, t3) {
  var r3, o3, f3, e3, c3;
  if (t3 ? l3 === "className" && (l3 = "class") : l3 === "class" && (l3 = "className"), l3 === "style")
    if (r3 = n2.style, typeof u3 == "string")
      r3.cssText = u3;
    else {
      if (typeof i3 == "string" && (r3.cssText = "", i3 = null), i3)
        for (e3 in i3)
          u3 && e3 in u3 || C(r3, e3, "");
      if (u3)
        for (c3 in u3)
          i3 && u3[c3] === i3[c3] || C(r3, c3, u3[c3]);
    }
  else
    l3[0] === "o" && l3[1] === "n" ? (o3 = l3 !== (l3 = l3.replace(/Capture$/, "")), f3 = l3.toLowerCase(), l3 = (f3 in n2 ? f3 : l3).slice(2), u3 ? (i3 || n2.addEventListener(l3, z, o3), (n2.l || (n2.l = {}))[l3] = u3) : n2.removeEventListener(l3, z, o3)) : l3 !== "list" && l3 !== "tagName" && l3 !== "form" && l3 !== "type" && l3 !== "size" && !t3 && l3 in n2 ? n2[l3] = u3 == null ? "" : u3 : typeof u3 != "function" && l3 !== "dangerouslySetInnerHTML" && (l3 !== (l3 = l3.replace(/^xlink:?/, "")) ? u3 == null || u3 === false ? n2.removeAttributeNS("http://www.w3.org/1999/xlink", l3.toLowerCase()) : n2.setAttributeNS("http://www.w3.org/1999/xlink", l3.toLowerCase(), u3) : u3 == null || u3 === false && !/^ar/.test(l3) ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
}
function z(l3) {
  this.l[l3.type](n.event ? n.event(l3) : l3);
}
function A(l3, u3, i3, t3, r3, o3, f3, e3, c3) {
  var s3, v3, h3, p3, y3, w4, k3, g3, _4, x3, P3 = u3.type;
  if (u3.constructor !== void 0)
    return null;
  (s3 = n.__b) && s3(u3);
  try {
    n:
      if (typeof P3 == "function") {
        if (g3 = u3.props, _4 = (s3 = P3.contextType) && t3[s3.__c], x3 = s3 ? _4 ? _4.props.value : s3.__ : t3, i3.__c ? k3 = (v3 = u3.__c = i3.__c).__ = v3.__E : ("prototype" in P3 && P3.prototype.render ? u3.__c = v3 = new P3(g3, x3) : (u3.__c = v3 = new m(g3, x3), v3.constructor = P3, v3.render = E), _4 && _4.sub(v3), v3.props = g3, v3.state || (v3.state = {}), v3.context = x3, v3.__n = t3, h3 = v3.__d = true, v3.__h = []), v3.__s == null && (v3.__s = v3.state), P3.getDerivedStateFromProps != null && (v3.__s == v3.state && (v3.__s = a({}, v3.__s)), a(v3.__s, P3.getDerivedStateFromProps(g3, v3.__s))), p3 = v3.props, y3 = v3.state, h3)
          P3.getDerivedStateFromProps == null && v3.componentWillMount != null && v3.componentWillMount(), v3.componentDidMount != null && v3.__h.push(v3.componentDidMount);
        else {
          if (P3.getDerivedStateFromProps == null && g3 !== p3 && v3.componentWillReceiveProps != null && v3.componentWillReceiveProps(g3, x3), !v3.__e && v3.shouldComponentUpdate != null && v3.shouldComponentUpdate(g3, v3.__s, x3) === false || u3.__v === i3.__v && !v3.__) {
            for (v3.props = g3, v3.state = v3.__s, u3.__v !== i3.__v && (v3.__d = false), v3.__v = u3, u3.__e = i3.__e, u3.__k = i3.__k, v3.__h.length && f3.push(v3), s3 = 0; s3 < u3.__k.length; s3++)
              u3.__k[s3] && (u3.__k[s3].__ = u3);
            break n;
          }
          v3.componentWillUpdate != null && v3.componentWillUpdate(g3, v3.__s, x3), v3.componentDidUpdate != null && v3.__h.push(function() {
            v3.componentDidUpdate(p3, y3, w4);
          });
        }
        v3.context = x3, v3.props = g3, v3.state = v3.__s, (s3 = n.__r) && s3(u3), v3.__d = false, v3.__v = u3, v3.__P = l3, s3 = v3.render(v3.props, v3.state, v3.context), u3.__k = s3 != null && s3.type == d && s3.key == null ? s3.props.children : Array.isArray(s3) ? s3 : [s3], v3.getChildContext != null && (t3 = a(a({}, t3), v3.getChildContext())), h3 || v3.getSnapshotBeforeUpdate == null || (w4 = v3.getSnapshotBeforeUpdate(p3, y3)), b(l3, u3, i3, t3, r3, o3, f3, e3, c3), v3.base = u3.__e, v3.__h.length && f3.push(v3), k3 && (v3.__E = v3.__ = null), v3.__e = false;
      } else
        o3 == null && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = $(i3.__e, u3, i3, t3, r3, o3, f3, c3);
    (s3 = n.diffed) && s3(u3);
  } catch (l4) {
    u3.__v = null, n.__e(l4, u3, i3);
  }
  return u3.__e;
}
function T(l3, u3) {
  n.__c && n.__c(u3, l3), l3.some(function(u4) {
    try {
      l3 = u4.__h, u4.__h = [], l3.some(function(n2) {
        n2.call(u4);
      });
    } catch (l4) {
      n.__e(l4, u4.__v);
    }
  });
}
function $(n2, l3, u3, i3, t3, r3, o3, f3) {
  var s3, a3, v3, h3, p3, y3 = u3.props, d3 = l3.props;
  if (t3 = l3.type === "svg" || t3, r3 != null) {
    for (s3 = 0; s3 < r3.length; s3++)
      if ((a3 = r3[s3]) != null && ((l3.type === null ? a3.nodeType === 3 : a3.localName === l3.type) || n2 == a3)) {
        n2 = a3, r3[s3] = null;
        break;
      }
  }
  if (n2 == null) {
    if (l3.type === null)
      return document.createTextNode(d3);
    n2 = t3 ? document.createElementNS("http://www.w3.org/2000/svg", l3.type) : document.createElement(l3.type, d3.is && { is: d3.is }), r3 = null, f3 = false;
  }
  if (l3.type === null)
    y3 !== d3 && n2.data != d3 && (n2.data = d3);
  else {
    if (r3 != null && (r3 = c.slice.call(n2.childNodes)), v3 = (y3 = u3.props || e).dangerouslySetInnerHTML, h3 = d3.dangerouslySetInnerHTML, !f3) {
      if (y3 === e)
        for (y3 = {}, p3 = 0; p3 < n2.attributes.length; p3++)
          y3[n2.attributes[p3].name] = n2.attributes[p3].value;
      (h3 || v3) && (h3 && v3 && h3.__html == v3.__html || (n2.innerHTML = h3 && h3.__html || ""));
    }
    P(n2, d3, y3, t3, f3), h3 ? l3.__k = [] : (l3.__k = l3.props.children, b(n2, l3, u3, i3, l3.type !== "foreignObject" && t3, r3, o3, e, f3)), f3 || ("value" in d3 && (s3 = d3.value) !== void 0 && s3 !== n2.value && N(n2, "value", s3, y3.value, false), "checked" in d3 && (s3 = d3.checked) !== void 0 && s3 !== n2.checked && N(n2, "checked", s3, y3.checked, false));
  }
  return n2;
}
function j(l3, u3, i3) {
  try {
    typeof l3 == "function" ? l3(u3) : l3.current = u3;
  } catch (l4) {
    n.__e(l4, i3);
  }
}
function D(l3, u3, i3) {
  var t3, r3, o3;
  if (n.unmount && n.unmount(l3), (t3 = l3.ref) && (t3.current && t3.current !== l3.__e || j(t3, null, u3)), i3 || typeof l3.type == "function" || (i3 = (r3 = l3.__e) != null), l3.__e = l3.__d = void 0, (t3 = l3.__c) != null) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (l4) {
        n.__e(l4, u3);
      }
    t3.base = t3.__P = null;
  }
  if (t3 = l3.__k)
    for (o3 = 0; o3 < t3.length; o3++)
      t3[o3] && D(t3[o3], u3, i3);
  r3 != null && v(r3);
}
function E(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function H(l3, u3, i3) {
  var t3, r3, f3;
  n.__ && n.__(l3, u3), r3 = (t3 = i3 === o) ? null : i3 && i3.__k || u3.__k, l3 = h(d, null, [l3]), f3 = [], A(u3, (t3 ? u3 : i3 || u3).__k = l3, r3 || e, e, u3.ownerSVGElement !== void 0, i3 && !t3 ? [i3] : r3 ? null : c.slice.call(u3.childNodes), f3, i3 || e, t3), T(f3, l3);
}
function I(n2, l3) {
  H(n2, l3, o);
}
function L(n2, l3) {
  var u3, i3;
  for (i3 in l3 = a(a({}, n2.props), l3), arguments.length > 2 && (l3.children = c.slice.call(arguments, 2)), u3 = {}, l3)
    i3 !== "key" && i3 !== "ref" && (u3[i3] = l3[i3]);
  return p(n2.type, u3, l3.key || n2.key, l3.ref || n2.ref, null);
}
function M(n2) {
  var l3 = {}, u3 = { __c: "__cC" + f++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var i3, t3 = this;
    return this.getChildContext || (i3 = [], this.getChildContext = function() {
      return l3[u3.__c] = t3, l3;
    }, this.shouldComponentUpdate = function(n4) {
      t3.props.value !== n4.value && i3.some(function(l4) {
        l4.context = n4.value, g(l4);
      });
    }, this.sub = function(n4) {
      i3.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        i3.splice(i3.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Consumer.contextType = u3, u3.Provider.__ = u3, u3;
}
n = { __e: function(n2, l3) {
  for (var u3, i3; l3 = l3.__; )
    if ((u3 = l3.__c) && !u3.__)
      try {
        if (u3.constructor && u3.constructor.getDerivedStateFromError != null && (i3 = true, u3.setState(u3.constructor.getDerivedStateFromError(n2))), u3.componentDidCatch != null && (i3 = true, u3.componentDidCatch(n2)), i3)
          return g(u3.__E = u3);
      } catch (l4) {
        n2 = l4;
      }
  throw n2;
} }, l = function(n2) {
  return n2 != null && n2.constructor === void 0;
}, m.prototype.setState = function(n2, l3) {
  var u3;
  u3 = this.__s !== this.state ? this.__s : this.__s = a({}, this.state), typeof n2 == "function" && (n2 = n2(u3, this.props)), n2 && a(u3, n2), n2 != null && this.__v && (l3 && this.__h.push(l3), g(this));
}, m.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), g(this));
}, m.prototype.render = d, u = [], i = 0, t = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o = e, f = 0;

// node_modules/preact/hooks/dist/hooks.module.js
var t2, u2, r2, i2 = 0, o2 = [], c2 = n.__r, f2 = n.diffed, e2 = n.__c, a2 = n.unmount;
function v2(t3, r3) {
  n.__h && n.__h(u2, t3, i2 || r3), i2 = 0;
  var o3 = u2.__H || (u2.__H = { __: [], __h: [] });
  return t3 >= o3.__.length && o3.__.push({}), o3.__[t3];
}
function m2(n2) {
  return i2 = 1, p2(E2, n2);
}
function p2(n2, r3, i3) {
  var o3 = v2(t2++, 2);
  return o3.__c || (o3.__c = u2, o3.__ = [i3 ? i3(r3) : E2(void 0, r3), function(t3) {
    var u3 = n2(o3.__[0], t3);
    o3.__[0] !== u3 && (o3.__[0] = u3, o3.__c.setState({}));
  }]), o3.__;
}
function l2(r3, i3) {
  var o3 = v2(t2++, 3);
  !n.__s && x2(o3.__H, i3) && (o3.__ = r3, o3.__H = i3, u2.__H.__h.push(o3));
}
function y2(r3, i3) {
  var o3 = v2(t2++, 4);
  !n.__s && x2(o3.__H, i3) && (o3.__ = r3, o3.__H = i3, u2.__h.push(o3));
}
function d2(n2) {
  return i2 = 5, h2(function() {
    return { current: n2 };
  }, []);
}
function s2(n2, t3, u3) {
  i2 = 6, y2(function() {
    typeof n2 == "function" ? n2(t3()) : n2 && (n2.current = t3());
  }, u3 == null ? u3 : u3.concat(n2));
}
function h2(n2, u3) {
  var r3 = v2(t2++, 7);
  return x2(r3.__H, u3) ? (r3.__H = u3, r3.__h = n2, r3.__ = n2()) : r3.__;
}
function T2(n2, t3) {
  return i2 = 8, h2(function() {
    return n2;
  }, t3);
}
function w2(n2) {
  var r3 = u2.context[n2.__c], i3 = v2(t2++, 9);
  return i3.__c = n2, r3 ? (i3.__ == null && (i3.__ = true, r3.sub(u2)), r3.props.value) : n2.__;
}
function A2(t3, u3) {
  n.useDebugValue && n.useDebugValue(u3 ? u3(t3) : t3);
}
function F(n2) {
  var r3 = v2(t2++, 10), i3 = m2();
  return r3.__ = n2, u2.componentDidCatch || (u2.componentDidCatch = function(n3) {
    r3.__ && r3.__(n3), i3[1](n3);
  }), [i3[0], function() {
    i3[1](void 0);
  }];
}
function _2() {
  o2.some(function(t3) {
    if (t3.__P)
      try {
        t3.__H.__h.forEach(g2), t3.__H.__h.forEach(q), t3.__H.__h = [];
      } catch (u3) {
        return t3.__H.__h = [], n.__e(u3, t3.__v), true;
      }
  }), o2 = [];
}
function g2(n2) {
  n2.t && n2.t();
}
function q(n2) {
  var t3 = n2.__();
  typeof t3 == "function" && (n2.t = t3);
}
function x2(n2, t3) {
  return !n2 || t3.some(function(t4, u3) {
    return t4 !== n2[u3];
  });
}
function E2(n2, t3) {
  return typeof t3 == "function" ? t3(n2) : t3;
}
n.__r = function(n2) {
  c2 && c2(n2), t2 = 0, (u2 = n2.__c).__H && (u2.__H.__h.forEach(g2), u2.__H.__h.forEach(q), u2.__H.__h = []);
}, n.diffed = function(t3) {
  f2 && f2(t3);
  var u3 = t3.__c;
  if (u3) {
    var i3 = u3.__H;
    i3 && i3.__h.length && (o2.push(u3) !== 1 && r2 === n.requestAnimationFrame || ((r2 = n.requestAnimationFrame) || function(n2) {
      var t4, u4 = function() {
        clearTimeout(r3), cancelAnimationFrame(t4), setTimeout(n2);
      }, r3 = setTimeout(u4, 100);
      typeof window != "undefined" && (t4 = requestAnimationFrame(u4));
    })(_2));
  }
}, n.__c = function(t3, u3) {
  u3.some(function(t4) {
    try {
      t4.__h.forEach(g2), t4.__h = t4.__h.filter(function(n2) {
        return !n2.__ || q(n2);
      });
    } catch (r3) {
      u3.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), u3 = [], n.__e(r3, t4.__v);
    }
  }), e2 && e2(t3, u3);
}, n.unmount = function(t3) {
  a2 && a2(t3);
  var u3 = t3.__c;
  if (u3) {
    var r3 = u3.__H;
    if (r3)
      try {
        r3.__.forEach(function(n2) {
          return n2.t && n2.t();
        });
      } catch (t4) {
        n.__e(t4, u3.__v);
      }
  }
};

// node_modules/preact/compat/dist/compat.module.js
function E3(n2, t3) {
  for (var e3 in t3)
    n2[e3] = t3[e3];
  return n2;
}
function w3(n2, t3) {
  for (var e3 in n2)
    if (e3 !== "__source" && !(e3 in t3))
      return true;
  for (var r3 in t3)
    if (r3 !== "__source" && n2[r3] !== t3[r3])
      return true;
  return false;
}
var C2 = function(n2) {
  var t3, e3;
  function r3(t4) {
    var e4;
    return (e4 = n2.call(this, t4) || this).isPureReactComponent = true, e4;
  }
  return e3 = n2, (t3 = r3).prototype = Object.create(e3.prototype), t3.prototype.constructor = t3, t3.__proto__ = e3, r3.prototype.shouldComponentUpdate = function(n3, t4) {
    return w3(this.props, n3) || w3(this.state, t4);
  }, r3;
}(m);
function _3(n2, t3) {
  function e3(n3) {
    var e4 = this.props.ref, r4 = e4 == n3.ref;
    return !r4 && e4 && (e4.call ? e4(null) : e4.current = null), t3 ? !t3(this.props, n3) || !r4 : w3(this.props, n3);
  }
  function r3(t4) {
    return this.shouldComponentUpdate = e3, h(n2, E3({}, t4));
  }
  return r3.prototype.isReactComponent = true, r3.displayName = "Memo(" + (n2.displayName || n2.name) + ")", r3.t = true, r3;
}
var A3 = n.__b;
function S(n2) {
  function t3(t4) {
    var e3 = E3({}, t4);
    return delete e3.ref, n2(e3, t4.ref);
  }
  return t3.prototype.isReactComponent = t3.t = true, t3.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t3;
}
n.__b = function(n2) {
  n2.type && n2.type.t && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), A3 && A3(n2);
};
var k2 = function(n2, t3) {
  return n2 ? x(n2).reduce(function(n3, e3, r3) {
    return n3.concat(t3(e3, r3));
  }, []) : null;
}, R = { map: k2, forEach: k2, count: function(n2) {
  return n2 ? x(n2).length : 0;
}, only: function(n2) {
  if ((n2 = x(n2)).length !== 1)
    throw new Error("Children.only() expects only one child.");
  return n2[0];
}, toArray: x }, F2 = n.__e;
function N2(n2) {
  return n2 && ((n2 = E3({}, n2)).__c = null, n2.__k = n2.__k && n2.__k.map(N2)), n2;
}
function U() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M2(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.u && t3.u(n2);
}
function L2(n2) {
  var t3, e3, r3;
  function o3(o4) {
    if (t3 || (t3 = n2()).then(function(n3) {
      e3 = n3.default || n3;
    }, function(n3) {
      r3 = n3;
    }), r3)
      throw r3;
    if (!e3)
      throw t3;
    return h(e3, o4);
  }
  return o3.displayName = "Lazy", o3.t = true, o3;
}
function O() {
  this.i = null, this.l = null;
}
n.__e = function(n2, t3, e3) {
  if (n2.then) {
    for (var r3, o3 = t3; o3 = o3.__; )
      if ((r3 = o3.__c) && r3.__c)
        return r3.__c(n2, t3.__c);
  }
  F2(n2, t3, e3);
}, (U.prototype = new m()).__c = function(n2, t3) {
  var e3 = this;
  e3.o == null && (e3.o = []), e3.o.push(t3);
  var r3 = M2(e3.__v), o3 = false, u3 = function() {
    o3 || (o3 = true, r3 ? r3(i3) : i3());
  };
  t3.__c = t3.componentWillUnmount, t3.componentWillUnmount = function() {
    u3(), t3.__c && t3.__c();
  };
  var i3 = function() {
    var n3;
    if (!--e3.__u)
      for (e3.__v.__k[0] = e3.state.u, e3.setState({ u: e3.__b = null }); n3 = e3.o.pop(); )
        n3.forceUpdate();
  };
  e3.__u++ || e3.setState({ u: e3.__b = e3.__v.__k[0] }), n2.then(u3, u3);
}, U.prototype.render = function(n2, t3) {
  return this.__b && (this.__v.__k[0] = N2(this.__b), this.__b = null), [h(m, null, t3.u ? null : n2.children), t3.u && n2.fallback];
};
var P2 = function(n2, t3, e3) {
  if (++e3[1] === e3[0] && n2.l.delete(t3), n2.props.revealOrder && (n2.props.revealOrder[0] !== "t" || !n2.l.size))
    for (e3 = n2.i; e3; ) {
      for (; e3.length > 3; )
        e3.pop()();
      if (e3[1] < e3[0])
        break;
      n2.i = e3 = e3[2];
    }
};
(O.prototype = new m()).u = function(n2) {
  var t3 = this, e3 = M2(t3.__v), r3 = t3.l.get(n2);
  return r3[0]++, function(o3) {
    var u3 = function() {
      t3.props.revealOrder ? (r3.push(o3), P2(t3, n2, r3)) : o3();
    };
    e3 ? e3(u3) : u3();
  };
}, O.prototype.render = function(n2) {
  this.i = null, this.l = /* @__PURE__ */ new Map();
  var t3 = x(n2.children);
  n2.revealOrder && n2.revealOrder[0] === "b" && t3.reverse();
  for (var e3 = t3.length; e3--; )
    this.l.set(t3[e3], this.i = [1, 0, this.i]);
  return n2.children;
}, O.prototype.componentDidUpdate = O.prototype.componentDidMount = function() {
  var n2 = this;
  n2.l.forEach(function(t3, e3) {
    P2(n2, e3, t3);
  });
};
var W = function() {
  function n2() {
  }
  var t3 = n2.prototype;
  return t3.getChildContext = function() {
    return this.props.context;
  }, t3.render = function(n3) {
    return n3.children;
  }, n2;
}();
function j2(n2) {
  var t3 = this, e3 = n2.container, r3 = h(W, { context: t3.context }, n2.vnode);
  return t3.s && t3.s !== e3 && (t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h), t3.p = false), n2.vnode ? t3.p ? (e3.__k = t3.__k, H(r3, e3), t3.__k = e3.__k) : (t3.v = document.createTextNode(""), I("", e3), e3.appendChild(t3.v), t3.p = true, t3.s = e3, H(r3, e3, t3.v), t3.__k = t3.v.__k) : t3.p && (t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h)), t3.h = r3, t3.componentWillUnmount = function() {
    t3.v.parentNode && t3.s.removeChild(t3.v), D(t3.h);
  }, null;
}
function z2(n2, t3) {
  return h(j2, { vnode: n2, container: t3 });
}
var D2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
m.prototype.isReactComponent = {};
var H2 = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.element") || 60103;
function T3(n2, t3, e3) {
  if (t3.__k == null)
    for (; t3.firstChild; )
      t3.removeChild(t3.firstChild);
  return H(n2, t3), typeof e3 == "function" && e3(), n2 ? n2.__c : null;
}
function V(n2, t3, e3) {
  return I(n2, t3), typeof e3 == "function" && e3(), n2 ? n2.__c : null;
}
var Z = n.event;
function I2(n2, t3) {
  n2["UNSAFE_" + t3] && !n2[t3] && Object.defineProperty(n2, t3, { configurable: false, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n3) {
    this["UNSAFE_" + t3] = n3;
  } });
}
n.event = function(n2) {
  Z && (n2 = Z(n2)), n2.persist = function() {
  };
  var t3 = false, e3 = false, r3 = n2.stopPropagation;
  n2.stopPropagation = function() {
    r3.call(n2), t3 = true;
  };
  var o3 = n2.preventDefault;
  return n2.preventDefault = function() {
    o3.call(n2), e3 = true;
  }, n2.isPropagationStopped = function() {
    return t3;
  }, n2.isDefaultPrevented = function() {
    return e3;
  }, n2.nativeEvent = n2;
};
var $2 = { configurable: true, get: function() {
  return this.class;
} }, q2 = n.vnode;
n.vnode = function(n2) {
  n2.$$typeof = H2;
  var t3 = n2.type, e3 = n2.props;
  if (t3) {
    if (e3.class != e3.className && ($2.enumerable = "className" in e3, e3.className != null && (e3.class = e3.className), Object.defineProperty(e3, "className", $2)), typeof t3 != "function") {
      var r3, o3, u3;
      for (u3 in e3.defaultValue && e3.value !== void 0 && (e3.value || e3.value === 0 || (e3.value = e3.defaultValue), delete e3.defaultValue), Array.isArray(e3.value) && e3.multiple && t3 === "select" && (x(e3.children).forEach(function(n3) {
        e3.value.indexOf(n3.props.value) != -1 && (n3.props.selected = true);
      }), delete e3.value), e3)
        if (r3 = D2.test(u3))
          break;
      if (r3)
        for (u3 in o3 = n2.props = {}, e3)
          o3[D2.test(u3) ? u3.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u3] = e3[u3];
    }
    !function(t4) {
      var e4 = n2.type, r4 = n2.props;
      if (r4 && typeof e4 == "string") {
        var o4 = {};
        for (var u4 in r4)
          /^on(Ani|Tra|Tou)/.test(u4) && (r4[u4.toLowerCase()] = r4[u4], delete r4[u4]), o4[u4.toLowerCase()] = u4;
        if (o4.ondoubleclick && (r4.ondblclick = r4[o4.ondoubleclick], delete r4[o4.ondoubleclick]), o4.onbeforeinput && (r4.onbeforeinput = r4[o4.onbeforeinput], delete r4[o4.onbeforeinput]), o4.onchange && (e4 === "textarea" || e4.toLowerCase() === "input" && !/^fil|che|ra/i.test(r4.type))) {
          var i3 = o4.oninput || "oninput";
          r4[i3] || (r4[i3] = r4[o4.onchange], delete r4[o4.onchange]);
        }
      }
    }(), typeof t3 == "function" && !t3.m && t3.prototype && (I2(t3.prototype, "componentWillMount"), I2(t3.prototype, "componentWillReceiveProps"), I2(t3.prototype, "componentWillUpdate"), t3.m = true);
  }
  q2 && q2(n2);
};
var B = "16.8.0";
function G(n2) {
  return h.bind(null, n2);
}
function J(n2) {
  return !!n2 && n2.$$typeof === H2;
}
function K2(n2) {
  return J(n2) ? L.apply(null, arguments) : n2;
}
function Q(n2) {
  return !!n2.__k && (H(null, n2), true);
}
function X(n2) {
  return n2 && (n2.base || n2.nodeType === 1 && n2) || null;
}
var Y = function(n2, t3) {
  return n2(t3);
};
var compat_module_default = { useState: m2, useReducer: p2, useEffect: l2, useLayoutEffect: y2, useRef: d2, useImperativeHandle: s2, useMemo: h2, useCallback: T2, useContext: w2, useDebugValue: A2, version: "16.8.0", Children: R, render: T3, hydrate: T3, unmountComponentAtNode: Q, createPortal: z2, createElement: h, createContext: M, createFactory: G, cloneElement: K2, createRef: y, Fragment: d, isValidElement: J, findDOMNode: X, Component: m, PureComponent: C2, memo: _3, forwardRef: S, unstable_batchedUpdates: Y, Suspense: U, SuspenseList: O, lazy: L2 };

// node_modules/algo-wc-qr-modal-ncc/dist/esm/index.js
var import_qrcode = __toESM(require_browser2());
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
function open(e3) {
  import_qrcode.default.toString(e3, { type: "terminal" }).then(console.log);
}
var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
var _iteratorSymbol = typeof Symbol != "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator", _asyncIteratorSymbol = typeof Symbol != "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(e3, n2) {
  try {
    var t3 = e3();
  } catch (e4) {
    return n2(e4);
  }
  return t3 && t3.then ? t3.then(void 0, n2) : t3;
}
var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E", WALLETCONNECT_HEADER_TEXT = "WalletConnect", ANIMATION_DURATION = 300, DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)", WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper", WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet", WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal", WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close", WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text", WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
function Header(e3) {
  return h("div", { className: "walletconnect-modal__header" }, h("img", { src: WALLETCONNECT_LOGO_SVG_URL, className: "walletconnect-modal__headerLogo" }), h("p", null, WALLETCONNECT_HEADER_TEXT), h("div", { className: "walletconnect-modal__close__wrapper", onClick: e3.onClose }, h("div", { id: WALLETCONNECT_CLOSE_BUTTON_ID, className: "walletconnect-modal__close__icon" }, h("div", { className: "walletconnect-modal__close__line1" }), h("div", { className: "walletconnect-modal__close__line2" }))));
}
function ConnectButton(e3) {
  return h("a", { className: "walletconnect-connect__button", href: e3.href, id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + e3.name, onClick: e3.onClick, rel: "noopener noreferrer", style: { backgroundColor: e3.color }, target: "_blank" }, e3.name);
}
var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
function WalletButton(e3) {
  var n2 = e3.color, t3 = e3.logo;
  return h("a", { className: "walletconnect-modal__base__row", href: e3.href, onClick: e3.onClick, rel: "noopener noreferrer", target: "_blank" }, h("h3", { className: "walletconnect-modal__base__row__h3" }, e3.name), h("div", { className: "walletconnect-modal__base__row__right" }, h("div", { className: "walletconnect-modal__base__row__right__app-icon", style: { background: "url('" + t3 + "') " + n2, backgroundSize: "100%" } }), h("img", { src: CARET_SVG_URL, className: "walletconnect-modal__base__row__right__caret" })));
}
function WalletIcon(e3) {
  var n2 = e3.name, t3 = window.innerWidth < 768 ? (n2.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
  return h("a", { className: "walletconnect-connect__button__icon_anchor", href: e3.href, onClick: e3.onClick, rel: "noopener noreferrer", target: "_blank" }, h("div", { className: "walletconnect-connect__button__icon", style: { background: "url('" + e3.logo + "') " + e3.color, backgroundSize: "100%" } }), h("div", { style: { fontSize: t3 }, className: "walletconnect-connect__button__text" }, n2));
}
var GRID_MIN_COUNT = 5, LINKS_PER_PAGE = 12;
function LinkDisplay(e3) {
  var n2 = isAndroid(), t3 = m2(""), o3 = t3[0], a3 = t3[1], l3 = m2(""), r3 = l3[0], i3 = l3[1], c3 = m2(1), s3 = c3[0], d3 = c3[1], _4 = r3 ? e3.links.filter(function(e4) {
    return e4.name.toLowerCase().includes(r3.toLowerCase());
  }) : e3.links, m3 = e3.errorMessage, p3 = r3 || _4.length > GRID_MIN_COUNT, g3 = Math.ceil(_4.length / LINKS_PER_PAGE), w4 = [(s3 - 1) * LINKS_PER_PAGE + 1, s3 * LINKS_PER_PAGE], u3 = _4.length ? _4.filter(function(e4, n3) {
    return n3 + 1 >= w4[0] && n3 + 1 <= w4[1];
  }) : [], f3 = !(n2 || !(g3 > 1)), h3 = void 0;
  return h("div", null, h("p", { id: WALLETCONNECT_CTA_TEXT_ID, className: "walletconnect-qrcode__text" }, n2 ? e3.text.connect_mobile_wallet : e3.text.choose_preferred_wallet), !n2 && h("input", { className: "walletconnect-search__input", placeholder: "Search", value: o3, onChange: function(e4) {
    a3(e4.target.value), clearTimeout(h3), e4.target.value ? h3 = setTimeout(function() {
      i3(e4.target.value), d3(1);
    }, 1e3) : (a3(""), i3(""), d3(1));
  } }), h("div", { className: "walletconnect-connect__buttons__wrapper" + (n2 ? "__android" : p3 && _4.length ? "__wrap" : "") }, n2 ? h(ConnectButton, { name: e3.text.connect, color: DEFAULT_BUTTON_COLOR, href: e3.uri, onClick: T2(function() {
    saveMobileLinkInfo({ name: "Unknown", href: e3.uri });
  }, []) }) : u3.length ? u3.map(function(n3) {
    var t4 = n3.color, o4 = n3.name, a4 = n3.shortName, l4 = n3.logo, r4 = formatIOSMobile(e3.uri, n3), i4 = T2(function() {
      saveMobileLinkInfo({ name: o4, href: r4 });
    }, [u3]);
    return p3 ? h(WalletIcon, { color: t4, href: r4, name: a4 || o4, logo: l4, onClick: i4 }) : h(WalletButton, { color: t4, href: r4, name: o4, logo: l4, onClick: i4 });
  }) : h(d, null, h("p", null, m3.length ? e3.errorMessage : e3.links.length && !_4.length ? e3.text.no_wallets_found : e3.text.loading))), f3 && h("div", { className: "walletconnect-modal__footer" }, Array(g3).fill(0).map(function(e4, n3) {
    var t4 = n3 + 1;
    return h("a", { style: { margin: "auto 10px", fontWeight: s3 === t4 ? "bold" : "normal" }, onClick: function() {
      return d3(t4);
    } }, t4);
  })));
}
function Notification(e3) {
  var n2 = !!e3.message.trim();
  return h("div", { className: "walletconnect-qrcode__notification" + (n2 ? " notification__show" : "") }, e3.message);
}
var formatQRCodeImage = function(e3) {
  try {
    var n2 = "";
    return Promise.resolve(import_qrcode.default.toString(e3, { margin: 0, type: "svg" })).then(function(e4) {
      return typeof e4 == "string" && (n2 = e4.replace("<svg", '<svg class="walletconnect-qrcode__image"')), n2;
    });
  } catch (e4) {
    return Promise.reject(e4);
  }
};
function QRCodeDisplay(e3) {
  var n2 = m2(""), t3 = n2[0], o3 = n2[1], a3 = m2(""), l3 = a3[0], r3 = a3[1];
  return l2(function() {
    try {
      return Promise.resolve(formatQRCodeImage(e3.uri)).then(function(e4) {
        r3(e4);
      });
    } catch (e4) {
      Promise.reject(e4);
    }
  }, []), h("div", null, h("p", { id: WALLETCONNECT_CTA_TEXT_ID, className: "walletconnect-qrcode__text" }, e3.text.scan_qrcode_with_wallet), h("div", { dangerouslySetInnerHTML: { __html: l3 } }), h("div", { className: "walletconnect-modal__footer" }, h("a", { onClick: function() {
    (0, import_copy_to_clipboard.default)(e3.uri) ? (o3(e3.text.copied_to_clipboard), setInterval(function() {
      return o3("");
    }, 1200)) : (o3("Error"), setInterval(function() {
      return o3("");
    }, 1200));
  } }, e3.text.copy_to_clipboard)), h(Notification, { message: t3 }));
}
function Modal(e3) {
  var n2 = isAndroid(), t3 = isMobile(), o3 = t3 ? e3.qrcodeModalOptions && e3.qrcodeModalOptions.mobileLinks ? e3.qrcodeModalOptions.mobileLinks : void 0 : e3.qrcodeModalOptions && e3.qrcodeModalOptions.desktopLinks ? e3.qrcodeModalOptions.desktopLinks : void 0, a3 = m2(false), l3 = a3[0], r3 = a3[1], i3 = m2(false), c3 = i3[0], s3 = i3[1], d3 = m2(!t3), _4 = d3[0], m3 = d3[1], p3 = { mobile: t3, text: e3.text, uri: e3.uri, qrcodeModalOptions: e3.qrcodeModalOptions }, g3 = m2(""), w4 = g3[0], u3 = g3[1], f3 = m2(false), h3 = f3[0], b2 = f3[1], x3 = m2([]), E4 = x3[0], C3 = x3[1], v3 = m2(""), y3 = v3[0], N3 = v3[1], T4 = function() {
    c3 || l3 || o3 && !o3.length || E4.length > 0 || l2(function() {
      !function() {
        try {
          if (n2)
            return Promise.resolve();
          r3(true);
          var a4 = _catch(function() {
            var n3 = e3.qrcodeModalOptions && e3.qrcodeModalOptions.registryUrl ? e3.qrcodeModalOptions.registryUrl : getWalletRegistryUrl();
            return Promise.resolve(fetch(n3)).then(function(n4) {
              return Promise.resolve(n4.json()).then(function(n5) {
                var a5 = getMobileLinkRegistry(formatMobileRegistry(n5.listings, t3 ? "mobile" : "desktop"), o3);
                r3(false), s3(true), N3(a5.length ? "" : e3.text.no_supported_wallets), C3(a5);
                var l4 = a5.length === 1;
                l4 && (u3(formatIOSMobile(e3.uri, a5[0])), m3(true)), b2(l4);
              });
            });
          }, function(n3) {
            r3(false), s3(true), N3(e3.text.something_went_wrong), console.error(n3);
          });
          Promise.resolve(a4 && a4.then ? a4.then(function() {
          }) : void 0);
        } catch (e4) {
          return Promise.reject(e4);
        }
      }();
    });
  };
  T4();
  var k3 = t3 ? _4 : !_4;
  return h("div", { id: WALLETCONNECT_MODAL_ID, className: "walletconnect-qrcode__base animated fadeIn" }, h("div", { className: "walletconnect-modal__base" }, h(Header, { onClose: e3.onClose }), h3 && _4 ? h("div", { className: "walletconnect-modal__single_wallet" }, h("a", { onClick: function() {
    return saveMobileLinkInfo({ name: E4[0].name, href: w4 });
  }, href: w4, rel: "noopener noreferrer", target: "_blank" }, e3.text.connect_with + " " + (h3 ? E4[0].name : "") + " \u203A")) : n2 || l3 || !l3 && E4.length ? h("div", { className: "walletconnect-modal__mobile__toggle" + (k3 ? " right__selected" : "") }, h("div", { className: "walletconnect-modal__mobile__toggle_selector" }), t3 ? h(d, null, h("a", { onClick: function() {
    return m3(false), T4();
  } }, e3.text.mobile), h("a", { onClick: function() {
    return m3(true);
  } }, e3.text.qrcode)) : h(d, null, h("a", { onClick: function() {
    return m3(true);
  } }, e3.text.qrcode), h("a", { onClick: function() {
    return m3(false), T4();
  } }, e3.text.desktop))) : null, h("div", null, _4 || !n2 && !l3 && !E4.length ? h(QRCodeDisplay, Object.assign({}, p3)) : h(LinkDisplay, Object.assign({}, p3, { links: E4, errorMessage: y3 })))));
}
var de = { choose_preferred_wallet: "W\xE4hle bevorzugte Wallet", connect_mobile_wallet: "Verbinde mit Mobile Wallet", scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet", connect: "Verbinden", qrcode: "QR-Code", mobile: "Mobile", desktop: "Desktop", copy_to_clipboard: "In die Zwischenablage kopieren", copied_to_clipboard: "In die Zwischenablage kopiert!", connect_with: "Verbinden mit Hilfe von", loading: "Laden...", something_went_wrong: "Etwas ist schief gelaufen", no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet", no_wallets_found: "keine Wallet gefunden" }, en = { choose_preferred_wallet: "Choose your preferred wallet", connect_mobile_wallet: "Connect to Mobile Wallet", scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet", connect: "Connect", qrcode: "QR Code", mobile: "Mobile", desktop: "Desktop", copy_to_clipboard: "Copy to clipboard", copied_to_clipboard: "Copied to clipboard!", connect_with: "Connect with", loading: "Loading...", something_went_wrong: "Something went wrong", no_supported_wallets: "There are no supported wallets yet", no_wallets_found: "No wallets found" }, es = { choose_preferred_wallet: "Elige tu billetera preferida", connect_mobile_wallet: "Conectar a billetera m\xF3vil", scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect", connect: "Conectar", qrcode: "C\xF3digo QR", mobile: "M\xF3vil", desktop: "Desktop", copy_to_clipboard: "Copiar", copied_to_clipboard: "Copiado!", connect_with: "Conectar mediante", loading: "Cargando...", something_went_wrong: "Algo sali\xF3 mal", no_supported_wallets: "Todav\xEDa no hay billeteras compatibles", no_wallets_found: "No se encontraron billeteras" }, fr = { choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9", connect_mobile_wallet: "Se connecter au portefeuille mobile", scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect", connect: "Se connecter", qrcode: "QR Code", mobile: "Mobile", desktop: "Desktop", copy_to_clipboard: "Copier", copied_to_clipboard: "Copi\xE9!", connect_with: "Connectez-vous \xE0 l'aide de", loading: "Chargement...", something_went_wrong: "Quelque chose a mal tourn\xE9", no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge", no_wallets_found: "Aucun portefeuille trouv\xE9" }, ko = { choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694", connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0", scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694", connect: "\uC5F0\uACB0", qrcode: "QR \uCF54\uB4DC", mobile: "\uBAA8\uBC14\uC77C", desktop: "\uB370\uC2A4\uD06C\uD0D1", copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC", copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!", connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4", loading: "\uB85C\uB4DC \uC911...", something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.", no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4", no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4" }, pt = { choose_preferred_wallet: "Escolha sua carteira preferida", connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel", scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect", connect: "Conectar", qrcode: "C\xF3digo QR", mobile: "M\xF3vel", desktop: "Desktop", copy_to_clipboard: "Copiar", copied_to_clipboard: "Copiado!", connect_with: "Ligar por meio de", loading: "Carregamento...", something_went_wrong: "Algo correu mal", no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas", no_wallets_found: "Nenhuma carteira encontrada" }, zh = { choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305", connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305", scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801", connect: "\u8FDE\u63A5", qrcode: "\u4E8C\u7EF4\u7801", mobile: "\u79FB\u52A8", desktop: "\u684C\u9762", copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F", copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01", connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5", loading: "\u6B63\u5728\u52A0\u8F7D...", something_went_wrong: "\u51FA\u4E86\u95EE\u9898", no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305", no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305" }, fa = { choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F", connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F", scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F", connect: "\u0627\u062A\u0635\u0627\u0644", qrcode: "\u06A9\u062F QR", mobile: "\u0633\u06CC\u0627\u0631", desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E", copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F", copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!", connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627", loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC", something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F", no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F", no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F" }, languages = { de, en, es, fr, ko, pt, zh, fa };
function injectStyleSheet() {
  var e3 = getDocumentOrThrow(), n2 = e3.getElementById(WALLETCONNECT_STYLE_ID);
  n2 && e3.head.removeChild(n2);
  var t3 = e3.createElement("style");
  t3.setAttribute("id", WALLETCONNECT_STYLE_ID), t3.innerText = WALLETCONNECT_STYLE_SHEET, e3.head.appendChild(t3);
}
function renderWrapper() {
  var e3 = getDocumentOrThrow(), n2 = e3.createElement("div");
  return n2.setAttribute("id", WALLETCONNECT_WRAPPER_ID), e3.body.appendChild(n2), n2;
}
function triggerCloseAnimation() {
  var e3 = getDocumentOrThrow(), n2 = e3.getElementById(WALLETCONNECT_MODAL_ID);
  n2 && (n2.className = n2.className.replace("fadeIn", "fadeOut"), setTimeout(function() {
    var n3 = e3.getElementById(WALLETCONNECT_WRAPPER_ID);
    n3 && e3.body.removeChild(n3);
  }, ANIMATION_DURATION));
}
function getWrappedCallback(e3) {
  return function() {
    triggerCloseAnimation(), e3 && e3();
  };
}
function getText() {
  var e3 = getNavigatorOrThrow().language.split("-")[0] || "en";
  return languages[e3] || languages.en;
}
function open$1(e3, n2, t3) {
  injectStyleSheet();
  var o3 = renderWrapper();
  T3(h(Modal, { text: getText(), uri: e3, onClose: getWrappedCallback(n2), qrcodeModalOptions: t3 }), o3);
}
function close$1() {
  triggerCloseAnimation();
}
var isNode3 = function() {
  return typeof process != "undefined" && process.versions !== void 0 && process.versions.node !== void 0;
};
function open$2(e3, n2, t3) {
  console.log(e3), isNode3() ? open(e3) : open$1(e3, n2, t3);
}
function close$2() {
  isNode3() || close$1();
}
var index = { open: open$2, close: close$2 };
var esm_default4 = index;

// src/index.ts
var import_buffer = __toESM(require_buffer());
var import_algosdk = __toESM(require_algosdk_min());
var import_utils6 = __toESM(require_cjs6());
var Algonaut = class {
  algodClient;
  indexerClient = void 0;
  account = void 0;
  address = void 0;
  sKey = void 0;
  mnemonic = void 0;
  config = void 0;
  sdk = void 0;
  uiLoading = false;
  walletConnect = {
    connected: false,
    connector: void 0,
    accounts: [],
    address: "",
    assets: [],
    chain: void 0
  };
  constructor(config) {
    this.config = config;
    this.algodClient = new import_algosdk.default.Algodv2(config.API_TOKEN, config.BASE_SERVER, config.PORT);
    if (config.INDEX_SERVER) {
      this.indexerClient = new import_algosdk.default.Indexer(config.API_TOKEN, config.INDEX_SERVER, config.PORT);
    } else {
      console.warn("No indexer configured because INDEX_SERVER was not provided.");
    }
    this.sdk = import_algosdk.default;
  }
  getConfig() {
    if (this.config)
      return this.config;
    return false;
  }
  async checkStatus() {
    const status = await this.algodClient.status().do();
    console.log("Algorand network status: %o", status);
    return status;
  }
  setAccount(account) {
    this.account = account;
    this.address = account.addr;
    if (this.config)
      this.config.SIGNING_MODE = "local";
    this.mnemonic = import_algosdk.default.secretKeyToMnemonic(account.sk);
  }
  setWalletConnectAccount(address) {
    this.account = {
      addr: address,
      sk: new Uint8Array([])
    };
    if (this.config)
      this.config.SIGNING_MODE = "walletconnect";
  }
  createWallet() {
    this.account = import_algosdk.default.generateAccount();
    if (this.account) {
      this.address = this.account.addr;
      this.mnemonic = import_algosdk.default.secretKeyToMnemonic(this.account.sk);
      return {
        address: this.account.addr,
        mnemonic: this.mnemonic || ""
      };
    } else {
      throw new Error("There was no account: could not create algonaut wallet!");
    }
  }
  recoverAccount(mnemonic) {
    try {
      this.account = import_algosdk.default.mnemonicToSecretKey(mnemonic);
      if (import_algosdk.default.isValidAddress(this.account?.addr)) {
        return this.account || false;
      }
      if (this.config)
        this.config.SIGNING_MODE = "local";
    } catch (error) {
      console.log(error);
      return false;
    }
    return false;
  }
  async waitForConfirmation(txId, limitDelta, log = false) {
    let lastround = (await this.algodClient.status().do())["last-round"];
    const limit = lastround + (limitDelta ? limitDelta : 50);
    const returnValue = {
      status: "fail",
      message: ""
    };
    while (lastround < limit) {
      let pendingInfo = "";
      try {
        pendingInfo = await this.algodClient.pendingTransactionInformation(txId).do();
        if (log) {
          console.log("waiting for confirmation");
        }
      } catch (er) {
        console.error(er.response?.text);
      }
      if (pendingInfo["confirmed-round"] !== null && pendingInfo["confirmed-round"] > 0) {
        console.log("Transaction confirmed in round " + pendingInfo["confirmed-round"]);
        returnValue.txId = txId;
        returnValue.status = "success";
        returnValue.message = "Transaction confirmed in round " + pendingInfo["confirmed-round"];
        break;
      }
      lastround++;
    }
    return returnValue;
  }
  generateLogicSig(base64ProgramString) {
    const program = new Uint8Array(import_buffer.Buffer.from(base64ProgramString, "base64"));
    return new import_algosdk.default.LogicSigAccount(program);
  }
  async atomicOptInAsset(assetIndex) {
    if (this.account && assetIndex) {
      const params = await this.algodClient.getTransactionParams().do();
      const optInTransaction = import_algosdk.default.makeAssetTransferTxnWithSuggestedParamsFromObject({
        from: this.account.addr,
        to: this.account.addr,
        suggestedParams: params,
        assetIndex,
        amount: 0
      });
      return {
        transaction: optInTransaction,
        transactionSigner: this.account,
        isLogigSig: false
      };
    } else {
      throw new Error("there was no account!");
    }
  }
  async optInAsset(assetIndex, callbacks) {
    if (!this.account)
      throw new Error("There was no account!");
    const { transaction } = await this.atomicOptInAsset(assetIndex);
    return await this.sendTransaction(transaction, callbacks);
  }
  async isOptedIntoAsset(args) {
    let optInState = false;
    const accountInfo = await this.getAccountInfo(args.account);
    accountInfo.assets.forEach((asset) => {
      if (asset["asset-id"] == args.assetId) {
        optInState = true;
      }
    });
    return optInState;
  }
  encodeArguments(args) {
    const encodedArgs = [];
    args.forEach((arg) => {
      if (typeof arg == "number") {
        encodedArgs.push(import_algosdk.default.encodeUint64(arg));
      } else if (typeof arg == "bigint") {
        encodedArgs.push(import_algosdk.default.encodeUint64(arg));
      } else if (typeof arg == "string") {
        encodedArgs.push(new Uint8Array(import_buffer.Buffer.from(arg)));
      }
    });
    return encodedArgs;
  }
  async atomicCreateAsset(args) {
    if (!args.metaBlock) {
      args.metaBlock = "wot? wot wot?";
    }
    if (!args.defaultFrozen)
      args.defaultFrozen = false;
    if (!args.assetURL)
      args.assetURL = void 0;
    const metaBlockLength = args.metaBlock.length;
    if (metaBlockLength > 511) {
      console.error("meta block is " + metaBlockLength);
      throw new Error("drat! this meta block is too long!");
    }
    const enc = new TextEncoder();
    if (!this.account)
      throw new Error("There was no account");
    const note = enc.encode(args.metaBlock);
    const addr = this.account.addr;
    const totalIssuance = args.amount;
    const manager = this.account.addr;
    const reserve = this.account.addr;
    const freeze = this.account.addr;
    const clawback = this.account.addr;
    const params = await this.algodClient.getTransactionParams().do();
    const txn = import_algosdk.default.makeAssetCreateTxnWithSuggestedParams(addr, note, totalIssuance, args.decimals, args.defaultFrozen, manager, reserve, freeze, clawback, args.symbol, args.assetName, args.assetURL, args.assetMetadataHash, params);
    return {
      transaction: txn,
      transactionSigner: this.account,
      isLogigSig: false
    };
  }
  async createAsset(args, callbacks) {
    const atomicTxn = await this.atomicCreateAsset(args);
    const txn = atomicTxn.transaction;
    try {
      const assetID = null;
      const txStatus = await this.sendTransaction(txn, callbacks);
      const ptx = await this.algodClient.pendingTransactionInformation(txn.txID().toString()).do();
      txStatus.createdIndex = ptx["asset-index"];
      return txStatus;
    } catch (er) {
      console.log("transaction error");
      console.log(er);
      throw new Error(er);
    }
  }
  async atomicDeleteAsset(assetId) {
    if (!this.account)
      throw new Error("there was no account!");
    const enc = new TextEncoder();
    const transaction = import_algosdk.default.makeAssetDestroyTxnWithSuggestedParams(this.account.addr, enc.encode("doh!"), assetId, await this.algodClient.getTransactionParams().do());
    return {
      transaction,
      transactionSigner: this.account,
      isLogigSig: false
    };
  }
  async deleteAsset(assetId, callbacks) {
    const { transaction } = await this.atomicDeleteAsset(assetId);
    return await this.sendTransaction(transaction, callbacks);
  }
  async atomicSendAsset(args) {
    if (!this.account)
      throw new Error("there is no account!");
    const transaction = import_algosdk.default.makeAssetTransferTxnWithSuggestedParamsFromObject({
      from: this.account.addr,
      to: args.to,
      amount: args.amount,
      assetIndex: args.assetIndex,
      suggestedParams: await this.algodClient.getTransactionParams().do()
    });
    return {
      transaction,
      transactionSigner: this.account,
      isLogigSig: false
    };
  }
  async sendAsset(args, callbacks) {
    if (!this.account)
      throw new Error("There was no account!");
    const { transaction } = await this.atomicSendAsset(args);
    return await this.sendTransaction(transaction, callbacks);
  }
  async getAssetInfo(assetIndex) {
    const info = await this.algodClient.getAssetByID(assetIndex).do();
    return info;
  }
  async atomicOptInApp(args) {
    if (this.account && args.appIndex) {
      const sender = this.account.addr;
      const params = await this.algodClient.getTransactionParams().do();
      const optInTransaction = import_algosdk.default.makeApplicationOptInTxnFromObject({
        from: sender,
        appIndex: args.appIndex,
        suggestedParams: params,
        appArgs: args.appArgs ? this.encodeArguments(args.appArgs) : void 0,
        accounts: args.optionalFields?.accounts ? args.optionalFields?.accounts : void 0,
        foreignApps: args.optionalFields?.applications ? args.optionalFields?.applications : void 0,
        foreignAssets: args.optionalFields?.assets ? args.optionalFields?.assets : void 0
      });
      return {
        transaction: optInTransaction,
        transactionSigner: this.account,
        isLogigSig: false
      };
    } else {
      throw new Error("algonautjs has no account loaded!");
    }
  }
  async optInApp(args, callbacks) {
    if (this.account && args.appIndex) {
      const { transaction } = await this.atomicOptInApp(args);
      return await this.sendTransaction(transaction, callbacks);
    } else {
      if (!this.account)
        throw new Error("No account set.");
      throw new Error("Must provide appIndex");
    }
  }
  async atomicDeleteApplication(appIndex) {
    if (this.account && appIndex) {
      try {
        const sender = this.account.addr;
        const params = await this.algodClient.getTransactionParams().do();
        const txn = import_algosdk.default.makeApplicationDeleteTxn(sender, params, appIndex);
        return {
          transaction: txn,
          transactionSigner: this.account,
          isLogigSig: false
        };
      } catch (e3) {
        throw new Error(e3);
      }
    } else {
      throw new Error("No account loaded");
    }
  }
  async deleteApplication(appIndex, callbacks) {
    if (!this.account)
      throw new Error("There was no account");
    try {
      const { transaction } = await this.atomicDeleteApplication(appIndex);
      const txId = transaction.txID().toString();
      const status = await this.sendTransaction(transaction, callbacks);
      const transactionResponse = await this.algodClient.pendingTransactionInformation(txId).do();
      const appId = transactionResponse["txn"]["txn"].apid;
      console.log("Deleted app-id: ", appId);
      return {
        status: "success",
        message: "deleted app index " + appId,
        txId
      };
    } catch (e3) {
      console.log(e3);
      throw new Error(e3.response?.text);
    }
  }
  async atomicCallApp(args) {
    if (this.account && args.appIndex && args.appArgs.length) {
      const processedArgs = this.encodeArguments(args.appArgs);
      const params = await this.algodClient.getTransactionParams().do();
      const callAppTransaction = import_algosdk.default.makeApplicationNoOpTxnFromObject({
        from: this.account.addr,
        suggestedParams: params,
        appIndex: args.appIndex,
        appArgs: processedArgs,
        accounts: args.optionalFields?.accounts || void 0,
        foreignApps: args.optionalFields?.applications || void 0,
        foreignAssets: args.optionalFields?.assets || void 0
      });
      return {
        transaction: callAppTransaction,
        transactionSigner: this.account,
        isLogigSig: false
      };
    } else {
      throw new Error("there was no account!");
    }
  }
  async callApp(args, callbacks) {
    if (!this.account)
      throw new Error("There was no account!");
    if (!args.appIndex)
      throw new Error("Must provide appIndex");
    if (!args.appArgs.length)
      throw new Error("Must provide at least one appArgs");
    const { transaction } = await this.atomicCallApp(args);
    return await this.sendTransaction(transaction, callbacks);
  }
  async atomicCallAppWithLSig(args) {
    if (this.account && args.appIndex && args.appArgs.length) {
      const processedArgs = this.encodeArguments(args.appArgs);
      const params = await this.algodClient.getTransactionParams().do();
      const callAppTransaction = import_algosdk.default.makeApplicationNoOpTxnFromObject({
        from: args.lsig.address(),
        suggestedParams: params,
        appIndex: args.appIndex,
        appArgs: processedArgs,
        accounts: args.optionalFields?.accounts || void 0,
        foreignApps: args.optionalFields?.applications || void 0,
        foreignAssets: args.optionalFields?.assets || void 0
      });
      return {
        transaction: callAppTransaction,
        transactionSigner: args.lsig,
        isLogigSig: true
      };
    } else {
      throw new Error("there was no account!");
    }
  }
  async atomicCloseOutApp(args) {
    if (this.account && args.appIndex && args.appArgs.length) {
      try {
        const params = await this.algodClient.getTransactionParams().do();
        const processedArgs = this.encodeArguments(args.appArgs);
        const closeOutTxn = import_algosdk.default.makeApplicationCloseOutTxnFromObject({
          from: this.account.addr,
          suggestedParams: params,
          appIndex: args.appIndex,
          appArgs: processedArgs,
          accounts: args.optionalFields?.accounts || void 0,
          foreignApps: args.optionalFields?.applications || void 0,
          foreignAssets: args.optionalFields?.assets || void 0
        });
        return {
          transaction: closeOutTxn,
          transactionSigner: this.account,
          isLogigSig: false
        };
      } catch (e3) {
        throw new Error(e3);
      }
    } else {
      throw new Error("requires app index");
    }
  }
  async closeOutApp(args, callbacks) {
    if (!this.account)
      throw new Error("There was no account!");
    if (!args.appIndex)
      throw new Error("Must provide appIndex");
    if (!args.appArgs.length)
      throw new Error("Must provide at least one appArgs");
    const { transaction } = await this.atomicCloseOutApp(args);
    return await this.sendTransaction(transaction, callbacks);
  }
  getAppEscrowAccount(appId) {
    return import_algosdk.default.getApplicationAddress(appId);
  }
  async getAppInfo(appId) {
    const info = await this.algodClient.getApplicationByID(appId).do();
    const state = {
      hasState: true,
      globals: [],
      locals: [],
      creatorAddress: info.params.creator,
      index: appId
    };
    if (info.params["global-state"]) {
      state.globals = this.decodeStateArray(info.params["global-state"]);
    }
    return state;
  }
  async createApp(args, callbacks) {
    if (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {
      console.warn("drat! your note is too long!");
      throw new Error("Your note is too long");
    }
    if (!this.account)
      throw new Error("There was no account!");
    try {
      const sender = this.account.addr;
      const onComplete = import_algosdk.default.OnApplicationComplete.NoOpOC;
      const params = await this.algodClient.getTransactionParams().do();
      let approvalProgram = new Uint8Array();
      let clearProgram = new Uint8Array();
      approvalProgram = await this.compileProgram(args.tealApprovalCode);
      clearProgram = await this.compileProgram(args.tealClearCode);
      if (approvalProgram && clearProgram) {
        const txn = import_algosdk.default.makeApplicationCreateTxn(sender, params, onComplete, approvalProgram, clearProgram, args.schema.localInts, args.schema.localBytes, args.schema.globalInts, args.schema.globalBytes, this.encodeArguments(args.appArgs), args.optionalFields?.accounts ? args.optionalFields.accounts : void 0, args.optionalFields?.applications ? args.optionalFields.applications : void 0, args.optionalFields?.assets ? args.optionalFields.assets : void 0, args.optionalFields?.note ? new Uint8Array(import_buffer.Buffer.from(args.optionalFields.note, "utf8")) : void 0);
        const txId = txn.txID().toString();
        const result = await this.sendTransaction(txn, callbacks);
        const transactionResponse = await this.algodClient.pendingTransactionInformation(txId).do();
        result.message = "Created App ID: " + transactionResponse["application-index"];
        result.createdIndex = transactionResponse["application-index"];
        result.meta = transactionResponse;
        result.txId = txId;
        return result;
      } else {
        throw new Error("could not compile teal code");
      }
    } catch (er) {
      throw new Error(er.message);
    }
  }
  async atomicCreateApp(args) {
    if (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {
      throw new Error("Your NOTE is too long, it must be less thatn 1024 Bytes");
    } else if (this.account) {
      try {
        const sender = this.account.addr;
        const onComplete = import_algosdk.default.OnApplicationComplete.NoOpOC;
        const params = await this.algodClient.getTransactionParams().do();
        let approvalProgram = new Uint8Array();
        let clearProgram = new Uint8Array();
        approvalProgram = await this.compileProgram(args.tealApprovalCode);
        clearProgram = await this.compileProgram(args.tealClearCode);
        if (!approvalProgram || !clearProgram) {
          throw new Error("Error: you must provide an approval program and a clear state program.");
        }
        const applicationCreateTransaction = import_algosdk.default.makeApplicationCreateTxn(sender, params, onComplete, approvalProgram, clearProgram, args.schema.localInts, args.schema.localBytes, args.schema.globalInts, args.schema.globalBytes, this.encodeArguments(args.appArgs), args.optionalFields?.accounts ? args.optionalFields.accounts : void 0, args.optionalFields?.applications ? args.optionalFields.applications : void 0, args.optionalFields?.assets ? args.optionalFields.assets : void 0, args.optionalFields?.note ? new Uint8Array(import_buffer.Buffer.from(args.optionalFields.note, "utf8")) : void 0);
        return {
          transaction: applicationCreateTransaction,
          transactionSigner: this.account,
          isLogigSig: false
        };
      } catch (er) {
        throw new Error("There was an error creating the transaction");
      }
    } else {
      throw new Error("Algonaut.js has no account loaded!");
    }
  }
  async deployTealWithLSig(args) {
    if (args.noteText && args.noteText.length > 511) {
      throw new Error("Your note is too long");
    }
    if (!this.account)
      throw new Error("there was no account");
    let encodedArgs = [];
    if (args.appArgs && args.appArgs.length) {
      encodedArgs = this.encodeArguments(args.appArgs);
    }
    const sender = args.lsig.address();
    const onComplete = import_algosdk.default.OnApplicationComplete.NoOpOC;
    const params = await this.algodClient.getTransactionParams().do();
    let approvalProgram = new Uint8Array();
    let clearProgram = new Uint8Array();
    try {
      approvalProgram = await this.compileProgram(args.tealApprovalCode);
      clearProgram = await this.compileProgram(args.tealClearCode);
      if (approvalProgram && clearProgram) {
        const txn = import_algosdk.default.makeApplicationCreateTxn(sender, params, onComplete, approvalProgram, clearProgram, args.schema.localInts, args.schema.localBytes, args.schema.globalInts, args.schema.globalBytes, encodedArgs, args.optionalFields?.accounts || void 0);
        const txId = txn.txID().toString();
        const signedTxn = import_algosdk.default.signLogicSigTransactionObject(txn, args.lsig);
        await this.algodClient.sendRawTransaction(signedTxn.blob).do();
        const txStatus = await this.waitForConfirmation(txId);
        const transactionResponse = await this.algodClient.pendingTransactionInformation(txId).do();
        const appId = transactionResponse["application-index"];
        return {
          status: "success",
          message: "created new app with id: " + appId,
          txId
        };
      } else {
        throw new Error("Error compiling programs.");
      }
    } catch (er) {
      console.error("Error deploying contract:");
      throw new Error(er);
    }
  }
  async atomicUpdateApp(args) {
    if (!this.account)
      throw new Error("Algonaut.js has no account loaded!");
    if (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {
      throw new Error("Your NOTE is too long, it must be less thatn 1024 Bytes");
    }
    try {
      const sender = this.account.addr;
      const onComplete = import_algosdk.default.OnApplicationComplete.NoOpOC;
      const params = await this.algodClient.getTransactionParams().do();
      let approvalProgram = new Uint8Array();
      let clearProgram = new Uint8Array();
      approvalProgram = await this.compileProgram(args.tealApprovalCode);
      clearProgram = await this.compileProgram(args.tealClearCode);
      if (!approvalProgram || !clearProgram) {
        throw new Error("Error: you must provide an approval program and a clear state program.");
      }
      const applicationCreateTransaction = import_algosdk.default.makeApplicationUpdateTxn(sender, params, args.appIndex, approvalProgram, clearProgram, this.encodeArguments(args.appArgs), args.optionalFields?.accounts ? args.optionalFields.accounts : void 0, args.optionalFields?.applications ? args.optionalFields.applications : void 0, args.optionalFields?.assets ? args.optionalFields.assets : void 0, args.optionalFields?.note ? new Uint8Array(import_buffer.Buffer.from(args.optionalFields.note, "utf8")) : void 0);
      return {
        transaction: applicationCreateTransaction,
        transactionSigner: this.account,
        isLogigSig: false
      };
    } catch (er) {
      throw new Error("There was an error creating the transaction");
    }
  }
  async updateApp(args, callbacks) {
    const { transaction } = await this.atomicUpdateApp(args);
    return await this.sendTransaction(transaction, callbacks);
  }
  async compileProgram(programSource) {
    const encoder = new TextEncoder();
    const programBytes = encoder.encode(programSource);
    const compileResponse = await this.algodClient.compile(programBytes).do();
    const compiledBytes = new Uint8Array(import_buffer.Buffer.from(compileResponse.result, "base64"));
    return compiledBytes;
  }
  async atomicPayment(args) {
    if (this.account) {
      const encodedNote = args.note ? new Uint8Array(import_buffer.Buffer.from(args.note, "utf8")) : new Uint8Array();
      const transaction = import_algosdk.default.makePaymentTxnWithSuggestedParamsFromObject({
        from: this.account.addr,
        to: args.to,
        amount: args.amount,
        note: encodedNote,
        suggestedParams: await this.algodClient.getTransactionParams().do()
      });
      return {
        transaction,
        transactionSigner: this.account,
        isLogigSig: false
      };
    } else {
      throw new Error("there is no account!");
    }
  }
  async sendAlgo(args, callbacks) {
    if (!this.account)
      throw new Error("there was no account!");
    const { transaction } = await this.atomicPayment(args);
    return await this.sendTransaction(transaction);
  }
  async getAccountInfo(address) {
    const accountInfo = await this.algodClient.accountInformation(address).do();
    return accountInfo;
  }
  async getAlgoBalance(address) {
    const accountInfo = await this.algodClient.accountInformation(address).do();
    return accountInfo.amount;
  }
  async getTokenBalance(address, assetIndex) {
    const accountInfo = await this.algodClient.accountInformation(address).do();
    let stkBalance = 0;
    accountInfo.assets.forEach((asset) => {
      if (asset["asset-id"] == assetIndex) {
        stkBalance = asset.amount;
      }
    });
    return stkBalance;
  }
  async accountHasTokens(address, assetIndex) {
    return "this is not done yet";
  }
  async getAppGlobalState(applicationIndex) {
    const info = await this.getAppInfo(applicationIndex);
    if (info.hasState) {
      return this.stateArrayToObject(info.globals);
    } else {
      return {};
    }
  }
  async getAppLocalState(applicationIndex) {
    if (this.account) {
      const state = {
        hasState: false,
        globals: [],
        locals: [],
        creatorAddress: "",
        index: applicationIndex
      };
      const accountInfoResponse = await this.algodClient.accountInformation(this.account?.addr).do();
      for (let i3 = 0; i3 < accountInfoResponse["apps-local-state"].length; i3++) {
        if (accountInfoResponse["apps-local-state"][i3].id == applicationIndex) {
          state.hasState = true;
          for (let n2 = 0; n2 < accountInfoResponse["apps-local-state"][i3]["key-value"].length; n2++) {
            const stateItem = accountInfoResponse["apps-local-state"][i3]["key-value"][n2];
            const key = import_buffer.Buffer.from(stateItem.key, "base64").toString();
            const type = stateItem.value.type;
            let value = void 0;
            let valueAsAddr = "";
            if (type == 1) {
              value = import_buffer.Buffer.from(stateItem.value.bytes, "base64").toString();
              valueAsAddr = import_algosdk.default.encodeAddress(import_buffer.Buffer.from(stateItem.value.bytes, "base64"));
            } else if (stateItem.value.type == 2) {
              value = stateItem.value.uint;
            }
            state.locals.push({
              key,
              value: value || "",
              address: valueAsAddr
            });
          }
        }
      }
      return state;
    } else {
      throw new Error("there is no account");
    }
  }
  async atomicAssetTransferWithLSig(args) {
    if (args.lsig) {
      const transaction = import_algosdk.default.makeAssetTransferTxnWithSuggestedParamsFromObject({
        from: args.lsig.address(),
        to: args.to,
        amount: args.amount,
        assetIndex: args.assetIndex,
        suggestedParams: await this.algodClient.getTransactionParams().do()
      });
      return {
        transaction,
        transactionSigner: args.lsig,
        isLogigSig: true
      };
    } else {
      throw new Error("there is no logic sig object!");
    }
  }
  async atomicPaymentWithLSig(args) {
    if (args.lsig) {
      const transaction = import_algosdk.default.makePaymentTxnWithSuggestedParamsFromObject({
        from: args.lsig.address(),
        to: args.to,
        amount: args.amount,
        suggestedParams: await this.algodClient.getTransactionParams().do()
      });
      return {
        transaction,
        transactionSigner: args.lsig,
        isLogigSig: true
      };
    } else {
      throw new Error("there is no account!");
    }
  }
  async sendTransaction(txnOrTxns, callbacks) {
    if (!this.account)
      throw new Error("There is no account");
    if (this.config && this.config.SIGNING_MODE && this.config.SIGNING_MODE === "walletconnect") {
      if (Array.isArray(txnOrTxns)) {
        return await this.sendWalletConnectTxns(txnOrTxns, callbacks);
      } else {
        if (txnOrTxns.transaction) {
          return await this.sendWalletConnectTxns([txnOrTxns], callbacks);
        } else {
          return await this.sendWalletConnectTxns([{
            transaction: txnOrTxns,
            transactionSigner: this.account,
            isLogigSig: false
          }], callbacks);
        }
      }
    } else {
      if (Array.isArray(txnOrTxns)) {
        return await this.sendAtomicTransaction(txnOrTxns, callbacks);
      } else {
        let txn;
        if (txnOrTxns && txnOrTxns.transaction) {
          txn = txnOrTxns.transaction;
        } else {
          txn = txnOrTxns;
        }
        if (!this.account || !this.account.sk)
          throw new Error("");
        const signedTxn = txn.signTxn(this.account.sk);
        if (callbacks?.onSign)
          callbacks.onSign(signedTxn);
        const tx = await this.algodClient.sendRawTransaction(signedTxn).do();
        if (callbacks?.onSend)
          callbacks.onSend(signedTxn);
        const txId = tx.txId || tx.id || tx.txId().toString();
        console.log("Transaction ID: " + txId);
        const txStatus = await this.waitForConfirmation(txId);
        if (callbacks?.onConfirm)
          callbacks.onConfirm(signedTxn);
        return txStatus;
      }
    }
  }
  async sendAtomicTransaction(transactions, callbacks) {
    try {
      const txns = [];
      const signed = [];
      transactions.forEach((txn) => {
        txns.push(txn.transaction);
      });
      const txnGroup = import_algosdk.default.assignGroupID(txns);
      transactions.forEach((txn, i3) => {
        let signedTx;
        if (txn.isLogigSig) {
          signedTx = import_algosdk.default.signLogicSigTransaction(txnGroup[i3], txn.transactionSigner);
        } else {
          signedTx = import_algosdk.default.signTransaction(txnGroup[i3], txn.transactionSigner.sk);
        }
        signed.push(signedTx.blob);
      });
      if (callbacks?.onSign)
        callbacks.onSign(signed);
      const tx = await this.algodClient.sendRawTransaction(signed).do();
      if (callbacks?.onSend)
        callbacks.onSend(tx);
      const txStatus = await this.waitForConfirmation(tx.txId);
      const transactionResponse = await this.algodClient.pendingTransactionInformation(tx.txId).do();
      txStatus.meta = transactionResponse;
      if (callbacks?.onConfirm)
        callbacks.onConfirm(txStatus);
      return txStatus;
    } catch (e3) {
      console.error("Error sending atomic transaction:");
      throw new Error(e3);
    }
  }
  async sendWalletConnectTxns(walletTxns, callbacks) {
    if (this.walletConnect.connected) {
      let txns = walletTxns.map((txn) => txn.transaction);
      if (walletTxns.length > 1) {
        txns = import_algosdk.default.assignGroupID(txns);
      }
      const txnsToSign = txns.map((txn) => {
        const encodedTxn = import_buffer.Buffer.from(import_algosdk.default.encodeUnsignedTransaction(txn)).toString("base64");
        return {
          txn: encodedTxn,
          message: "txn description"
        };
      });
      const requestParams = [txnsToSign];
      const request = (0, import_utils6.formatJsonRpcRequest)("algo_signTxn", requestParams);
      let result;
      try {
        result = await this.walletConnect.connector?.sendCustomRequest(request);
      } catch (er) {
        throw new Error("You canceled the transaction");
      }
      const signedPartialTxns = result.map((r3, i3) => {
        if (r3 == null) {
          throw new Error(`Transaction at index ${i3}: was not signed when it should have been`);
        }
        const rawSignedTxn = import_buffer.Buffer.from(r3, "base64");
        return new Uint8Array(rawSignedTxn);
      });
      if (callbacks?.onSign)
        callbacks.onSign(signedPartialTxns);
      if (signedPartialTxns) {
        let tx;
        try {
          tx = await this.algodClient.sendRawTransaction(signedPartialTxns).do();
        } catch (er) {
          tx = er;
          console.error("Error sending raw transaction");
          throw new Error(er);
        }
        if (callbacks?.onSend)
          callbacks.onSend(tx);
        const txStatus = await this.waitForConfirmation(tx.txId);
        const transactionResponse = await this.algodClient.pendingTransactionInformation(tx.txId).do();
        txStatus.meta = transactionResponse;
        if (callbacks?.onConfirm)
          callbacks.onConfirm(txStatus);
        return txStatus;
      } else {
        throw new Error("there were no signed transactions returned");
      }
    } else {
      throw new Error("There is no wallet connect session");
    }
  }
  usingWalletConnect() {
    if (this.config && this.config.SIGNING_MODE && this.config.SIGNING_MODE === "walletconnect") {
      return true;
    }
    return false;
  }
  async createWalletConnectTransactions(transactions) {
    const txns = [];
    transactions.forEach((txn) => {
      txns.push(txn.transaction);
    });
    return txns;
  }
  async sendTxWithAlgoSigner(params) {
    try {
      await this.connectToAlgoSigner();
      const txParams = await window.AlgoSigner.algod({
        ledger: params.LEDGER,
        path: "/v2/transactions/params"
      });
      const signedTx = await window.AlgoSigner.sign({
        assetIndex: params.assetIndex || null,
        from: params.from,
        to: params.to,
        amount: +params.amount,
        note: params.note || "",
        type: params.type,
        fee: txParams["min-fee"],
        firstRound: txParams["last-round"],
        lastRound: txParams["last-round"] + 1e3,
        genesisID: txParams["genesis-id"],
        genesisHash: txParams["genesis-hash"],
        flatFee: true
      });
      const tx = window.AlgoSigner.send({
        ledger: params.LEDGER,
        tx: signedTx.blob
      });
      return this.waitForAlgoSignerConfirmation(tx);
    } catch (error) {
      console.log(error);
      throw new Error("Error sending transaction: " + JSON.stringify(error));
    }
  }
  async waitForAlgoSignerConfirmation(tx) {
    console.log(`Transaction ${tx.txId} waiting for confirmation...`);
    let status = await window.AlgoSigner.algod({
      ledger: "TestNet",
      path: "/v2/transactions/pending/" + tx.txId
    });
    while (true) {
      if (status["confirmed-round"] !== null && status["confirmed-round"] > 0) {
        console.log(`Transaction confirmed in round ${status["confirmed-round"]}.`);
        break;
      }
      status = await window.AlgoSigner.algod({
        ledger: "TestNet",
        path: "/v2/transactions/pending/" + tx.txId
      });
    }
    return tx;
  }
  async disconnectAlgoWallet() {
    if (this.walletConnect.connected) {
      this.walletConnect.connector?.killSession();
    }
  }
  async connectAlgoWallet(clientListener) {
    console.log("connecting wallet: ");
    if (!clientListener)
      clientListener = void 0;
    const bridge = "https://bridge.walletconnect.org";
    const wcConnector = new esm_default3({
      bridge,
      qrcodeModal: esm_default4
    });
    this.walletConnect.connector = wcConnector;
    console.log("connector created");
    console.log(this.walletConnect.connector);
    if (!this.walletConnect.connector.connected) {
      this.walletConnect.connector.createSession();
      console.log("session created");
    }
    this.subscribeToEvents(clientListener);
  }
  subscribeToEvents(clientListener) {
    if (!this.walletConnect.connector) {
      return;
    }
    this.walletConnect.connector.on("session_update", async (error, payload) => {
      console.log('connector.on("session_update")');
      if (error) {
        throw error;
      }
      const { accounts } = payload.params[0];
      if (clientListener)
        clientListener.onSessionUpdate(payload);
      this.onSessionUpdate(accounts);
    });
    this.walletConnect.connector.on("connect", (error, payload) => {
      console.log('connector.on("connect")');
      if (error) {
        throw error;
      }
      if (clientListener)
        clientListener.onConnect(payload);
      this.onConnect(payload);
    });
    this.walletConnect.connector.on("disconnect", (error, payload) => {
      console.log('connector.on("disconnect")');
      if (error) {
        console.log(payload);
        throw error;
      }
      if (clientListener)
        clientListener.onDisconnect(payload);
      this.onDisconnect();
    });
    if (this.walletConnect.connector.connected) {
      const { accounts } = this.walletConnect.connector;
      const address = accounts[0];
      this.walletConnect.connected = true;
      this.walletConnect.accounts = accounts;
      this.walletConnect.address = address;
      this.onSessionUpdate(accounts);
    }
  }
  async killSession() {
    if (this.walletConnect.connector) {
      this.walletConnect.connector.killSession();
    }
    this.resetApp();
  }
  async chainUpdate(newChain) {
    this.walletConnect.chain = newChain;
  }
  async resetApp() {
    console.log("reset app called");
    console.log("TBD!");
  }
  async onConnect(payload) {
    const { accounts } = payload.params[0];
    const address = accounts[0];
    this.setWalletConnectAccount(address);
    this.walletConnect.connected = true;
    this.walletConnect.accounts = accounts;
    this.walletConnect.address = address;
  }
  onDisconnect() {
    this.walletConnect.connected = false;
    this.walletConnect.accounts = [];
    this.walletConnect.address = "";
    this.account = void 0;
  }
  async onSessionUpdate(accounts) {
    this.walletConnect.address = accounts[0];
    this.walletConnect.accounts = accounts;
    this.setWalletConnectAccount(accounts[0]);
  }
  stateArrayToObject(stateArray) {
    const stateObj = {};
    stateArray.forEach((value) => {
      if (value.key)
        stateObj[value.key] = value.value || null;
    });
    return stateObj;
  }
  fromBase64(encoded) {
    return import_buffer.Buffer.from(encoded, "base64").toString();
  }
  valueAsAddr(encoded) {
    return import_algosdk.default.encodeAddress(import_buffer.Buffer.from(encoded, "base64"));
  }
  decodeStateArray(stateArray) {
    const result = [];
    for (let n2 = 0; n2 < stateArray.length; n2++) {
      const stateItem = stateArray[n2];
      const key = this.fromBase64(stateItem.key);
      const type = stateItem.value.type;
      let value = void 0;
      let valueAsAddr = "";
      if (type == 1) {
        value = this.fromBase64(stateItem.value.bytes);
        valueAsAddr = this.valueAsAddr(stateItem.value.bytes);
      } else if (stateItem.value.type == 2) {
        value = stateItem.value.uint;
      }
      result.push({
        key,
        value: value || "",
        address: valueAsAddr
      });
    }
    return result;
  }
  isAlgoSignerInstalled() {
    return typeof window.AlgoSigner !== "undefined";
  }
  async connectToAlgoSigner() {
    return await window.AlgoSigner.connect();
  }
  async getAccounts(ledger) {
    await this.connectToAlgoSigner();
    const accounts = await window.AlgoSigner.accounts({ ledger });
    return accounts;
  }
};
export {
  Algonaut as default
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! For license information please see algosdk.min.js.LICENSE.txt */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
/** @preserve
 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
 * derived from CryptoJS.mode.CTR
 * Jan Hruby jhruby.web@gmail.com
 */
//# sourceMappingURL=index.mjs.map
