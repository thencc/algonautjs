{"version":3,"sources":["../src/index.ts","../src/AlgonautTypes.ts","../node_modules/.pnpm/@vue-reactivity+watch@0.2.0_@vue+reactivity@3.3.4_@vue+shared@3.3.4/node_modules/@vue-reactivity/watch/dist/index.mjs","../src/algo-config.ts","../src/constants.ts","../src/utils.ts"],"names":["init_cjs_shims","import_buffer","callWithErrorHandling","fn","type","args","res","err","handleError","callWithAsyncErrorHandling","isFunction","isPromise","values","warn","message","createError","INITIAL_WATCHER_VALUE","watch","source","cb","options","doWatch","immediate","deep","flush","getter","forceTrigger","isMultiSource","isRef","isShallow","isReactive","isArray","s","traverse","cleanup","onCleanup","NOOP","baseGetter","effect","oldValue","job","newValue","v","i","hasChanged","scheduler","ReactiveEffect","value","seen","isObject","_","key","testnetConfig","mainnetConfig","defaultNodeConfig","defaultLibConfig","logger","unsAcctSync","Algonaut","config","esm_default","K","Sn","Ue","zn","Bn","libConfig","hn","nodeConfig","isValid","AlgodClient","IndexerClient","status","Ve","acct","walletInitParams","En","mnemonic","d","route","inkeyW","inkeyClientSdk","txId","limitDelta","log","_a","lastround","limit","returnValue","pendingInfo","er","base64ProgramString","program","LogicSigAccount","assetIndex","optionalTxnArgs","suggestedParams","makeAssetTransferTxnWithSuggestedParamsFromObject","callbacks","transaction","optInState","asset","encodedArgs","arg","encodeUint64","fromAddr","metaBlockLength","note","totalIssuance","manager","reserve","freeze","clawback","makeAssetCreateTxnWithSuggestedParams","txn","txStatus","ptx","assetId","enc","makeAssetDestroyTxnWithSuggestedParams","isValidAddress","_b","_c","_d","_e","_f","_g","makeApplicationOptInTxnFromObject","appIndex","makeApplicationDeleteTxn","e","processedArgs","makeApplicationNoOpTxnFromObject","makeApplicationCloseOutTxnFromObject","appId","getApplicationAddress","proms","promsRes","info","localState","state","approvalProgram","clearProgram","makeApplicationCreateTxnFromObject","OnApplicationComplete","result","transactionResponse","onComplete","makeApplicationCreateTxn","sender","signedTxn","signLogicSigTransactionObject","makeApplicationUpdateTxn","programSource","programBytes","compileResponse","encodedNote","makePaymentTxnWithSuggestedParamsFromObject","address","accountInfo","bal","applicationIndex","accountInfoResponse","n","stateItem","valueAsAddr","encodeAddress","txnOrTxns","txnArr","algoTxnArr","t","nativeT","gId","txnBuffArr","awTxnsToSign","awTxnsSigned","Wn","tx","str","stateArray","stateObj","encoded","decodeUnsignedTransaction","to","from","microalgosToAlgos","account","generateAccount","secretKeyToMnemonic","mnemonicToSecretKey","error","buff","src_default","buffer"],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer';\n\nimport algosdk, {\n\tsecretKeyToMnemonic,\n\tgenerateAccount,\n\tAccount as AlgosdkAccount,\n\tAlgodv2,\n\tIndexer,\n\tLogicSigAccount,\n\tmakeAssetTransferTxnWithSuggestedParamsFromObject,\n\tmakeApplicationOptInTxnFromObject,\n\tmakeAssetCreateTxnWithSuggestedParams,\n\tmakeAssetDestroyTxnWithSuggestedParams,\n\tmakeApplicationDeleteTxn,\n\tmakeApplicationNoOpTxnFromObject,\n\tmakeApplicationCloseOutTxnFromObject,\n\tmakeApplicationCreateTxnFromObject,\n\tOnApplicationComplete,\n\tmakeApplicationCreateTxn,\n\tsignLogicSigTransactionObject,\n\tmakeApplicationUpdateTxn,\n\tencodeAddress,\n\tmakePaymentTxnWithSuggestedParamsFromObject,\n\tTransaction,\n\tmnemonicToSecretKey,\n\tisValidAddress,\n\tencodeUint64,\n\tgetApplicationAddress,\n\tmicroalgosToAlgos,\n\tdecodeUnsignedTransaction\n} from 'algosdk';\n\nimport type {\n\tAlgonautConfig,\n\tAlgonautWallet,\n\tAlgonautTransactionStatus,\n\tAlgonautAtomicTransaction,\n\tAlgonautTransactionFields,\n\tAlgonautAppState,\n\tAlgonautStateData,\n\tAlgonautError,\n\tAlgonautTxnCallbacks,\n\tAlgonautCreateAssetArguments,\n\tAlgonautSendAssetArguments,\n\tAlgonautCallAppArguments,\n\tAlgonautDeployArguments,\n\tAlgonautLsigDeployArguments,\n\tAlgonautLsigCallAppArguments,\n\tAlgonautLsigSendAssetArguments,\n\tAlgonautPaymentArguments,\n\tAlgonautLsigPaymentArguments,\n\tAlgonautUpdateAppArguments,\n\tAlgonautGetApplicationResponse,\n\tAlgonautAppStateEncoded\n} from './AlgonautTypes';\nexport * from './AlgonautTypes';\nexport type AlgoTxn = Transaction;\n\nimport {\n\tAnyWalletState,\n\tinitWallets,\n\tconnectWallet,\n\tdisconnectWallet,\n\tdisconnectAllWallets,\n\trecallState,\n\tsetAsActiveAccount,\n\tsetLogsEnabled as AWSetLogsEnabled,\n\tsignTransactions,\n\tsubscribeToAccountChanges,\n\tWALLET_ID\n} from '@thencc/any-wallet';\nimport type {\n\tAccount,\n\tW_ID,\n\tWalletInitParamsObj\n} from '@thencc/any-wallet';\nexport * from '@thencc/any-wallet';\n\nimport type { createClient } from '@thencc/inkey-client-js';\ntype InkeySdk = Awaited<ReturnType<typeof createClient>>;\n\nimport { defaultNodeConfig, mainnetConfig, testnetConfig } from './algo-config';\nimport { defaultLibConfig } from './constants';\nimport { logger } from './utils';\n\n/*\n\nfor stateful contracts i think we want to read it in and hold all the\nNV pairs as fields\n\nand maybe read the TEAL and make wrapper methods for things we see in\na config file?\n\nTBD:\n\n- standard typed return values\n- standard error values, pre-parse the algo error goop\n\n\nthere are a couple ways to go for atomic txs, i THINK the more pleasant API is\n\nawait runAtomicTransaction([\n\tawait atomicSendASA(),\n\tawait atomicSendAlgo(),\n\tawait atomicCallApp()\n])\n\n*/\n\nlet unsAcctSync = null as null | (() => void);\n\nexport class Algonaut {\n\talgodClient!: Algodv2; // it will be set or it throws an Error\n\tindexerClient = undefined as undefined | Indexer;\n\tnodeConfig = defaultNodeConfig;\n\tlibConfig = defaultLibConfig;\n\n\t// expose entire algosdk in case the dapp needs more\n\tsdk = algosdk;\n\n\t// handles all algo wallets (inkey, pera, etc) + remembers last used in localstorage\n\twalletState = AnyWalletState;\n\tinkeyClientSdk = null as null | InkeySdk;\n\tinkeyLoading = false;\n\tinkeyLoaded = false;\n\n\taccount = null as null | typeof AnyWalletState.activeAccount;\n\tget connectedAccounts() {\n\t\treturn AnyWalletState.connectedAccounts;\n\t}\n\n\t// TODO come back to private class fields during the security pass. + figure out how to make account immutable\n\t// \"#account\" set on aw acct listener (but private fields compile weird..? making a #private field in the type dec)\n\t// #account = null as null | typeof AnyWalletState.activeAccount;\n\t// get account() {\n\t// \treturn this.#account;\n\t// }\n\n\t/**\n\t * Instantiates Algonaut.js.\n\t *\n\t * @example\n\t * Usage:\n\t *\n\t * ```js\n\t * import { Algonaut } from '@thencc/algonautjs';\n\t * const algonaut = new Algonaut({\n\t * \t\tnodeConfig: {\n\t *\t \t\tBASE_SERVER: 'https://testnet-algorand.api.purestake.io/ps2',\n\t *\t \t\tINDEX_SERVER: 'https://testnet-algorand.api.purestake.io/idx2'\n\t *\t \t\tLEDGER: 'TestNet',\n\t *\t \t\tPORT: '',\n\t *\t \t\tAPI_TOKEN: { 'X-API-Key': 'YOUR_API_TOKEN' }\n\t * \t\t}\n\t * });\n\t * ```\n\t *\n\t * @param config config object\n\t */\n\tconstructor(config?: AlgonautConfig) {\n\t\tthis.setNodeConfig(config?.nodeConfig); // makes algod client too\n\t\tthis.initWallets(config?.initWallets);\n\t\tthis.setLibConfig(config?.libConfig);\n\t\tthis.initAcctSync();\n\t}\n\n\tsetLibConfig(libConfig?: AlgonautConfig['libConfig']) {\n\t\t// logger.log('setLibConfig', libConfig);\n\t\tif (libConfig == undefined) {\n\t\t\tlibConfig = defaultLibConfig;\n\t\t}\n\t\tif (libConfig !== undefined) {\n\t\t\tif ('disableLogs' in libConfig && typeof libConfig.disableLogs == 'boolean') {\n\t\t\t\tlogger.enabled = !libConfig.disableLogs;\n\t\t\t\tAWSetLogsEnabled(!libConfig.disableLogs);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * checks if config obj is valid for use\n\t * @param config algonaut config for network + signing mode\n\t * @returns boolean. true is good.\n\t */\n\tisValidNodeConfig(nodeConfig?: AlgonautConfig['nodeConfig']): boolean {\n\t\t// logger.log('isValidNodeConfig?', config);\n\t\tlet isValid = true;\n\n\t\t// do all checks\n\t\tif (nodeConfig == undefined || !nodeConfig.BASE_SERVER) {\n\t\t\tisValid = false;\n\t\t}\n\t\t// FYI some configs dont need an api token\n\n\t\t// TODO add more checks...\n\n\t\treturn isValid;\n\t}\n\n\t/**\n\t * sets config for use (new algod, indexerClient, etc)\n\t * @param config algonaut config for network + signing mode\n\t * \t\t- will throw Error if config is lousy\n\t */\n\tsetNodeConfig(nodeConfig?: AlgonautConfig['nodeConfig'] | 'mainnet' | 'testnet') {\n\t\tlogger.log('setNodeConfig', nodeConfig);\n\n\t\tif (nodeConfig == undefined) {\n\t\t\tnodeConfig = defaultNodeConfig;\n\t\t}\n\n\t\tif (typeof nodeConfig == 'string') {\n\t\t\tif (nodeConfig == 'mainnet') {\n\t\t\t\tnodeConfig = mainnetConfig;\n\t\t\t} else if (nodeConfig == 'testnet') {\n\t\t\t\tnodeConfig = testnetConfig;\n\t\t\t} else {\n\t\t\t\tthrow new Error('bad node config string.');\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isValidNodeConfig(nodeConfig)) {\n\t\t\tthrow new Error('bad node config!');\n\t\t}\n\t\tif (typeof nodeConfig == 'undefined') {\n\t\t\tthrow new Error('node config undefined'); // shouldnt ever happen... but needed to TS to be happy\n\t\t}\n\n\t\tthis.nodeConfig = nodeConfig;\n\t\tthis.algodClient = new Algodv2(nodeConfig.API_TOKEN, nodeConfig.BASE_SERVER, nodeConfig.PORT);\n\n\t\tif (nodeConfig.INDEX_SERVER) {\n\t\t\tthis.indexerClient = new Indexer(nodeConfig.API_TOKEN, nodeConfig.INDEX_SERVER, nodeConfig.PORT);\n\t\t} else {\n\t\t\tconsole.warn('No indexer configured because INDEX_SERVER was not provided.');\n\t\t}\n\t}\n\n\t/**\n\t * @returns nodeConfig object or `false` if no nodeConfig is set\n\t */\n\tgetNodeConfig(): AlgonautConfig['nodeConfig'] | boolean {\n\t\tif (this.nodeConfig) return this.nodeConfig;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks status of Algorand network\n\t * @returns Promise resolving to status of Algorand network\n\t */\n\tasync checkStatus(): Promise<any | AlgonautError> {\n\t\tif (!this.getNodeConfig()) {\n\t\t\tthrow new Error('No node configuration set.');\n\t\t}\n\n\t\tconst status = await this.algodClient.status().do();\n\t\tlogger.log('Algorand network status: %o', status);\n\t\treturn status;\n\t}\n\n\tinitAcctSync() {\n\t\tunsAcctSync = subscribeToAccountChanges(\n\t\t\t(acct) => {\n\t\t\t\tlogger.log('acct changed', acct);\n\t\t\t\tthis.account = acct;\n\t\t\t\t// this.#account = acct; // revisit this for security pass + consider field setting not just entire obj\n\t\t\t}\n\t\t);\n\t}\n\tstopAcctSync() {\n\t\tif (unsAcctSync) unsAcctSync();\n\t}\n\n\t// direct map from any-wallet for ease\n\tsetActiveAccount = setAsActiveAccount;\n\n\tinitWallets(walletInitParams?: AlgonautConfig['initWallets']) {\n\t\tif (walletInitParams == undefined) {\n\t\t\tlogger.debug('.enableWallets called without any init params.');\n\t\t}\n\t\t// default to NONE\n\t\tconst defaultWip: WalletInitParamsObj = {\n\t\t\t// inkey: true, // not even inkey\n\t\t};\n\t\tconst wip = walletInitParams || defaultWip;\n\t\tinitWallets(wip); // defaults to all except mnemonic client\n\t}\n\n\t/**\n\t * @deprecated use .connect() with mnemonic arg\n\t * Recovers account from mnemonic\n\t *  (helpful for rapid development but overall very insecure unless on server-side)\n\t * @param mnemonic Mnemonic associated with Algonaut account\n\t * @returns If mnemonic is valid, it returns the account (address, chain). Otherwise, throws an error.\n\t */\n\tasync mnemonicConnect(mnemonic: string): Promise<Account[]> {\n\t\tif (!mnemonic) throw new Error('algonaut.mnemonicConnect: No mnemonic provided.');\n\t\treturn await this.connect('mnemonic', mnemonic);\n\t}\n\n\t/**\n\t * @deprecated use .connect or loop through enabled wallets' methods\n\t */\n\tasync inkeyConnect(): Promise<Account[]> {\n\t\tconsole.warn('.inkeyConnect is deprecated. please use .connect');\n\t\treturn await this.connect('inkey');\n\t}\n\n\t/**\n\t * @deprecated use .disconnect or loop through enabled wallets' methods\n\t */\n\tasync inkeyDisconnect() {\n\t\tconsole.warn('.inkeyDisconnect is deprecated. please use .disconnect');\n\t\treturn await this.disconnect(WALLET_ID.INKEY);\n\t}\n\n\t/**\n\t * Shows the inkey-wallet modal\n\t * @returns\n\t */\n\tasync inkeyShow(route?: string) {\n\t\tconst ic = await this.getInkeyClientSdk();\n\t\tic.show(route);\n\t}\n\n\t/**\n\t * Hides the inkey-wallet modal\n\t * @returns\n\t */\n\tasync inkeyHide() {\n\t\tconst ic = await this.getInkeyClientSdk();\n\t\tic.hide();\n\t}\n\n\t/**\n\t * Loads and/or returns the inkey-wallet client sdk for whatever use. see inkey-client-js docs for more.\n\t * @returns\n\t */\n\tasync getInkeyClientSdk() {\n\t\tlogger.log('getInkeyClientSdk');\n\t\tif (this.inkeyClientSdk !== null) {\n\t\t\tthis.inkeyLoaded = true;\n\t\t\treturn this.inkeyClientSdk;\n\t\t} else {\n\t\t\t// load it\n\t\t\tconst inkeyW = this.walletState.allWallets.inkey;\n\t\t\tif (!inkeyW) {\n\t\t\t\tconsole.warn('Inkey wallet not enabled by dev');\n\t\t\t\tthrow new Error('Inkey wallet not enabled by dev');\n\t\t\t}\n\n\t\t\tthis.inkeyLoading = true;\n\t\t\tawait inkeyW.loadClient();\n\t\t\tthis.inkeyLoading = false;\n\n\t\t\tconst inkeyClientSdk: InkeySdk = inkeyW.client!.sdk;\n\n\t\t\tif (inkeyClientSdk.frameBus.ready == false) {\n\t\t\t\tlogger.debug('inkeySdk FrameBus not yet ready...');\n\t\t\t\tawait inkeyClientSdk.frameBus.isReady();\n\t\t\t\tlogger.debug('inkeySdk FrameBus IS ready.');\n\t\t\t}\n\n\t\t\tthis.inkeyLoaded = true;\n\t\t\tthis.inkeyClientSdk = inkeyClientSdk;\n\t\t\treturn this.inkeyClientSdk;\n\t\t}\n\t}\n\n\t/**\n\t * connects the given wallet + optional init params\n\t */\n\tconnect = connectWallet;\n\tdisconnect = disconnectWallet;\n\tdisconnectAll = disconnectAllWallets;\n\treconnect = recallState;\n\n\t/**\n\t * General purpose method to await transaction confirmation\n\t * @param txId a string id of the transacion you want to watch\n\t * @param limitDelta how many rounds to wait, defaults to 50\n\t * @param log set to true if you'd like to see \"waiting for confirmation\" log messages\n\t */\n\tasync waitForConfirmation(txId: string, limitDelta?: number, log = false): Promise<AlgonautTransactionStatus> {\n\t\tif (!txId) throw new Error('waitForConfirmation: No transaction ID provided.');\n\n\t\tlet lastround = (await this.algodClient.status().do())['last-round'];\n\t\tconst limit = lastround + (limitDelta ? limitDelta : 50);\n\n\t\tconst returnValue = {\n\t\t\tstatus: 'fail',\n\t\t\tmessage: ''\n\t\t} as AlgonautTransactionStatus;\n\n\t\twhile (lastround < limit) {\n\t\t\tlet pendingInfo = '' as any;\n\t\t\ttry {\n\t\t\t\tpendingInfo = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\t\t\t\tif (log) {\n\t\t\t\t\tlogger.log('waiting for confirmation');\n\t\t\t\t}\n\t\t\t} catch (er: any) {\n\t\t\t\tconsole.error(er.response?.text);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tpendingInfo['confirmed-round'] !== null &&\n\t\t\t\tpendingInfo['confirmed-round'] > 0\n\t\t\t) {\n\n\t\t\t\tif (log) {\n\t\t\t\t\tlogger.log('Transaction confirmed in round ' + pendingInfo['confirmed-round']);\n\t\t\t\t}\n\n\t\t\t\treturnValue.txId = txId;\n\t\t\t\treturnValue.status = 'success';\n\t\t\t\treturnValue.message = 'Transaction confirmed in round ' + pendingInfo['confirmed-round'];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlastround = (await this.algodClient.status().do())['last-round'];\n\t\t}\n\n\t\treturn returnValue;\n\n\t}\n\n\t/**\n\t * Creates a LogicSig from a base64 program string.  Note that this method does not COMPILE\n\t * the program, just builds an LSig from an already compiled base64 result!\n\t * @param base64ProgramString\n\t * @returns an algosdk LogicSigAccount\n\t */\n\tgenerateLogicSig(base64ProgramString: string): LogicSigAccount {\n\t\tif (!base64ProgramString) throw new Error('No program string provided.');\n\n\t\tconst program = new Uint8Array(\n\t\t\tBuffer.from(base64ProgramString, 'base64')\n\t\t);\n\n\t\treturn new LogicSigAccount(program);\n\t}\n\n\tasync atomicOptInAsset(assetIndex: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!this.walletState.activeAddress) throw new Error('No account set in Algonaut.');\n\t\tif (!assetIndex) throw new Error('No asset index provided.');\n\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst optInTransaction = makeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\tfrom: this.walletState.activeAddress,\n\t\t\tto: this.walletState.activeAddress,\n\t\t\tassetIndex: assetIndex,\n\t\t\tamount: 0,\n\t\t\tsuggestedParams,\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: optInTransaction,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Opt-in the current account for the a token or NFT Asset.\n\t * @param assetIndex number of asset to opt-in to\n\t * @param callbacks `AlgonautTxnCallbacks`, passed to {@link sendTransaction}\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync optInAsset(assetIndex: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\tif (!this.walletState.activeAddress) throw new Error('There was no account!');\n\t\tif (!assetIndex) throw new Error('No asset index provided.');\n\t\tconst { transaction } = await this.atomicOptInAsset(assetIndex, optionalTxnArgs);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\n\t// this is a bit harder with the algosdk api\n\t// what we may want to do be more opinionated and have a standard local\n\t// field we always set on apps when opted in\n\n\t// OR maybe we check for HAS STATE which might check for local state\n\t// of any kind on that app id?\n\n\t// async isOptedIntoApp(account: string, appId: number): boolean {\n\t// \tlet optInState = false;\n\n\t// \tconst accountInfo = await this.getAccountInfo(account);\n\t// \taccountInfo.assets.forEach((asset: any) => {\n\t// \t\tif (asset['asset-id'] == assetId) {\n\t// \t\t\toptInState = true;\n\t// \t\t}\n\n\t// \t});\n\n\t// \treturn optInState;\n\t// }\n\n\n\t/**\n\t * You can be opted into an asset but still have a zero balance. Use this call\n\t * for cases where you just need to know the address's opt-in state\n\t * @param args object containing `account` and `assetId` properties\n\t * @returns boolean true if account holds asset\n\t */\n\tasync isOptedIntoAsset(args: { account: string, assetId: number }): Promise<boolean> {\n\t\tif (!args.account) throw new Error('No account provided.');\n\t\tif (!args.assetId) throw new Error('No asset ID provided.');\n\n\t\tlet optInState = false;\n\t\tconst accountInfo = await this.getAccountInfo(args.account);\n\t\taccountInfo.assets.forEach((asset: any) => {\n\t\t\tif (asset['asset-id'] == args.assetId) {\n\t\t\t\toptInState = true;\n\t\t\t}\n\n\t\t});\n\n\t\treturn optInState;\n\t}\n\n\t/**\n\t * Sync function that returns a correctly-encoded argument array for\n\t * an algo transaction\n\t * @param args must be an any[] array, as it will often need to be\n\t * a mix of strings and numbers. Valid types are: string, number, and bigint\n\t * @returns a Uint8Array of encoded arguments\n\t */\n\tencodeArguments(args: any[]): Uint8Array[] {\n\t\tconst encodedArgs = [] as Uint8Array[];\n\n\t\t// loop through args and encode them based on type\n\t\targs.forEach((arg: any) => {\n\t\t\tif (typeof arg == 'number') {\n\t\t\t\tencodedArgs.push(encodeUint64(arg));\n\t\t\t} else if (typeof arg == 'bigint') {\n\t\t\t\tencodedArgs.push(encodeUint64(arg));\n\t\t\t} else if (typeof arg == 'string') {\n\t\t\t\tencodedArgs.push(new Uint8Array(Buffer.from(arg)));\n\t\t\t}\n\t\t});\n\n\t\treturn encodedArgs;\n\t}\n\n\t/**\n\t * Create asset transaction\n\t * @param args : AlgonautCreateAssetArguments obj must contain: `assetName`, `symbol`, `decimals`, `amount`.\n\t * @returns atomic txn to create asset\n\t*/\n\tasync atomicCreateAsset(args: AlgonautCreateAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.assetName) throw new Error('args.assetName not provided.');\n\t\tif (!args.symbol) throw new Error('args.symbol not provided');\n\t\tif (typeof args.decimals == 'undefined') throw new Error('args.decimals not provided.');\n\t\tif (!args.amount) throw new Error('args.amount not provided.');\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tif (!args.metaBlock) {\n\t\t\targs.metaBlock = ' ';\n\t\t}\n\n\t\tif (!args.defaultFrozen) args.defaultFrozen = false;\n\t\tif (!args.assetURL) args.assetURL = undefined;\n\n\t\tconst metaBlockLength = args.metaBlock.length;\n\n\t\tif (metaBlockLength > 1023) {\n\t\t\tconsole.error('meta block is ' + metaBlockLength);\n\t\t\tthrow new Error('drat! this meta block is too long!');\n\t\t}\n\n\t\tconst enc = new TextEncoder();\n\n\t\t// arbitrary data: 1024 bytes, or about 1023 characters\n\t\tconst note = enc.encode(args.metaBlock);\n\t\tconst totalIssuance = args.amount;\n\n\t\t// set accounts\n\t\tconst manager = (args.manager && args.manager.length > 0) ? args.manager : fromAddr;\n\t\tconst reserve = (args.reserve && args.reserve.length > 0) ? args.reserve : fromAddr;\n\t\tconst freeze = (args.freeze && args.freeze.length > 0) ? args.freeze : fromAddr;\n\t\tconst clawback = (args.clawback && args.clawback.length > 0) ? args.clawback : fromAddr;\n\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t// signing and sending \"txn\" allows \"addr\" to create an asset\n\t\tconst txn = makeAssetCreateTxnWithSuggestedParams(\n\t\t\tfromAddr,\n\t\t\tnote,\n\t\t\ttotalIssuance,\n\t\t\targs.decimals,\n\t\t\targs.defaultFrozen,\n\t\t\tmanager,\n\t\t\treserve,\n\t\t\tfreeze,\n\t\t\tclawback,\n\t\t\targs.symbol,\n\t\t\targs.assetName,\n\t\t\targs.assetURL,\n\t\t\targs.assetMetadataHash,\n\t\t\tsuggestedParams\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: txn,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\n\t/**\n\t * Create asset\n\t * @param args AlgonautCreateAssetArguments. Must pass `assetName`, `symbol`, `decimals`, `amount`.\n\t * @param callbacks AlgonautTxnCallbacks\n\t * @returns asset index\n\t*/\n\tasync createAsset(\n\t\targs: AlgonautCreateAssetArguments,\n\t\tcallbacks?: AlgonautTxnCallbacks\n\t): Promise<AlgonautTransactionStatus> {\n\t\tconst atomicTxn = await this.atomicCreateAsset(args);\n\t\tconst txn = atomicTxn.transaction;\n\n\t\ttry {\n\t\t\t// const assetID = null;\n\t\t\tconst txStatus = await this.sendTransaction(txn, callbacks);\n\n\t\t\tconst ptx = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(txn.txID().toString())\n\t\t\t\t.do();\n\t\t\ttxStatus.createdIndex = ptx['asset-index'];\n\n\t\t\treturn txStatus;\n\n\t\t} catch (er) {\n\t\t\tlogger.log('transaction error');\n\t\t\tlogger.log(er);\n\t\t\tthrow new Error(er as any);\n\t\t}\n\t}\n\n\tasync atomicDeleteAsset(assetId: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!this.walletState.activeAddress) throw new Error('there was no account!');\n\t\tif (!assetId) throw new Error('No assetId provided!');\n\n\t\tconst enc = new TextEncoder();\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst transaction = makeAssetDestroyTxnWithSuggestedParams(\n\t\t\tthis.walletState.activeAddress,\n\t\t\tenc.encode('doh!'), // what is this?\n\t\t\tassetId,\n\t\t\tsuggestedParams,\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: transaction,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Deletes asset\n\t * @param assetId Index of the ASA to delete\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync deleteAsset(assetId: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\tif (!assetId) throw new Error('No asset ID provided!');\n\t\tconst { transaction } = await this.atomicDeleteAsset(assetId, optionalTxnArgs);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Creates send asset transaction.\n\t *\n\t * IMPORTANT: Before you can call this, the target account has to \"opt-in\"\n\t * to the ASA index.  You can't just send ASAs to people blind!\n\t *\n\t * @param args - object containing `to`, `assetIndex`, and `amount` properties\n\t * @returns Promise resolving to `AlgonautAtomicTransaction`\n\t */\n\tasync atomicSendAsset(args: AlgonautSendAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.to) throw new Error('No to address provided');\n\t\tif (!isValidAddress(args.to)) throw new Error('Invalid to address');\n\t\tif (!args.assetIndex) throw new Error('No asset index provided');\n\t\tif (!(typeof args.amount == 'bigint' || typeof args.amount == 'number')) {\n\t\t\tthrow new Error('Amount has to be a number.');\n\t\t}\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst transaction =\n\t\t\tmakeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\tfrom: fromAddr,\n\t\t\t\tto: args.to,\n\t\t\t\tamount: args.amount,\n\t\t\t\tassetIndex: args.assetIndex,\n\t\t\t\tsuggestedParams\n\t\t\t});\n\n\t\treturn {\n\t\t\ttransaction: transaction,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Sends asset to an address.\n\t *\n\t * IMPORTANT: Before you can call this, the target account has to \"opt-in\"\n\t * to the ASA index.  You can't just send ASAs to people blind!\n\t *\n\t * @param args - object containing `to`, `assetIndex`, and `amount` properties\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync sendAsset(args: AlgonautSendAssetArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tconst { transaction } = await this.atomicSendAsset(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Get info about an asset\n\t * @param assetIndex\n\t * @returns\n\t */\n\tasync getAssetInfo(assetIndex: number): Promise<any> {\n\t\tif (!assetIndex) throw new Error('No asset ID provided');\n\n\t\tconst info = await this.algodClient.getAssetByID(assetIndex).do();\n\t\treturn info;\n\t}\n\n\t/**\n\t * Creates transaction to opt into an app\n\t * @param args AlgonautCallAppArgs\n\t * @returns AlgonautAtomicTransaction\n\t */\n\tasync atomicOptInApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.appIndex) throw new Error('No app ID provided');\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst optInTransaction = makeApplicationOptInTxnFromObject({\n\t\t\tfrom: fromAddr,\n\t\t\tappIndex: args.appIndex,\n\t\t\tsuggestedParams,\n\t\t\tappArgs: args.appArgs ? this.encodeArguments(args.appArgs) : undefined,\n\t\t\taccounts: args.optionalFields?.accounts ? args.optionalFields?.accounts : undefined,\n\t\t\tforeignApps: args.optionalFields?.applications ? args.optionalFields?.applications : undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets ? args.optionalFields?.assets : undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: optInTransaction,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Opt-in the current account for an app.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields`\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync optInApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicOptInApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Returns atomic transaction that deletes application\n\t * @param appIndex - ID of application\n\t * @returns Promise resolving to atomic transaction that deletes application\n\t */\n\tasync atomicDeleteApp(appIndex: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!appIndex) throw new Error('No app ID provided');\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst txn = makeApplicationDeleteTxn(fromAddr, suggestedParams, appIndex);\n\n\t\treturn {\n\t\t\ttransaction: txn,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Deletes an application from the blockchain\n\t * @param appIndex - ID of application\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync deleteApp(appIndex: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\ttry {\n\t\t\tconst { transaction } = await this.atomicDeleteApp(appIndex, optionalTxnArgs);\n\t\t\tconst txId = transaction.txID().toString();\n\n\t\t\t// display results\n\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t.do();\n\t\t\tconst appId = transactionResponse['txn']['txn'].apid;\n\n\t\t\treturn {\n\t\t\t\tstatus: 'success',\n\t\t\t\tmessage: 'deleted app index ' + appId,\n\t\t\t\ttxId\n\t\t\t};\n\n\t\t} catch (e: any) {\n\t\t\tlogger.log(e);\n\t\t\tthrow new Error(e.response?.text);\n\t\t}\n\t}\n\n\tasync atomicCallApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = args?.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\t\tif (!args.appArgs.length) throw new Error('Must provide at least one appArgs');\n\n\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst callAppTransaction = makeApplicationNoOpTxnFromObject({\n\t\t\tfrom: fromAddr,\n\t\t\tsuggestedParams,\n\t\t\tappIndex: args.appIndex,\n\t\t\tappArgs: processedArgs,\n\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets || undefined,\n\t\t\tnote: args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: callAppTransaction,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Call a \"method\" on a stateful contract.  In TEAL, you're really giving\n\t * an argument which branches to a specific place and reads the other args\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t */\n\tasync callApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicCallApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\tasync atomicCallAppWithLSig(args: AlgonautLsigCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\t\tif (!args.appArgs.length) throw new Error('Must provide at least one appArgs');\n\n\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst callAppTransaction = makeApplicationNoOpTxnFromObject({\n\t\t\tfrom: args.lsig.address(),\n\t\t\tsuggestedParams,\n\t\t\tappIndex: args.appIndex,\n\t\t\tappArgs: processedArgs,\n\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: callAppTransaction,\n\t\t\tisLogigSig: true,\n\t\t\tlSig: args.lsig,\n\t\t};\n\t}\n\n\t/**\n\t * Returns an atomic transaction that closes out the user's local state in an application.\n\t * The opposite of {@link atomicOptInApp}.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t * @returns Promise resolving to atomic transaction\n\t */\n\tasync atomicCloseOutApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = args?.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\n\t\ttry {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\t\tconst closeOutTxn = makeApplicationCloseOutTxnFromObject({\n\t\t\t\tfrom: fromAddr,\n\t\t\t\tsuggestedParams,\n\t\t\t\tappIndex: args.appIndex,\n\t\t\t\tappArgs: processedArgs,\n\t\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: closeOutTxn,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\t\t} catch (e: any) {\n\t\t\tthrow new Error(e);\n\t\t}\n\t}\n\n\t/**\n\t * Closes out the user's local state in an application.\n\t * The opposite of {@link optInApp}.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to atomic transaction\n\t */\n\tasync closeOutApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks) {\n\t\tconst { transaction } = await this.atomicCloseOutApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Get an application's escrow account\n\t * @param appId - ID of application\n\t * @returns Escrow account address as string\n\t */\n\tgetAppEscrowAccount(appId: number | bigint): string {\n\t\tif (!appId) throw new Error('No appId provided');\n\t\treturn getApplicationAddress(appId);\n\t}\n\n\t/**\n\t * Get info about an application (globals, locals, creator address, index)\n\t *\n\t * @param appId - ID of application\n\t * @returns Promise resolving to application state\n\t */\n\tasync getAppInfo(appId: number): Promise<AlgonautAppState> {\n\t\tif (!appId) throw new Error('No appId provided');\n\n\t\tconst proms = [\n\t\t\tthis.algodClient.getApplicationByID(appId).do(),\n\t\t] as Promise<any>[];\n\n\t\tconst addr = this.walletState.activeAddress;\n\t\t// get locals if we have an account\n\t\tif (addr) {\n\t\t\tproms.push(this.getAppLocalState(appId)); // TODO get rid of this call / only return locals (not incorrect duplicate state obj)\n\t\t}\n\n\t\tconst promsRes = await Promise.all(proms);\n\t\tconst info = promsRes[0] as AlgonautGetApplicationResponse;\n\t\tconst localState = promsRes[1] as AlgonautAppState | void;\n\n\t\t// decode state\n\t\tconst state = {\n\t\t\thasState: true,\n\t\t\tglobals: [],\n\t\t\tlocals: localState?.locals || [],\n\t\t\tcreatorAddress: info.params.creator,\n\t\t\tindex: appId\n\t\t} as AlgonautAppState;\n\n\t\tif (info.params['global-state']) {\n\t\t\tstate.globals = this.decodeStateArray(info.params['global-state']);\n\t\t}\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Create and deploy a new Smart Contract from TEAL code\n\t *\n\t * @param args AlgonautDeployArguments\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns AlgonautTransactionStatus\n\t */\n\tasync createApp(\n\t\targs: AlgonautDeployArguments,\n\t\tcallbacks?: AlgonautTxnCallbacks\n\t): Promise<AlgonautTransactionStatus> {\n\t\tif (args.optionalFields &&\n\t\t\targs.optionalFields.note &&\n\t\t\targs.optionalFields.note.length > 1023) {\n\t\t\tconsole.warn('drat! your note is too long!');\n\t\t\tthrow new Error('Your note is too long');\n\t\t}\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (!args.schema) throw new Error('No schema provided');\n\n\t\ttry {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\t\t\t// logger.log('approval', approvalProgram);\n\t\t\t// logger.log('clear', clearProgram);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (approvalProgram && clearProgram) {\n\n\t\t\t\tconst txn = makeApplicationCreateTxnFromObject({\n\t\t\t\t\tfrom: fromAddr,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete: OnApplicationComplete.NoOpOC,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\tnumLocalInts: args.schema.localInts,\n\t\t\t\t\tnumLocalByteSlices: args.schema.localBytes,\n\t\t\t\t\tnumGlobalInts: args.schema.globalInts,\n\t\t\t\t\tnumGlobalByteSlices: args.schema.globalBytes,\n\t\t\t\t\tappArgs: this.encodeArguments(args.appArgs),\n\t\t\t\t\taccounts: args.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\t\tforeignApps: args.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\t\tforeignAssets: args.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\t\tnote: args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t\t});\n\t\t\t\tconst txId = txn.txID().toString();\n\n\t\t\t\t// Wait for confirmation\n\t\t\t\tconst result = await this.sendTransaction(txn, callbacks);\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\n\t\t\t\tresult.message = 'Created App ID: ' + transactionResponse['application-index'];\n\t\t\t\tresult.createdIndex = transactionResponse['application-index'];\n\t\t\t\tresult.meta = transactionResponse;\n\t\t\t\tresult.txId = txId;\n\t\t\t\treturn result;\n\n\t\t\t} else {\n\t\t\t\tthrow new Error('could not compile teal code');\n\t\t\t}\n\n\t\t} catch (er: any) {\n\t\t\tthrow new Error(er.message);\n\t\t}\n\t}\n\n\t/**\n\t * Create an atomic transaction to deploy a\n\t * new Smart Contract from TEAL code\n\t *\n\t * @param args AlgonautDeployArguments\n\t * @returns AlgonautAtomicTransaction\n\t */\n\tasync atomicCreateApp(args: AlgonautDeployArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (!args.schema) throw new Error('No schema provided');\n\n\t\tif (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {\n\t\t\tthrow new Error('Your NOTE is too long, it must be less thatn 1024 Bytes');\n\t\t} else if (fromAddr) {\n\t\t\ttry {\n\t\t\t\tconst onComplete = OnApplicationComplete.NoOpOC;\n\t\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t\t// create unsigned transaction\n\t\t\t\tif (!approvalProgram || !clearProgram) {\n\t\t\t\t\tthrow new Error('Error: you must provide an approval program and a clear state program.');\n\t\t\t\t}\n\n\t\t\t\tconst applicationCreateTransaction = makeApplicationCreateTxn(\n\t\t\t\t\tfromAddr,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\t\targs.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t\t);\n\n\t\t\t\treturn {\n\t\t\t\t\ttransaction: applicationCreateTransaction,\n\t\t\t\t\tisLogigSig: false\n\t\t\t\t};\n\n\t\t\t} catch (er: any) {\n\t\t\t\tthrow new Error('There was an error creating the transaction');\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Algonaut.js has no account loaded!');\n\t\t}\n\t}\n\n\n\t/**\n\t * deploys a contract from an lsig account\n\t * keep in mind that the local and global byte and int values have caps,\n\t * 16 for local and 32 for global and that the cost of deploying the\n\t * app goes up based on how many of these slots you want to allocate\n\t *\n\t * @param args AlgonautLsigDeployArguments\n\t * @returns\n\t */\n\tasync deployTealWithLSig(\n\t\targs: AlgonautLsigDeployArguments\n\t): Promise<AlgonautTransactionStatus> {\n\t\tif (args.noteText && args.noteText.length > 511) {\n\t\t\tthrow new Error('Your note is too long');\n\t\t}\n\n\t\tlet encodedArgs = [] as Uint8Array[];\n\t\tif (args.appArgs && args.appArgs.length) {\n\t\t\tencodedArgs = this.encodeArguments(args.appArgs);\n\t\t}\n\n\t\tconst sender = args.lsig.address();\n\t\tconst onComplete = OnApplicationComplete.NoOpOC;\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tlet approvalProgram = new Uint8Array();\n\t\tlet clearProgram = new Uint8Array();\n\n\t\ttry {\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (approvalProgram && clearProgram) {\n\t\t\t\tconst txn = makeApplicationCreateTxn(\n\t\t\t\t\tsender,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tencodedArgs,\n\t\t\t\t\targs.optionalFields?.accounts || undefined\n\t\t\t\t);\n\n\t\t\t\tconst txId = txn.txID().toString();\n\t\t\t\tconst signedTxn = signLogicSigTransactionObject(txn, args.lsig);\n\n\t\t\t\tawait this.algodClient.sendRawTransaction(signedTxn.blob).do();\n\n\t\t\t\t// TBD check txStatus\n\t\t\t\t// const txStatus = await this.waitForConfirmation(txId);\n\n\t\t\t\t// display results\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\t\t\t\tconst appId = transactionResponse['application-index'];\n\n\t\t\t\treturn {\n\t\t\t\t\tstatus: 'success',\n\t\t\t\t\tmessage: 'created new app with id: ' + appId,\n\t\t\t\t\ttxId\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthrow new Error('Error compiling programs.');\n\t\t\t}\n\t\t} catch (er: any) {\n\t\t\tconsole.error('Error deploying contract:');\n\t\t\tthrow new Error(er);\n\t\t}\n\t}\n\n\t/**\n\t * Updates an application with `makeApplicationUpdateTxn`\n\t * @param args AlgonautUpdateAppArguments\n\t * @returns atomic transaction that updates the app\n\t */\n\tasync atomicUpdateApp(args: AlgonautUpdateAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {\n\t\t\tthrow new Error('Your NOTE is too long, it must be less thatn 1024 Bytes');\n\t\t}\n\n\t\ttry {\n\t\t\t// const onComplete = OnApplicationComplete.NoOpOC;\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (!approvalProgram || !clearProgram) {\n\t\t\t\tthrow new Error('Error: you must provide an approval program and a clear state program.');\n\t\t\t}\n\n\t\t\tconst applicationCreateTransaction = makeApplicationUpdateTxn(\n\t\t\t\tfromAddr,\n\t\t\t\tsuggestedParams,\n\t\t\t\targs.appIndex,\n\t\t\t\tapprovalProgram,\n\t\t\t\tclearProgram,\n\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\targs.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\ttransaction: applicationCreateTransaction,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\n\t\t} catch (er: any) {\n\t\t\tthrow new Error('There was an error creating the transaction');\n\t\t}\n\t}\n\n\t/**\n\t * Sends an update app transaction\n\t * @param args AlgonautUpdateAppArguments\n\t * @param callbacks optional callbacks: `onSign`, `onSend`, `onConfirm`\n\t * @returns transaction status\n\t */\n\tasync updateApp(args: AlgonautUpdateAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicUpdateApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Compiles TEAL source via [algodClient.compile](https://py-algorand-sdk.readthedocs.io/en/latest/algosdk/v2client/algod.html#v2client.algod.AlgodClient.compile)\n\t * @param programSource source to compile\n\t * @returns Promise resolving to Buffer of compiled bytes\n\t */\n\tasync compileProgram(programSource: string): Promise<Uint8Array> {\n\t\tconst encoder = new TextEncoder();\n\t\tconst programBytes = encoder.encode(programSource);\n\t\tconst compileResponse = await this.algodClient.compile(programBytes).do();\n\t\tconst compiledBytes = new Uint8Array(\n\t\t\tBuffer.from(compileResponse.result, 'base64')\n\t\t);\n\t\treturn compiledBytes;\n\t}\n\n\tasync atomicSendAlgo(args: AlgonautPaymentArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!(typeof args.amount == 'bigint' || typeof args.amount == 'number')) {\n\t\t\tthrow new Error('Amount has to be a number.');\n\t\t}\n\t\tif (!args.to) throw new Error('You did not specify a to address');\n\t\tif (!isValidAddress(args.to)) throw new Error('Invalid to address');\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tif (fromAddr) {\n\t\t\tconst encodedNote = args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : new Uint8Array();\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tconst transaction =\n\t\t\t\tmakePaymentTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: fromAddr,\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tnote: encodedNote,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no fromAddr');\n\t\t}\n\t}\n\n\t/**\n\t * Sends ALGO from own account to `args.to`\n\t *\n\t * @param args `AlgonautPaymentArgs` object containing `to`, `amount`, and optional `note`\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to transaction status\n\t */\n\tasync sendAlgo(args: AlgonautPaymentArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicSendAlgo(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Fetch full account info for an account\n\t * @param address the accress to read info for\n\t * @returns Promise of type AccountInfo\n\t */\n\tasync getAccountInfo(address: string): Promise<any> {\n\t\tif (!address) throw new Error('No address provided');\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\treturn accountInfo;\n\t}\n\n\n\t/**\n\t * Checks Algo balance of account\n\t * @param address - Wallet of balance to check\n\t * @returns Promise resolving to Algo balance\n\t */\n\tasync getAlgoBalance(address: string): Promise<any> {\n\t\tif (!address) throw new Error('No address provided');\n\t\t//logger.log('checking algo balance');\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\treturn accountInfo.amount;\n\t}\n\n\t/**\n\t * Checks token balance of account\n\t * @param address - Wallet of balance to check\n\t * @param assetIndex - the ASA index\n\t * @returns Promise resolving to token balance\n\t */\n\tasync getTokenBalance(address: string, assetIndex: number): Promise<number> {\n\t\tif (!address) throw new Error('No address provided');\n\t\tif (!assetIndex) throw new Error('No asset index provided');\n\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\t//logger.log('accountInfo', accountInfo);\n\n\t\tlet bal = 0;\n\t\taccountInfo.assets.forEach((asset: any) => {\n\t\t\tif (asset['asset-id'] == assetIndex) {\n\t\t\t\tbal = asset.amount;\n\t\t\t}\n\t\t});\n\n\t\treturn bal;\n\t}\n\n\t/**\n\t * Checks if account has at least one token (before playback)\n\t * Keeping this here in case this is a faster/less expensive operation than checking actual balance\n\t * @param address - Address to check\n\t * @param assetIndex - the index of the ASA\n\t */\n\tasync accountHasTokens(address: string, assetIndex: number): Promise<boolean> {\n\t\tconst bal = await this.getTokenBalance(address, assetIndex);\n\t\tif (bal > 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Gets global state for an application.\n\t * @param applicationIndex - the applications index\n\t * @returns {object} object representing global state\n\t */\n\tasync getAppGlobalState(applicationIndex: number): Promise<any> {\n\t\tif (!applicationIndex) throw new Error('No application ID provided');\n\n\t\tconst info = await this.getAppInfo(applicationIndex);\n\t\tif (info.hasState) {\n\t\t\treturn this.stateArrayToObject(info.globals);\n\t\t} else {\n\t\t\treturn {} as any;\n\t\t}\n\t}\n\n\t/**\n\t * Gets account local state for an app. Defaults to AnyWallets.activeAddress unless\n\t * an address is provided.\n\t * @param applicationIndex the applications index\n\t */\n\tasync getAppLocalState(applicationIndex: number, address?: string): Promise<AlgonautAppState | void> {\n\t\tif (!applicationIndex) throw new Error('No application ID provided');\n\n\t\tconst state = {\n\t\t\thasState: false,\n\t\t\tglobals: [],\n\t\t\tlocals: [],\n\t\t\tcreatorAddress: '',\n\t\t\tindex: applicationIndex\n\t\t} as AlgonautAppState;\n\n\t\t// read state\n\n\t\t// can we detect addresses values and auto-convert them?\n\t\t// maybe a 32-byte field gets an address field added?\n\n\t\tif (this.walletState.activeAddress && !address) {\n\t\t\taddress = this.walletState.activeAddress;\n\t\t}\n\n\t\tif (address) {\n\t\t\tconst accountInfoResponse = await this.algodClient\n\t\t\t\t.accountInformation(address)\n\t\t\t\t.do();\n\n\t\t\t//logger.log(accountInfoResponse);\n\n\t\t\tfor (let i = 0; i < accountInfoResponse['apps-local-state'].length; i++) {\n\t\t\t\tif (accountInfoResponse['apps-local-state'][i].id == applicationIndex) {\n\t\t\t\t\t//logger.log('Found Application');\n\n\t\t\t\t\tstate.hasState = true;\n\n\t\t\t\t\tfor (let n = 0; n < accountInfoResponse['apps-local-state'][i]['key-value'].length; n++) {\n\n\t\t\t\t\t\tconst stateItem = accountInfoResponse['apps-local-state'][i]['key-value'][n];\n\t\t\t\t\t\tconst key = Buffer.from(stateItem.key, 'base64').toString();\n\t\t\t\t\t\tconst type = stateItem.value.type;\n\t\t\t\t\t\tlet value = undefined as undefined | string | number;\n\t\t\t\t\t\tlet valueAsAddr = '';\n\n\t\t\t\t\t\tif (type == 1) {\n\t\t\t\t\t\t\tvalue = Buffer.from(stateItem.value.bytes, 'base64').toString();\n\t\t\t\t\t\t\tvalueAsAddr = encodeAddress(Buffer.from(stateItem.value.bytes, 'base64'));\n\n\t\t\t\t\t\t} else if (stateItem.value.type == 2) {\n\t\t\t\t\t\t\tvalue = stateItem.value.uint;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.locals.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tvalue: value || '',\n\t\t\t\t\t\t\taddress: valueAsAddr\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn state;\n\t\t} else {\n\t\t\t// throw new Error('No address provided, and no account set.');\n\t\t\tconsole.warn('Algonaut used in non-authd state, not getting local vars');\n\t\t}\n\t}\n\n\tasync atomicAssetTransferWithLSig(args: AlgonautLsigSendAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (args.lsig) {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tconst transaction =\n\t\t\t\tmakeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tassetIndex: args.assetIndex,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\tisLogigSig: true,\n\t\t\t\tlSig: args.lsig,\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no logic sig object!');\n\t\t}\n\t}\n\n\tasync atomicPaymentWithLSig(args: AlgonautLsigPaymentArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (args.lsig) {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\t\tconst transaction =\n\t\t\t\tmakePaymentTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\tisLogigSig: true,\n\t\t\t\tlSig: args.lsig,\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no account!');\n\t\t}\n\t}\n\n\tnormalizeTxns(txnOrTxns: Transaction | AlgonautAtomicTransaction | AlgonautAtomicTransaction[]) {\n\t\tlogger.log('normalizeTxns', txnOrTxns);\n\n\t\tlet txnArr: (AlgonautAtomicTransaction | Transaction)[] = [];\n\n\t\tif (!Array.isArray(txnOrTxns)) {\n\t\t\ttxnArr = [txnOrTxns];\n\t\t} else {\n\t\t\ttxnArr = txnOrTxns;\n\t\t}\n\t\t// logger.log('txnArr', txnArr);\n\n\t\tlet algoTxnArr: Transaction[] = [];\n\t\talgoTxnArr = txnArr.map((t) => {\n\t\t\tlet nativeT = (t as AlgonautAtomicTransaction).transaction as Transaction | undefined;\n\t\t\tif (nativeT == undefined) {\n\t\t\t\tnativeT = t as Transaction;\n\t\t\t}\n\t\t\treturn nativeT;\n\t\t});\n\t\tlogger.log('algoTxnArr', [...algoTxnArr]);\n\n\t\t// assign txn(s) a group id\n\t\tif (algoTxnArr.length > 1) {\n\t\t\talgoTxnArr = algosdk.assignGroupID(algoTxnArr);\n\t\t\tlogger.log('added group id to txn array');\n\t\t\tif (algoTxnArr[0].group) {\n\t\t\t\tconst gId = this.txnBuffToB64(algoTxnArr[0].group);\n\t\t\t\tlogger.log('gId', gId);\n\t\t\t}\n\t\t}\n\n\t\tconst txnBuffArr = algoTxnArr.map(t => t.toByte());\n\t\tlogger.log('txnBuffArr', txnBuffArr);\n\n\t\treturn txnBuffArr;\n\t}\n\n\t/**\n\t * Signs a transaction or multiple w the correct wallet according to AW (does not send / submit txn(s) to network)\n\t * @param txnOrTxns Either an array of atomic transactions or a single transaction to sign\n\t * @param signedTxns array of\n\t * @returns Promise resolving to AlgonautTransactionStatus\n\t */\n\tasync signTransaction(txnOrTxns: AlgonautAtomicTransaction[] | Transaction | AlgonautAtomicTransaction): Promise<Uint8Array[]> {\n\t\tconst awTxnsToSign = this.normalizeTxns(txnOrTxns);\n\t\tlogger.log('awTxnsToSign', awTxnsToSign);\n\t\tlet awTxnsSigned: Uint8Array[];\n\t\ttry {\n\t\t\tawTxnsSigned = await signTransactions(awTxnsToSign);\n\t\t\tlogger.log('awTxnsSigned', awTxnsSigned);\n\t\t} catch (e) {\n\t\t\tconsole.warn('err signing txns...');\n\t\t\tlogger.log(e);\n\t\t\tthrow new Error('Error signing transactions');\n\t\t}\n\t\treturn awTxnsSigned;\n\t}\n\n\t/**\n\t * Sends a transaction or multiple w the correct wallet according to AW\n\t * @param txnOrTxns Either an array of atomic transactions or a single transaction to sign\n\t * @param callbacks Optional object with callbacks - `onSign`, `onSend`, and `onConfirm`\n\t * @returns Promise resolving to AlgonautTransactionStatus\n\t */\n\tasync sendTransaction(txnOrTxns: AlgonautAtomicTransaction[] | Transaction | AlgonautAtomicTransaction, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\t/**\n\t\t * 1. normalize incoming txn(s) to array of Uint8Arrs\n\t\t * 2. sign w AW\n\t\t * 3. send Raw txn arr\n\t\t * 4. return result + txid\n\t\t */\n\n\t\tconst awTxnsSigned = await this.signTransaction(txnOrTxns);\n\n\t\tif (callbacks?.onSign) callbacks.onSign(awTxnsSigned);\n\n\t\tconst tx = await this.algodClient.sendRawTransaction(awTxnsSigned).do();\n\n\t\tif (callbacks?.onSend) callbacks.onSend(tx);\n\n\t\t// Wait for transaction to be confirmed\n\t\tconst txStatus = await this.waitForConfirmation(tx.txId);\n\n\t\tconst transactionResponse = await this.algodClient\n\t\t\t.pendingTransactionInformation(tx.txId)\n\t\t\t.do();\n\t\ttxStatus.meta = transactionResponse;\n\n\t\tif (callbacks?.onConfirm) callbacks.onConfirm(txStatus);\n\t\treturn txStatus;\n\t}\n\n\t/**\n\t *\n\t * @param str string\n\t * @param enc the encoding type of the string (defaults to utf8)\n\t * @returns string encoded as Uint8Array\n\t */\n\ttoUint8Array(str: string, enc: BufferEncoding = 'utf8'): Uint8Array {\n\t\treturn new Uint8Array(Buffer.from(str, enc));\n\t}\n\n\t/**\n\t * @deprecated use toUint8Array instead.\n\t * @param str string\n\t * @param enc the encoding type of the string (defaults to utf8)\n\t * @returns string encoded as Uint8Array\n\t */\n\tto8Arr(str: string, enc: BufferEncoding = 'utf8'): Uint8Array {\n\t\treturn this.toUint8Array(str, enc);\n\t}\n\n\t/**\n\t * Helper function to turn `globals` and `locals` array into more useful objects\n\t *\n\t * @param stateArray State array returned from functions like {@link getAppInfo}\n\t * @returns A more useful object: `{ array[0].key: array[0].value, array[1].key: array[1].value, ... }`\n\t * TODO add correct typing for this method\n\t */\n\tstateArrayToObject(stateArray: object[]): any {\n\t\tconst stateObj = {} as any;\n\t\tstateArray.forEach((value: any) => {\n\t\t\tif (value.key) stateObj[value.key] = value.value || null;\n\t\t});\n\t\treturn stateObj;\n\t}\n\n\t/**\n\t * Used for decoding state\n\t * @param encoded Base64 string\n\t * @returns Human-readable string\n\t */\n\tb64StrToHumanStr(encoded: string): string {\n\t\treturn Buffer.from(encoded, 'base64').toString();\n\t}\n\n\t/**\n\t * @deprecated Use b64StrToHumanStr instead\n\t * @param encoded Base64 string\n\t * @returns Human-readable string\n\t */\n\tfromBase64(encoded: string): string {\n\t\treturn this.b64StrToHumanStr(encoded);\n\t}\n\n\t/**\n\t * Decodes a Base64-encoded Uint8 Algorand address and returns a string\n\t * @param encoded An encoded Algorand address\n\t * @returns Decoded address\n\t */\n\tvalueAsAddr(encoded: string): string {\n\t\treturn encodeAddress(Buffer.from(encoded, 'base64'));\n\t}\n\n\t/**\n\t * Decodes app state into a human-readable format\n\t * @param stateArray Encoded app state\n\t * @returns Array of objects with key, value, and address properties\n\t */\n\tdecodeStateArray(stateArray: AlgonautAppStateEncoded[]) {\n\t\tconst result: AlgonautStateData[] = [];\n\n\t\tfor (let n = 0;\n\t\t\tn < stateArray.length;\n\t\t\tn++) {\n\n\t\t\tconst stateItem = stateArray[n];\n\n\t\t\tconst key = this.b64StrToHumanStr(stateItem.key);\n\t\t\tconst type = stateItem.value.type;\n\t\t\tlet value = undefined as undefined | string | number;\n\t\t\tlet valueAsAddr = '';\n\n\t\t\tif (type == 1) {\n\t\t\t\tvalue = this.b64StrToHumanStr(stateItem.value.bytes);\n\t\t\t\tvalueAsAddr = this.valueAsAddr(stateItem.value.bytes);\n\n\t\t\t} else if (stateItem.value.type == 2) {\n\t\t\t\tvalue = stateItem.value.uint;\n\t\t\t}\n\n\t\t\tresult.push({\n\t\t\t\tkey: key,\n\t\t\t\tvalue: value || '',\n\t\t\t\taddress: valueAsAddr\n\t\t\t});\n\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Does what it says on the tin.\n\t * @param txn base64-encoded unsigned transaction\n\t * @returns transaction object\n\t */\n\tdecodeBase64UnsignedTransaction(txn: string): Transaction {\n\t\treturn decodeUnsignedTransaction(Buffer.from(txn, 'base64'));\n\t}\n\n\t/**\n\t * Describes an Algorand transaction, for display in Inkey\n\t * @param txn Transaction to describe\n\t */\n\ttxnSummary(txn: Transaction) {\n\t\t// for reference: https://developer.algorand.org/docs/get-details/transactions/transactions/\n\n\t\tif (txn.type) {\n\t\t\tconst to = txn.to ? encodeAddress(txn.to.publicKey) : '';\n\t\t\tconst from = txn.from ? encodeAddress(txn.from.publicKey) : '';\n\n\t\t\t// sending algo\n\t\t\tif (txn.type === 'pay') {\n\t\t\t\tif (txn.amount) {\n\t\t\t\t\treturn `Send ${microalgosToAlgos(txn.amount as number)} ALGO to ${to}`;\n\t\t\t\t} else {\n\t\t\t\t\treturn `Send 0 ALGO to ${to}`;\n\t\t\t\t}\n\n\t\t\t\t// sending assets\n\t\t\t} else if (txn.type === 'axfer') {\n\t\t\t\tif (!txn.amount && to === from) {\n\t\t\t\t\treturn `Opt-in to asset ID ${txn.assetIndex}`;\n\t\t\t\t} else {\n\t\t\t\t\tconst amount = txn.amount ? txn.amount : 0;\n\t\t\t\t\treturn `Transfer ${amount} of asset ID ${txn.assetIndex} to ${to}`;\n\t\t\t\t}\n\n\t\t\t\t// asset config\n\t\t\t\t// this could be creating, destroying, or configuring an asset,\n\t\t\t\t// depending on which fields are set\n\t\t\t} else if (txn.type === 'acfg') {\n\n\t\t\t\t// if unit name is supplied, we are creating\n\t\t\t\tif (txn.assetUnitName) {\n\t\t\t\t\treturn `Create asset ${txn.assetName}, symbol ${txn.assetUnitName}`;\n\t\t\t\t}\n\n\t\t\t\treturn `Configure asset ${txn.assetIndex}`;\n\n\t\t\t\t// asset freeze\n\t\t\t} else if (txn.type === 'afrz') {\n\t\t\t\treturn `Freeze asset ${txn.assetIndex}`;\n\n\t\t\t\t// application call\n\t\t\t} else if (txn.type === 'appl') {\n\t\t\t\t// let's find out what kind of application call this is\n\t\t\t\t// reference: https://developer.algorand.org/docs/get-details/dapps/avm/teal/specification/#oncomplete\n\t\t\t\tswitch (txn.appOnComplete) {\n\t\t\t\t\t// NoOp\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturn `Call to application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// OptIn\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn `Opt-in to application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// CloseOut\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn `Close out application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// ClearState\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturn `Execute clear state program of application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// Update\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\treturn `Update application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// Delete\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\treturn `Delete application ID ${txn.appIndex}`;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (txn.appIndex == undefined) {\n\t\t\t\t\t\t\t// Create\n\t\t\t\t\t\t\treturn 'Create an application';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn `Call to application ID ${txn.appIndex}`;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// default case\n\t\t\t} else {\n\t\t\t\treturn `Transaction of type ${txn.type} to ${to}`;\n\t\t\t}\n\t\t} else {\n\t\t\t// no better option\n\t\t\treturn txn.toString();\n\t\t}\n\t}\n\n\t/**\n\t * Creates a wallet address + mnemonic from account's secret key.\n\t * Changed in 0.3: this does NOT set algonaut.account.\n\t * @returns AlgonautWallet Object containing `address` and `mnemonic`\n\t */\n\tcreateWallet(): AlgonautWallet {\n\t\tconst account = generateAccount();\n\n\t\tif (account) {\n\t\t\tconst mnemonic = secretKeyToMnemonic(account.sk);\n\t\t\treturn {\n\t\t\t\taddress: account.addr,\n\t\t\t\tmnemonic: mnemonic,\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('There was no account: could not create algonaut wallet!');\n\t\t}\n\t}\n\n\t/**\n\t * Recovers account from mnemonic\n\t * Changed in 0.3: this does NOT set algonaut.account.\n\t * @param mnemonic Mnemonic associated with Algonaut account\n\t * @returns If mnemonic is valid, returns algosdk account (.addr, .sk). Otherwise, throws an error.\n\t */\n\trecoverAccount(mnemonic: string): AlgosdkAccount {\n\t\tif (!mnemonic) throw new Error('No mnemonic provided.');\n\n\t\ttry {\n\t\t\tconst account = mnemonicToSecretKey(mnemonic);\n\t\t\tif (isValidAddress(account?.addr)) {\n\t\t\t\treturn account;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Not a valid mnemonic.');\n\t\t\t}\n\t\t} catch (error: any) {\n\t\t\t// should we throw an error here instead of returning false?\n\t\t\tconsole.error(error);\n\t\t\tthrow new Error('Could not recover account from mnemonic.');\n\t\t}\n\t}\n\n\t/**\n\t * txn(b64) -> txnBuff (buffer)\n\t * @param txn base64-encoded unsigned transaction\n\t * @returns trransaction as buffer object\n\t */\n\ttxnB64ToTxnBuff(txn: string): Buffer {\n\t\treturn Buffer.from(txn, 'base64');\n\t}\n\n\t/**\n\t * Converts between buff -> b64 (txns)\n\t * @param buff likely a algorand txn as a Uint8Array buffer\n\t * @returns string (like for inkey / base64 transmit use)\n\t */\n\ttxnBuffToB64(buff: Uint8Array): string {\n\t\treturn Buffer.from(buff).toString('base64');\n\t}\n\n\t/**\n\t * Does what it says on the tin.\n\t * @param txn algorand txn object\n\t * @returns string (like for inkey / base64 transmit use)\n\t */\n\ttxnToStr(txn: algosdk.Transaction): string {\n\t\tconst buff = txn.toByte();\n\t\treturn this.txnBuffToB64(buff);\n\t}\n\n}\nexport default Algonaut;\n\nexport const buffer = Buffer; // sometimes this is helpful on the frontend\n","import type {\n\tLogicSigAccount,\n\tTransaction,\n\tSuggestedParams,\n\tMultisigMetadata,\n} from 'algosdk';\n\n// FYI the line below breaks in some deno envs\nimport type { ApplicationStateSchema } from 'algosdk/dist/types/client/v2/algod/models/types';\n\nimport type { WalletInitParamsObj } from '@thencc/any-wallet';\n\nexport type AlgonautConfig = {\n\tlibConfig?: {\n\t\tdisableLogs?: boolean; // should default to true\n\t};\n\n\tnodeConfig?: {\n\t\tBASE_SERVER: string;\n\t\tINDEX_SERVER?: string; // optional, but helpful\n\t\tLEDGER: string;\n\t\tPORT: string;\n\t\tAPI_TOKEN: any;\n\t};\n\n\t// if we wanted to support multiple init params of any-wallet, but too verbose...\n\t// anyWalletConfig?: {\n\t// \twalletInitParams?: WalletInitParamsObj;\n\t// };\n\tinitWallets?: WalletInitParamsObj;\n}\n\nexport interface AlgonautStateData {\n\tkey: string;\n\tvalue: string | number | bigint;\n\taddress: string; // if we can detect an address, we put it here\n}\n\nexport interface AlgonautContractSchema {\n\tlocalInts: number,\n\tlocalBytes: number,\n\tglobalInts: number,\n\tglobalBytes: number,\n}\n\nexport interface AlgonautDeployArguments {\n\ttealApprovalCode: string;\n\ttealClearCode: string;\n\tappArgs: any[];\n\tschema: AlgonautContractSchema;\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautUpdateAppArguments {\n\tappIndex: number;\n\ttealApprovalCode: string;\n\ttealClearCode: string;\n\tappArgs: any[];\n\t//schema: AlgonautContractSchema;\n\toptionalFields?: AlgonautTransactionFields;\n\t//lease: Uint8Array;\n\t//rekeyTo: string;\n}\n\nexport interface AlgonautDeleteAppArguments {\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautLsigDeployArguments extends AlgonautDeployArguments {\n\tlsig: LogicSigAccount;\n\tnoteText?: string;\n}\n\nexport interface AlgonautAppStateEncoded {\n\tkey: string;\n\tvalue: {\n\t\tbytes: string;\n\t\ttype: number;\n\t\tuint: number\n\t}\n}\n\nexport interface AlgonautGetApplicationResponse {\n\tid: number;\n\tparams: {\n\t\t'approval-program': string;\n\t\t'clear-state-program': string;\n\t\tcreator: string;\n\t\textraProgramPages?: number;\n\t\t'global-state'?: AlgonautAppStateEncoded[];\n\t\t'global-state-schema'?: ApplicationStateSchema;\n\t\t'local-state-schema'?: ApplicationStateSchema;\n\t}\n}\n\nexport interface AlgonautAppState {\n\tindex: number;\n\thasState: boolean;\n\tcreatorAddress: string;\n\tglobals: AlgonautStateData[];\n\tlocals: AlgonautStateData[];\n}\n\nexport interface AlgonautCallAppArguments {\n\tfrom?: string;\n\tappIndex: number;\n\tappArgs: any[];\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautLsigCallAppArguments extends AlgonautCallAppArguments {\n\tlsig: LogicSigAccount;\n}\n\nexport interface AlgonautCreateAssetArguments {\n\tfrom?: string;\n\tassetName: string;\n\tsymbol: string;\n\tmetaBlock: string;\n\tdecimals: number;\n\tamount: number;\n\tassetURL?: string;\n\tdefaultFrozen?: boolean;\n\tassetMetadataHash?: string;\n\tclawback?: string;\n\tmanager?: string;\n\treserve?: string;\n\tfreeze?: string;\n\trekeyTo?: string;\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautDestroyAssetArguments {\n\trekeyTo?: string;\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautSendAssetArguments {\n\tto: string;\n\tfrom?: string;\n\tassetIndex: number;\n\tamount: number | bigint;\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautLsigSendAssetArguments extends AlgonautSendAssetArguments {\n\tlsig: LogicSigAccount;\n}\n\nexport interface AlgonautPaymentArguments {\n\tamount: number | bigint;\n\tto: string;\n\tfrom?: string;\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautLsigPaymentArguments extends AlgonautPaymentArguments {\n\tlsig: LogicSigAccount;\n}\n\nexport interface AlgonautTxnCallbacks {\n\tonSign(payload: any): void;\n\tonSend(payload: any): void;\n\tonConfirm(payload: any): void;\n}\n\nexport type AlgonautError = {\n\tmessage: string;\n\trawError?: any;\n}\n\nexport type AlgonautTransactionStatus = {\n\tstatus: 'success' | 'fail' | 'rejected';\n\tmessage: string;\n\tindex?: number;\n\ttxId: string;\n\terror?: Error;\n\tmeta?: any;\n\tcreatedIndex?: number; // implement this for created apps and assets\n}\n\nexport type AlgonautWallet = {\n\taddress: string;\n\tmnemonic: string;\n}\n\nexport type AlgonautTransactionFields = {\n\taccounts?: string[],\n\tapplications?: number[],\n\tassets?: number[],\n\treKeyTo?: string,\n\tnote?: string,\n\tcloseRemainderTo?: string,\n\tmanager?: string,\n\tfreeze?: string,\n\tclawback?: string,\n\treserve?: string;\n\tsuggestedParams?: SuggestedParams;\n}\n\nexport type AlgonautAtomicTransaction = {\n\ttransaction: Transaction;\n\tisLogigSig: boolean;\n\tlSig?: LogicSigAccount;\n}\n\nexport type InkeySignTxnResponse = {\n\tsuccess: boolean;\n\treject?: boolean;\n\terror?: any;\n\tsignedTxns?: Uint8Array[] | Uint8Array;\n}\n\nexport type TxnForSigning = {\n\ttxn: string; // base64 encoded transaction\n\ttxnDecoded?: Transaction;\n\tisLogicSig?: boolean;\n\tisMultisig?: boolean;\n\tmultisigMeta?: MultisigMetadata;\n}","// src/index.ts\nimport { ReactiveEffect, isReactive, isRef, isShallow } from \"@vue/reactivity\";\nimport { NOOP, hasChanged, isArray, isFunction as isFunction2, isObject } from \"@vue/shared\";\n\n// src/errorHandling.ts\nimport { isFunction, isPromise } from \"@vue/shared\";\nfunction callWithErrorHandling(fn, type, args) {\n  let res;\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, type);\n  }\n  return res;\n}\nfunction callWithAsyncErrorHandling(fn, type, args) {\n  if (isFunction(fn)) {\n    const res = callWithErrorHandling(fn, type, args);\n    if (res && isPromise(res)) {\n      res.catch((err) => {\n        handleError(err, type);\n      });\n    }\n    return res;\n  }\n  const values = [];\n  for (let i = 0; i < fn.length; i++)\n    values.push(callWithAsyncErrorHandling(fn[i], type, args));\n  return values;\n}\nfunction handleError(err, type) {\n  console.error(new Error(`[@vue-reactivity/watch]: ${type}`));\n  console.error(err);\n}\nfunction warn(message) {\n  console.warn(createError(message));\n}\nfunction createError(message) {\n  return new Error(`[reactivue]: ${message}`);\n}\n\n// src/index.ts\nvar INITIAL_WATCHER_VALUE = {};\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\nfunction watch(source, cb, options) {\n  return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, { immediate, deep, flush } = {}) {\n  let getter;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => source;\n    deep = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(isReactive);\n    getter = () => source.map((s) => {\n      if (isRef(s))\n        return s.value;\n      else if (isReactive(s))\n        return traverse(s);\n      else if (isFunction2(s))\n        return callWithErrorHandling(s, \"watch getter\");\n      else\n        return warn(\"invalid source\");\n    });\n  } else if (isFunction2(source)) {\n    if (cb) {\n      getter = () => callWithErrorHandling(source, \"watch getter\");\n    } else {\n      getter = () => {\n        if (cleanup)\n          cleanup();\n        return callWithAsyncErrorHandling(source, \"watch callback\", [onCleanup]);\n      };\n    }\n  } else {\n    getter = NOOP;\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    getter = () => traverse(baseGetter());\n  }\n  let cleanup;\n  let onCleanup = (fn) => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, \"watch cleanup\");\n    };\n  };\n  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\n  const job = () => {\n    if (!effect.active)\n      return;\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup)\n          cleanup();\n        callWithAsyncErrorHandling(cb, \"watch value\", [\n          newValue,\n          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,\n          onCleanup\n        ]);\n        oldValue = newValue;\n      }\n    } else {\n      effect.run();\n    }\n  };\n  job.allowRecurse = !!cb;\n  let scheduler;\n  if (flush === \"sync\") {\n    scheduler = job;\n  } else {\n    scheduler = () => {\n      job();\n    };\n  }\n  const effect = new ReactiveEffect(getter, scheduler);\n  if (cb) {\n    if (immediate)\n      job();\n    else\n      oldValue = effect.run();\n  } else {\n    effect.run();\n  }\n  return () => effect.stop();\n}\nfunction traverse(value, seen = /* @__PURE__ */ new Set()) {\n  if (!isObject(value) || seen.has(value))\n    return value;\n  seen.add(value);\n  if (isArray(value)) {\n    for (let i = 0; i < value.length; i++)\n      traverse(value[i], seen);\n  } else if (value instanceof Map) {\n    value.forEach((_, key) => {\n      traverse(value.get(key), seen);\n    });\n  } else if (value instanceof Set) {\n    value.forEach((v) => {\n      traverse(v, seen);\n    });\n  } else {\n    for (const key of Object.keys(value))\n      traverse(value[key], seen);\n  }\n  return value;\n}\nexport {\n  watch,\n  watchEffect\n};\n","import type { AlgonautConfig } from './AlgonautTypes';\n\nexport const testnetConfig: AlgonautConfig['nodeConfig'] = {\n\tLEDGER: 'testnet',\n\tBASE_SERVER: 'https://testnet-api.algonode.cloud',\n\tINDEX_SERVER: 'https://testnet-idx.algonode.cloud',\n\tAPI_TOKEN: '',\n\tPORT: '', // 443\n};\nexport const mainnetConfig: AlgonautConfig['nodeConfig'] = {\n\tLEDGER: 'mainnet',\n\tBASE_SERVER: 'https://mainnet-api.algonode.cloud',\n\tINDEX_SERVER: 'https://mainnet-idx.algonode.cloud',\n\tAPI_TOKEN: '',\n\tPORT: '',\n};\nexport const defaultNodeConfig = testnetConfig;\n","import type { AlgonautConfig } from './AlgonautTypes';\n\nexport const defaultLibConfig: AlgonautConfig['libConfig'] = {\n\tdisableLogs: true,\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// log helper - for disabling logs w a query string but not the dapp's logs\nexport const logger = {\n\tenabled: false,\n\tlog(...args: any) {\n\t\tif (!this.enabled) return;\n\t\tconsole.log(...args);\n\t},\n\tdebug(...args: any) {\n\t\tif (!this.enabled) return;\n\t\tconsole.debug(...args);\n\t},\n};\n"]}