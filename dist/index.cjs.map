{
  "version": 3,
  "sources": ["../node_modules/.pnpm/vlq@2.0.4/node_modules/vlq/dist/index.cjs", "../src/index.ts", "../src/algo-config.ts", "../src/constants.ts", "../src/utils.ts"],
  "sourcesContent": ["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vlq = {}));\n})(this, (function (exports) { 'use strict';\n\n\t/** @type {Record<string, number>} */\n\tlet char_to_integer = {};\n\n\t/** @type {Record<number, string>} */\n\tlet integer_to_char = {};\n\n\t'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n\t\t.split('')\n\t\t.forEach(function (char, i) {\n\t\t\tchar_to_integer[char] = i;\n\t\t\tinteger_to_char[i] = char;\n\t\t});\n\n\t/** @param {string} string */\n\tfunction decode(string) {\n\t\t/** @type {number[]} */\n\t\tlet result = [];\n\n\t\tlet shift = 0;\n\t\tlet value = 0;\n\n\t\tfor (let i = 0; i < string.length; i += 1) {\n\t\t\tlet integer = char_to_integer[string[i]];\n\n\t\t\tif (integer === undefined) {\n\t\t\t\tthrow new Error('Invalid character (' + string[i] + ')');\n\t\t\t}\n\n\t\t\tconst has_continuation_bit = integer & 32;\n\n\t\t\tinteger &= 31;\n\t\t\tvalue += integer << shift;\n\n\t\t\tif (has_continuation_bit) {\n\t\t\t\tshift += 5;\n\t\t\t} else {\n\t\t\t\tconst should_negate = value & 1;\n\t\t\t\tvalue >>>= 1;\n\n\t\t\t\tif (should_negate) {\n\t\t\t\t\tresult.push(value === 0 ? -0x80000000 : -value);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(value);\n\t\t\t\t}\n\n\t\t\t\t// reset\n\t\t\t\tvalue = shift = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/** @param {number | number[]} value */\n\tfunction encode(value) {\n\t\tif (typeof value === 'number') {\n\t\t\treturn encode_integer(value);\n\t\t}\n\n\t\tlet result = '';\n\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\tresult += encode_integer(value[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/** @param {number} num */\n\tfunction encode_integer(num) {\n\t\tlet result = '';\n\n\t\tif (num < 0) {\n\t\t\tnum = (-num << 1) | 1;\n\t\t} else {\n\t\t\tnum <<= 1;\n\t\t}\n\n\t\tdo {\n\t\t\tlet clamped = num & 31;\n\t\t\tnum >>>= 5;\n\n\t\t\tif (num > 0) {\n\t\t\t\tclamped |= 32;\n\t\t\t}\n\n\t\t\tresult += integer_to_char[clamped];\n\t\t} while (num > 0);\n\n\t\treturn result;\n\t}\n\n\texports.decode = decode;\n\texports.encode = encode;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n", "import { Buffer } from 'buffer';\n\nimport algosdk, {\n\tsecretKeyToMnemonic,\n\tgenerateAccount,\n\tAccount as AlgosdkAccount,\n\tAlgodv2,\n\tIndexer,\n\tLogicSigAccount,\n\tmakeAssetTransferTxnWithSuggestedParamsFromObject,\n\tmakeApplicationOptInTxnFromObject,\n\tmakeAssetCreateTxnWithSuggestedParams,\n\tmakeAssetDestroyTxnWithSuggestedParams,\n\tmakeApplicationDeleteTxn,\n\tmakeApplicationNoOpTxnFromObject,\n\tmakeApplicationCloseOutTxnFromObject,\n\tmakeApplicationCreateTxnFromObject,\n\tOnApplicationComplete,\n\tmakeApplicationCreateTxn,\n\tsignLogicSigTransactionObject,\n\tmakeApplicationUpdateTxn,\n\tencodeAddress,\n\tmakePaymentTxnWithSuggestedParamsFromObject,\n\tTransaction,\n\tmnemonicToSecretKey,\n\tisValidAddress,\n\tencodeUint64,\n\tgetApplicationAddress,\n\tmicroalgosToAlgos,\n\tdecodeUnsignedTransaction,\n\tsignMultisigTransaction\n} from 'algosdk';\n\nimport type {\n\tAlgonautConfig,\n\tAlgonautWallet,\n\tAlgonautTransactionStatus,\n\tAlgonautAtomicTransaction,\n\tAlgonautTransactionFields,\n\tAlgonautAppState,\n\tAlgonautStateData,\n\tAlgonautError,\n\tAlgonautTxnCallbacks,\n\tAlgonautContractSchema,\n\tAlgonautCreateAssetArguments,\n\tAlgonautSendAssetArguments,\n\tAlgonautCallAppArguments,\n\tAlgonautDeployArguments,\n\tAlgonautLsigDeployArguments,\n\tAlgonautLsigCallAppArguments,\n\tAlgonautLsigSendAssetArguments,\n\tAlgonautPaymentArguments,\n\tAlgonautLsigPaymentArguments,\n\tAlgonautUpdateAppArguments,\n\tAlgonautGetApplicationResponse,\n\tAlgonautAppStateEncoded,\n\tTxnForSigning\n} from './AlgonautTypes';\nexport * from './AlgonautTypes';\nexport type AlgoTxn = Transaction;\n\nimport { \n\tAnyWalletState, \n\tenableWallets, \n\tremoveAllAccounts, \n\tsetLogsEnabled as AWSetLogsEnabled, \n\tsignTransactions, \n\tsubscribeToAccountChanges,\n\tWALLET_ID\n} from '@thencc/any-wallet';\nimport type {\n\tAccount,\n\tClientInitParams,\n\tWalletInitParamsObj\n} from '@thencc/any-wallet';\nexport * from '@thencc/any-wallet';\n\nimport { defaultNodeConfig, mainnetConfig, testnetConfig } from './algo-config';\nimport { defaultLibConfig } from './constants';\nimport { logger } from './utils';\n\n/*\n\nfor stateful contracts i think we want to read it in and hold all the\nNV pairs as fields\n\nand maybe read the TEAL and make wrapper methods for things we see in\na config file?\n\nTBD:\n\n- standard typed return values\n- standard error values, pre-parse the algo error goop\n\n\nthere are a couple ways to go for atomic txs, i THINK the more pleasant API is\n\nawait runAtomicTransaction([\n\tawait atomicSendASA(),\n\tawait atomicSendAlgo(),\n\tawait atomicCallApp()\n])\n\n*/\n\nlet unsAcctSync = null as null | (() => void);\n\nexport class Algonaut {\n\talgodClient!: Algodv2; // it will be set or it throws an Error\n\tindexerClient = undefined as undefined | Indexer;\n\tnodeConfig = defaultNodeConfig;\n\tlibConfig = defaultLibConfig;\n\t\n\t// expose entire algosdk in case the dapp needs more\n\tsdk = algosdk;\n\t\n\t// handles all algo wallets (inkey, pera, etc) + remembers last used in localstorage\n\twalletState = AnyWalletState;\n\n\taccount = null as null | typeof AnyWalletState.activeAccount;\n\tget connectedAccounts() {\n\t\treturn AnyWalletState.connectedAccounts;\n\t}\n\n\t// TODO come back to private class fields during the security pass. + figure out how to make account immutable\n\t// \"#account\" set on aw acct listener (but private fields compile weird..? making a #private field in the type dec)\n\t// #account = null as null | typeof AnyWalletState.activeAccount;\n\t// get account() {\n\t// \treturn this.#account;\n\t// }\n\n\t/**\n\t * Instantiates Algonaut.js.\n\t *\n\t * @example\n\t * Usage:\n\t *\n\t * ```js\n\t * import { Algonaut } from '@thencc/algonautjs';\n\t * const algonaut = new Algonaut({\n\t * \t\tnodeConfig: {\n\t *\t \t\tBASE_SERVER: 'https://testnet-algorand.api.purestake.io/ps2',\n\t *\t \t\tINDEX_SERVER: 'https://testnet-algorand.api.purestake.io/idx2'\n\t *\t \t\tLEDGER: 'TestNet',\n\t *\t \t\tPORT: '',\n\t *\t \t\tAPI_TOKEN: { 'X-API-Key': 'YOUR_API_TOKEN' }\n\t * \t\t}\n\t * });\n\t * ```\n\t *\n\t * @param config config object\n\t */\n\tconstructor(config?: AlgonautConfig) {\n\t\tthis.setNodeConfig(config?.nodeConfig); // makes algod client too\n\t\tthis.enableWallets(config?.initWallets);\n\t\tthis.setLibConfig(config?.libConfig);\n\t\tthis.initAcctSync();\n\t}\n\n\tsetLibConfig(libConfig?: AlgonautConfig['libConfig']) {\n\t\t// logger.log('setLibConfig', libConfig);\n\t\tif (libConfig == undefined)  {\n\t\t\tlibConfig = defaultLibConfig;\n\t\t}\n\t\tif (libConfig !== undefined) {\n\t\t\tif ('disableLogs' in libConfig && typeof libConfig.disableLogs == 'boolean') {\n\t\t\t\tlogger.enabled = !libConfig.disableLogs;\n\t\t\t\tAWSetLogsEnabled(!libConfig.disableLogs);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * checks if config obj is valid for use\n\t * @param config algonaut config for network + signing mode\n\t * @returns boolean. true is good.\n\t */\n\tisValidNodeConfig(nodeConfig?: AlgonautConfig['nodeConfig']): boolean {\n\t\t// logger.log('isValidNodeConfig?', config);\n\t\tlet isValid = true;\n\n\t\t// do all checks\n\t\tif (nodeConfig == undefined || !nodeConfig.BASE_SERVER) {\n\t\t\tisValid = false;\n\t\t}\n\t\t// FYI some configs dont need an api token\n\n\t\t// TODO add more checks...\n\n\t\treturn isValid;\n\t}\n\n\t/**\n\t * sets config for use (new algod, indexerClient, etc)\n\t * @param config algonaut config for network + signing mode\n\t * \t\t- will throw Error if config is lousy\n\t */\n\tsetNodeConfig(nodeConfig?: AlgonautConfig['nodeConfig'] | 'mainnet' | 'testnet') {\n\t\t// logger.log('setNodeConfig', config);\n\t\tif (nodeConfig == undefined) {\n\t\t\tnodeConfig = defaultNodeConfig;\n\t\t}\n\n\t\tif (typeof nodeConfig == 'string') {\n\t\t\tif (nodeConfig == 'mainnet') {\n\t\t\t\tnodeConfig = mainnetConfig;\n\t\t\t} else if (nodeConfig == 'testnet') {\n\t\t\t\tnodeConfig = testnetConfig;\n\t\t\t} else {\n\t\t\t\tthrow new Error('bad node config string.');\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isValidNodeConfig(nodeConfig)) {\n\t\t\tthrow new Error('bad node config!');\n\t\t}\n\t\tif (typeof nodeConfig == 'undefined') {\n\t\t\tthrow new Error('node config undefined'); // shouldnt ever happen... but needed to TS to be happy\n\t\t}\n\n\t\tthis.nodeConfig = nodeConfig;\n\t\tthis.algodClient = new Algodv2(nodeConfig.API_TOKEN, nodeConfig.BASE_SERVER, nodeConfig.PORT);\n\n\t\tif (nodeConfig.INDEX_SERVER) {\n\t\t\tthis.indexerClient = new Indexer(nodeConfig.API_TOKEN, nodeConfig.INDEX_SERVER, nodeConfig.PORT);\n\t\t} else {\n\t\t\tconsole.warn('No indexer configured because INDEX_SERVER was not provided.');\n\t\t}\n\t}\n\n\t/**\n\t * @returns nodeConfig object or `false` if no nodeConfig is set\n\t */\n\tgetNodeConfig(): AlgonautConfig['nodeConfig'] | boolean {\n\t\tif (this.nodeConfig) return this.nodeConfig;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks status of Algorand network\n\t * @returns Promise resolving to status of Algorand network\n\t */\n\tasync checkStatus(): Promise<any | AlgonautError> {\n\t\tif (!this.getNodeConfig()) {\n\t\t\tthrow new Error('No node configuration set.');\n\t\t}\n\n\t\tconst status = await this.algodClient.status().do();\n\t\tlogger.log('Algorand network status: %o', status);\n\t\treturn status;\n\t}\n\n\tinitAcctSync() {\n\t\tunsAcctSync = subscribeToAccountChanges(\n\t\t\t(acct) => {\n\t\t\t\tlogger.log('acct changed', acct);\n\t\t\t\tthis.account = acct;\n\t\t\t}\n\t\t);\n\t}\n\tstopAcctSync() {\n\t\tif (unsAcctSync) unsAcctSync();\n\t}\n\n\tenableWallets(walletInitParams?: AlgonautConfig['initWallets']) {\n\t\tif (walletInitParams == undefined) {\n\t\t\tlogger.log('enabling inkey wallet by default');\n\t\t}\n\t\tconst defaultWip: WalletInitParamsObj = {\n\t\t\tinkey: true\n\t\t};\n\t\tconst wip = walletInitParams || defaultWip;\n\t\tenableWallets(wip); // defaults to all except mnemonic client\n\t}\n\n\t/**\n\t * @deprecated use .connect() with mnemonic arg\n\t * Recovers account from mnemonic\n\t *  (helpful for rapid development but overall very insecure unless on server-side)\n\t * @param mnemonic Mnemonic associated with Algonaut account\n\t * @returns If mnemonic is valid, it returns the account (address, chain). Otherwise, throws an error.\n\t */\n\tasync mnemonicConnect(mnemonic: string): Promise<Account[]> {\n\t\tif (!mnemonic) throw new Error('algonaut.mnemonicConnect: No mnemonic provided.');\n\t\treturn await this.connect({\n\t\t\tmnemonic\n\t\t});\n\t}\n\n\t/**\n\t * @deprecated use .connect or loop through enabled wallets' methods\n\t */\n\tasync inkeyConnect(): Promise<Account[]> {\n\t\tconsole.warn('.inkeyConnect is deprecated. please use .connect');\n\t\treturn await this.connect({\n\t\t\tinkey: true // \"true\" means use the defaults\n\t\t});\n\t}\n\n\t/**\n\t * @deprecated use .disconnect or loop through enabled wallets' methods\n\t */\n\tasync inkeyDisconnect() {\n\t\tconsole.warn('.inkeyDisconnect is deprecated. please use .disconnect');\n\t\treturn await this.disconnect([WALLET_ID.INKEY]);\n\t}\n\n\t/**\n\t * Shows the inkey-wallet modal \n\t * @returns \n\t */\n\tasync inkeyShow() {\n\t\t// TODO add to this method a check to see if inkey is connected, \n\t\t// if not call that first.... + w username is prev authed\n\t\tlet inkeyW = AnyWalletState.enabledWallets?.inkey;\n\t\tif (!inkeyW) {\n\t\t\tconsole.warn('Inkey wallet is not enabled');\n\t\t\treturn;\n\t\t}\n\t\tif (AnyWalletState.activeWalletId == null) {\n\t\t\tawait this.inkeyConnect();\n\t\t}\n\n\t\t// TODO ? should we check for any connected account being of inkey type? or just the active one?\n\t\t// if (AnyWalletState.stored.connectedAccounts.includes())\n\t\tif (AnyWalletState.activeWalletId !== 'inkey') {\n\t\t\tconsole.warn('Inkey is not the active wallet, cannot show it. ');\n\t\t\treturn;\n\t\t}\n\n\t\tawait inkeyW.loadClient();\n\t\tif ((inkeyW.client as any).sdk.frameBus.ready) {\n\t\t\t(inkeyW.client as any).sdk.show();\n\t\t} else {\n\t\t\tconsole.warn('inkey comms not yet ready.')\n\t\t}\n\t}\n\n\t/**\n\t * Hides the inkey-wallet modal\n\t * @returns \n\t */\n\tasync inkeyHide() {\n\t\tlet inkeyW = AnyWalletState.enabledWallets?.inkey;\n\t\tif (!inkeyW) {\n\t\t\tconsole.warn('inkey wallet not enabled');\n\t\t\treturn;\n\t\t}\n\t\t// TODO ? do we need this connect in the hide method?\n\t\t// if (AnyWalletState.activeWalletId == null) {\n\t\t// \tawait this.inkeyConnect();\n\t\t// }\n\t\t// if (AnyWalletState.activeWalletId !== 'inkey') {\n\t\t// \tconsole.warn('Inkey is not the active wallet, cannot hide it. ');\n\t\t// \treturn;\n\t\t// }\n\n\t\tawait inkeyW.loadClient();\n\t\tif ((inkeyW.client as any).sdk.frameBus.ready) {\n\t\t\t(inkeyW.client as any).sdk.hide();\n\t\t} else {\n\t\t\tconsole.warn('inkey comms not yet ready.')\n\t\t}\n\t}\n\n\t/**\n\t * Connects a wallet to be used as algonaut.account. uses:\n\t * \t- the SINGLE passed in init params for the specified wallet\n\t *  - or, the SINGLE enabled wallet IF 1 wallet is enabled (as is the default. just inkey)\n\t * FAILs and throws when multiple init params are passed in or multiple wallets are enabled when nothing is passed in (since it doesnt know which to connect up)\n\t */\n\tasync connect(initWallets?: WalletInitParamsObj) {\n\t\t// logger.log('connect initWallets', initWallets);\n\t\tif (initWallets !== undefined) {\n\t\t\tconst initWs = Object.entries(initWallets);\n\t\t\tif (initWs.length == 1) {\n\t\t\t\tconst wId = initWs[0][0] as WALLET_ID;\t\t\t\t\n\t\t\t\tconst wInitParams = initWs[0][1] as ClientInitParams; // grab the only enabled wallet\n\t\t\t\tconst w = AnyWalletState.allWallets[wId];\n\t\t\t\tlogger.debug('connect: ', wId, wInitParams)\n\n\t\t\t\tif (w !== undefined) {\n\t\t\t\t\t// possibly enable this wallet \n\t\t\t\t\tif (AnyWalletState.enabledWallets == null || \n\t\t\t\t\t\t!(AnyWalletState.enabledWallets[wId])\n\t\t\t\t\t) {\n\t\t\t\t\t\t// AnyWalletState.enabledWallets[wId] = w; // same same as below\n\t\t\t\t\t\tenableWallets(initWallets);\n\t\t\t\t\t}\n\n\t\t\t\t\t// FYI ignore the .isConnected check (as in below init using singular enabledWallet) \n\t\t\t\t\t// to allow for authing into multiple accounts of 1 wallet type\n\n\t\t\t\t\tw.initParams = wInitParams;\n\n\t\t\t\t\t// let connectParams = undefined;\n\t\t\t\t\t// if (w.id == 'inkey' && w.isActive && this.account?.name) {\n\t\t\t\t\t// \tconnectParams = {\n\t\t\t\t\t// \t\tusername: this.account.name,\n\t\t\t\t\t// \t};\n\t\t\t\t\t// }\n\t\t\t\t\t// return await w.connect(connectParams);\n\n\t\t\t\t\treturn await w.connect();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Could not find wallet to enable');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Cannot init multiple wallets at once using .connect(). To enable multiple wallets at once define initWallets params in Algonaut class instantiation.');\n\t\t\t}\n\t\t} else {\n\t\t\t// then assume to use the only enabled wallet (must be only 1)\n\t\t\tif (AnyWalletState.enabledWallets) {\n\t\t\t\tconst enabledWs = Object.entries(AnyWalletState.enabledWallets);\n\t\t\t\tif (enabledWs.length == 1) {\n\t\t\t\t\tconst w = enabledWs[0][1]; // grab the only enabled wallet\n\t\t\t\t\tif (w) {\n\t\t\t\t\t\tif (!w.isConnected) {\n\t\t\t\t\t\t\t// let connectParams = undefined;\n\t\t\t\t\t\t\t// if (w.id == 'inkey' && w.isActive && this.account?.name) {\n\t\t\t\t\t\t\t// \tconnectParams = {\n\t\t\t\t\t\t\t// \t\tusername: this.account.name,\n\t\t\t\t\t\t\t// \t};\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\t// return await w.connect(connectParams);\n\t\t\t\t\t\t\treturn await w.connect();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('Wallet already connected.');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Wallet wasnt initialized correctly.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Too many wallets enabled to know which to connect.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('No enabled wallets to connect.');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * disconnects\n\t * \t- the active wallet IF no arg passed in\n\t * \t- all the wallets IF \"true\" is passed in as an arg\n\t * \t- or, specific wallets if an array of wallet ids is passed in. (ex: [\"inkey\", \"algosigner\", \"mnemonic\"] )\n\t */\n\tasync disconnect(wIds?: WALLET_ID[] | true) {\n\t\tif (typeof wIds == undefined) {\n\t\t\t// (try) disconnect active wallet only\n\t\t\tif (AnyWalletState.enabledWallets) {\n\t\t\t\tconst enabledWs = Object.entries(AnyWalletState.enabledWallets);\n\t\t\t\tif (enabledWs.length == 1) {\n\t\t\t\t\tconst w = enabledWs[0][1]; // grab the only enabled wallet\n\t\t\t\t\tif (w) {\n\t\t\t\t\t\tif (w.isConnected) {\n\t\t\t\t\t\t\tlogger.log('disconnecting active wallet:', w.id);\n\t\t\t\t\t\t\treturn await w.disconnect();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('Wallet already disconnected.');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Wallet wasnt initialized correctly.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Too many wallets enabled to know which to connect.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('No enabled wallets to disconnect.');\n\t\t\t}\n\t\t} else if (typeof wIds == 'boolean') {\n\t\t\tif (wIds == true) {\n\t\t\t\t// disconnect ALL wallets\n\t\t\t\tlogger.log('disconnecting all wallets from dapp');\n\t\t\t\tfor (let wId of Object.keys(AnyWalletState.allWallets)) {\n\t\t\t\t\tconst w = AnyWalletState.allWallets[wId as WALLET_ID];\n\t\t\t\t\tif (w) {\n\t\t\t\t\t\tif (w.isConnected) {\n\t\t\t\t\t\t\tlogger.log('disconnecting wallet:', wId);\n\t\t\t\t\t\t\treturn await w.disconnect();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('Wallet already disconnected.');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Could not find wallet by id to disconnect... (shouldnt happen)');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// nothing\n\t\t\t\t// for wIds == false\n\t\t\t}\n\t\t} else if (Array.isArray(wIds)) {\n\t\t\t// disconnect this/these wallets by wallet id\n\t\t\tlogger.log('disconnecting these wallets:', wIds);\n\t\t\tfor (let wId of wIds) {\n\t\t\t\tconst w = AnyWalletState.allWallets[wId];\n\t\t\t\tif (w) {\n\t\t\t\t\tif (w.isConnected) {\n\t\t\t\t\t\tlogger.log('disconnecting wallet:', wId);\n\t\t\t\t\t\treturn await w.disconnect();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Wallet already disconnected.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Could not find wallet by id to disconnect... (shouldnt happen)');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.debug('this shouldnt happen... passed in a bad arg to .disconnect() ');\n\t\t}\n\t}\n\n\tdisconnectAll() {\n\t\tremoveAllAccounts();\n\t}\n\n\t/**\n\t * General purpose method to await transaction confirmation\n\t * @param txId a string id of the transacion you want to watch\n\t * @param limitDelta how many rounds to wait, defaults to 50\n\t * @param log set to true if you'd like to see \"waiting for confirmation\" log messages\n\t */\n\tasync waitForConfirmation(txId: string, limitDelta?: number, log = false): Promise<AlgonautTransactionStatus> {\n\t\tif (!txId) throw new Error('waitForConfirmation: No transaction ID provided.');\n\n\t\tlet lastround = (await this.algodClient.status().do())['last-round'];\n\t\tconst limit = lastround + (limitDelta ? limitDelta : 50);\n\n\t\tconst returnValue = {\n\t\t\tstatus: 'fail',\n\t\t\tmessage: ''\n\t\t} as AlgonautTransactionStatus;\n\n\t\twhile (lastround < limit) {\n\t\t\tlet pendingInfo = '' as any;\n\t\t\ttry {\n\t\t\t\tpendingInfo = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\t\t\t\tif (log) {\n\t\t\t\t\tlogger.log('waiting for confirmation');\n\t\t\t\t}\n\t\t\t} catch (er: any) {\n\t\t\t\tconsole.error(er.response?.text);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tpendingInfo['confirmed-round'] !== null &&\n\t\t\t\tpendingInfo['confirmed-round'] > 0\n\t\t\t) {\n\n\t\t\t\tif (log) {\n\t\t\t\t\tlogger.log('Transaction confirmed in round ' + pendingInfo['confirmed-round']);\n\t\t\t\t}\n\n\t\t\t\treturnValue.txId = txId;\n\t\t\t\treturnValue.status = 'success';\n\t\t\t\treturnValue.message = 'Transaction confirmed in round ' + pendingInfo['confirmed-round'];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlastround = (await this.algodClient.status().do())['last-round'];\n\t\t}\n\n\t\treturn returnValue;\n\n\t}\n\n\t/**\n\t * Creates a LogicSig from a base64 program string.  Note that this method does not COMPILE\n\t * the program, just builds an LSig from an already compiled base64 result!\n\t * @param base64ProgramString\n\t * @returns an algosdk LogicSigAccount\n\t */\n\tgenerateLogicSig(base64ProgramString: string): LogicSigAccount {\n\t\tif (!base64ProgramString) throw new Error('No program string provided.');\n\n\t\tconst program = new Uint8Array(\n\t\t\tBuffer.from(base64ProgramString, 'base64')\n\t\t);\n\n\t\treturn new LogicSigAccount(program);\n\t}\n\n\tasync atomicOptInAsset(assetIndex: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!this.walletState.activeAddress) throw new Error('No account set in Algonaut.');\n\t\tif (!assetIndex) throw new Error('No asset index provided.');\n\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst optInTransaction = makeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\tfrom: this.walletState.activeAddress,\n\t\t\tto: this.walletState.activeAddress,\n\t\t\tassetIndex: assetIndex,\n\t\t\tamount: 0,\n\t\t\tsuggestedParams,\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: optInTransaction,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Opt-in the current account for the a token or NFT Asset.\n\t * @param assetIndex number of asset to opt-in to\n\t * @param callbacks `AlgonautTxnCallbacks`, passed to {@link sendTransaction}\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync optInAsset(assetIndex: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\tif (!this.walletState.activeAddress) throw new Error('There was no account!');\n\t\tif (!assetIndex) throw new Error('No asset index provided.');\n\t\tconst { transaction } = await this.atomicOptInAsset(assetIndex, optionalTxnArgs);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\n\t// this is a bit harder with the algosdk api\n\t// what we may want to do be more opinionated and have a standard local\n\t// field we always set on apps when opted in\n\n\t// OR maybe we check for HAS STATE which might check for local state\n\t// of any kind on that app id?\n\n\t// async isOptedIntoApp(account: string, appId: number): boolean {\n\t// \tlet optInState = false;\n\n\t// \tconst accountInfo = await this.getAccountInfo(account);\n\t// \taccountInfo.assets.forEach((asset: any) => {\n\t// \t\tif (asset['asset-id'] == assetId) {\n\t// \t\t\toptInState = true;\n\t// \t\t}\n\n\t// \t});\n\n\t// \treturn optInState;\n\t// }\n\n\n\t/**\n\t * You can be opted into an asset but still have a zero balance. Use this call\n\t * for cases where you just need to know the address's opt-in state\n\t * @param args object containing `account` and `assetId` properties\n\t * @returns boolean true if account holds asset\n\t */\n\tasync isOptedIntoAsset(args: { account: string, assetId: number }): Promise<boolean> {\n\t\tif (!args.account) throw new Error('No account provided.');\n\t\tif (!args.assetId) throw new Error('No asset ID provided.');\n\n\t\tlet optInState = false;\n\t\tconst accountInfo = await this.getAccountInfo(args.account);\n\t\taccountInfo.assets.forEach((asset: any) => {\n\t\t\tif (asset['asset-id'] == args.assetId) {\n\t\t\t\toptInState = true;\n\t\t\t}\n\n\t\t});\n\n\t\treturn optInState;\n\t}\n\n\t/**\n\t * Sync function that returns a correctly-encoded argument array for\n\t * an algo transaction\n\t * @param args must be an any[] array, as it will often need to be\n\t * a mix of strings and numbers. Valid types are: string, number, and bigint\n\t * @returns a Uint8Array of encoded arguments\n\t */\n\tencodeArguments(args: any[]): Uint8Array[] {\n\t\tconst encodedArgs = [] as Uint8Array[];\n\n\t\t// loop through args and encode them based on type\n\t\targs.forEach((arg: any) => {\n\t\t\tif (typeof arg == 'number') {\n\t\t\t\tencodedArgs.push(encodeUint64(arg));\n\t\t\t} else if (typeof arg == 'bigint') {\n\t\t\t\tencodedArgs.push(encodeUint64(arg));\n\t\t\t} else if (typeof arg == 'string') {\n\t\t\t\tencodedArgs.push(new Uint8Array(Buffer.from(arg)));\n\t\t\t}\n\t\t});\n\n\t\treturn encodedArgs;\n\t}\n\n\t/**\n\t * Create asset transaction\n\t * @param args : AlgonautCreateAssetArguments obj must contain: `assetName`, `symbol`, `decimals`, `amount`.\n\t * @returns atomic txn to create asset\n\t*/\n\tasync atomicCreateAsset(args: AlgonautCreateAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.assetName) throw new Error('args.assetName not provided.');\n\t\tif (!args.symbol) throw new Error('args.symbol not provided');\n\t\tif (typeof args.decimals == 'undefined') throw new Error('args.decimals not provided.');\n\t\tif (!args.amount) throw new Error('args.amount not provided.');\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tif (!args.metaBlock) {\n\t\t\targs.metaBlock = ' ';\n\t\t}\n\n\t\tif (!args.defaultFrozen) args.defaultFrozen = false;\n\t\tif (!args.assetURL) args.assetURL = undefined;\n\n\t\tconst metaBlockLength = args.metaBlock.length;\n\n\t\tif (metaBlockLength > 1023) {\n\t\t\tconsole.error('meta block is ' + metaBlockLength);\n\t\t\tthrow new Error('drat! this meta block is too long!');\n\t\t}\n\n\t\tconst enc = new TextEncoder();\n\n\t\t// arbitrary data: 1024 bytes, or about 1023 characters\n\t\tconst note = enc.encode(args.metaBlock);\n\t\tconst totalIssuance = args.amount;\n\n\t\t// set accounts\n\t\tconst manager = (args.manager && args.manager.length > 0) ? args.manager : fromAddr;\n\t\tconst reserve = (args.reserve && args.reserve.length > 0) ? args.reserve : fromAddr;\n\t\tconst freeze = (args.freeze && args.freeze.length > 0) ? args.freeze : fromAddr;\n\t\tconst clawback = (args.clawback && args.clawback.length > 0) ? args.clawback : fromAddr;\n\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t// signing and sending \"txn\" allows \"addr\" to create an asset\n\t\tconst txn = makeAssetCreateTxnWithSuggestedParams(\n\t\t\tfromAddr,\n\t\t\tnote,\n\t\t\ttotalIssuance,\n\t\t\targs.decimals,\n\t\t\targs.defaultFrozen,\n\t\t\tmanager,\n\t\t\treserve,\n\t\t\tfreeze,\n\t\t\tclawback,\n\t\t\targs.symbol,\n\t\t\targs.assetName,\n\t\t\targs.assetURL,\n\t\t\targs.assetMetadataHash,\n\t\t\tsuggestedParams\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: txn,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\n\t/**\n\t * Create asset\n\t * @param args AlgonautCreateAssetArguments. Must pass `assetName`, `symbol`, `decimals`, `amount`.\n\t * @param callbacks AlgonautTxnCallbacks\n\t * @returns asset index\n\t*/\n\tasync createAsset(\n\t\targs: AlgonautCreateAssetArguments,\n\t\tcallbacks?: AlgonautTxnCallbacks\n\t): Promise<AlgonautTransactionStatus> {\n\t\tconst atomicTxn = await this.atomicCreateAsset(args);\n\t\tconst txn = atomicTxn.transaction;\n\n\t\ttry {\n\t\t\tconst assetID = null;\n\t\t\tconst txStatus = await this.sendTransaction(txn, callbacks);\n\n\t\t\tconst ptx = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(txn.txID().toString())\n\t\t\t\t.do();\n\t\t\ttxStatus.createdIndex = ptx['asset-index'];\n\n\t\t\treturn txStatus;\n\n\t\t} catch (er) {\n\t\t\tlogger.log('transaction error');\n\t\t\tlogger.log(er);\n\t\t\tthrow new Error(er as any);\n\t\t}\n\t}\n\n\tasync atomicDeleteAsset(assetId: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!this.walletState.activeAddress) throw new Error('there was no account!');\n\t\tif (!assetId) throw new Error('No assetId provided!');\n\n\t\tconst enc = new TextEncoder();\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst transaction = makeAssetDestroyTxnWithSuggestedParams(\n\t\t\tthis.walletState.activeAddress,\n\t\t\tenc.encode('doh!'), // what is this?\n\t\t\tassetId,\n\t\t\tsuggestedParams,\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: transaction,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Deletes asset\n\t * @param assetId Index of the ASA to delete\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync deleteAsset(assetId: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\tif (!assetId) throw new Error('No asset ID provided!');\n\t\tconst { transaction } = await this.atomicDeleteAsset(assetId, optionalTxnArgs);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Creates send asset transaction.\n\t *\n\t * IMPORTANT: Before you can call this, the target account has to \"opt-in\"\n\t * to the ASA index.  You can't just send ASAs to people blind!\n\t *\n\t * @param args - object containing `to`, `assetIndex`, and `amount` properties\n\t * @returns Promise resolving to `AlgonautAtomicTransaction`\n\t */\n\tasync atomicSendAsset(args: AlgonautSendAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.to) throw new Error('No to address provided');\n\t\tif (!isValidAddress(args.to)) throw new Error('Invalid to address');\n\t\tif (!args.assetIndex) throw new Error('No asset index provided');\n\t\tif (!(typeof args.amount == 'bigint' || typeof args.amount == 'number')) {\n\t\t\tthrow new Error('Amount has to be a number.');\n\t\t}\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst transaction =\n\t\t\tmakeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\tfrom: fromAddr,\n\t\t\t\tto: args.to,\n\t\t\t\tamount: args.amount,\n\t\t\t\tassetIndex: args.assetIndex,\n\t\t\t\tsuggestedParams\n\t\t\t});\n\n\t\treturn {\n\t\t\ttransaction: transaction,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Sends asset to an address.\n\t *\n\t * IMPORTANT: Before you can call this, the target account has to \"opt-in\"\n\t * to the ASA index.  You can't just send ASAs to people blind!\n\t *\n\t * @param args - object containing `to`, `assetIndex`, and `amount` properties\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync sendAsset(args: AlgonautSendAssetArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tconst { transaction } = await this.atomicSendAsset(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Get info about an asset\n\t * @param assetIndex\n\t * @returns\n\t */\n\tasync getAssetInfo(assetIndex: number): Promise<any> {\n\t\tif (!assetIndex) throw new Error('No asset ID provided');\n\n\t\tconst info = await this.algodClient.getAssetByID(assetIndex).do();\n\t\treturn info;\n\t}\n\n\t/**\n\t * Creates transaction to opt into an app\n\t * @param args AlgonautCallAppArgs\n\t * @returns AlgonautAtomicTransaction\n\t */\n\tasync atomicOptInApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.appIndex) throw new Error('No app ID provided');\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst optInTransaction = makeApplicationOptInTxnFromObject({\n\t\t\tfrom: fromAddr,\n\t\t\tappIndex: args.appIndex,\n\t\t\tsuggestedParams,\n\t\t\tappArgs: args.appArgs ? this.encodeArguments(args.appArgs) : undefined,\n\t\t\taccounts: args.optionalFields?.accounts ? args.optionalFields?.accounts : undefined,\n\t\t\tforeignApps: args.optionalFields?.applications ? args.optionalFields?.applications : undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets ? args.optionalFields?.assets : undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: optInTransaction,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Opt-in the current account for an app.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields`\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync optInApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicOptInApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Returns atomic transaction that deletes application\n\t * @param appIndex - ID of application\n\t * @returns Promise resolving to atomic transaction that deletes application\n\t */\n\tasync atomicDeleteApp(appIndex: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!appIndex) throw new Error('No app ID provided');\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst txn = makeApplicationDeleteTxn(fromAddr, suggestedParams, appIndex);\n\n\t\treturn {\n\t\t\ttransaction: txn,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Deletes an application from the blockchain\n\t * @param appIndex - ID of application\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync deleteApp(appIndex: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\ttry {\n\t\t\tconst { transaction } = await this.atomicDeleteApp(appIndex, optionalTxnArgs);\n\t\t\tconst txId = transaction.txID().toString();\n\n\t\t\tconst status = await this.sendTransaction(transaction, callbacks);\n\n\t\t\t// display results\n\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t.do();\n\t\t\tconst appId = transactionResponse['txn']['txn'].apid;\n\n\t\t\treturn {\n\t\t\t\tstatus: 'success',\n\t\t\t\tmessage: 'deleted app index ' + appId,\n\t\t\t\ttxId\n\t\t\t};\n\n\t\t} catch (e: any) {\n\t\t\tlogger.log(e);\n\t\t\tthrow new Error(e.response?.text);\n\t\t}\n\t}\n\n\tasync atomicCallApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = args?.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\t\tif (!args.appArgs.length) throw new Error('Must provide at least one appArgs');\n\n\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst callAppTransaction = makeApplicationNoOpTxnFromObject({\n\t\t\tfrom: fromAddr,\n\t\t\tsuggestedParams,\n\t\t\tappIndex: args.appIndex,\n\t\t\tappArgs: processedArgs,\n\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets || undefined,\n\t\t\tnote: args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: callAppTransaction,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Call a \"method\" on a stateful contract.  In TEAL, you're really giving\n\t * an argument which branches to a specific place and reads the other args\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t */\n\tasync callApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicCallApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\tasync atomicCallAppWithLSig(args: AlgonautLsigCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\t\tif (!args.appArgs.length) throw new Error('Must provide at least one appArgs');\n\n\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst callAppTransaction = makeApplicationNoOpTxnFromObject({\n\t\t\tfrom: args.lsig.address(),\n\t\t\tsuggestedParams,\n\t\t\tappIndex: args.appIndex,\n\t\t\tappArgs: processedArgs,\n\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: callAppTransaction,\n\t\t\ttransactionSigner: args.lsig,\n\t\t\tisLogigSig: true\n\t\t};\n\t}\n\n\t/**\n\t * Returns an atomic transaction that closes out the user's local state in an application.\n\t * The opposite of {@link atomicOptInApp}.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t * @returns Promise resolving to atomic transaction\n\t */\n\tasync atomicCloseOutApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = args?.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\n\t\ttry {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\t\tconst closeOutTxn = makeApplicationCloseOutTxnFromObject({\n\t\t\t\tfrom: fromAddr,\n\t\t\t\tsuggestedParams,\n\t\t\t\tappIndex: args.appIndex,\n\t\t\t\tappArgs: processedArgs,\n\t\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: closeOutTxn,\n\t\t\t\ttransactionSigner: undefined,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\t\t} catch (e: any) {\n\t\t\tthrow new Error(e);\n\t\t}\n\t}\n\n\t/**\n\t * Closes out the user's local state in an application.\n\t * The opposite of {@link optInApp}.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to atomic transaction\n\t */\n\tasync closeOutApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks) {\n\t\tconst { transaction } = await this.atomicCloseOutApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Get an application's escrow account\n\t * @param appId - ID of application\n\t * @returns Escrow account address as string\n\t */\n\tgetAppEscrowAccount(appId: number | bigint): string {\n\t\tif (!appId) throw new Error('No appId provided');\n\t\treturn getApplicationAddress(appId);\n\t}\n\n\t/**\n\t * Get info about an application (globals, locals, creator address, index)\n\t *\n\t * @param appId - ID of application\n\t * @returns Promise resolving to application state\n\t */\n\tasync getAppInfo(appId: number): Promise<AlgonautAppState> {\n\t\tif (!appId) throw new Error('No appId provided');\n\n\t\tconst proms = [\n\t\t\tthis.algodClient.getApplicationByID(appId).do(),\n\t\t] as Promise<any>[];\n\n\t\tconst addr = this.walletState.activeAddress;\n\t\t// get locals if we have an account\n\t\tif (addr) {\n\t\t\tproms.push(this.getAppLocalState(appId)); // TODO get rid of this call / only return locals (not incorrect duplicate state obj)\n\t\t}\n\n\t\tconst promsRes = await Promise.all(proms);\n\t\tconst info = promsRes[0] as AlgonautGetApplicationResponse;\n\t\tconst localState = promsRes[1] as AlgonautAppState | void;\n\n\t\t// decode state\n\t\tconst state = {\n\t\t\thasState: true,\n\t\t\tglobals: [],\n\t\t\tlocals: localState?.locals || [],\n\t\t\tcreatorAddress: info.params.creator,\n\t\t\tindex: appId\n\t\t} as AlgonautAppState;\n\n\t\tif (info.params['global-state']) {\n\t\t\tstate.globals = this.decodeStateArray(info.params['global-state']);\n\t\t}\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Create and deploy a new Smart Contract from TEAL code\n\t *\n\t * @param args AlgonautDeployArguments\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns AlgonautTransactionStatus\n\t */\n\tasync createApp(\n\t\targs: AlgonautDeployArguments,\n\t\tcallbacks?: AlgonautTxnCallbacks\n\t): Promise<AlgonautTransactionStatus> {\n\t\tif (args.optionalFields &&\n\t\t\targs.optionalFields.note &&\n\t\t\targs.optionalFields.note.length > 1023) {\n\t\t\tconsole.warn('drat! your note is too long!');\n\t\t\tthrow new Error('Your note is too long');\n\t\t}\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (!args.schema) throw new Error('No schema provided');\n\n\t\ttry {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\t\t\t// logger.log('approval', approvalProgram);\n\t\t\t// logger.log('clear', clearProgram);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (approvalProgram && clearProgram) {\n\n\t\t\t\tconst txn = makeApplicationCreateTxnFromObject({\n\t\t\t\t\tfrom: fromAddr,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete: OnApplicationComplete.NoOpOC,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\tnumLocalInts: args.schema.localInts,\n\t\t\t\t\tnumLocalByteSlices: args.schema.localBytes,\n\t\t\t\t\tnumGlobalInts: args.schema.globalInts,\n\t\t\t\t\tnumGlobalByteSlices: args.schema.globalBytes,\n\t\t\t\t\tappArgs: this.encodeArguments(args.appArgs),\n\t\t\t\t\taccounts: args.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\t\tforeignApps: args.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\t\tforeignAssets: args.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\t\tnote: args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t\t});\n\t\t\t\tconst txId = txn.txID().toString();\n\n\t\t\t\t// Wait for confirmation\n\t\t\t\tconst result = await this.sendTransaction(txn, callbacks);\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\n\t\t\t\tresult.message = 'Created App ID: ' + transactionResponse['application-index'];\n\t\t\t\tresult.createdIndex = transactionResponse['application-index'];\n\t\t\t\tresult.meta = transactionResponse;\n\t\t\t\tresult.txId = txId;\n\t\t\t\treturn result;\n\n\t\t\t} else {\n\t\t\t\tthrow new Error('could not compile teal code');\n\t\t\t}\n\n\t\t} catch (er: any) {\n\t\t\tthrow new Error(er.message);\n\t\t}\n\t}\n\n\t/**\n\t * Create an atomic transaction to deploy a\n\t * new Smart Contract from TEAL code\n\t *\n\t * @param args AlgonautDeployArguments\n\t * @returns AlgonautAtomicTransaction\n\t */\n\tasync atomicCreateApp(args: AlgonautDeployArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (!args.schema) throw new Error('No schema provided');\n\n\t\tif (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {\n\t\t\tthrow new Error('Your NOTE is too long, it must be less thatn 1024 Bytes');\n\t\t} else if (fromAddr) {\n\t\t\ttry {\n\t\t\t\tconst onComplete = OnApplicationComplete.NoOpOC;\n\t\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t\t// create unsigned transaction\n\t\t\t\tif (!approvalProgram || !clearProgram) {\n\t\t\t\t\tthrow new Error('Error: you must provide an approval program and a clear state program.');\n\t\t\t\t}\n\n\t\t\t\tconst applicationCreateTransaction = makeApplicationCreateTxn(\n\t\t\t\t\tfromAddr,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\t\targs.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t\t);\n\n\t\t\t\treturn {\n\t\t\t\t\ttransaction: applicationCreateTransaction,\n\t\t\t\t\ttransactionSigner: undefined,\n\t\t\t\t\tisLogigSig: false\n\t\t\t\t};\n\n\t\t\t} catch (er: any) {\n\t\t\t\tthrow new Error('There was an error creating the transaction');\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Algonaut.js has no account loaded!');\n\t\t}\n\t}\n\n\n\t/**\n\t * deploys a contract from an lsig account\n\t * keep in mind that the local and global byte and int values have caps,\n\t * 16 for local and 32 for global and that the cost of deploying the\n\t * app goes up based on how many of these slots you want to allocate\n\t *\n\t * @param args AlgonautLsigDeployArguments\n\t * @returns\n\t */\n\tasync deployTealWithLSig(\n\t\targs: AlgonautLsigDeployArguments\n\t): Promise<AlgonautTransactionStatus> {\n\t\tif (args.noteText && args.noteText.length > 511) {\n\t\t\tthrow new Error('Your note is too long');\n\t\t}\n\n\t\tlet encodedArgs = [] as Uint8Array[];\n\t\tif (args.appArgs && args.appArgs.length) {\n\t\t\tencodedArgs = this.encodeArguments(args.appArgs);\n\t\t}\n\n\t\tconst sender = args.lsig.address();\n\t\tconst onComplete = OnApplicationComplete.NoOpOC;\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tlet approvalProgram = new Uint8Array();\n\t\tlet clearProgram = new Uint8Array();\n\n\t\ttry {\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (approvalProgram && clearProgram) {\n\t\t\t\tconst txn = makeApplicationCreateTxn(\n\t\t\t\t\tsender,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tencodedArgs,\n\t\t\t\t\targs.optionalFields?.accounts || undefined\n\t\t\t\t);\n\n\t\t\t\tconst txId = txn.txID().toString();\n\t\t\t\tconst signedTxn = signLogicSigTransactionObject(txn, args.lsig);\n\n\t\t\t\tawait this.algodClient.sendRawTransaction(signedTxn.blob).do();\n\t\t\t\tconst txStatus = await this.waitForConfirmation(txId);\n\n\t\t\t\t// TBD check txStatus\n\n\t\t\t\t// display results\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\t\t\t\tconst appId = transactionResponse['application-index'];\n\n\t\t\t\treturn {\n\t\t\t\t\tstatus: 'success',\n\t\t\t\t\tmessage: 'created new app with id: ' + appId,\n\t\t\t\t\ttxId\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthrow new Error('Error compiling programs.');\n\t\t\t}\n\t\t} catch (er: any) {\n\t\t\tconsole.error('Error deploying contract:');\n\t\t\tthrow new Error(er);\n\t\t}\n\t}\n\n\t/**\n\t * Updates an application with `makeApplicationUpdateTxn`\n\t * @param args AlgonautUpdateAppArguments\n\t * @returns atomic transaction that updates the app\n\t */\n\tasync atomicUpdateApp(args: AlgonautUpdateAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {\n\t\t\tthrow new Error('Your NOTE is too long, it must be less thatn 1024 Bytes');\n\t\t}\n\n\t\ttry {\n\t\t\tconst onComplete = OnApplicationComplete.NoOpOC;\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (!approvalProgram || !clearProgram) {\n\t\t\t\tthrow new Error('Error: you must provide an approval program and a clear state program.');\n\t\t\t}\n\n\t\t\tconst applicationCreateTransaction = makeApplicationUpdateTxn(\n\t\t\t\tfromAddr,\n\t\t\t\tsuggestedParams,\n\t\t\t\targs.appIndex,\n\t\t\t\tapprovalProgram,\n\t\t\t\tclearProgram,\n\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\targs.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\ttransaction: applicationCreateTransaction,\n\t\t\t\ttransactionSigner: undefined,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\n\t\t} catch (er: any) {\n\t\t\tthrow new Error('There was an error creating the transaction');\n\t\t}\n\t}\n\n\t/**\n\t * Sends an update app transaction\n\t * @param args AlgonautUpdateAppArguments\n\t * @param callbacks optional callbacks: `onSign`, `onSend`, `onConfirm`\n\t * @returns transaction status\n\t */\n\tasync updateApp(args: AlgonautUpdateAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicUpdateApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Compiles TEAL source via [algodClient.compile](https://py-algorand-sdk.readthedocs.io/en/latest/algosdk/v2client/algod.html#v2client.algod.AlgodClient.compile)\n\t * @param programSource source to compile\n\t * @returns Promise resolving to Buffer of compiled bytes\n\t */\n\tasync compileProgram(programSource: string): Promise<Uint8Array> {\n\t\tconst encoder = new TextEncoder();\n\t\tconst programBytes = encoder.encode(programSource);\n\t\tconst compileResponse = await this.algodClient.compile(programBytes).do();\n\t\tconst compiledBytes = new Uint8Array(\n\t\t\tBuffer.from(compileResponse.result, 'base64')\n\t\t);\n\t\treturn compiledBytes;\n\t}\n\n\tasync atomicSendAlgo(args: AlgonautPaymentArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!(typeof args.amount == 'bigint' || typeof args.amount == 'number')) {\n\t\t\tthrow new Error('Amount has to be a number.');\n\t\t}\n\t\tif (!args.to) throw new Error('You did not specify a to address');\n\t\tif (!isValidAddress(args.to)) throw new Error('Invalid to address');\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tif (fromAddr) {\n\t\t\tconst encodedNote = args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : new Uint8Array();\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tconst transaction =\n\t\t\t\tmakePaymentTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: fromAddr,\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tnote: encodedNote,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\ttransactionSigner: undefined,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no fromAddr');\n\t\t}\n\t}\n\n\t/**\n\t * Sends ALGO from own account to `args.to`\n\t *\n\t * @param args `AlgonautPaymentArgs` object containing `to`, `amount`, and optional `note`\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to transaction status\n\t */\n\tasync sendAlgo(args: AlgonautPaymentArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicSendAlgo(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Fetch full account info for an account\n\t * @param address the accress to read info for\n\t * @returns Promise of type AccountInfo\n\t */\n\tasync getAccountInfo(address: string): Promise<any> {\n\t\tif (!address) throw new Error('No address provided');\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\treturn accountInfo;\n\t}\n\n\n\t/**\n\t * Checks Algo balance of account\n\t * @param address - Wallet of balance to check\n\t * @returns Promise resolving to Algo balance\n\t */\n\tasync getAlgoBalance(address: string): Promise<any> {\n\t\tif (!address) throw new Error('No address provided');\n\t\t//logger.log('checking algo balance');\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\treturn accountInfo.amount;\n\t}\n\n\t/**\n\t * Checks token balance of account\n\t * @param address - Wallet of balance to check\n\t * @param assetIndex - the ASA index\n\t * @returns Promise resolving to token balance\n\t */\n\tasync getTokenBalance(address: string, assetIndex: number): Promise<number> {\n\t\tif (!address) throw new Error('No address provided');\n\t\tif (!assetIndex) throw new Error('No asset index provided');\n\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\t//logger.log('accountInfo', accountInfo);\n\n\t\tlet bal = 0;\n\t\taccountInfo.assets.forEach((asset: any) => {\n\t\t\tif (asset['asset-id'] == assetIndex) {\n\t\t\t\tbal = asset.amount;\n\t\t\t}\n\t\t});\n\n\t\treturn bal;\n\t}\n\n\t/**\n\t * Checks if account has at least one token (before playback)\n\t * Keeping this here in case this is a faster/less expensive operation than checking actual balance\n\t * @param address - Address to check\n\t * @param assetIndex - the index of the ASA\n\t */\n\tasync accountHasTokens(address: string, assetIndex: number): Promise<boolean> {\n\t\tlet bal = await this.getTokenBalance(address, assetIndex);\n\t\tif (bal > 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Gets global state for an application.\n\t * @param applicationIndex - the applications index\n\t * @returns {object} object representing global state\n\t */\n\tasync getAppGlobalState(applicationIndex: number): Promise<any> {\n\t\tif (!applicationIndex) throw new Error('No application ID provided');\n\n\t\tconst info = await this.getAppInfo(applicationIndex);\n\t\tif (info.hasState) {\n\t\t\treturn this.stateArrayToObject(info.globals);\n\t\t} else {\n\t\t\treturn {} as any;\n\t\t}\n\t}\n\n\t/**\n\t * Gets account local state for an app. Defaults to AnyWallets.activeAddress unless\n\t * an address is provided.\n\t * @param applicationIndex the applications index\n\t */\n\tasync getAppLocalState(applicationIndex: number, address?: string): Promise<AlgonautAppState | void> {\n\t\tif (!applicationIndex) throw new Error('No application ID provided');\n\n\t\tconst state = {\n\t\t\thasState: false,\n\t\t\tglobals: [],\n\t\t\tlocals: [],\n\t\t\tcreatorAddress: '',\n\t\t\tindex: applicationIndex\n\t\t} as AlgonautAppState;\n\n\t\t// read state\n\n\t\t// can we detect addresses values and auto-convert them?\n\t\t// maybe a 32-byte field gets an address field added?\n\n\t\tif (this.walletState.activeAddress && !address) {\n\t\t\taddress = this.walletState.activeAddress;\n\t\t}\n\n\t\tif (address) {\n\t\t\tconst accountInfoResponse = await this.algodClient\n\t\t\t\t.accountInformation(address)\n\t\t\t\t.do();\n\n\t\t\t//logger.log(accountInfoResponse);\n\n\t\t\tfor (let i = 0; i < accountInfoResponse['apps-local-state'].length; i++) {\n\t\t\t\tif (accountInfoResponse['apps-local-state'][i].id == applicationIndex) {\n\t\t\t\t\t//logger.log('Found Application');\n\n\t\t\t\t\tstate.hasState = true;\n\n\t\t\t\t\tfor (let n = 0; n < accountInfoResponse['apps-local-state'][i]['key-value'].length; n++) {\n\n\t\t\t\t\t\tconst stateItem = accountInfoResponse['apps-local-state'][i]['key-value'][n];\n\t\t\t\t\t\tconst key = Buffer.from(stateItem.key, 'base64').toString();\n\t\t\t\t\t\tconst type = stateItem.value.type;\n\t\t\t\t\t\tlet value = undefined as undefined | string | number;\n\t\t\t\t\t\tlet valueAsAddr = '';\n\n\t\t\t\t\t\tif (type == 1) {\n\t\t\t\t\t\t\tvalue = Buffer.from(stateItem.value.bytes, 'base64').toString();\n\t\t\t\t\t\t\tvalueAsAddr = encodeAddress(Buffer.from(stateItem.value.bytes, 'base64'));\n\n\t\t\t\t\t\t} else if (stateItem.value.type == 2) {\n\t\t\t\t\t\t\tvalue = stateItem.value.uint;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.locals.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tvalue: value || '',\n\t\t\t\t\t\t\taddress: valueAsAddr\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn state;\n\t\t} else {\n\t\t\t// throw new Error('No address provided, and no account set.');\n\t\t\tconsole.warn('Algonaut used in non-authd state, not getting local vars');\n\t\t}\n\t}\n\n\tasync atomicAssetTransferWithLSig(args: AlgonautLsigSendAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (args.lsig) {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tconst transaction =\n\t\t\t\tmakeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tassetIndex: args.assetIndex,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\ttransactionSigner: args.lsig,\n\t\t\t\tisLogigSig: true\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no logic sig object!');\n\t\t}\n\t}\n\n\tasync atomicPaymentWithLSig(args: AlgonautLsigPaymentArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (args.lsig) {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\t\tconst transaction =\n\t\t\t\tmakePaymentTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\ttransactionSigner: args.lsig,\n\t\t\t\tisLogigSig: true\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no account!');\n\t\t}\n\t}\n\n\tnormalizeTxns(txnOrTxns: Transaction | AlgonautAtomicTransaction | AlgonautAtomicTransaction[]) {\n\t\tlogger.log('normalizeTxns', txnOrTxns);\n\n\t\tlet txnArr: (AlgonautAtomicTransaction | Transaction)[] = [];\n\n\t\tif (!Array.isArray(txnOrTxns)) {\n\t\t\ttxnArr = [txnOrTxns];\n\t\t} else {\n\t\t\ttxnArr = txnOrTxns;\n\t\t}\n\t\t// logger.log('txnArr', txnArr);\n\n\t\tlet algoTxnArr: Transaction[] = [];\n\t\talgoTxnArr = txnArr.map((t) => {\n\t\t\tlet nativeT = (t as AlgonautAtomicTransaction).transaction as Transaction | undefined;\n\t\t\tif (nativeT == undefined) {\n\t\t\t\tnativeT = t as Transaction;\n\t\t\t}\n\t\t\treturn nativeT;\n\t\t});\n\t\t// logger.log('algoTxnArr', algoTxnArr);\n\t\tconst txnBuffArr = algoTxnArr.map(t => t.toByte());\n\t\t// logger.log('txnBuffArr', txnBuffArr);\n\n\t\treturn txnBuffArr;\n\t}\n\n\t/**\n\t * Signs a transaction or multiple w the correct wallet according to AW (does not send / submit txn(s) to network)\n\t * @param txnOrTxns Either an array of atomic transactions or a single transaction to sign\n\t * @param signedTxns array of \n\t * @returns Promise resolving to AlgonautTransactionStatus\n\t */\n\tasync signTransaction(txnOrTxns: AlgonautAtomicTransaction[] | Transaction | AlgonautAtomicTransaction): Promise<Uint8Array[]> {\n\t\tconst awTxnsToSign = this.normalizeTxns(txnOrTxns);\n\t\tlogger.log('awTxnsToSign', awTxnsToSign);\n\t\tlet awTxnsSigned: Uint8Array[];\n\t\ttry {\n\t\t\tawTxnsSigned = await signTransactions(awTxnsToSign);\n\t\t\tlogger.log('awTxnsSigned', awTxnsSigned);\n\t\t} catch(e) {\n\t\t\tconsole.warn('err signing txns...');\n\t\t\tlogger.log(e);\n\t\t\tthrow new Error('Error signing transactions');\n\t\t}\n\t\treturn awTxnsSigned;\n\t}\n\n\t/**\n\t * Sends a transaction or multiple w the correct wallet according to AW\n\t * @param txnOrTxns Either an array of atomic transactions or a single transaction to sign\n\t * @param callbacks Optional object with callbacks - `onSign`, `onSend`, and `onConfirm`\n\t * @returns Promise resolving to AlgonautTransactionStatus\n\t */\n\tasync sendTransaction(txnOrTxns: AlgonautAtomicTransaction[] | Transaction | AlgonautAtomicTransaction, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\t/**\n\t\t * 1. normalize incoming txn(s) to array of Uint8Arrs\n\t\t * 2. sign w AW\n\t\t * 3. send Raw txn arr\n\t\t * 4. return result + txid\n\t\t */\n\n\t\tconst awTxnsSigned = await this.signTransaction(txnOrTxns);\n\n\t\tif (callbacks?.onSign) callbacks.onSign(awTxnsSigned);\n\n\t\tconst tx = await this.algodClient.sendRawTransaction(awTxnsSigned).do();\n\n\t\tif (callbacks?.onSend) callbacks.onSend(tx);\n\n\t\t// Wait for transaction to be confirmed\n\t\tconst txStatus = await this.waitForConfirmation(tx.txId);\n\n\t\tconst transactionResponse = await this.algodClient\n\t\t\t.pendingTransactionInformation(tx.txId)\n\t\t\t.do();\n\t\ttxStatus.meta = transactionResponse;\n\n\t\tif (callbacks?.onConfirm) callbacks.onConfirm(txStatus);\n\t\treturn txStatus;\n\t}\n\n\t/**\n\t * \n\t * @param str string\n\t * @param enc the encoding type of the string (defaults to utf8)\n\t * @returns string encoded as Uint8Array\n\t */\n\ttoUint8Array(str: string, enc: BufferEncoding = 'utf8'): Uint8Array {\n\t\treturn new Uint8Array(Buffer.from(str, enc));\n\t}\n\n\t/**\n\t * @deprecated use toUint8Array instead.\n\t * @param str string\n\t * @param enc the encoding type of the string (defaults to utf8)\n\t * @returns string encoded as Uint8Array\n\t */\n\tto8Arr(str: string, enc: BufferEncoding = 'utf8'): Uint8Array {\n\t\treturn this.toUint8Array(str, enc);\n\t}\n\n\t/**\n\t * Helper function to turn `globals` and `locals` array into more useful objects\n\t *\n\t * @param stateArray State array returned from functions like {@link getAppInfo}\n\t * @returns A more useful object: `{ array[0].key: array[0].value, array[1].key: array[1].value, ... }`\n\t * TODO add correct typing for this method\n\t */\n\tstateArrayToObject(stateArray: object[]): any {\n\t\tconst stateObj = {} as any;\n\t\tstateArray.forEach((value: any) => {\n\t\t\tif (value.key) stateObj[value.key] = value.value || null;\n\t\t});\n\t\treturn stateObj;\n\t}\n\n\t/**\n\t * Used for decoding state\n\t * @param encoded Base64 string\n\t * @returns Human-readable string\n\t */\n\tb64StrToHumanStr(encoded: string): string {\n\t\treturn Buffer.from(encoded, 'base64').toString();\n\t}\n\n\t/**\n\t * @deprecated Use b64StrToHumanStr instead\n\t * @param encoded Base64 string\n\t * @returns Human-readable string\n\t */\n\tfromBase64(encoded: string): string {\n\t\treturn this.b64StrToHumanStr(encoded);\n\t}\n\n\t/**\n\t * Decodes a Base64-encoded Uint8 Algorand address and returns a string\n\t * @param encoded An encoded Algorand address\n\t * @returns Decoded address\n\t */\n\tvalueAsAddr(encoded: string): string {\n\t\treturn encodeAddress(Buffer.from(encoded, 'base64'));\n\t}\n\n\t/**\n\t * Decodes app state into a human-readable format\n\t * @param stateArray Encoded app state\n\t * @returns Array of objects with key, value, and address properties\n\t */\n\tdecodeStateArray(stateArray: AlgonautAppStateEncoded[]) {\n\t\tconst result: AlgonautStateData[] = [];\n\n\t\tfor (let n = 0;\n\t\t\tn < stateArray.length;\n\t\t\tn++) {\n\n\t\t\tconst stateItem = stateArray[n];\n\n\t\t\tconst key = this.b64StrToHumanStr(stateItem.key);\n\t\t\tconst type = stateItem.value.type;\n\t\t\tlet value = undefined as undefined | string | number;\n\t\t\tlet valueAsAddr = '';\n\n\t\t\tif (type == 1) {\n\t\t\t\tvalue = this.b64StrToHumanStr(stateItem.value.bytes);\n\t\t\t\tvalueAsAddr = this.valueAsAddr(stateItem.value.bytes);\n\n\t\t\t} else if (stateItem.value.type == 2) {\n\t\t\t\tvalue = stateItem.value.uint;\n\t\t\t}\n\n\t\t\tresult.push({\n\t\t\t\tkey: key,\n\t\t\t\tvalue: value || '',\n\t\t\t\taddress: valueAsAddr\n\t\t\t});\n\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Does what it says on the tin.\n\t * @param txn base64-encoded unsigned transaction\n\t * @returns transaction object\n\t */\n\tdecodeBase64UnsignedTransaction(txn: string): Transaction {\n\t\treturn decodeUnsignedTransaction(Buffer.from(txn, 'base64'));\n\t}\n\n\t/**\n\t * Describes an Algorand transaction, for display in Inkey\n\t * @param txn Transaction to describe\n\t */\n\ttxnSummary(txn: Transaction) {\n\t\t// for reference: https://developer.algorand.org/docs/get-details/transactions/transactions/\n\n\t\tif (txn.type) {\n\t\t\tconst to = txn.to ? encodeAddress(txn.to.publicKey) : '';\n\t\t\tconst from = txn.from ? encodeAddress(txn.from.publicKey) : '';\n\n\t\t\t// sending algo\n\t\t\tif (txn.type === 'pay') {\n\t\t\t\tif (txn.amount) {\n\t\t\t\t\treturn `Send ${microalgosToAlgos(txn.amount as number)} ALGO to ${to}`;\n\t\t\t\t} else {\n\t\t\t\t\treturn `Send 0 ALGO to ${to}`;\n\t\t\t\t}\n\n\t\t\t\t// sending assets\n\t\t\t} else if (txn.type === 'axfer') {\n\t\t\t\tif (!txn.amount && to === from) {\n\t\t\t\t\treturn `Opt-in to asset ID ${txn.assetIndex}`;\n\t\t\t\t} else {\n\t\t\t\t\tconst amount = txn.amount ? txn.amount : 0;\n\t\t\t\t\treturn `Transfer ${amount} of asset ID ${txn.assetIndex} to ${to}`;\n\t\t\t\t}\n\n\t\t\t\t// asset config\n\t\t\t\t// this could be creating, destroying, or configuring an asset,\n\t\t\t\t// depending on which fields are set\n\t\t\t} else if (txn.type === 'acfg') {\n\n\t\t\t\t// if unit name is supplied, we are creating\n\t\t\t\tif (txn.assetUnitName) {\n\t\t\t\t\treturn `Create asset ${txn.assetName}, symbol ${txn.assetUnitName}`;\n\t\t\t\t}\n\n\t\t\t\treturn `Configure asset ${txn.assetIndex}`;\n\n\t\t\t\t// asset freeze\n\t\t\t} else if (txn.type === 'afrz') {\n\t\t\t\treturn `Freeze asset ${txn.assetIndex}`;\n\n\t\t\t\t// application call\n\t\t\t} else if (txn.type === 'appl') {\n\t\t\t\t// let's find out what kind of application call this is\n\t\t\t\t// reference: https://developer.algorand.org/docs/get-details/dapps/avm/teal/specification/#oncomplete\n\t\t\t\tswitch (txn.appOnComplete) {\n\t\t\t\t\t// NoOp\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturn `Call to application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// OptIn\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn `Opt-in to application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// CloseOut\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn `Close out application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// ClearState\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturn `Execute clear state program of application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// Update\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\treturn `Update application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// Delete\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\treturn `Delete application ID ${txn.appIndex}`;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn `Call to application ID ${txn.appIndex}`;\n\t\t\t\t}\n\n\t\t\t\t// default case\n\t\t\t} else {\n\t\t\t\treturn `Transaction of type ${txn.type} to ${to}`;\n\t\t\t}\n\t\t} else {\n\t\t\t// no better option\n\t\t\treturn txn.toString();\n\t\t}\n\t}\n\n\t/**\n\t * Creates a wallet address + mnemonic from account's secret key.\n\t * Changed in 0.3: this does NOT set algonaut.account.\n\t * @returns AlgonautWallet Object containing `address` and `mnemonic`\n\t */\n\tcreateWallet(): AlgonautWallet {\n\t\tconst account = generateAccount();\n\n\t\tif (account) {\n\t\t\tconst mnemonic = secretKeyToMnemonic(account.sk);\n\t\t\treturn {\n\t\t\t\taddress: account.addr,\n\t\t\t\tmnemonic: mnemonic,\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('There was no account: could not create algonaut wallet!');\n\t\t}\n\t}\n\n\t/**\n\t * Recovers account from mnemonic\n\t * Changed in 0.3: this does NOT set algonaut.account.\n\t * @param mnemonic Mnemonic associated with Algonaut account\n\t * @returns If mnemonic is valid, returns algosdk account (.addr, .sk). Otherwise, throws an error.\n\t */\n\trecoverAccount(mnemonic: string): AlgosdkAccount {\n\t\tif (!mnemonic) throw new Error('No mnemonic provided.');\n\n\t\ttry {\n\t\t\tconst account = mnemonicToSecretKey(mnemonic);\n\t\t\tif (isValidAddress(account?.addr)) {\n\t\t\t\treturn account;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Not a valid mnemonic.');\n\t\t\t}\n\t\t} catch (error: any) {\n\t\t\t// should we throw an error here instead of returning false?\n\t\t\tconsole.error(error);\n\t\t\tthrow new Error('Could not recover account from mnemonic.');\n\t\t}\n\t}\n\n\t/**\n\t * txn(b64) -> txnBuff (buffer)\n\t * @param txn base64-encoded unsigned transaction\n\t * @returns trransaction as buffer object\n\t */\n\ttxnB64ToTxnBuff(txn: string): Buffer {\n\t\treturn Buffer.from(txn, 'base64');\n\t}\n\n\t/**\n\t * Converts between buff -> b64 (txns)\n\t * @param buff likely a algorand txn as a Uint8Array buffer\n\t * @returns string (like for inkey / base64 transmit use)\n\t */\n\ttxnBuffToB64(buff: Uint8Array): string {\n\t\treturn Buffer.from(buff).toString('base64');\n\t}\n\n\t/**\n\t * Does what it says on the tin.\n\t * @param txn algorand txn object\n\t * @returns string (like for inkey / base64 transmit use)\n\t */\n\ttxnToStr(txn: algosdk.Transaction): string {\n\t\tconst buff = txn.toByte();\n\t\treturn this.txnBuffToB64(buff);\n\t}\n\n}\nexport default Algonaut;\n\nexport const buffer = Buffer; // sometimes this is helpful on the frontend\n", "import type { AlgonautConfig } from './AlgonautTypes';\n\nexport const testnetConfig: AlgonautConfig['nodeConfig'] = {\n\tLEDGER: 'testnet',\n\tBASE_SERVER: 'https://testnet-api.algonode.cloud',\n\tINDEX_SERVER: '',\n\tAPI_TOKEN: '',\n\tPORT: '',\n};\nexport const mainnetConfig: AlgonautConfig['nodeConfig'] = {\n\tLEDGER: 'mainnet',\n\tBASE_SERVER: 'https://mainnet-api.algonode.cloud',\n\tINDEX_SERVER: '',\n\tAPI_TOKEN: '',\n\tPORT: '',\n};\nexport const defaultNodeConfig = testnetConfig;\n", "import type { AlgonautConfig } from './AlgonautTypes';\n\nexport const defaultLibConfig: AlgonautConfig['libConfig'] = {\n\tdisableLogs: true,\n};\n", "\n// log helper - for disabling logs w a query string but not the dapp's logs\nexport const logger = {\n\tenabled: false,\n\tlog(...args: any) {\n\t\tif (!this.enabled) return;\n\t\tconsole.log(...args);\n\t},\n\tdebug(...args: any) {\n\t\tif (!this.enabled) return;\n\t\tconsole.debug(...args);\n\t},\n};\n"],
  "mappings": ";;;;;;;;2mJAAA,IAAAA,GAAAC,EAAA,CAAAC,GAAAC,KAAA,EAAC,SAAUC,EAAQC,EAAS,CAC3B,OAAOH,IAAY,UAAY,OAAOC,GAAW,IAAcE,EAAQH,EAAO,EAC9E,OAAO,QAAW,YAAc,OAAO,IAAM,OAAO,CAAC,SAAS,EAAGG,CAAO,GACvED,EAAS,OAAO,WAAe,IAAc,WAAaA,GAAU,KAAMC,EAAQD,EAAO,IAAM,CAAC,CAAC,EACnG,GAAGF,GAAO,SAAUA,EAAS,CAAE,aAG9B,IAAII,EAAkB,CAAC,EAGnBC,EAAkB,CAAC,EAEvB,oEACE,MAAM,EAAE,EACR,QAAQ,SAAUC,EAAMC,EAAG,CAC3BH,EAAgBE,GAAQC,EACxBF,EAAgBE,GAAKD,CACtB,CAAC,EAGF,SAASE,EAAOC,EAAQ,CAEvB,IAAIC,EAAS,CAAC,EAEVC,EAAQ,EACRC,EAAQ,EAEZ,QAASL,EAAI,EAAGA,EAAIE,EAAO,OAAQF,GAAK,EAAG,CAC1C,IAAIM,EAAUT,EAAgBK,EAAOF,IAErC,GAAIM,IAAY,OACf,MAAM,IAAI,MAAM,sBAAwBJ,EAAOF,GAAK,GAAG,EAGxD,IAAMO,EAAuBD,EAAU,GAKvC,GAHAA,GAAW,GACXD,GAASC,GAAWF,EAEhBG,EACHH,GAAS,MACH,CACN,IAAMI,GAAgBH,EAAQ,EAC9BA,KAAW,EAEPG,GACHL,EAAO,KAAKE,IAAU,EAAI,YAAc,CAACA,CAAK,EAE9CF,EAAO,KAAKE,CAAK,EAIlBA,EAAQD,EAAQ,CACjB,CACD,CAEA,OAAOD,CACR,CAGA,SAASM,EAAOJ,EAAO,CACtB,GAAI,OAAOA,GAAU,SACpB,OAAOK,EAAeL,CAAK,EAG5B,IAAIF,EAAS,GACb,QAASH,EAAI,EAAGA,EAAIK,EAAM,OAAQL,GAAK,EACtCG,GAAUO,EAAeL,EAAML,EAAE,EAGlC,OAAOG,CACR,CAGA,SAASO,EAAeC,EAAK,CAC5B,IAAIR,EAAS,GAETQ,EAAM,EACTA,EAAO,CAACA,GAAO,EAAK,EAEpBA,IAAQ,EAGT,EAAG,CACF,IAAIC,EAAUD,EAAM,GACpBA,KAAS,EAELA,EAAM,IACTC,GAAW,IAGZT,GAAUL,EAAgBc,EAC3B,OAASD,EAAM,GAEf,OAAOR,CACR,CAEAV,EAAQ,OAASQ,EACjBR,EAAQ,OAASgB,EAEjB,OAAO,eAAehB,EAAS,aAAc,CAAE,MAAO,EAAK,CAAC,CAE7D,CAAE;;;;yypCCtGF,IAAAoB,GAAA,GAAAC,GAAAD,GAAA,iBAAAE,GAAA,aAAAC,GAAA,mBAAAC,GAAA,eAAAC,GAAA,eAAAC,GAAA,eAAAC,GAAA,gBAAAC,GAAA,oBAAAC,GAAA,yBAAAC,GAAA,sBAAAC,GAAA,uBAAAC,GAAA,8BAAAC,GAAA,cAAAC,GAAA,yBAAAC,GAAA,wBAAAC,GAAA,WAAAC,GAAA,iBAAAC,GAAA,YAAAC,GAAA,mBAAAC,GAAA,kBAAAC,GAAA,mBAAAC,GAAA,0BAAAC,GAAA,cAAAC,GAAA,WAAAC,GAAA,UAAAC,GAAA,kBAAAC,GAAA,6BAAAC,GAAA,sBAAAC,GAAA,uBAAAC,GAAA,mBAAAC,GAAA,qBAAAC,GAAA,kBAAAC,GAAA,8BAAAC,GAAA,4BAAAC,GAAA,aAAAC,QAAA,eAAAC,GAAArC,y8+BCEO,IAAMsC,GAA8C,CAC1D,OAAQ,UACR,YAAa,qCACb,aAAc,GACd,UAAW,GACX,KAAM,EACP,EACaC,GAA8C,CAC1D,OAAQ,UACR,YAAa,qCACb,aAAc,GACd,UAAW,GACX,KAAM,EACP,EACaC,GAAoBF,GCd1B,IAAMG,GAAgD,CAC5D,YAAa,EACd,ECFO,IAAMC,GAAS,CACrB,QAAS,GACT,OAAOC,EAAW,CACb,CAAC,KAAK,SACV,QAAQ,IAAI,GAAGA,CAAI,CACpB,EACA,SAASA,EAAW,CACf,CAAC,KAAK,SACV,QAAQ,MAAM,GAAGA,CAAI,CACtB,CACD,EHZA,IAAAC,GAAuB,kBAEvBC,GA6BO,WA0EHC,GAAc,KAELC,GAAN,KAAe,CA6CrB,YAAYC,EAAyB,CA3CrC,mBAAgB,OAChB,gBAAaC,GACb,eAAYC,GAGZ,SAAM,GAAAC,QAGN,iBAAcC,GAEd,aAAU,KAkCT,KAAK,cAAcJ,GAAA,YAAAA,EAAQ,UAAU,EACrC,KAAK,cAAcA,GAAA,YAAAA,EAAQ,WAAW,EACtC,KAAK,aAAaA,GAAA,YAAAA,EAAQ,SAAS,EACnC,KAAK,aAAa,CACnB,CArCA,IAAI,mBAAoB,CACvB,OAAOI,GAAe,iBACvB,CAqCA,aAAaC,EAAyC,CAEjDA,GAAa,OAChBA,EAAYH,IAETG,IAAc,QACb,gBAAiBA,GAAa,OAAOA,EAAU,aAAe,YACjEC,GAAO,QAAU,CAACD,EAAU,YAC5BE,GAAiB,CAACF,EAAU,WAAW,EAG1C,CAOA,kBAAkBG,EAAoD,CAErE,IAAIC,EAAU,GAGd,OAAID,GAAc,MAAa,CAACA,EAAW,eAC1CC,EAAU,IAMJA,CACR,CAOA,cAAcD,EAAmE,CAMhF,GAJIA,GAAc,OACjBA,EAAaP,IAGV,OAAOO,GAAc,SACxB,GAAIA,GAAc,UACjBA,EAAaE,WACHF,GAAc,UACxBA,EAAaG,OAEb,OAAM,IAAI,MAAM,yBAAyB,EAI3C,GAAI,CAAC,KAAK,kBAAkBH,CAAU,EACrC,MAAM,IAAI,MAAM,kBAAkB,EAEnC,GAAI,OAAOA,GAAc,YACxB,MAAM,IAAI,MAAM,uBAAuB,EAGxC,KAAK,WAAaA,EAClB,KAAK,YAAc,IAAI,WAAQA,EAAW,UAAWA,EAAW,YAAaA,EAAW,IAAI,EAExFA,EAAW,aACd,KAAK,cAAgB,IAAI,WAAQA,EAAW,UAAWA,EAAW,aAAcA,EAAW,IAAI,EAE/F,QAAQ,KAAK,8DAA8D,CAE7E,CAKA,eAAwD,CACvD,OAAI,KAAK,WAAmB,KAAK,WAC1B,EACR,CAMA,MAAM,aAA4C,CACjD,GAAI,CAAC,KAAK,cAAc,EACvB,MAAM,IAAI,MAAM,4BAA4B,EAG7C,IAAMI,EAAS,MAAM,KAAK,YAAY,OAAO,EAAE,GAAG,EAClD,OAAAN,GAAO,IAAI,8BAA+BM,CAAM,EACzCA,CACR,CAEA,cAAe,CACdd,GAAce,GACZC,GAAS,CACTR,GAAO,IAAI,eAAgBQ,CAAI,EAC/B,KAAK,QAAUA,CAChB,CACD,CACD,CACA,cAAe,CACVhB,IAAaA,GAAY,CAC9B,CAEA,cAAciB,EAAkD,CAC3DA,GAAoB,MACvBT,GAAO,IAAI,kCAAkC,EAM9CU,GADYD,GAH4B,CACvC,MAAO,EACR,CAEiB,CAClB,CASA,MAAM,gBAAgBE,EAAsC,CAC3D,GAAI,CAACA,EAAU,MAAM,IAAI,MAAM,iDAAiD,EAChF,OAAO,MAAM,KAAK,QAAQ,CACzB,SAAAA,CACD,CAAC,CACF,CAKA,MAAM,cAAmC,CACxC,eAAQ,KAAK,kDAAkD,EACxD,MAAM,KAAK,QAAQ,CACzB,MAAO,EACR,CAAC,CACF,CAKA,MAAM,iBAAkB,CACvB,eAAQ,KAAK,wDAAwD,EAC9D,MAAM,KAAK,WAAW,CAACC,GAAU,KAAK,CAAC,CAC/C,CAMA,MAAM,WAAY,CAvTnB,IAAAC,EA0TE,IAAIC,GAASD,EAAAf,GAAe,iBAAf,YAAAe,EAA+B,MAC5C,GAAI,CAACC,EAAQ,CACZ,QAAQ,KAAK,6BAA6B,EAC1C,MACD,CAOA,GANIhB,GAAe,gBAAkB,MACpC,MAAM,KAAK,aAAa,EAKrBA,GAAe,iBAAmB,QAAS,CAC9C,QAAQ,KAAK,kDAAkD,EAC/D,MACD,CAEA,MAAMgB,EAAO,WAAW,EACnBA,EAAO,OAAe,IAAI,SAAS,MACtCA,EAAO,OAAe,IAAI,KAAK,EAEhC,QAAQ,KAAK,4BAA4B,CAE3C,CAMA,MAAM,WAAY,CAtVnB,IAAAD,EAuVE,IAAIC,GAASD,EAAAf,GAAe,iBAAf,YAAAe,EAA+B,MAC5C,GAAI,CAACC,EAAQ,CACZ,QAAQ,KAAK,0BAA0B,EACvC,MACD,CAUA,MAAMA,EAAO,WAAW,EACnBA,EAAO,OAAe,IAAI,SAAS,MACtCA,EAAO,OAAe,IAAI,KAAK,EAEhC,QAAQ,KAAK,4BAA4B,CAE3C,CAQA,MAAM,QAAQC,EAAmC,CAEhD,GAAIA,IAAgB,OAAW,CAC9B,IAAMC,EAAS,OAAO,QAAQD,CAAW,EACzC,GAAIC,EAAO,QAAU,EAAG,CACvB,IAAMC,EAAMD,EAAO,GAAG,GAChBE,EAAcF,EAAO,GAAG,GACxBG,EAAIrB,GAAe,WAAWmB,GAGpC,GAFAjB,GAAO,MAAM,YAAaiB,EAAKC,CAAW,EAEtCC,IAAM,OAET,OAAIrB,GAAe,gBAAkB,MACpC,CAAEA,GAAe,eAAemB,KAGhCP,GAAcK,CAAW,EAM1BI,EAAE,WAAaD,EAUR,MAAMC,EAAE,QAAQ,EAEvB,MAAM,IAAI,MAAM,iCAAiC,CAEnD,KACC,OAAM,IAAI,MAAM,sJAAsJ,CAExK,SAEKrB,GAAe,eAAgB,CAClC,IAAMsB,EAAY,OAAO,QAAQtB,GAAe,cAAc,EAC9D,GAAIsB,EAAU,QAAU,EAAG,CAC1B,IAAMD,EAAIC,EAAU,GAAG,GACvB,GAAID,EAAG,CACN,GAAKA,EAAE,YAUN,MAAM,IAAI,MAAM,2BAA2B,EAF3C,OAAO,MAAMA,EAAE,QAAQ,CAIzB,KACC,OAAM,IAAI,MAAM,qCAAqC,CAEvD,KACC,OAAM,IAAI,MAAM,oDAAoD,CAEtE,KACC,OAAM,IAAI,MAAM,gCAAgC,CAGnD,CAQA,MAAM,WAAWE,EAA2B,CAC3C,GAAI,OAAOA,GAAQ,KAElB,GAAIvB,GAAe,eAAgB,CAClC,IAAMsB,EAAY,OAAO,QAAQtB,GAAe,cAAc,EAC9D,GAAIsB,EAAU,QAAU,EAAG,CAC1B,IAAMD,EAAIC,EAAU,GAAG,GACvB,GAAID,EAAG,CACN,GAAIA,EAAE,YACL,OAAAnB,GAAO,IAAI,+BAAgCmB,EAAE,EAAE,EACxC,MAAMA,EAAE,WAAW,EAE1B,MAAM,IAAI,MAAM,8BAA8B,CAEhD,KACC,OAAM,IAAI,MAAM,qCAAqC,CAEvD,KACC,OAAM,IAAI,MAAM,oDAAoD,CAEtE,KACC,OAAM,IAAI,MAAM,mCAAmC,UAE1C,OAAOE,GAAQ,WACzB,GAAIA,GAAQ,GAAM,CAEjBrB,GAAO,IAAI,qCAAqC,EAChD,QAASiB,KAAO,OAAO,KAAKnB,GAAe,UAAU,EAAG,CACvD,IAAMqB,EAAIrB,GAAe,WAAWmB,GACpC,GAAIE,EAAG,CACN,GAAIA,EAAE,YACL,OAAAnB,GAAO,IAAI,wBAAyBiB,CAAG,EAChC,MAAME,EAAE,WAAW,EAE1B,MAAM,IAAI,MAAM,8BAA8B,CAEhD,KACC,OAAM,IAAI,MAAM,gEAAgE,CAElF,CACD,UAIU,MAAM,QAAQE,CAAI,EAAG,CAE/BrB,GAAO,IAAI,+BAAgCqB,CAAI,EAC/C,QAASJ,KAAOI,EAAM,CACrB,IAAMF,EAAIrB,GAAe,WAAWmB,GACpC,GAAIE,EAAG,CACN,GAAIA,EAAE,YACL,OAAAnB,GAAO,IAAI,wBAAyBiB,CAAG,EAChC,MAAME,EAAE,WAAW,EAE1B,MAAM,IAAI,MAAM,8BAA8B,CAEhD,KACC,OAAM,IAAI,MAAM,gEAAgE,CAElF,CACD,MACCnB,GAAO,MAAM,+DAA+D,CAE9E,CAEA,eAAgB,CACfsB,GAAkB,CACnB,CAQA,MAAM,oBAAoBC,EAAcC,EAAqBC,EAAM,GAA2C,CA1gB/G,IAAAZ,EA2gBE,GAAI,CAACU,EAAM,MAAM,IAAI,MAAM,kDAAkD,EAE7E,IAAIG,GAAa,MAAM,KAAK,YAAY,OAAO,EAAE,GAAG,GAAG,cACjDC,EAAQD,GAAaF,GAA0B,IAE/CI,EAAc,CACnB,OAAQ,OACR,QAAS,EACV,EAEA,KAAOF,EAAYC,GAAO,CACzB,IAAIE,EAAc,GAClB,GAAI,CACHA,EAAc,MAAM,KAAK,YACvB,8BAA8BN,CAAI,EAClC,GAAG,EACDE,GACHzB,GAAO,IAAI,0BAA0B,CAEvC,OAAS8B,EAAP,CACD,QAAQ,OAAMjB,EAAAiB,EAAG,WAAH,YAAAjB,EAAa,IAAI,CAChC,CAEA,GACCgB,EAAY,qBAAuB,MACnCA,EAAY,mBAAqB,EAChC,CAEGJ,GACHzB,GAAO,IAAI,kCAAoC6B,EAAY,kBAAkB,EAG9ED,EAAY,KAAOL,EACnBK,EAAY,OAAS,UACrBA,EAAY,QAAU,kCAAoCC,EAAY,mBAEtE,KACD,CAEAH,GAAa,MAAM,KAAK,YAAY,OAAO,EAAE,GAAG,GAAG,aACpD,CAEA,OAAOE,CAER,CAQA,iBAAiBG,EAA8C,CAC9D,GAAI,CAACA,EAAqB,MAAM,IAAI,MAAM,6BAA6B,EAEvE,IAAMC,EAAU,IAAI,WACnB,UAAO,KAAKD,EAAqB,QAAQ,CAC1C,EAEA,OAAO,IAAI,mBAAgBC,CAAO,CACnC,CAEA,MAAM,iBAAiBC,EAAoBC,EAAiF,CAC3H,GAAI,CAAC,KAAK,YAAY,cAAe,MAAM,IAAI,MAAM,6BAA6B,EAClF,GAAI,CAACD,EAAY,MAAM,IAAI,MAAM,0BAA0B,EAE3D,IAAME,GAAkBD,GAAA,YAAAA,EAAiB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAU9G,MAAO,CACN,eATwB,sDAAkD,CAC1E,KAAM,KAAK,YAAY,cACvB,GAAI,KAAK,YAAY,cACrB,WAAYD,EACZ,OAAQ,EACR,gBAAAE,CACD,CAAC,EAIA,kBAAmB,OACnB,WAAY,EACb,CACD,CAQA,MAAM,WAAWF,EAAoBG,EAAkCF,EAAiF,CACvJ,GAAI,CAAC,KAAK,YAAY,cAAe,MAAM,IAAI,MAAM,uBAAuB,EAC5E,GAAI,CAACD,EAAY,MAAM,IAAI,MAAM,0BAA0B,EAC3D,GAAM,CAAE,YAAAI,CAAY,EAAI,MAAM,KAAK,iBAAiBJ,EAAYC,CAAe,EAC/E,OAAO,MAAM,KAAK,gBAAgBG,EAAaD,CAAS,CACzD,CA+BA,MAAM,iBAAiBE,EAA8D,CACpF,GAAI,CAACA,EAAK,QAAS,MAAM,IAAI,MAAM,sBAAsB,EACzD,GAAI,CAACA,EAAK,QAAS,MAAM,IAAI,MAAM,uBAAuB,EAE1D,IAAIC,EAAa,GAEjB,OADoB,MAAM,KAAK,eAAeD,EAAK,OAAO,GAC9C,OAAO,QAASE,GAAe,CACtCA,EAAM,aAAeF,EAAK,UAC7BC,EAAa,GAGf,CAAC,EAEMA,CACR,CASA,gBAAgBD,EAA2B,CAC1C,IAAMG,EAAc,CAAC,EAGrB,OAAAH,EAAK,QAASI,GAAa,CACtB,OAAOA,GAAO,SACjBD,EAAY,QAAK,iBAAaC,CAAG,CAAC,EACxB,OAAOA,GAAO,SACxBD,EAAY,QAAK,iBAAaC,CAAG,CAAC,EACxB,OAAOA,GAAO,UACxBD,EAAY,KAAK,IAAI,WAAW,UAAO,KAAKC,CAAG,CAAC,CAAC,CAEnD,CAAC,EAEMD,CACR,CAOA,MAAM,kBAAkBH,EAAwE,CArrBjG,IAAAzB,GAsrBE,GAAI,CAACyB,EAAK,UAAW,MAAM,IAAI,MAAM,8BAA8B,EACnE,GAAI,CAACA,EAAK,OAAQ,MAAM,IAAI,MAAM,0BAA0B,EAC5D,GAAI,OAAOA,EAAK,UAAY,YAAa,MAAM,IAAI,MAAM,6BAA6B,EACtF,GAAI,CAACA,EAAK,OAAQ,MAAM,IAAI,MAAM,2BAA2B,EAC7D,IAAMK,EAAWL,EAAK,MAAQ,KAAK,YAAY,cAC/C,GAAI,CAACK,EAAU,MAAM,IAAI,MAAM,sBAAsB,EAEhDL,EAAK,YACTA,EAAK,UAAY,KAGbA,EAAK,gBAAeA,EAAK,cAAgB,IACzCA,EAAK,WAAUA,EAAK,SAAW,QAEpC,IAAMM,EAAkBN,EAAK,UAAU,OAEvC,GAAIM,EAAkB,KACrB,cAAQ,MAAM,iBAAmBA,CAAe,EAC1C,IAAI,MAAM,oCAAoC,EAMrD,IAAMC,EAHM,IAAI,YAAY,EAGX,OAAOP,EAAK,SAAS,EAChCQ,EAAgBR,EAAK,OAGrBS,EAAWT,EAAK,SAAWA,EAAK,QAAQ,OAAS,EAAKA,EAAK,QAAUK,EACrEK,EAAWV,EAAK,SAAWA,EAAK,QAAQ,OAAS,EAAKA,EAAK,QAAUK,EACrEM,EAAUX,EAAK,QAAUA,EAAK,OAAO,OAAS,EAAKA,EAAK,OAASK,EACjEO,EAAYZ,EAAK,UAAYA,EAAK,SAAS,OAAS,EAAKA,EAAK,SAAWK,EAEzER,IAAkBtB,GAAAyB,EAAK,iBAAL,YAAAzB,GAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAoBlH,MAAO,CACN,eAlBW,0CACX8B,EACAE,EACAC,EACAR,EAAK,SACLA,EAAK,cACLS,EACAC,EACAC,EACAC,EACAZ,EAAK,OACLA,EAAK,UACLA,EAAK,SACLA,EAAK,kBACLH,CACD,EAIC,kBAAmB,OACnB,WAAY,EACb,CACD,CASA,MAAM,YACLG,EACAF,EACqC,CAErC,IAAMe,GADY,MAAM,KAAK,kBAAkBb,CAAI,GAC7B,YAEtB,GAAI,CAEH,IAAMc,EAAW,MAAM,KAAK,gBAAgBD,EAAKf,CAAS,EAEpDiB,EAAM,MAAM,KAAK,YACrB,8BAA8BF,EAAI,KAAK,EAAE,SAAS,CAAC,EACnD,GAAG,EACL,OAAAC,EAAS,aAAeC,EAAI,eAErBD,CAER,OAAStB,EAAP,CACD,MAAA9B,GAAO,IAAI,mBAAmB,EAC9BA,GAAO,IAAI8B,CAAE,EACP,IAAI,MAAMA,CAAS,CAC1B,CACD,CAEA,MAAM,kBAAkBwB,EAAiBpB,EAAiF,CACzH,GAAI,CAAC,KAAK,YAAY,cAAe,MAAM,IAAI,MAAM,uBAAuB,EAC5E,GAAI,CAACoB,EAAS,MAAM,IAAI,MAAM,sBAAsB,EAEpD,IAAMC,EAAM,IAAI,YACVpB,GAAkBD,GAAA,YAAAA,EAAiB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAS9G,MAAO,CACN,eARmB,2CACnB,KAAK,YAAY,cACjBqB,EAAI,OAAO,MAAM,EACjBD,EACAnB,CACD,EAIC,kBAAmB,OACnB,WAAY,EACb,CACD,CAQA,MAAM,YAAYmB,EAAiBlB,EAAkCF,EAAiF,CACrJ,GAAI,CAACoB,EAAS,MAAM,IAAI,MAAM,uBAAuB,EACrD,GAAM,CAAE,YAAAjB,CAAY,EAAI,MAAM,KAAK,kBAAkBiB,EAASpB,CAAe,EAC7E,OAAO,MAAM,KAAK,gBAAgBG,EAAaD,CAAS,CACzD,CAWA,MAAM,gBAAgBE,EAAsE,CA5zB7F,IAAAzB,EA6zBE,GAAI,CAACyB,EAAK,GAAI,MAAM,IAAI,MAAM,wBAAwB,EACtD,GAAI,IAAC,mBAAeA,EAAK,EAAE,EAAG,MAAM,IAAI,MAAM,oBAAoB,EAClE,GAAI,CAACA,EAAK,WAAY,MAAM,IAAI,MAAM,yBAAyB,EAC/D,GAAI,EAAE,OAAOA,EAAK,QAAU,UAAY,OAAOA,EAAK,QAAU,UAC7D,MAAM,IAAI,MAAM,4BAA4B,EAE7C,IAAMK,EAAWL,EAAK,MAAQ,KAAK,YAAY,cAC/C,GAAI,CAACK,EAAU,MAAM,IAAI,MAAM,sBAAsB,EAErD,IAAMR,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAWlH,MAAO,CACN,eATA,sDAAkD,CACjD,KAAM8B,EACN,GAAIL,EAAK,GACT,OAAQA,EAAK,OACb,WAAYA,EAAK,WACjB,gBAAAH,CACD,CAAC,EAID,kBAAmB,OACnB,WAAY,EACb,CACD,CAYA,MAAM,UAAUG,EAAkCF,EAAsE,CAEvH,GAAI,EADaE,EAAK,MAAQ,KAAK,YAAY,eAChC,MAAM,IAAI,MAAM,sBAAsB,EACrD,GAAM,CAAE,YAAAD,CAAY,EAAI,MAAM,KAAK,gBAAgBC,CAAI,EACvD,OAAO,MAAM,KAAK,gBAAgBD,EAAaD,CAAS,CACzD,CAOA,MAAM,aAAaH,EAAkC,CACpD,GAAI,CAACA,EAAY,MAAM,IAAI,MAAM,sBAAsB,EAGvD,OADa,MAAM,KAAK,YAAY,aAAaA,CAAU,EAAE,GAAG,CAEjE,CAOA,MAAM,eAAeK,EAAoE,CA13B1F,IAAAzB,EAAA2C,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EA23BE,GAAI,CAACvB,EAAK,SAAU,MAAM,IAAI,MAAM,oBAAoB,EACxD,IAAMK,EAAW,KAAK,YAAY,cAClC,GAAI,CAACA,EAAU,MAAM,IAAI,MAAM,sBAAsB,EACrD,IAAMR,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAYlH,MAAO,CACN,eAXwB,sCAAkC,CAC1D,KAAM8B,EACN,SAAUL,EAAK,SACf,gBAAAH,EACA,QAASG,EAAK,QAAU,KAAK,gBAAgBA,EAAK,OAAO,EAAI,OAC7D,UAAUkB,EAAAlB,EAAK,iBAAL,MAAAkB,EAAqB,UAAWC,EAAAnB,EAAK,iBAAL,YAAAmB,EAAqB,SAAW,OAC1E,aAAaC,EAAApB,EAAK,iBAAL,MAAAoB,EAAqB,cAAeC,EAAArB,EAAK,iBAAL,YAAAqB,EAAqB,aAAe,OACrF,eAAeC,EAAAtB,EAAK,iBAAL,MAAAsB,EAAqB,QAASC,EAAAvB,EAAK,iBAAL,YAAAuB,EAAqB,OAAS,MAC5E,CAAC,EAIA,kBAAmB,OACnB,WAAY,EACb,CACD,CAQA,MAAM,SAASvB,EAAgCF,EAAsE,CACpH,GAAM,CAAE,YAAAC,CAAY,EAAI,MAAM,KAAK,eAAeC,CAAI,EACtD,OAAO,MAAM,KAAK,gBAAgBD,EAAaD,CAAS,CACzD,CAOA,MAAM,gBAAgB0B,EAAkB5B,EAAiF,CACxH,GAAI,CAAC4B,EAAU,MAAM,IAAI,MAAM,oBAAoB,EACnD,IAAMnB,EAAW,KAAK,YAAY,cAClC,GAAI,CAACA,EAAU,MAAM,IAAI,MAAM,sBAAsB,EAErD,IAAMR,GAAkBD,GAAA,YAAAA,EAAiB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAG9G,MAAO,CACN,eAHW,6BAAyBS,EAAUR,EAAiB2B,CAAQ,EAIvE,kBAAmB,OACnB,WAAY,EACb,CACD,CAQA,MAAM,UAAUA,EAAkB1B,EAAkCF,EAAiF,CAt7BtJ,IAAArB,EAu7BE,GAAI,CACH,GAAM,CAAE,YAAAwB,CAAY,EAAI,MAAM,KAAK,gBAAgByB,EAAU5B,CAAe,EACtEX,EAAOc,EAAY,KAAK,EAAE,SAAS,EAEnC/B,EAAS,MAAM,KAAK,gBAAgB+B,EAAaD,CAAS,EAM1D2B,GAHsB,MAAM,KAAK,YACrC,8BAA8BxC,CAAI,EAClC,GAAG,GAC6B,IAAO,IAAO,KAEhD,MAAO,CACN,OAAQ,UACR,QAAS,qBAAuBwC,EAChC,KAAAxC,CACD,CAED,OAASyC,EAAP,CACD,MAAAhE,GAAO,IAAIgE,CAAC,EACN,IAAI,OAAMnD,EAAAmD,EAAE,WAAF,YAAAnD,EAAY,IAAI,CACjC,CACD,CAEA,MAAM,cAAcyB,EAAoE,CA/8BzF,IAAAzB,EAAA2C,EAAAC,EAAAC,EAAAC,EAg9BE,IAAMhB,GAAWL,GAAA,YAAAA,EAAM,OAAQ,KAAK,YAAY,cAChD,GAAI,CAACK,EAAU,MAAM,IAAI,MAAM,sBAAsB,EACrD,GAAI,CAACL,EAAK,SAAU,MAAM,IAAI,MAAM,uBAAuB,EAC3D,GAAI,CAACA,EAAK,QAAQ,OAAQ,MAAM,IAAI,MAAM,mCAAmC,EAE7E,IAAM2B,EAAgB,KAAK,gBAAgB3B,EAAK,OAAO,EACjDH,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAYlH,MAAO,CACN,eAZ0B,qCAAiC,CAC3D,KAAM8B,EACN,gBAAAR,EACA,SAAUG,EAAK,SACf,QAAS2B,EACT,WAAUT,EAAAlB,EAAK,iBAAL,YAAAkB,EAAqB,WAAY,OAC3C,cAAaC,EAAAnB,EAAK,iBAAL,YAAAmB,EAAqB,eAAgB,OAClD,gBAAeC,EAAApB,EAAK,iBAAL,YAAAoB,EAAqB,SAAU,OAC9C,MAAMC,EAAArB,EAAK,iBAAL,MAAAqB,EAAqB,KAAO,KAAK,aAAarB,EAAK,eAAe,IAAI,EAAI,MACjF,CAAC,EAIA,kBAAmB,OACnB,WAAY,EACb,CACD,CAOA,MAAM,QAAQA,EAAgCF,EAAsE,CACnH,GAAM,CAAE,YAAAC,CAAY,EAAI,MAAM,KAAK,cAAcC,CAAI,EACrD,OAAO,MAAM,KAAK,gBAAgBD,EAAaD,CAAS,CACzD,CAEA,MAAM,sBAAsBE,EAAwE,CAn/BrG,IAAAzB,EAAA2C,EAAAC,EAAAC,EAo/BE,GAAI,CAACpB,EAAK,SAAU,MAAM,IAAI,MAAM,uBAAuB,EAC3D,GAAI,CAACA,EAAK,QAAQ,OAAQ,MAAM,IAAI,MAAM,mCAAmC,EAE7E,IAAM2B,EAAgB,KAAK,gBAAgB3B,EAAK,OAAO,EACjDH,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAWlH,MAAO,CACN,eAX0B,qCAAiC,CAC3D,KAAMyB,EAAK,KAAK,QAAQ,EACxB,gBAAAH,EACA,SAAUG,EAAK,SACf,QAAS2B,EACT,WAAUT,EAAAlB,EAAK,iBAAL,YAAAkB,EAAqB,WAAY,OAC3C,cAAaC,EAAAnB,EAAK,iBAAL,YAAAmB,EAAqB,eAAgB,OAClD,gBAAeC,EAAApB,EAAK,iBAAL,YAAAoB,EAAqB,SAAU,MAC/C,CAAC,EAIA,kBAAmBpB,EAAK,KACxB,WAAY,EACb,CACD,CAQA,MAAM,kBAAkBA,EAAoE,CAhhC7F,IAAAzB,EAAA2C,EAAAC,EAAAC,EAihCE,IAAMf,GAAWL,GAAA,YAAAA,EAAM,OAAQ,KAAK,YAAY,cAChD,GAAI,CAACK,EAAU,MAAM,IAAI,MAAM,sBAAsB,EACrD,GAAI,CAACL,EAAK,SAAU,MAAM,IAAI,MAAM,uBAAuB,EAE3D,GAAI,CACH,IAAMH,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAC5GoD,EAAgB,KAAK,gBAAgB3B,EAAK,OAAO,EAWvD,MAAO,CACN,eAXmB,yCAAqC,CACxD,KAAMK,EACN,gBAAAR,EACA,SAAUG,EAAK,SACf,QAAS2B,EACT,WAAUT,EAAAlB,EAAK,iBAAL,YAAAkB,EAAqB,WAAY,OAC3C,cAAaC,EAAAnB,EAAK,iBAAL,YAAAmB,EAAqB,eAAgB,OAClD,gBAAeC,EAAApB,EAAK,iBAAL,YAAAoB,EAAqB,SAAU,MAC/C,CAAC,EAIA,kBAAmB,OACnB,WAAY,EACb,CACD,OAASM,EAAP,CACD,MAAM,IAAI,MAAMA,CAAC,CAClB,CACD,CASA,MAAM,YAAY1B,EAAgCF,EAAkC,CACnF,GAAM,CAAE,YAAAC,CAAY,EAAI,MAAM,KAAK,kBAAkBC,CAAI,EACzD,OAAO,MAAM,KAAK,gBAAgBD,EAAaD,CAAS,CACzD,CAOA,oBAAoB2B,EAAgC,CACnD,GAAI,CAACA,EAAO,MAAM,IAAI,MAAM,mBAAmB,EAC/C,SAAO,0BAAsBA,CAAK,CACnC,CAQA,MAAM,WAAWA,EAA0C,CAC1D,GAAI,CAACA,EAAO,MAAM,IAAI,MAAM,mBAAmB,EAE/C,IAAMG,EAAQ,CACb,KAAK,YAAY,mBAAmBH,CAAK,EAAE,GAAG,CAC/C,EAEa,KAAK,YAAY,eAG7BG,EAAM,KAAK,KAAK,iBAAiBH,CAAK,CAAC,EAGxC,IAAMI,EAAW,MAAM,QAAQ,IAAID,CAAK,EAClCE,EAAOD,EAAS,GAChBE,EAAaF,EAAS,GAGtBG,EAAQ,CACb,SAAU,GACV,QAAS,CAAC,EACV,QAAQD,GAAA,YAAAA,EAAY,SAAU,CAAC,EAC/B,eAAgBD,EAAK,OAAO,QAC5B,MAAOL,CACR,EAEA,OAAIK,EAAK,OAAO,kBACfE,EAAM,QAAU,KAAK,iBAAiBF,EAAK,OAAO,eAAe,GAG3DE,CACR,CASA,MAAM,UACLhC,EACAF,EACqC,CAnnCvC,IAAAvB,EAAA2C,EAAAC,EAAAC,EAAAC,EAonCE,GAAIrB,EAAK,gBACRA,EAAK,eAAe,MACpBA,EAAK,eAAe,KAAK,OAAS,KAClC,cAAQ,KAAK,8BAA8B,EACrC,IAAI,MAAM,uBAAuB,EAExC,IAAMK,EAAW,KAAK,YAAY,cAClC,GAAI,CAACA,EAAU,MAAM,IAAI,MAAM,sBAAsB,EACrD,GAAI,CAACL,EAAK,iBAAkB,MAAM,IAAI,MAAM,8BAA8B,EAC1E,GAAI,CAACA,EAAK,cAAe,MAAM,IAAI,MAAM,2BAA2B,EACpE,GAAI,CAACA,EAAK,OAAQ,MAAM,IAAI,MAAM,oBAAoB,EAEtD,GAAI,CACH,IAAMH,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAE9G0D,EAAkB,IAAI,WACtBC,EAAe,IAAI,WAQvB,GANAD,EAAkB,MAAM,KAAK,eAAejC,EAAK,gBAAgB,EACjEkC,EAAe,MAAM,KAAK,eAAelC,EAAK,aAAa,EAKvDiC,GAAmBC,EAAc,CAEpC,IAAMrB,KAAM,uCAAmC,CAC9C,KAAMR,EACN,gBAAAR,EACA,WAAY,yBAAsB,OAClC,gBAAAoC,EACA,aAAAC,EACA,aAAclC,EAAK,OAAO,UAC1B,mBAAoBA,EAAK,OAAO,WAChC,cAAeA,EAAK,OAAO,WAC3B,oBAAqBA,EAAK,OAAO,YACjC,QAAS,KAAK,gBAAgBA,EAAK,OAAO,EAC1C,UAAUkB,EAAAlB,EAAK,iBAAL,MAAAkB,EAAqB,SAAWlB,EAAK,eAAe,SAAW,OACzE,aAAamB,EAAAnB,EAAK,iBAAL,MAAAmB,EAAqB,aAAenB,EAAK,eAAe,aAAe,OACpF,eAAeoB,EAAApB,EAAK,iBAAL,MAAAoB,EAAqB,OAASpB,EAAK,eAAe,OAAS,OAC1E,MAAMqB,EAAArB,EAAK,iBAAL,MAAAqB,EAAqB,KAAO,KAAK,aAAarB,EAAK,eAAe,IAAI,EAAI,MACjF,CAAC,EACKf,GAAO4B,EAAI,KAAK,EAAE,SAAS,EAG3BsB,EAAS,MAAM,KAAK,gBAAgBtB,EAAKf,CAAS,EAClDsC,EAAsB,MAAM,KAAK,YACrC,8BAA8BnD,EAAI,EAClC,GAAG,EAEL,OAAAkD,EAAO,QAAU,mBAAqBC,EAAoB,qBAC1DD,EAAO,aAAeC,EAAoB,qBAC1CD,EAAO,KAAOC,EACdD,EAAO,KAAOlD,GACPkD,CAER,KACC,OAAM,IAAI,MAAM,6BAA6B,CAG/C,OAAS3C,EAAP,CACD,MAAM,IAAI,MAAMA,EAAG,OAAO,CAC3B,CACD,CASA,MAAM,gBAAgBQ,EAAmE,CA5rC1F,IAAAzB,EAAA2C,EAAAC,EAAAC,EAAAC,EA6rCE,IAAMhB,EAAW,KAAK,YAAY,cAClC,GAAI,CAACA,EAAU,MAAM,IAAI,MAAM,sBAAsB,EACrD,GAAI,CAACL,EAAK,iBAAkB,MAAM,IAAI,MAAM,8BAA8B,EAC1E,GAAI,CAACA,EAAK,cAAe,MAAM,IAAI,MAAM,2BAA2B,EACpE,GAAI,CAACA,EAAK,OAAQ,MAAM,IAAI,MAAM,oBAAoB,EAEtD,GAAIA,EAAK,gBAAkBA,EAAK,eAAe,MAAQA,EAAK,eAAe,KAAK,OAAS,KACxF,MAAM,IAAI,MAAM,yDAAyD,EACnE,GAAIK,EACV,GAAI,CACH,IAAMgC,EAAa,yBAAsB,OACnCxC,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAE9G0D,EAAkB,IAAI,WACtBC,EAAe,IAAI,WAMvB,GAJAD,EAAkB,MAAM,KAAK,eAAejC,EAAK,gBAAgB,EACjEkC,EAAe,MAAM,KAAK,eAAelC,EAAK,aAAa,EAGvD,CAACiC,GAAmB,CAACC,EACxB,MAAM,IAAI,MAAM,wEAAwE,EAoBzF,MAAO,CACN,eAlBoC,6BACpC7B,EACAR,EACAwC,EACAJ,EACAC,EACAlC,EAAK,OAAO,UACZA,EAAK,OAAO,WACZA,EAAK,OAAO,WACZA,EAAK,OAAO,YACZ,KAAK,gBAAgBA,EAAK,OAAO,GACjCkB,EAAAlB,EAAK,iBAAL,MAAAkB,EAAqB,SAAWlB,EAAK,eAAe,SAAW,QAC/DmB,EAAAnB,EAAK,iBAAL,MAAAmB,EAAqB,aAAenB,EAAK,eAAe,aAAe,QACvEoB,EAAApB,EAAK,iBAAL,MAAAoB,EAAqB,OAASpB,EAAK,eAAe,OAAS,QAC3DqB,EAAArB,EAAK,iBAAL,MAAAqB,EAAqB,KAAO,KAAK,aAAarB,EAAK,eAAe,IAAI,EAAI,MAC3E,EAIC,kBAAmB,OACnB,WAAY,EACb,CAED,OAASR,EAAP,CACD,MAAM,IAAI,MAAM,6CAA6C,CAC9D,KAEA,OAAM,IAAI,MAAM,oCAAoC,CAEtD,CAYA,MAAM,mBACLQ,EACqC,CAhwCvC,IAAAzB,EAAA2C,EAiwCE,GAAIlB,EAAK,UAAYA,EAAK,SAAS,OAAS,IAC3C,MAAM,IAAI,MAAM,uBAAuB,EAGxC,IAAIG,EAAc,CAAC,EACfH,EAAK,SAAWA,EAAK,QAAQ,SAChCG,EAAc,KAAK,gBAAgBH,EAAK,OAAO,GAGhD,IAAMsC,EAAStC,EAAK,KAAK,QAAQ,EAC3BqC,EAAa,yBAAsB,OACnCxC,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAE9G0D,EAAkB,IAAI,WACtBC,EAAe,IAAI,WAEvB,GAAI,CAKH,GAJAD,EAAkB,MAAM,KAAK,eAAejC,EAAK,gBAAgB,EACjEkC,EAAe,MAAM,KAAK,eAAelC,EAAK,aAAa,EAGvDiC,GAAmBC,EAAc,CACpC,IAAMrB,KAAM,6BACXyB,EACAzC,EACAwC,EACAJ,EACAC,EACAlC,EAAK,OAAO,UACZA,EAAK,OAAO,WACZA,EAAK,OAAO,WACZA,EAAK,OAAO,YACZG,IACAe,EAAAlB,EAAK,iBAAL,YAAAkB,EAAqB,WAAY,MAClC,EAEMjC,EAAO4B,EAAI,KAAK,EAAE,SAAS,EAC3B0B,KAAY,kCAA8B1B,EAAKb,EAAK,IAAI,EAE9D,MAAM,KAAK,YAAY,mBAAmBuC,EAAU,IAAI,EAAE,GAAG,EAC7D,IAAMzB,GAAW,MAAM,KAAK,oBAAoB7B,CAAI,EAQ9CwC,GAHsB,MAAM,KAAK,YACrC,8BAA8BxC,CAAI,EAClC,GAAG,GAC6B,qBAElC,MAAO,CACN,OAAQ,UACR,QAAS,4BAA8BwC,EACvC,KAAAxC,CACD,CACD,KACC,OAAM,IAAI,MAAM,2BAA2B,CAE7C,OAASO,EAAP,CACD,cAAQ,MAAM,2BAA2B,EACnC,IAAI,MAAMA,CAAE,CACnB,CACD,CAOA,MAAM,gBAAgBQ,EAAsE,CAt0C7F,IAAAzB,EAAA2C,EAAAC,EAAAC,EAAAC,EAu0CE,IAAMhB,EAAW,KAAK,YAAY,cAClC,GAAI,CAACA,EAAU,MAAM,IAAI,MAAM,sBAAsB,EACrD,GAAI,CAACL,EAAK,iBAAkB,MAAM,IAAI,MAAM,8BAA8B,EAC1E,GAAI,CAACA,EAAK,cAAe,MAAM,IAAI,MAAM,2BAA2B,EACpE,GAAIA,EAAK,gBAAkBA,EAAK,eAAe,MAAQA,EAAK,eAAe,KAAK,OAAS,KACxF,MAAM,IAAI,MAAM,yDAAyD,EAG1E,GAAI,CACH,IAAMqC,EAAa,yBAAsB,OACnCxC,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAE9G0D,EAAkB,IAAI,WACtBC,EAAe,IAAI,WAMvB,GAJAD,EAAkB,MAAM,KAAK,eAAejC,EAAK,gBAAgB,EACjEkC,EAAe,MAAM,KAAK,eAAelC,EAAK,aAAa,EAGvD,CAACiC,GAAmB,CAACC,EACxB,MAAM,IAAI,MAAM,wEAAwE,EAgBzF,MAAO,CACN,eAdoC,6BACpC7B,EACAR,EACAG,EAAK,SACLiC,EACAC,EACA,KAAK,gBAAgBlC,EAAK,OAAO,GACjCkB,EAAAlB,EAAK,iBAAL,MAAAkB,EAAqB,SAAWlB,EAAK,eAAe,SAAW,QAC/DmB,EAAAnB,EAAK,iBAAL,MAAAmB,EAAqB,aAAenB,EAAK,eAAe,aAAe,QACvEoB,EAAApB,EAAK,iBAAL,MAAAoB,EAAqB,OAASpB,EAAK,eAAe,OAAS,QAC3DqB,EAAArB,EAAK,iBAAL,MAAAqB,EAAqB,KAAO,KAAK,aAAarB,EAAK,eAAe,IAAI,EAAI,MAC3E,EAIC,kBAAmB,OACnB,WAAY,EACb,CAED,OAASR,EAAP,CACD,MAAM,IAAI,MAAM,6CAA6C,CAC9D,CACD,CAQA,MAAM,UAAUQ,EAAkCF,EAAsE,CACvH,GAAM,CAAE,YAAAC,CAAY,EAAI,MAAM,KAAK,gBAAgBC,CAAI,EACvD,OAAO,MAAM,KAAK,gBAAgBD,EAAaD,CAAS,CACzD,CAOA,MAAM,eAAe0C,EAA4C,CAEhE,IAAMC,EADU,IAAI,YAAY,EACH,OAAOD,CAAa,EAC3CE,EAAkB,MAAM,KAAK,YAAY,QAAQD,CAAY,EAAE,GAAG,EAIxE,OAHsB,IAAI,WACzB,UAAO,KAAKC,EAAgB,OAAQ,QAAQ,CAC7C,CAED,CAEA,MAAM,eAAe1C,EAAoE,CAh5C1F,IAAAzB,EAAA2C,EAi5CE,GAAI,EAAE,OAAOlB,EAAK,QAAU,UAAY,OAAOA,EAAK,QAAU,UAC7D,MAAM,IAAI,MAAM,4BAA4B,EAE7C,GAAI,CAACA,EAAK,GAAI,MAAM,IAAI,MAAM,kCAAkC,EAChE,GAAI,IAAC,mBAAeA,EAAK,EAAE,EAAG,MAAM,IAAI,MAAM,oBAAoB,EAClE,IAAMK,EAAWL,EAAK,MAAQ,KAAK,YAAY,cAC/C,GAAI,CAACK,EAAU,MAAM,IAAI,MAAM,sBAAsB,EAErD,GAAIA,EAAU,CACb,IAAMsC,GAAcpE,EAAAyB,EAAK,iBAAL,MAAAzB,EAAqB,KAAO,KAAK,aAAayB,EAAK,eAAe,IAAI,EAAI,IAAI,WAC5FH,IAAkBqB,EAAAlB,EAAK,iBAAL,YAAAkB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAWlH,MAAO,CACN,eATA,gDAA4C,CAC3C,KAAMb,EACN,GAAIL,EAAK,GACT,OAAQA,EAAK,OACb,KAAM2C,EACN,gBAAA9C,CACD,CAAC,EAID,kBAAmB,OACnB,WAAY,EACb,CACD,KACC,OAAM,IAAI,MAAM,sBAAsB,CAExC,CASA,MAAM,SAASG,EAAgCF,EAAsE,CACpH,GAAM,CAAE,YAAAC,CAAY,EAAI,MAAM,KAAK,eAAeC,CAAI,EACtD,OAAO,MAAM,KAAK,gBAAgBD,EAAaD,CAAS,CACzD,CAOA,MAAM,eAAe8C,EAA+B,CACnD,GAAI,CAACA,EAAS,MAAM,IAAI,MAAM,qBAAqB,EAEnD,OADoB,MAAM,KAAK,YAAY,mBAAmBA,CAAO,EAAE,GAAG,CAE3E,CAQA,MAAM,eAAeA,EAA+B,CACnD,GAAI,CAACA,EAAS,MAAM,IAAI,MAAM,qBAAqB,EAGnD,OADoB,MAAM,KAAK,YAAY,mBAAmBA,CAAO,EAAE,GAAG,GACvD,MACpB,CAQA,MAAM,gBAAgBA,EAAiBjD,EAAqC,CAC3E,GAAI,CAACiD,EAAS,MAAM,IAAI,MAAM,qBAAqB,EACnD,GAAI,CAACjD,EAAY,MAAM,IAAI,MAAM,yBAAyB,EAE1D,IAAMkD,EAAc,MAAM,KAAK,YAAY,mBAAmBD,CAAO,EAAE,GAAG,EAGtEE,EAAM,EACV,OAAAD,EAAY,OAAO,QAAS3C,GAAe,CACtCA,EAAM,aAAeP,IACxBmD,EAAM5C,EAAM,OAEd,CAAC,EAEM4C,CACR,CAQA,MAAM,iBAAiBF,EAAiBjD,EAAsC,CAE7E,OADU,MAAM,KAAK,gBAAgBiD,EAASjD,CAAU,EAC9C,CAKX,CAOA,MAAM,kBAAkBoD,EAAwC,CAC/D,GAAI,CAACA,EAAkB,MAAM,IAAI,MAAM,4BAA4B,EAEnE,IAAMjB,EAAO,MAAM,KAAK,WAAWiB,CAAgB,EACnD,OAAIjB,EAAK,SACD,KAAK,mBAAmBA,EAAK,OAAO,EAEpC,CAAC,CAEV,CAOA,MAAM,iBAAiBiB,EAA0BH,EAAoD,CACpG,GAAI,CAACG,EAAkB,MAAM,IAAI,MAAM,4BAA4B,EAEnE,IAAMf,EAAQ,CACb,SAAU,GACV,QAAS,CAAC,EACV,OAAQ,CAAC,EACT,eAAgB,GAChB,MAAOe,CACR,EAWA,GAJI,KAAK,YAAY,eAAiB,CAACH,IACtCA,EAAU,KAAK,YAAY,eAGxBA,EAAS,CACZ,IAAMI,EAAsB,MAAM,KAAK,YACrC,mBAAmBJ,CAAO,EAC1B,GAAG,EAIL,QAASpF,EAAI,EAAGA,EAAIwF,EAAoB,oBAAoB,OAAQxF,IACnE,GAAIwF,EAAoB,oBAAoBxF,GAAG,IAAMuF,EAAkB,CAGtEf,EAAM,SAAW,GAEjB,QAASiB,EAAI,EAAGA,EAAID,EAAoB,oBAAoBxF,GAAG,aAAa,OAAQyF,IAAK,CAExF,IAAMC,EAAYF,EAAoB,oBAAoBxF,GAAG,aAAayF,GACpEE,EAAM,UAAO,KAAKD,EAAU,IAAK,QAAQ,EAAE,SAAS,EACpDE,EAAOF,EAAU,MAAM,KACzBG,EACAC,EAAc,GAEdF,GAAQ,GACXC,EAAQ,UAAO,KAAKH,EAAU,MAAM,MAAO,QAAQ,EAAE,SAAS,EAC9DI,KAAc,kBAAc,UAAO,KAAKJ,EAAU,MAAM,MAAO,QAAQ,CAAC,GAE9DA,EAAU,MAAM,MAAQ,IAClCG,EAAQH,EAAU,MAAM,MAGzBlB,EAAM,OAAO,KAAK,CACjB,IAAKmB,EACL,MAAOE,GAAS,GAChB,QAASC,CACV,CAAC,CAEF,CACD,CAGD,OAAOtB,CACR,MAEC,QAAQ,KAAK,0DAA0D,CAEzE,CAEA,MAAM,4BAA4BhC,EAA0E,CAjlD7G,IAAAzB,EAklDE,GAAIyB,EAAK,KAAM,CACd,IAAMH,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EAWlH,MAAO,CACN,eATA,sDAAkD,CACjD,KAAMyB,EAAK,KAAK,QAAQ,EACxB,GAAIA,EAAK,GACT,OAAQA,EAAK,OACb,WAAYA,EAAK,WACjB,gBAAAH,CACD,CAAC,EAID,kBAAmBG,EAAK,KACxB,WAAY,EACb,CACD,KACC,OAAM,IAAI,MAAM,+BAA+B,CAEjD,CAEA,MAAM,sBAAsBA,EAAwE,CAxmDrG,IAAAzB,EAymDE,GAAIyB,EAAK,KAAM,CACd,IAAMH,IAAkBtB,EAAAyB,EAAK,iBAAL,YAAAzB,EAAqB,kBAAoB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,EASlH,MAAO,CACN,eARA,gDAA4C,CAC3C,KAAMyB,EAAK,KAAK,QAAQ,EACxB,GAAIA,EAAK,GACT,OAAQA,EAAK,OACb,gBAAAH,CACD,CAAC,EAID,kBAAmBG,EAAK,KACxB,WAAY,EACb,CACD,KACC,OAAM,IAAI,MAAM,sBAAsB,CAExC,CAEA,cAAcuD,EAAkF,CAC/F7F,GAAO,IAAI,gBAAiB6F,CAAS,EAErC,IAAIC,EAAsD,CAAC,EAEtD,MAAM,QAAQD,CAAS,EAG3BC,EAASD,EAFTC,EAAS,CAACD,CAAS,EAMpB,IAAIE,EAA4B,CAAC,EACjC,OAAAA,EAAaD,EAAO,IAAKE,GAAM,CAC9B,IAAIC,EAAWD,EAAgC,YAC/C,OAAIC,GAAW,OACdA,EAAUD,GAEJC,CACR,CAAC,EAEkBF,EAAW,IAAIC,GAAKA,EAAE,OAAO,CAAC,CAIlD,CAQA,MAAM,gBAAgBH,EAAyG,CAC9H,IAAMK,EAAe,KAAK,cAAcL,CAAS,EACjD7F,GAAO,IAAI,eAAgBkG,CAAY,EACvC,IAAIC,EACJ,GAAI,CACHA,EAAe,MAAMC,GAAiBF,CAAY,EAClDlG,GAAO,IAAI,eAAgBmG,CAAY,CACxC,OAAQnC,EAAN,CACD,cAAQ,KAAK,qBAAqB,EAClChE,GAAO,IAAIgE,CAAC,EACN,IAAI,MAAM,4BAA4B,CAC7C,CACA,OAAOmC,CACR,CAQA,MAAM,gBAAgBN,EAAkFzD,EAAsE,CAQ7K,IAAM+D,EAAe,MAAM,KAAK,gBAAgBN,CAAS,EAErDzD,GAAA,MAAAA,EAAW,QAAQA,EAAU,OAAO+D,CAAY,EAEpD,IAAME,EAAK,MAAM,KAAK,YAAY,mBAAmBF,CAAY,EAAE,GAAG,EAElE/D,GAAA,MAAAA,EAAW,QAAQA,EAAU,OAAOiE,CAAE,EAG1C,IAAMjD,EAAW,MAAM,KAAK,oBAAoBiD,EAAG,IAAI,EAEjD3B,EAAsB,MAAM,KAAK,YACrC,8BAA8B2B,EAAG,IAAI,EACrC,GAAG,EACL,OAAAjD,EAAS,KAAOsB,EAEZtC,GAAA,MAAAA,EAAW,WAAWA,EAAU,UAAUgB,CAAQ,EAC/CA,CACR,CAQA,aAAakD,EAAa/C,EAAsB,OAAoB,CACnE,OAAO,IAAI,WAAW,UAAO,KAAK+C,EAAK/C,CAAG,CAAC,CAC5C,CAQA,OAAO+C,EAAa/C,EAAsB,OAAoB,CAC7D,OAAO,KAAK,aAAa+C,EAAK/C,CAAG,CAClC,CASA,mBAAmBgD,EAA2B,CAC7C,IAAMC,EAAW,CAAC,EAClB,OAAAD,EAAW,QAASZ,GAAe,CAC9BA,EAAM,MAAKa,EAASb,EAAM,KAAOA,EAAM,OAAS,KACrD,CAAC,EACMa,CACR,CAOA,iBAAiBC,EAAyB,CACzC,OAAO,UAAO,KAAKA,EAAS,QAAQ,EAAE,SAAS,CAChD,CAOA,WAAWA,EAAyB,CACnC,OAAO,KAAK,iBAAiBA,CAAO,CACrC,CAOA,YAAYA,EAAyB,CACpC,SAAO,kBAAc,UAAO,KAAKA,EAAS,QAAQ,CAAC,CACpD,CAOA,iBAAiBF,EAAuC,CACvD,IAAM9B,EAA8B,CAAC,EAErC,QAAS,EAAI,EACZ,EAAI8B,EAAW,OACf,IAAK,CAEL,IAAMf,EAAYe,EAAW,GAEvBd,EAAM,KAAK,iBAAiBD,EAAU,GAAG,EACzCE,EAAOF,EAAU,MAAM,KACzBG,EACAC,EAAc,GAEdF,GAAQ,GACXC,EAAQ,KAAK,iBAAiBH,EAAU,MAAM,KAAK,EACnDI,EAAc,KAAK,YAAYJ,EAAU,MAAM,KAAK,GAE1CA,EAAU,MAAM,MAAQ,IAClCG,EAAQH,EAAU,MAAM,MAGzBf,EAAO,KAAK,CACX,IAAKgB,EACL,MAAOE,GAAS,GAChB,QAASC,CACV,CAAC,CAEF,CAEA,OAAOnB,CACR,CAOA,gCAAgCtB,EAA0B,CACzD,SAAO,8BAA0B,UAAO,KAAKA,EAAK,QAAQ,CAAC,CAC5D,CAMA,WAAWA,EAAkB,CAG5B,GAAIA,EAAI,KAAM,CACb,IAAMuD,EAAKvD,EAAI,MAAK,kBAAcA,EAAI,GAAG,SAAS,EAAI,GAChDwD,EAAOxD,EAAI,QAAO,kBAAcA,EAAI,KAAK,SAAS,EAAI,GAG5D,GAAIA,EAAI,OAAS,MAChB,OAAIA,EAAI,OACA,WAAQ,sBAAkBA,EAAI,MAAgB,aAAauD,IAE3D,kBAAkBA,IAIpB,GAAIvD,EAAI,OAAS,QACvB,MAAI,CAACA,EAAI,QAAUuD,IAAOC,EAClB,sBAAsBxD,EAAI,aAG1B,YADQA,EAAI,OAASA,EAAI,OAAS,iBACAA,EAAI,iBAAiBuD,IAMzD,GAAIvD,EAAI,OAAS,OAGvB,OAAIA,EAAI,cACA,gBAAgBA,EAAI,qBAAqBA,EAAI,gBAG9C,mBAAmBA,EAAI,aAGxB,GAAIA,EAAI,OAAS,OACvB,MAAO,gBAAgBA,EAAI,aAGrB,GAAIA,EAAI,OAAS,OAGvB,OAAQA,EAAI,mBAEN,GACJ,MAAO,0BAA0BA,EAAI,eAGjC,GACJ,MAAO,4BAA4BA,EAAI,eAGnC,GACJ,MAAO,4BAA4BA,EAAI,eAGnC,GACJ,MAAO,iDAAiDA,EAAI,eAGxD,GACJ,MAAO,yBAAyBA,EAAI,eAGhC,GACJ,MAAO,yBAAyBA,EAAI,mBAGpC,MAAO,0BAA0BA,EAAI,eAKvC,OAAO,uBAAuBA,EAAI,WAAWuD,GAE/C,KAEC,QAAOvD,EAAI,SAAS,CAEtB,CAOA,cAA+B,CAC9B,IAAMyD,KAAU,oBAAgB,EAEhC,GAAIA,EAAS,CACZ,IAAMjG,KAAW,wBAAoBiG,EAAQ,EAAE,EAC/C,MAAO,CACN,QAASA,EAAQ,KACjB,SAAUjG,CACX,CACD,KACC,OAAM,IAAI,MAAM,yDAAyD,CAE3E,CAQA,eAAeA,EAAkC,CAChD,GAAI,CAACA,EAAU,MAAM,IAAI,MAAM,uBAAuB,EAEtD,GAAI,CACH,IAAMiG,KAAU,wBAAoBjG,CAAQ,EAC5C,MAAI,mBAAeiG,GAAA,YAAAA,EAAS,IAAI,EAC/B,OAAOA,EAEP,MAAM,IAAI,MAAM,uBAAuB,CAEzC,OAASC,EAAP,CAED,cAAQ,MAAMA,CAAK,EACb,IAAI,MAAM,0CAA0C,CAC3D,CACD,CAOA,gBAAgB1D,EAAqB,CACpC,OAAO,UAAO,KAAKA,EAAK,QAAQ,CACjC,CAOA,aAAa2D,EAA0B,CACtC,OAAO,UAAO,KAAKA,CAAI,EAAE,SAAS,QAAQ,CAC3C,CAOA,SAAS3D,EAAkC,CAC1C,IAAM2D,EAAO3D,EAAI,OAAO,EACxB,OAAO,KAAK,aAAa2D,CAAI,CAC9B,CAED,EACOC,GAAQtH,GAEFuH,GAAS",
  "names": ["require_dist", "__commonJSMin", "exports", "module", "global", "factory", "char_to_integer", "integer_to_char", "char", "i", "decode", "string", "result", "shift", "value", "integer", "has_continuation_bit", "should_negate", "encode", "encode_integer", "num", "clamped", "src_exports", "__export", "ie", "Algonaut", "i", "I", "Dn", "m", "yn", "Hn", "Vn", "Bn", "Rn", "oe", "N", "Re", "_", "buffer", "j", "src_default", "Zn", "Un", "Nn", "ne", "Y", "y", "$", "He", "Qe", "Gn", "Be", "Yn", "vn", "q", "tt", "et", "ao", "__toCommonJS", "testnetConfig", "mainnetConfig", "defaultNodeConfig", "defaultLibConfig", "logger", "args", "import_buffer", "import_algosdk", "unsAcctSync", "Algonaut", "config", "defaultNodeConfig", "defaultLibConfig", "algosdk", "i", "libConfig", "logger", "Yn", "nodeConfig", "isValid", "mainnetConfig", "testnetConfig", "status", "tt", "acct", "walletInitParams", "Un", "mnemonic", "N", "_a", "inkeyW", "initWallets", "initWs", "wId", "wInitParams", "w", "enabledWs", "wIds", "Gn", "txId", "limitDelta", "log", "lastround", "limit", "returnValue", "pendingInfo", "er", "base64ProgramString", "program", "assetIndex", "optionalTxnArgs", "suggestedParams", "callbacks", "transaction", "args", "optInState", "asset", "encodedArgs", "arg", "fromAddr", "metaBlockLength", "note", "totalIssuance", "manager", "reserve", "freeze", "clawback", "txn", "txStatus", "ptx", "assetId", "enc", "_b", "_c", "_d", "_e", "_f", "_g", "appIndex", "appId", "e", "processedArgs", "proms", "promsRes", "info", "localState", "state", "approvalProgram", "clearProgram", "result", "transactionResponse", "onComplete", "sender", "signedTxn", "programSource", "programBytes", "compileResponse", "encodedNote", "address", "accountInfo", "bal", "applicationIndex", "accountInfoResponse", "n", "stateItem", "key", "type", "value", "valueAsAddr", "txnOrTxns", "txnArr", "algoTxnArr", "t", "nativeT", "awTxnsToSign", "awTxnsSigned", "vn", "tx", "str", "stateArray", "stateObj", "encoded", "to", "from", "account", "error", "buff", "src_default", "buffer"]
}
