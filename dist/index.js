var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++)
            r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K2[i * 2];
            l = K2[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof require !== "undefined") {
          crypto2 = require("crypto");
          if (crypto2 && crypto2.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto2.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/js-sha512/src/sha512.js
var require_sha512 = __commonJS({
  "node_modules/js-sha512/src/sha512.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW2 = typeof window === "object";
      var root2 = WINDOW2 ? window : {};
      if (root2.JS_SHA512_NO_WINDOW) {
        WINDOW2 = false;
      }
      var WEB_WORKER2 = !WINDOW2 && typeof self === "object";
      var NODE_JS2 = !root2.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS2) {
        root2 = global;
      } else if (WEB_WORKER2) {
        root2 = self;
      }
      var COMMON_JS2 = !root2.JS_SHA512_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD2 = typeof define === "function" && define.amd;
      var ARRAY_BUFFER2 = !root2.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS2 = "0123456789abcdef".split("");
      var EXTRA2 = [-2147483648, 8388608, 32768, 128];
      var SHIFT2 = [24, 16, 8, 0];
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      var OUTPUT_TYPES2 = ["hex", "array", "digest", "arrayBuffer"];
      var blocks2 = [];
      if (root2.JS_SHA512_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER2 && (root2.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod2 = function(outputType, bits) {
        return function(message) {
          return new Sha512(bits, true).update(message)[outputType]();
        };
      };
      var createMethod2 = function(bits) {
        var method2 = createOutputMethod2("hex", bits);
        method2.create = function() {
          return new Sha512(bits);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES2.length; ++i) {
          var type = OUTPUT_TYPES2[i];
          method2[type] = createOutputMethod2(type, bits);
        }
        return method2;
      };
      var createHmacOutputMethod2 = function(outputType, bits) {
        return function(key, message) {
          return new HmacSha512(key, bits, true).update(message)[outputType]();
        };
      };
      var createHmacMethod2 = function(bits) {
        var method2 = createHmacOutputMethod2("hex", bits);
        method2.create = function(key) {
          return new HmacSha512(key, bits);
        };
        method2.update = function(key, message) {
          return method2.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES2.length; ++i) {
          var type = OUTPUT_TYPES2[i];
          method2[type] = createHmacOutputMethod2(type, bits);
        }
        return method2;
      };
      function Sha512(bits, sharedMemory) {
        if (sharedMemory) {
          blocks2[0] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
          this.blocks = blocks2;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (bits == 384) {
          this.h0h = 3418070365;
          this.h0l = 3238371032;
          this.h1h = 1654270250;
          this.h1l = 914150663;
          this.h2h = 2438529370;
          this.h2l = 812702999;
          this.h3h = 355462360;
          this.h3l = 4144912697;
          this.h4h = 1731405415;
          this.h4l = 4290775857;
          this.h5h = 2394180231;
          this.h5l = 1750603025;
          this.h6h = 3675008525;
          this.h6l = 1694076839;
          this.h7h = 1203062813;
          this.h7l = 3204075428;
        } else if (bits == 256) {
          this.h0h = 573645204;
          this.h0l = 4230739756;
          this.h1h = 2673172387;
          this.h1l = 3360449730;
          this.h2h = 596883563;
          this.h2l = 1867755857;
          this.h3h = 2520282905;
          this.h3l = 1497426621;
          this.h4h = 2519219938;
          this.h4l = 2827943907;
          this.h5h = 3193839141;
          this.h5l = 1401305490;
          this.h6h = 721525244;
          this.h6l = 746961066;
          this.h7h = 246885852;
          this.h7l = 2177182882;
        } else if (bits == 224) {
          this.h0h = 2352822216;
          this.h0l = 424955298;
          this.h1h = 1944164710;
          this.h1l = 2312950998;
          this.h2h = 502970286;
          this.h2l = 855612546;
          this.h3h = 1738396948;
          this.h3l = 1479516111;
          this.h4h = 258812777;
          this.h4l = 2077511080;
          this.h5h = 2011393907;
          this.h5l = 79989058;
          this.h6h = 1067287976;
          this.h6l = 1780299464;
          this.h7h = 286451373;
          this.h7l = 2446758561;
        } else {
          this.h0h = 1779033703;
          this.h0l = 4089235720;
          this.h1h = 3144134277;
          this.h1l = 2227873595;
          this.h2h = 1013904242;
          this.h2l = 4271175723;
          this.h3h = 2773480762;
          this.h3l = 1595750129;
          this.h4h = 1359893119;
          this.h4l = 2917565137;
          this.h5h = 2600822924;
          this.h5l = 725511199;
          this.h6h = 528734635;
          this.h6l = 4215389547;
          this.h7h = 1541459225;
          this.h7l = 327033209;
        }
        this.bits = bits;
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
      }
      Sha512.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var code, index = 0, i, length = message.length, blocks3 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks3[0] = this.block;
            blocks3[1] = blocks3[2] = blocks3[3] = blocks3[4] = blocks3[5] = blocks3[6] = blocks3[7] = blocks3[8] = blocks3[9] = blocks3[10] = blocks3[11] = blocks3[12] = blocks3[13] = blocks3[14] = blocks3[15] = blocks3[16] = blocks3[17] = blocks3[18] = blocks3[19] = blocks3[20] = blocks3[21] = blocks3[22] = blocks3[23] = blocks3[24] = blocks3[25] = blocks3[26] = blocks3[27] = blocks3[28] = blocks3[29] = blocks3[30] = blocks3[31] = blocks3[32] = 0;
          }
          if (notString) {
            for (i = this.start; index < length && i < 128; ++index) {
              blocks3[i >> 2] |= message[index] << SHIFT2[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 128; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks3[i >> 2] |= code << SHIFT2[i++ & 3];
              } else if (code < 2048) {
                blocks3[i >> 2] |= (192 | code >> 6) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks3[i >> 2] |= (224 | code >> 12) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks3[i >> 2] |= (240 | code >> 18) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i++ & 3];
                blocks3[i >> 2] |= (128 | code & 63) << SHIFT2[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 128) {
            this.block = blocks3[32];
            this.start = i - 128;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha512.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks3 = this.blocks, i = this.lastByteIndex;
        blocks3[32] = this.block;
        blocks3[i >> 2] |= EXTRA2[i & 3];
        this.block = blocks3[32];
        if (i >= 112) {
          if (!this.hashed) {
            this.hash();
          }
          blocks3[0] = this.block;
          blocks3[1] = blocks3[2] = blocks3[3] = blocks3[4] = blocks3[5] = blocks3[6] = blocks3[7] = blocks3[8] = blocks3[9] = blocks3[10] = blocks3[11] = blocks3[12] = blocks3[13] = blocks3[14] = blocks3[15] = blocks3[16] = blocks3[17] = blocks3[18] = blocks3[19] = blocks3[20] = blocks3[21] = blocks3[22] = blocks3[23] = blocks3[24] = blocks3[25] = blocks3[26] = blocks3[27] = blocks3[28] = blocks3[29] = blocks3[30] = blocks3[31] = blocks3[32] = 0;
        }
        blocks3[30] = this.hBytes << 3 | this.bytes >>> 29;
        blocks3[31] = this.bytes << 3;
        this.hash();
      };
      Sha512.prototype.hash = function() {
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks3 = this.blocks, j, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
        for (j = 32; j < 160; j += 2) {
          t1h = blocks3[j - 30];
          t1l = blocks3[j - 29];
          s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
          s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
          t1h = blocks3[j - 4];
          t1l = blocks3[j - 3];
          s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
          s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
          t1h = blocks3[j - 32];
          t1l = blocks3[j - 31];
          t2h = blocks3[j - 14];
          t2l = blocks3[j - 13];
          c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
          blocks3[j] = c4 << 16 | c3 & 65535;
          blocks3[j + 1] = c2 << 16 | c1 & 65535;
        }
        var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
        bch = bh & ch;
        bcl = bl & cl;
        for (j = 0; j < 160; j += 8) {
          s0h = (ah >>> 28 | al << 4) ^ (al >>> 2 | ah << 30) ^ (al >>> 7 | ah << 25);
          s0l = (al >>> 28 | ah << 4) ^ (ah >>> 2 | al << 30) ^ (ah >>> 7 | al << 25);
          s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
          s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
          abh = ah & bh;
          abl = al & bl;
          majh = abh ^ ah & ch ^ bch;
          majl = abl ^ al & cl ^ bcl;
          chh = eh & fh ^ ~eh & gh;
          chl = el & fl ^ ~el & gl;
          t1h = blocks3[j];
          t1l = blocks3[j + 1];
          t2h = K2[j];
          t2l = K2[j + 1];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (dl & 65535) + (t1l & 65535);
          c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          hh = c4 << 16 | c3 & 65535;
          hl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          dh = c4 << 16 | c3 & 65535;
          dl = c2 << 16 | c1 & 65535;
          s0h = (dh >>> 28 | dl << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25);
          s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25);
          s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23);
          s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23);
          dah = dh & ah;
          dal = dl & al;
          majh = dah ^ dh & bh ^ abh;
          majl = dal ^ dl & bl ^ abl;
          chh = hh & eh ^ ~hh & fh;
          chl = hl & el ^ ~hl & fl;
          t1h = blocks3[j + 2];
          t1l = blocks3[j + 3];
          t2h = K2[j + 2];
          t2l = K2[j + 3];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (cl & 65535) + (t1l & 65535);
          c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          gh = c4 << 16 | c3 & 65535;
          gl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ch = c4 << 16 | c3 & 65535;
          cl = c2 << 16 | c1 & 65535;
          s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
          s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
          s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23);
          s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23);
          cdh = ch & dh;
          cdl = cl & dl;
          majh = cdh ^ ch & ah ^ dah;
          majl = cdl ^ cl & al ^ dal;
          chh = gh & hh ^ ~gh & eh;
          chl = gl & hl ^ ~gl & el;
          t1h = blocks3[j + 4];
          t1l = blocks3[j + 5];
          t2h = K2[j + 4];
          t2l = K2[j + 5];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (bl & 65535) + (t1l & 65535);
          c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          fh = c4 << 16 | c3 & 65535;
          fl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          bh = c4 << 16 | c3 & 65535;
          bl = c2 << 16 | c1 & 65535;
          s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
          s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
          s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23);
          s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23);
          bch = bh & ch;
          bcl = bl & cl;
          majh = bch ^ bh & dh ^ cdh;
          majl = bcl ^ bl & dl ^ cdl;
          chh = fh & gh ^ ~fh & hh;
          chl = fl & gl ^ ~fl & hl;
          t1h = blocks3[j + 6];
          t1l = blocks3[j + 7];
          t2h = K2[j + 6];
          t2l = K2[j + 7];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (al & 65535) + (t1l & 65535);
          c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ah & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          eh = c4 << 16 | c3 & 65535;
          el = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ah = c4 << 16 | c3 & 65535;
          al = c2 << 16 | c1 & 65535;
        }
        c1 = (h0l & 65535) + (al & 65535);
        c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
        c3 = (h0h & 65535) + (ah & 65535) + (c2 >>> 16);
        c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
        this.h0h = c4 << 16 | c3 & 65535;
        this.h0l = c2 << 16 | c1 & 65535;
        c1 = (h1l & 65535) + (bl & 65535);
        c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
        c3 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
        c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
        this.h1h = c4 << 16 | c3 & 65535;
        this.h1l = c2 << 16 | c1 & 65535;
        c1 = (h2l & 65535) + (cl & 65535);
        c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
        c3 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
        c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
        this.h2h = c4 << 16 | c3 & 65535;
        this.h2l = c2 << 16 | c1 & 65535;
        c1 = (h3l & 65535) + (dl & 65535);
        c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
        c3 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
        c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
        this.h3h = c4 << 16 | c3 & 65535;
        this.h3l = c2 << 16 | c1 & 65535;
        c1 = (h4l & 65535) + (el & 65535);
        c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
        c3 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
        c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
        this.h4h = c4 << 16 | c3 & 65535;
        this.h4l = c2 << 16 | c1 & 65535;
        c1 = (h5l & 65535) + (fl & 65535);
        c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
        c3 = (h5h & 65535) + (fh & 65535) + (c2 >>> 16);
        c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
        this.h5h = c4 << 16 | c3 & 65535;
        this.h5l = c2 << 16 | c1 & 65535;
        c1 = (h6l & 65535) + (gl & 65535);
        c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
        c3 = (h6h & 65535) + (gh & 65535) + (c2 >>> 16);
        c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
        this.h6h = c4 << 16 | c3 & 65535;
        this.h6l = c2 << 16 | c1 & 65535;
        c1 = (h7l & 65535) + (hl & 65535);
        c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
        c3 = (h7h & 65535) + (hh & 65535) + (c2 >>> 16);
        c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
        this.h7h = c4 << 16 | c3 & 65535;
        this.h7l = c2 << 16 | c1 & 65535;
      };
      Sha512.prototype.hex = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var hex = HEX_CHARS2[h0h >> 28 & 15] + HEX_CHARS2[h0h >> 24 & 15] + HEX_CHARS2[h0h >> 20 & 15] + HEX_CHARS2[h0h >> 16 & 15] + HEX_CHARS2[h0h >> 12 & 15] + HEX_CHARS2[h0h >> 8 & 15] + HEX_CHARS2[h0h >> 4 & 15] + HEX_CHARS2[h0h & 15] + HEX_CHARS2[h0l >> 28 & 15] + HEX_CHARS2[h0l >> 24 & 15] + HEX_CHARS2[h0l >> 20 & 15] + HEX_CHARS2[h0l >> 16 & 15] + HEX_CHARS2[h0l >> 12 & 15] + HEX_CHARS2[h0l >> 8 & 15] + HEX_CHARS2[h0l >> 4 & 15] + HEX_CHARS2[h0l & 15] + HEX_CHARS2[h1h >> 28 & 15] + HEX_CHARS2[h1h >> 24 & 15] + HEX_CHARS2[h1h >> 20 & 15] + HEX_CHARS2[h1h >> 16 & 15] + HEX_CHARS2[h1h >> 12 & 15] + HEX_CHARS2[h1h >> 8 & 15] + HEX_CHARS2[h1h >> 4 & 15] + HEX_CHARS2[h1h & 15] + HEX_CHARS2[h1l >> 28 & 15] + HEX_CHARS2[h1l >> 24 & 15] + HEX_CHARS2[h1l >> 20 & 15] + HEX_CHARS2[h1l >> 16 & 15] + HEX_CHARS2[h1l >> 12 & 15] + HEX_CHARS2[h1l >> 8 & 15] + HEX_CHARS2[h1l >> 4 & 15] + HEX_CHARS2[h1l & 15] + HEX_CHARS2[h2h >> 28 & 15] + HEX_CHARS2[h2h >> 24 & 15] + HEX_CHARS2[h2h >> 20 & 15] + HEX_CHARS2[h2h >> 16 & 15] + HEX_CHARS2[h2h >> 12 & 15] + HEX_CHARS2[h2h >> 8 & 15] + HEX_CHARS2[h2h >> 4 & 15] + HEX_CHARS2[h2h & 15] + HEX_CHARS2[h2l >> 28 & 15] + HEX_CHARS2[h2l >> 24 & 15] + HEX_CHARS2[h2l >> 20 & 15] + HEX_CHARS2[h2l >> 16 & 15] + HEX_CHARS2[h2l >> 12 & 15] + HEX_CHARS2[h2l >> 8 & 15] + HEX_CHARS2[h2l >> 4 & 15] + HEX_CHARS2[h2l & 15] + HEX_CHARS2[h3h >> 28 & 15] + HEX_CHARS2[h3h >> 24 & 15] + HEX_CHARS2[h3h >> 20 & 15] + HEX_CHARS2[h3h >> 16 & 15] + HEX_CHARS2[h3h >> 12 & 15] + HEX_CHARS2[h3h >> 8 & 15] + HEX_CHARS2[h3h >> 4 & 15] + HEX_CHARS2[h3h & 15];
        if (bits >= 256) {
          hex += HEX_CHARS2[h3l >> 28 & 15] + HEX_CHARS2[h3l >> 24 & 15] + HEX_CHARS2[h3l >> 20 & 15] + HEX_CHARS2[h3l >> 16 & 15] + HEX_CHARS2[h3l >> 12 & 15] + HEX_CHARS2[h3l >> 8 & 15] + HEX_CHARS2[h3l >> 4 & 15] + HEX_CHARS2[h3l & 15];
        }
        if (bits >= 384) {
          hex += HEX_CHARS2[h4h >> 28 & 15] + HEX_CHARS2[h4h >> 24 & 15] + HEX_CHARS2[h4h >> 20 & 15] + HEX_CHARS2[h4h >> 16 & 15] + HEX_CHARS2[h4h >> 12 & 15] + HEX_CHARS2[h4h >> 8 & 15] + HEX_CHARS2[h4h >> 4 & 15] + HEX_CHARS2[h4h & 15] + HEX_CHARS2[h4l >> 28 & 15] + HEX_CHARS2[h4l >> 24 & 15] + HEX_CHARS2[h4l >> 20 & 15] + HEX_CHARS2[h4l >> 16 & 15] + HEX_CHARS2[h4l >> 12 & 15] + HEX_CHARS2[h4l >> 8 & 15] + HEX_CHARS2[h4l >> 4 & 15] + HEX_CHARS2[h4l & 15] + HEX_CHARS2[h5h >> 28 & 15] + HEX_CHARS2[h5h >> 24 & 15] + HEX_CHARS2[h5h >> 20 & 15] + HEX_CHARS2[h5h >> 16 & 15] + HEX_CHARS2[h5h >> 12 & 15] + HEX_CHARS2[h5h >> 8 & 15] + HEX_CHARS2[h5h >> 4 & 15] + HEX_CHARS2[h5h & 15] + HEX_CHARS2[h5l >> 28 & 15] + HEX_CHARS2[h5l >> 24 & 15] + HEX_CHARS2[h5l >> 20 & 15] + HEX_CHARS2[h5l >> 16 & 15] + HEX_CHARS2[h5l >> 12 & 15] + HEX_CHARS2[h5l >> 8 & 15] + HEX_CHARS2[h5l >> 4 & 15] + HEX_CHARS2[h5l & 15];
        }
        if (bits == 512) {
          hex += HEX_CHARS2[h6h >> 28 & 15] + HEX_CHARS2[h6h >> 24 & 15] + HEX_CHARS2[h6h >> 20 & 15] + HEX_CHARS2[h6h >> 16 & 15] + HEX_CHARS2[h6h >> 12 & 15] + HEX_CHARS2[h6h >> 8 & 15] + HEX_CHARS2[h6h >> 4 & 15] + HEX_CHARS2[h6h & 15] + HEX_CHARS2[h6l >> 28 & 15] + HEX_CHARS2[h6l >> 24 & 15] + HEX_CHARS2[h6l >> 20 & 15] + HEX_CHARS2[h6l >> 16 & 15] + HEX_CHARS2[h6l >> 12 & 15] + HEX_CHARS2[h6l >> 8 & 15] + HEX_CHARS2[h6l >> 4 & 15] + HEX_CHARS2[h6l & 15] + HEX_CHARS2[h7h >> 28 & 15] + HEX_CHARS2[h7h >> 24 & 15] + HEX_CHARS2[h7h >> 20 & 15] + HEX_CHARS2[h7h >> 16 & 15] + HEX_CHARS2[h7h >> 12 & 15] + HEX_CHARS2[h7h >> 8 & 15] + HEX_CHARS2[h7h >> 4 & 15] + HEX_CHARS2[h7h & 15] + HEX_CHARS2[h7l >> 28 & 15] + HEX_CHARS2[h7l >> 24 & 15] + HEX_CHARS2[h7l >> 20 & 15] + HEX_CHARS2[h7l >> 16 & 15] + HEX_CHARS2[h7l >> 12 & 15] + HEX_CHARS2[h7l >> 8 & 15] + HEX_CHARS2[h7l >> 4 & 15] + HEX_CHARS2[h7l & 15];
        }
        return hex;
      };
      Sha512.prototype.toString = Sha512.prototype.hex;
      Sha512.prototype.digest = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var arr = [
          h0h >> 24 & 255,
          h0h >> 16 & 255,
          h0h >> 8 & 255,
          h0h & 255,
          h0l >> 24 & 255,
          h0l >> 16 & 255,
          h0l >> 8 & 255,
          h0l & 255,
          h1h >> 24 & 255,
          h1h >> 16 & 255,
          h1h >> 8 & 255,
          h1h & 255,
          h1l >> 24 & 255,
          h1l >> 16 & 255,
          h1l >> 8 & 255,
          h1l & 255,
          h2h >> 24 & 255,
          h2h >> 16 & 255,
          h2h >> 8 & 255,
          h2h & 255,
          h2l >> 24 & 255,
          h2l >> 16 & 255,
          h2l >> 8 & 255,
          h2l & 255,
          h3h >> 24 & 255,
          h3h >> 16 & 255,
          h3h >> 8 & 255,
          h3h & 255
        ];
        if (bits >= 256) {
          arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
        }
        if (bits >= 384) {
          arr.push(h4h >> 24 & 255, h4h >> 16 & 255, h4h >> 8 & 255, h4h & 255, h4l >> 24 & 255, h4l >> 16 & 255, h4l >> 8 & 255, h4l & 255, h5h >> 24 & 255, h5h >> 16 & 255, h5h >> 8 & 255, h5h & 255, h5l >> 24 & 255, h5l >> 16 & 255, h5l >> 8 & 255, h5l & 255);
        }
        if (bits == 512) {
          arr.push(h6h >> 24 & 255, h6h >> 16 & 255, h6h >> 8 & 255, h6h & 255, h6l >> 24 & 255, h6l >> 16 & 255, h6l >> 8 & 255, h6l & 255, h7h >> 24 & 255, h7h >> 16 & 255, h7h >> 8 & 255, h7h & 255, h7l >> 24 & 255, h7l >> 16 & 255, h7l >> 8 & 255, h7l & 255);
        }
        return arr;
      };
      Sha512.prototype.array = Sha512.prototype.digest;
      Sha512.prototype.arrayBuffer = function() {
        this.finalize();
        var bits = this.bits;
        var buffer = new ArrayBuffer(bits / 8);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0h);
        dataView.setUint32(4, this.h0l);
        dataView.setUint32(8, this.h1h);
        dataView.setUint32(12, this.h1l);
        dataView.setUint32(16, this.h2h);
        dataView.setUint32(20, this.h2l);
        dataView.setUint32(24, this.h3h);
        if (bits >= 256) {
          dataView.setUint32(28, this.h3l);
        }
        if (bits >= 384) {
          dataView.setUint32(32, this.h4h);
          dataView.setUint32(36, this.h4l);
          dataView.setUint32(40, this.h5h);
          dataView.setUint32(44, this.h5l);
        }
        if (bits == 512) {
          dataView.setUint32(48, this.h6h);
          dataView.setUint32(52, this.h6l);
          dataView.setUint32(56, this.h7h);
          dataView.setUint32(60, this.h7l);
        }
        return buffer;
      };
      Sha512.prototype.clone = function() {
        var hash = new Sha512(this.bits, false);
        this.copyTo(hash);
        return hash;
      };
      Sha512.prototype.copyTo = function(hash) {
        var i = 0, attrs = [
          "h0h",
          "h0l",
          "h1h",
          "h1l",
          "h2h",
          "h2l",
          "h3h",
          "h3l",
          "h4h",
          "h4l",
          "h5h",
          "h5l",
          "h6h",
          "h6l",
          "h7h",
          "h7l",
          "start",
          "bytes",
          "hBytes",
          "finalized",
          "hashed",
          "lastByteIndex"
        ];
        for (i = 0; i < attrs.length; ++i) {
          hash[attrs[i]] = this[attrs[i]];
        }
        for (i = 0; i < this.blocks.length; ++i) {
          hash.blocks[i] = this.blocks[i];
        }
      };
      function HmacSha512(key, bits, sharedMemory) {
        var notString, type = typeof key;
        if (type !== "string") {
          if (type === "object") {
            if (key === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(key)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var length = key.length;
        if (!notString) {
          var bytes = [], length = key.length, index = 0, code;
          for (var i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >> 12;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes[index++] = 240 | code >> 18;
              bytes[index++] = 128 | code >> 12 & 63;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        }
        if (key.length > 128) {
          key = new Sha512(bits, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (var i = 0; i < 128; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha512.call(this, bits, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha512.prototype = new Sha512();
      HmacSha512.prototype.finalize = function() {
        Sha512.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha512.call(this, this.bits, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha512.prototype.finalize.call(this);
        }
      };
      HmacSha512.prototype.clone = function() {
        var hash = new HmacSha512([], this.bits, false);
        this.copyTo(hash);
        hash.inner = this.inner;
        for (var i = 0; i < this.oKeyPad.length; ++i) {
          hash.oKeyPad[i] = this.oKeyPad[i];
        }
        return hash;
      };
      var exports3 = createMethod2(512);
      exports3.sha512 = exports3;
      exports3.sha384 = createMethod2(384);
      exports3.sha512_256 = createMethod2(256);
      exports3.sha512_224 = createMethod2(224);
      exports3.sha512.hmac = createHmacMethod2(512);
      exports3.sha384.hmac = createHmacMethod2(384);
      exports3.sha512_256.hmac = createHmacMethod2(256);
      exports3.sha512_224.hmac = createHmacMethod2(224);
      if (COMMON_JS2) {
        module2.exports = exports3;
      } else {
        root2.sha512 = exports3.sha512;
        root2.sha384 = exports3.sha384;
        root2.sha512_256 = exports3.sha512_256;
        root2.sha512_224 = exports3.sha512_224;
        if (AMD2) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/algosdk/dist/cjs/src/nacl/naclWrappers.js
var require_naclWrappers = __commonJS({
  "node_modules/algosdk/dist/cjs/src/nacl/naclWrappers.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SEED_BTYES_LENGTH = exports2.HASH_BYTES_LENGTH = exports2.SECRET_KEY_LENGTH = exports2.PUBLIC_KEY_LENGTH = exports2.verify = exports2.bytesEqual = exports2.sign = exports2.keyPairFromSecretKey = exports2.keyPair = exports2.keyPairFromSeed = exports2.randomBytes = exports2.genericHash = void 0;
    var tweetnacl_1 = __importDefault(require_nacl_fast());
    var js_sha512_1 = __importDefault(require_sha512());
    function genericHash(arr) {
      return js_sha512_1.default.sha512_256.array(arr);
    }
    exports2.genericHash = genericHash;
    function randomBytes(length) {
      return tweetnacl_1.default.randomBytes(length);
    }
    exports2.randomBytes = randomBytes;
    function keyPairFromSeed(seed) {
      return tweetnacl_1.default.sign.keyPair.fromSeed(seed);
    }
    exports2.keyPairFromSeed = keyPairFromSeed;
    function keyPair() {
      const seed = randomBytes(tweetnacl_1.default.box.secretKeyLength);
      return keyPairFromSeed(seed);
    }
    exports2.keyPair = keyPair;
    function keyPairFromSecretKey(sk) {
      return tweetnacl_1.default.sign.keyPair.fromSecretKey(sk);
    }
    exports2.keyPairFromSecretKey = keyPairFromSecretKey;
    function sign(msg, secretKey) {
      return tweetnacl_1.default.sign.detached(msg, secretKey);
    }
    exports2.sign = sign;
    function bytesEqual(a, b) {
      return tweetnacl_1.default.verify(a, b);
    }
    exports2.bytesEqual = bytesEqual;
    function verify(message, signature, verifyKey) {
      return tweetnacl_1.default.sign.detached.verify(message, signature, verifyKey);
    }
    exports2.verify = verify;
    exports2.PUBLIC_KEY_LENGTH = tweetnacl_1.default.sign.publicKeyLength;
    exports2.SECRET_KEY_LENGTH = tweetnacl_1.default.sign.secretKeyLength;
    exports2.HASH_BYTES_LENGTH = 32;
    exports2.SEED_BTYES_LENGTH = 32;
  }
});

// node_modules/hi-base32/src/base32.js
var require_base32 = __commonJS({
  "node_modules/hi-base32/src/base32.js"(exports2, module2) {
    (function() {
      "use strict";
      var root2 = typeof window === "object" ? window : {};
      var NODE_JS2 = !root2.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS2) {
        root2 = global;
      }
      var COMMON_JS2 = !root2.HI_BASE32_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD2 = typeof define === "function" && define.amd;
      var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
      var BASE32_DECODE_CHAR = {
        "A": 0,
        "B": 1,
        "C": 2,
        "D": 3,
        "E": 4,
        "F": 5,
        "G": 6,
        "H": 7,
        "I": 8,
        "J": 9,
        "K": 10,
        "L": 11,
        "M": 12,
        "N": 13,
        "O": 14,
        "P": 15,
        "Q": 16,
        "R": 17,
        "S": 18,
        "T": 19,
        "U": 20,
        "V": 21,
        "W": 22,
        "X": 23,
        "Y": 24,
        "Z": 25,
        "2": 26,
        "3": 27,
        "4": 28,
        "5": 29,
        "6": 30,
        "7": 31
      };
      var blocks2 = [0, 0, 0, 0, 0, 0, 0, 0];
      var throwInvalidUtf8 = function(position, partial) {
        if (partial.length > 10) {
          partial = "..." + partial.substr(-10);
        }
        var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
        err.position = position;
        throw err;
      };
      var toUtf8String = function(bytes) {
        var str = "", length = bytes.length, i = 0, followingChars = 0, b, c;
        while (i < length) {
          b = bytes[i++];
          if (b <= 127) {
            str += String.fromCharCode(b);
            continue;
          } else if (b > 191 && b <= 223) {
            c = b & 31;
            followingChars = 1;
          } else if (b <= 239) {
            c = b & 15;
            followingChars = 2;
          } else if (b <= 247) {
            c = b & 7;
            followingChars = 3;
          } else {
            throwInvalidUtf8(i, str);
          }
          for (var j = 0; j < followingChars; ++j) {
            b = bytes[i++];
            if (b < 128 || b > 191) {
              throwInvalidUtf8(i, str);
            }
            c <<= 6;
            c += b & 63;
          }
          if (c >= 55296 && c <= 57343) {
            throwInvalidUtf8(i, str);
          }
          if (c > 1114111) {
            throwInvalidUtf8(i, str);
          }
          if (c <= 65535) {
            str += String.fromCharCode(c);
          } else {
            c -= 65536;
            str += String.fromCharCode((c >> 10) + 55296);
            str += String.fromCharCode((c & 1023) + 56320);
          }
        }
        return str;
      };
      var decodeAsBytes = function(base32Str) {
        if (base32Str === "") {
          return [];
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        base32Str = base32Str.replace(/=/g, "");
        var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = base32Str.length;
        for (var i = 0, count = length >> 3 << 3; i < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
          bytes[index++] = (v7 << 5 | v8) & 255;
        }
        var remain = length - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
        }
        return bytes;
      };
      var encodeAscii = function(str) {
        var v1, v2, v3, v4, v5, base32Str = "", length = str.length;
        for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i++);
          v4 = str.charCodeAt(i++);
          v5 = str.charCodeAt(i++);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length - count;
        if (remain === 1) {
          v1 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = str.charCodeAt(i++);
          v2 = str.charCodeAt(i++);
          v3 = str.charCodeAt(i++);
          v4 = str.charCodeAt(i);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encodeUtf8 = function(str) {
        var v1, v2, v3, v4, v5, code, end = false, base32Str = "", index = 0, i, start = 0, bytes = 0, length = str.length;
        if (str === "") {
          return base32Str;
        }
        do {
          blocks2[0] = blocks2[5];
          blocks2[1] = blocks2[6];
          blocks2[2] = blocks2[7];
          for (i = start; index < length && i < 5; ++index) {
            code = str.charCodeAt(index);
            if (code < 128) {
              blocks2[i++] = code;
            } else if (code < 2048) {
              blocks2[i++] = 192 | code >> 6;
              blocks2[i++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              blocks2[i++] = 224 | code >> 12;
              blocks2[i++] = 128 | code >> 6 & 63;
              blocks2[i++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++index) & 1023);
              blocks2[i++] = 240 | code >> 18;
              blocks2[i++] = 128 | code >> 12 & 63;
              blocks2[i++] = 128 | code >> 6 & 63;
              blocks2[i++] = 128 | code & 63;
            }
          }
          bytes += i - start;
          start = i - 5;
          if (index === length) {
            ++index;
          }
          if (index > length && i < 6) {
            end = true;
          }
          v1 = blocks2[0];
          if (i > 4) {
            v2 = blocks2[1];
            v3 = blocks2[2];
            v4 = blocks2[3];
            v5 = blocks2[4];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          } else if (i === 1) {
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (i === 2) {
            v2 = blocks2[1];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (i === 3) {
            v2 = blocks2[1];
            v3 = blocks2[2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else {
            v2 = blocks2[1];
            v3 = blocks2[2];
            v4 = blocks2[3];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
          }
        } while (!end);
        return base32Str;
      };
      var encodeBytes = function(bytes) {
        var v1, v2, v3, v4, v5, base32Str = "", length = bytes.length;
        for (var i = 0, count = parseInt(length / 5) * 5; i < count; ) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i++];
          v4 = bytes[i++];
          v5 = bytes[i++];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length - count;
        if (remain === 1) {
          v1 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = bytes[i++];
          v2 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i++];
          v4 = bytes[i];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encode2 = function(input, asciiOnly) {
        var notString = typeof input !== "string";
        if (notString && input.constructor === ArrayBuffer) {
          input = new Uint8Array(input);
        }
        if (notString) {
          return encodeBytes(input);
        } else if (asciiOnly) {
          return encodeAscii(input);
        } else {
          return encodeUtf8(input);
        }
      };
      var decode2 = function(base32Str, asciiOnly) {
        if (!asciiOnly) {
          return toUtf8String(decodeAsBytes(base32Str));
        }
        if (base32Str === "") {
          return "";
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        var v1, v2, v3, v4, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
        if (length === -1) {
          length = base32Str.length;
        }
        for (var i = 0, count = length >> 3 << 3; i < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
        }
        var remain = length - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255);
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255);
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
        }
        return str;
      };
      var exports3 = {
        encode: encode2,
        decode: decode2
      };
      decode2.asBytes = decodeAsBytes;
      if (COMMON_JS2) {
        module2.exports = exports3;
      } else {
        root2.base32 = exports3;
        if (AMD2) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    ;
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method2) {
          var n, i = 1, m = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            n = new BigNumber2(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method2.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy)
            t = xc, xc = yc, yc = t, y.s = -y.s;
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL)
            zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0)
            t = yc, yc = xc, xc = t, b = a;
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2)
              i = g1, g1 = g2, g2 = i, len -= i;
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports2, module2) {
    var BigNumber = require_bignumber();
    var JSON2 = module2.exports;
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports2, module2) {
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        storeAsString: false,
        alwaysParseAsBig: false,
        useNativeBigInt: false,
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`);
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`);
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m) {
        throw {
          name: "SyntaxError",
          message: m,
          at,
          text
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null)
            BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt)
                string2 += text.substring(startAt, at - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at - 1 > startAt)
                string2 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k, v, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v = walk(value2, k2);
              if (v !== void 0) {
                value2[k2] = v;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module2.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports2, module2) {
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module2.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module2.exports.parse = json_parse();
    module2.exports.stringify = json_stringify;
  }
});

// node_modules/algosdk/dist/cjs/src/types/intDecoding.js
var require_intDecoding = __commonJS({
  "node_modules/algosdk/dist/cjs/src/types/intDecoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var IntDecoding;
    (function(IntDecoding2) {
      IntDecoding2["DEFAULT"] = "default";
      IntDecoding2["SAFE"] = "safe";
      IntDecoding2["MIXED"] = "mixed";
      IntDecoding2["BIGINT"] = "bigint";
    })(IntDecoding || (IntDecoding = {}));
    exports2.default = IntDecoding;
  }
});

// node_modules/algosdk/dist/cjs/src/utils/utils.js
var require_utils = __commonJS({
  "node_modules/algosdk/dist/cjs/src/utils/utils.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNode = exports2.removeUndefinedProperties = exports2.concatArrays = exports2.arrayEqual = exports2.parseJSON = void 0;
    var json_bigint_1 = __importDefault(require_json_bigint());
    var intDecoding_1 = __importDefault(require_intDecoding());
    var JSONbig = json_bigint_1.default({ useNativeBigInt: true, strict: true });
    function parseJSON(str, options) {
      const intDecoding = options && options.intDecoding ? options.intDecoding : intDecoding_1.default.DEFAULT;
      const parsed = JSONbig.parse(str, (_, value) => {
        if (value != null && typeof value === "object" && Object.getPrototypeOf(value) == null) {
          Object.setPrototypeOf(value, Object.prototype);
        }
        if (typeof value === "bigint") {
          if (intDecoding === "bigint" || intDecoding === "mixed" && value > Number.MAX_SAFE_INTEGER) {
            return value;
          }
          if (intDecoding === "default" || intDecoding === "mixed") {
            return Number(value);
          }
          throw new Error(`Integer exceeds maximum safe integer: ${value.toString()}. Try parsing with a different intDecoding option.`);
        }
        if (typeof value === "number") {
          if (intDecoding === "bigint" && Number.isInteger(value)) {
            return BigInt(value);
          }
        }
        return value;
      });
      return parsed;
    }
    exports2.parseJSON = parseJSON;
    function arrayEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      return Array.from(a).every((val, i) => val === b[i]);
    }
    exports2.arrayEqual = arrayEqual;
    function concatArrays(...arrs) {
      const size = arrs.reduce((sum, arr) => sum + arr.length, 0);
      const c = new Uint8Array(size);
      let offset = 0;
      for (let i = 0; i < arrs.length; i++) {
        c.set(arrs[i], offset);
        offset += arrs[i].length;
      }
      return c;
    }
    exports2.concatArrays = concatArrays;
    function removeUndefinedProperties(obj) {
      const mutableCopy = { ...obj };
      Object.keys(mutableCopy).forEach((key) => {
        if (typeof mutableCopy[key] === "undefined")
          delete mutableCopy[key];
      });
      return mutableCopy;
    }
    exports2.removeUndefinedProperties = removeUndefinedProperties;
    function isNode() {
      return typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node !== "undefined";
    }
    exports2.isNode = isNode;
  }
});

// node_modules/algosdk/dist/cjs/src/encoding/uint64.js
var require_uint64 = __commonJS({
  "node_modules/algosdk/dist/cjs/src/encoding/uint64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeUint64 = exports2.encodeUint64 = void 0;
    function encodeUint64(num) {
      const isInteger = typeof num === "bigint" || Number.isInteger(num);
      if (!isInteger || num < 0 || num > BigInt("0xffffffffffffffff")) {
        throw new Error("Input is not a 64-bit unsigned integer");
      }
      const buf = Buffer.allocUnsafe(8);
      buf.writeBigUInt64BE(BigInt(num));
      return new Uint8Array(buf);
    }
    exports2.encodeUint64 = encodeUint64;
    function decodeUint64(data, decodingMode = "safe") {
      if (decodingMode !== "safe" && decodingMode !== "mixed" && decodingMode !== "bigint") {
        throw new Error(`Unknown decodingMode option: ${decodingMode}`);
      }
      if (data.byteLength === 0 || data.byteLength > 8) {
        throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);
      }
      const padding = Buffer.allocUnsafe(8 - data.byteLength);
      padding.fill(0);
      const buf = Buffer.concat([padding, Buffer.from(data)]);
      const num = buf.readBigUInt64BE();
      const isBig = num > Number.MAX_SAFE_INTEGER;
      if (decodingMode === "safe") {
        if (isBig) {
          throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
        }
        return Number(num);
      }
      if (decodingMode === "mixed" && !isBig) {
        return Number(num);
      }
      return num;
    }
    exports2.decodeUint64 = decodeUint64;
  }
});

// node_modules/algosdk/dist/cjs/src/encoding/address.js
var require_address = __commonJS({
  "node_modules/algosdk/dist/cjs/src/encoding/address.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getApplicationAddress = exports2.fromMultisigPreImgAddrs = exports2.fromMultisigPreImg = exports2.encodeAddress = exports2.isValidAddress = exports2.decodeAddress = exports2.UNEXPECTED_PK_LEN_ERROR_MSG = exports2.INVALID_MSIG_PK_ERROR_MSG = exports2.INVALID_MSIG_THRESHOLD_ERROR_MSG = exports2.INVALID_MSIG_VERSION_ERROR_MSG = exports2.CHECKSUM_ADDRESS_ERROR_MSG = exports2.MALFORMED_ADDRESS_ERROR_MSG = exports2.ALGORAND_ZERO_ADDRESS_STRING = void 0;
    var hi_base32_1 = __importDefault(require_base32());
    var nacl = __importStar(require_naclWrappers());
    var utils = __importStar(require_utils());
    var uint64_1 = require_uint64();
    var ALGORAND_ADDRESS_BYTE_LENGTH = 36;
    var ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
    var ALGORAND_ADDRESS_LENGTH = 58;
    exports2.ALGORAND_ZERO_ADDRESS_STRING = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
    var MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
      77,
      117,
      108,
      116,
      105,
      115,
      105,
      103,
      65,
      100,
      100,
      114
    ]);
    var APP_ID_PREFIX = Buffer.from("appID");
    exports2.MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
    exports2.CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
    exports2.INVALID_MSIG_VERSION_ERROR_MSG = "invalid multisig version";
    exports2.INVALID_MSIG_THRESHOLD_ERROR_MSG = "bad multisig threshold";
    exports2.INVALID_MSIG_PK_ERROR_MSG = "bad multisig public key - wrong length";
    exports2.UNEXPECTED_PK_LEN_ERROR_MSG = "nacl public key length is not 32 bytes";
    function decodeAddress(address) {
      if (typeof address !== "string" || address.length !== ALGORAND_ADDRESS_LENGTH)
        throw new Error(exports2.MALFORMED_ADDRESS_ERROR_MSG);
      const decoded = hi_base32_1.default.decode.asBytes(address.toString());
      if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
        throw new Error(exports2.MALFORMED_ADDRESS_ERROR_MSG);
      const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
      const cs = new Uint8Array(decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
      const checksum = nacl.genericHash(pk).slice(nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.HASH_BYTES_LENGTH);
      if (!utils.arrayEqual(checksum, cs))
        throw new Error(exports2.CHECKSUM_ADDRESS_ERROR_MSG);
      return { publicKey: pk, checksum: cs };
    }
    exports2.decodeAddress = decodeAddress;
    function isValidAddress(address) {
      try {
        decodeAddress(address);
      } catch (e) {
        return false;
      }
      return true;
    }
    exports2.isValidAddress = isValidAddress;
    function encodeAddress(address) {
      const checksum = nacl.genericHash(address).slice(nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.PUBLIC_KEY_LENGTH);
      const addr = hi_base32_1.default.encode(utils.concatArrays(address, checksum));
      return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH);
    }
    exports2.encodeAddress = encodeAddress;
    function fromMultisigPreImg({ version, threshold, pks }) {
      if (version !== 1 || version > 255 || version < 0) {
        throw new Error(exports2.INVALID_MSIG_VERSION_ERROR_MSG);
      }
      if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {
        throw new Error(exports2.INVALID_MSIG_THRESHOLD_ERROR_MSG);
      }
      const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
      if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {
        throw new Error(exports2.UNEXPECTED_PK_LEN_ERROR_MSG);
      }
      const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
      merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
      merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);
      merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
      for (let i = 0; i < pks.length; i++) {
        if (pks[i].length !== pkLen) {
          throw new Error(exports2.INVALID_MSIG_PK_ERROR_MSG);
        }
        merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);
      }
      return new Uint8Array(nacl.genericHash(merged));
    }
    exports2.fromMultisigPreImg = fromMultisigPreImg;
    function fromMultisigPreImgAddrs({ version, threshold, addrs }) {
      const pks = addrs.map((addr) => decodeAddress(addr).publicKey);
      return encodeAddress(fromMultisigPreImg({ version, threshold, pks }));
    }
    exports2.fromMultisigPreImgAddrs = fromMultisigPreImgAddrs;
    function getApplicationAddress(appID) {
      const toBeSigned = utils.concatArrays(APP_ID_PREFIX, uint64_1.encodeUint64(appID));
      const hash = nacl.genericHash(toBeSigned);
      return encodeAddress(new Uint8Array(hash));
    }
    exports2.getApplicationAddress = getApplicationAddress;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/utils/utf8.js
var require_utf8 = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/utils/utf8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.utf8DecodeTD = exports2.TEXT_DECODER_THRESHOLD = exports2.utf8DecodeJs = exports2.utf8EncodeTE = exports2.TEXT_ENCODER_THRESHOLD = exports2.utf8EncodeJs = exports2.utf8Count = exports2.TEXT_ENCODING_AVAILABLE = void 0;
    exports2.TEXT_ENCODING_AVAILABLE = typeof process !== "undefined" && process.env.TEXT_ENCODING !== "never" && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
    function utf8Count(str) {
      const strLength = str.length;
      let byteLength = 0;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          byteLength++;
          continue;
        } else if ((value & 4294965248) === 0) {
          byteLength += 2;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            byteLength += 3;
          } else {
            byteLength += 4;
          }
        }
      }
      return byteLength;
    }
    exports2.utf8Count = utf8Count;
    function utf8EncodeJs(str, output, outputOffset) {
      const strLength = str.length;
      let offset = outputOffset;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          output[offset++] = value;
          continue;
        } else if ((value & 4294965248) === 0) {
          output[offset++] = value >> 6 & 31 | 192;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            output[offset++] = value >> 12 & 15 | 224;
            output[offset++] = value >> 6 & 63 | 128;
          } else {
            output[offset++] = value >> 18 & 7 | 240;
            output[offset++] = value >> 12 & 63 | 128;
            output[offset++] = value >> 6 & 63 | 128;
          }
        }
        output[offset++] = value & 63 | 128;
      }
    }
    exports2.utf8EncodeJs = utf8EncodeJs;
    var sharedTextEncoder = exports2.TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;
    exports2.TEXT_ENCODER_THRESHOLD = typeof process !== "undefined" && process.env.TEXT_ENCODING !== "force" ? 200 : 0;
    function utf8EncodeTEencode(str, output, outputOffset) {
      output.set(sharedTextEncoder.encode(str), outputOffset);
    }
    function utf8EncodeTEencodeInto(str, output, outputOffset) {
      sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
    }
    exports2.utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
    var CHUNK_SIZE = 4096;
    function utf8DecodeJs(bytes, inputOffset, byteLength) {
      let offset = inputOffset;
      const end = offset + byteLength;
      const units = [];
      let result = "";
      while (offset < end) {
        const byte1 = bytes[offset++];
        if ((byte1 & 128) === 0) {
          units.push(byte1);
        } else if ((byte1 & 224) === 192) {
          const byte2 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 6 | byte2);
        } else if ((byte1 & 240) === 224) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 248) === 240) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          const byte4 = bytes[offset++] & 63;
          let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (unit > 65535) {
            unit -= 65536;
            units.push(unit >>> 10 & 1023 | 55296);
            unit = 56320 | unit & 1023;
          }
          units.push(unit);
        } else {
          units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
          result += String.fromCharCode(...units);
          units.length = 0;
        }
      }
      if (units.length > 0) {
        result += String.fromCharCode(...units);
      }
      return result;
    }
    exports2.utf8DecodeJs = utf8DecodeJs;
    var sharedTextDecoder = exports2.TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
    exports2.TEXT_DECODER_THRESHOLD = typeof process !== "undefined" && process.env.TEXT_DECODER !== "force" ? 200 : 0;
    function utf8DecodeTD(bytes, inputOffset, byteLength) {
      const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
      return sharedTextDecoder.decode(stringBytes);
    }
    exports2.utf8DecodeTD = utf8DecodeTD;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/ExtData.js
var require_ExtData = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/ExtData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtData = void 0;
    var ExtData = class {
      constructor(type, data) {
        this.type = type;
        this.data = data;
      }
    };
    exports2.ExtData = ExtData;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/utils/int.js
var require_int = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/utils/int.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getUint64 = exports2.getInt64 = exports2.setBigInt64 = exports2.setInt64 = exports2.setUint64 = void 0;
    function setUint64(view, offset, value) {
      const high = value / 4294967296;
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports2.setUint64 = setUint64;
    function setInt64(view, offset, value) {
      const high = Math.floor(value / 4294967296);
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports2.setInt64 = setInt64;
    function setBigInt64(view, offset, value) {
      let high = Number(value / BigInt(4294967296));
      const low = Number(value % BigInt(4294967296));
      if (high < 0 && low !== 0) {
        high -= 1;
      }
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports2.setBigInt64 = setBigInt64;
    function getInt64(view, offset) {
      const high = view.getInt32(offset);
      const low = view.getUint32(offset + 4);
      const exceeds_min_safe_int = high < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || high === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && low === 0;
      const exceeds_max_safe_int = high > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
      if (exceeds_min_safe_int || exceeds_max_safe_int) {
        return BigInt(high) * BigInt(4294967296) + BigInt(low);
      }
      return high * 4294967296 + low;
    }
    exports2.getInt64 = getInt64;
    function getUint64(view, offset) {
      const high = view.getUint32(offset);
      const low = view.getUint32(offset + 4);
      const exceeds_max_safe_int = high > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
      if (exceeds_max_safe_int) {
        return BigInt(high) * BigInt(4294967296) + BigInt(low);
      }
      return high * 4294967296 + low;
    }
    exports2.getUint64 = getUint64;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timestampExtension = exports2.decodeTimestampExtension = exports2.decodeTimestampToTimeSpec = exports2.encodeTimestampExtension = exports2.encodeDateToTimeSpec = exports2.encodeTimeSpecToTimestamp = exports2.EXT_TIMESTAMP = void 0;
    var int_1 = require_int();
    exports2.EXT_TIMESTAMP = -1;
    var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    function encodeTimeSpecToTimestamp({ sec, nsec }) {
      if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
          const rv = new Uint8Array(4);
          const view = new DataView(rv.buffer);
          view.setUint32(0, sec);
          return rv;
        } else {
          const secHigh = sec / 4294967296;
          const secLow = sec & 4294967295;
          const rv = new Uint8Array(8);
          const view = new DataView(rv.buffer);
          view.setUint32(0, nsec << 2 | secHigh & 3);
          view.setUint32(4, secLow);
          return rv;
        }
      } else {
        const rv = new Uint8Array(12);
        const view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        int_1.setInt64(view, 4, sec);
        return rv;
      }
    }
    exports2.encodeTimeSpecToTimestamp = encodeTimeSpecToTimestamp;
    function encodeDateToTimeSpec(date) {
      const msec = date.getTime();
      const sec = Math.floor(msec / 1e3);
      const nsec = (msec - sec * 1e3) * 1e6;
      const nsecInSec = Math.floor(nsec / 1e9);
      return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9
      };
    }
    exports2.encodeDateToTimeSpec = encodeDateToTimeSpec;
    function encodeTimestampExtension(object) {
      if (object instanceof Date) {
        const timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
      } else {
        return null;
      }
    }
    exports2.encodeTimestampExtension = encodeTimestampExtension;
    function decodeTimestampToTimeSpec(data) {
      const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
      switch (data.byteLength) {
        case 4: {
          const sec = view.getUint32(0);
          const nsec = 0;
          return { sec, nsec };
        }
        case 8: {
          const nsec30AndSecHigh2 = view.getUint32(0);
          const secLow32 = view.getUint32(4);
          const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
          const nsec = nsec30AndSecHigh2 >>> 2;
          return { sec, nsec };
        }
        case 12: {
          const sec = int_1.getInt64(view, 4);
          const nsec = view.getUint32(0);
          return { sec, nsec };
        }
        default:
          throw new Error(`Unrecognized data size for timestamp: ${data.length}`);
      }
    }
    exports2.decodeTimestampToTimeSpec = decodeTimestampToTimeSpec;
    function decodeTimestampExtension(data) {
      const timeSpec = decodeTimestampToTimeSpec(data);
      return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
    }
    exports2.decodeTimestampExtension = decodeTimestampExtension;
    exports2.timestampExtension = {
      type: exports2.EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/algo-msgpack-with-bigint/dist/ExtensionCodec.js
var require_ExtensionCodec = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/ExtensionCodec.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtensionCodec = void 0;
    var ExtData_1 = require_ExtData();
    var timestamp_1 = require_timestamp();
    var ExtensionCodec = class {
      constructor() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestamp_1.timestampExtension);
      }
      register({ type, encode: encode2, decode: decode2 }) {
        if (type >= 0) {
          this.encoders[type] = encode2;
          this.decoders[type] = decode2;
        } else {
          const index = 1 + type;
          this.builtInEncoders[index] = encode2;
          this.builtInDecoders[index] = decode2;
        }
      }
      tryToEncode(object, context) {
        for (let i = 0; i < this.builtInEncoders.length; i++) {
          const encoder = this.builtInEncoders[i];
          if (encoder != null) {
            const data = encoder(object, context);
            if (data != null) {
              const type = -1 - i;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        for (let i = 0; i < this.encoders.length; i++) {
          const encoder = this.encoders[i];
          if (encoder != null) {
            const data = encoder(object, context);
            if (data != null) {
              const type = i;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData_1.ExtData) {
          return object;
        }
        return null;
      }
      decode(data, type, context) {
        const decoder = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decoder) {
          return decoder(data, type, context);
        } else {
          return new ExtData_1.ExtData(type, data);
        }
      }
    };
    exports2.ExtensionCodec = ExtensionCodec;
    ExtensionCodec.defaultCodec = new ExtensionCodec();
  }
});

// node_modules/algo-msgpack-with-bigint/dist/utils/typedArrays.js
var require_typedArrays = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/utils/typedArrays.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDataView = exports2.ensureUint8Array = void 0;
    function ensureUint8Array(buffer) {
      if (buffer instanceof Uint8Array) {
        return buffer;
      } else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      } else if (buffer instanceof ArrayBuffer) {
        return new Uint8Array(buffer);
      } else {
        return Uint8Array.from(buffer);
      }
    }
    exports2.ensureUint8Array = ensureUint8Array;
    function createDataView(buffer) {
      if (buffer instanceof ArrayBuffer) {
        return new DataView(buffer);
      }
      const bufferView = ensureUint8Array(buffer);
      return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    }
    exports2.createDataView = createDataView;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/Encoder.js
var require_Encoder = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/Encoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Encoder = exports2.DEFAULT_INITIAL_BUFFER_SIZE = exports2.DEFAULT_MAX_DEPTH = void 0;
    var utf8_1 = require_utf8();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var typedArrays_1 = require_typedArrays();
    exports2.DEFAULT_MAX_DEPTH = 100;
    exports2.DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    var Encoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxDepth = exports2.DEFAULT_MAX_DEPTH, initialBufferSize = exports2.DEFAULT_INITIAL_BUFFER_SIZE, sortKeys = false, forceFloat32 = false, ignoreUndefined = false, forceIntegerToFloat = false) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxDepth = maxDepth;
        this.initialBufferSize = initialBufferSize;
        this.sortKeys = sortKeys;
        this.forceFloat32 = forceFloat32;
        this.ignoreUndefined = ignoreUndefined;
        this.forceIntegerToFloat = forceIntegerToFloat;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      getUint8Array() {
        return this.bytes.subarray(0, this.pos);
      }
      reinitializeState() {
        this.pos = 0;
      }
      encode(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.getUint8Array();
      }
      doEncode(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          this.encodeNumber(object);
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else if (typeof object === "bigint") {
          this.encodebigint(object);
        } else {
          this.encodeObject(object, depth);
        }
      }
      ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      }
      resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      }
      encodeNil() {
        this.writeU8(192);
      }
      encodeBoolean(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      }
      encodeNumber(object) {
        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else {
              this.writeU8(207);
              this.writeU64(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else {
              this.writeU8(211);
              this.writeI64(object);
            }
          }
        } else {
          if (this.forceFloat32) {
            this.writeU8(202);
            this.writeF32(object);
          } else {
            this.writeU8(203);
            this.writeF64(object);
          }
        }
      }
      encodebigint(object) {
        if (object >= BigInt(0)) {
          if (object < BigInt(128)) {
            this.writeU8(Number(object));
          } else if (object < BigInt(256)) {
            this.writeU8(204);
            this.writeU8(Number(object));
          } else if (object < BigInt(65536)) {
            this.writeU8(205);
            this.writeU16(Number(object));
          } else if (object < BigInt(4294967296)) {
            this.writeU8(206);
            this.writeU32(Number(object));
          } else {
            this.writeU8(207);
            this.writeBig64(object);
          }
        } else {
          if (object >= BigInt(-32)) {
            this.writeU8(224 | Number(object) + 32);
          } else if (object >= BigInt(-128)) {
            this.writeU8(208);
            this.writeI8(Number(object));
          } else if (object >= BigInt(-32768)) {
            this.writeU8(209);
            this.writeI16(Number(object));
          } else if (object >= BigInt(-2147483648)) {
            this.writeU8(210);
            this.writeI32(Number(object));
          } else {
            this.writeU8(211);
            this.writeBig64(object);
          }
        }
      }
      writeStringHeader(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
      }
      encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const strLength = object.length;
        if (utf8_1.TEXT_ENCODING_AVAILABLE && strLength > utf8_1.TEXT_ENCODER_THRESHOLD) {
          const byteLength = utf8_1.utf8Count(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          utf8_1.utf8EncodeTE(object, this.bytes, this.pos);
          this.pos += byteLength;
        } else {
          const byteLength = utf8_1.utf8Count(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          utf8_1.utf8EncodeJs(object, this.bytes, this.pos);
          this.pos += byteLength;
        }
      }
      encodeObject(object, depth) {
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
      }
      encodeBinary(object) {
        const size = object.byteLength;
        if (size < 256) {
          this.writeU8(196);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(197);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(198);
          this.writeU32(size);
        } else {
          throw new Error(`Too large binary: ${size}`);
        }
        const bytes = typedArrays_1.ensureUint8Array(object);
        this.writeU8a(bytes);
      }
      encodeArray(object, depth) {
        const size = object.length;
        if (size < 16) {
          this.writeU8(144 + size);
        } else if (size < 65536) {
          this.writeU8(220);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(221);
          this.writeU32(size);
        } else {
          throw new Error(`Too large array: ${size}`);
        }
        for (const item of object) {
          this.doEncode(item, depth + 1);
        }
      }
      countWithoutUndefined(object, keys) {
        let count = 0;
        for (const key of keys) {
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      }
      encodeMap(object, depth) {
        const keys = Object.keys(object);
        if (this.sortKeys) {
          keys.sort();
        }
        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
          this.writeU8(128 + size);
        } else if (size < 65536) {
          this.writeU8(222);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(223);
          this.writeU32(size);
        } else {
          throw new Error(`Too large map object: ${size}`);
        }
        for (const key of keys) {
          const value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      }
      encodeExtension(ext) {
        const size = ext.data.length;
        if (size === 1) {
          this.writeU8(212);
        } else if (size === 2) {
          this.writeU8(213);
        } else if (size === 4) {
          this.writeU8(214);
        } else if (size === 8) {
          this.writeU8(215);
        } else if (size === 16) {
          this.writeU8(216);
        } else if (size < 256) {
          this.writeU8(199);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(200);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(201);
          this.writeU32(size);
        } else {
          throw new Error(`Too large extension object: ${size}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      }
      writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      }
      writeU8a(values) {
        const size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
      }
      writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      }
      writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      }
      writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      }
      writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      }
      writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      }
      writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      }
      writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      }
      writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        int_1.setUint64(this.view, this.pos, value);
        this.pos += 8;
      }
      writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        int_1.setInt64(this.view, this.pos, value);
        this.pos += 8;
      }
      writeBig64(value) {
        this.ensureBufferSizeToWrite(8);
        int_1.setBigInt64(this.view, this.pos, value);
        this.pos += 8;
      }
    };
    exports2.Encoder = Encoder;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/encode.js
var require_encode = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/encode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = void 0;
    var Encoder_1 = require_Encoder();
    var defaultEncodeOptions = {};
    function encode2(value, options = defaultEncodeOptions) {
      const encoder = new Encoder_1.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
      return encoder.encode(value);
    }
    exports2.encode = encode2;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/utils/prettyByte.js
var require_prettyByte = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/utils/prettyByte.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prettyByte = void 0;
    function prettyByte(byte) {
      return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
    }
    exports2.prettyByte = prettyByte;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/CachedKeyDecoder.js
var require_CachedKeyDecoder = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/CachedKeyDecoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CachedKeyDecoder = void 0;
    var utf8_1 = require_utf8();
    var DEFAULT_MAX_KEY_LENGTH = 16;
    var DEFAULT_MAX_LENGTH_PER_KEY = 16;
    var CachedKeyDecoder = class {
      constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        this.caches = [];
        for (let i = 0; i < this.maxKeyLength; i++) {
          this.caches.push([]);
        }
      }
      canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      }
      get(bytes, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        const recordsLength = records.length;
        FIND_CHUNK:
          for (let i = 0; i < recordsLength; i++) {
            const record = records[i];
            const recordBytes = record.bytes;
            for (let j = 0; j < byteLength; j++) {
              if (recordBytes[j] !== bytes[inputOffset + j]) {
                continue FIND_CHUNK;
              }
            }
            return record.value;
          }
        return null;
      }
      store(bytes, value) {
        const records = this.caches[bytes.length - 1];
        const record = { bytes, value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      }
      decode(bytes, inputOffset, byteLength) {
        const cachedValue = this.get(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        const value = utf8_1.utf8DecodeJs(bytes, inputOffset, byteLength);
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, value);
        return value;
      }
    };
    exports2.CachedKeyDecoder = CachedKeyDecoder;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/Decoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Decoder = exports2.DataViewIndexOutOfBoundsError = void 0;
    var prettyByte_1 = require_prettyByte();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var utf8_1 = require_utf8();
    var typedArrays_1 = require_typedArrays();
    var CachedKeyDecoder_1 = require_CachedKeyDecoder();
    var isValidMapKeyType = (key) => {
      const keyType = typeof key;
      return keyType === "string" || keyType === "number";
    };
    var HEAD_BYTE_REQUIRED = -1;
    var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    exports2.DataViewIndexOutOfBoundsError = (() => {
      try {
        EMPTY_VIEW.getInt8(0);
      } catch (e) {
        return e.constructor;
      }
      throw new Error("never reached");
    })();
    var MORE_DATA = new exports2.DataViewIndexOutOfBoundsError("Insufficient data");
    var DEFAULT_MAX_LENGTH = 4294967295;
    var sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();
    var Decoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxStrLength = DEFAULT_MAX_LENGTH, maxBinLength = DEFAULT_MAX_LENGTH, maxArrayLength = DEFAULT_MAX_LENGTH, maxMapLength = DEFAULT_MAX_LENGTH, maxExtLength = DEFAULT_MAX_LENGTH, keyDecoder = sharedCachedKeyDecoder) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
      }
      reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
      }
      setBuffer(buffer) {
        this.bytes = typedArrays_1.ensureUint8Array(buffer);
        this.view = typedArrays_1.createDataView(this.bytes);
        this.pos = 0;
      }
      appendBuffer(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining()) {
          this.setBuffer(buffer);
        } else {
          const remainingData = this.bytes.subarray(this.pos);
          const newData = typedArrays_1.ensureUint8Array(buffer);
          const concated = new Uint8Array(remainingData.length + newData.length);
          concated.set(remainingData);
          concated.set(newData, remainingData.length);
          this.setBuffer(concated);
        }
      }
      hasRemaining(size = 1) {
        return this.view.byteLength - this.pos >= size;
      }
      createNoExtraBytesError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
      }
      decode(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        return this.doDecodeSingleSync();
      }
      doDecodeSingleSync() {
        const object = this.doDecodeSync();
        if (this.hasRemaining()) {
          throw this.createNoExtraBytesError(this.pos);
        }
        return object;
      }
      async decodeAsync(stream) {
        let decoded = false;
        let object;
        for await (const buffer of stream) {
          if (decoded) {
            throw this.createNoExtraBytesError(this.totalPos);
          }
          this.appendBuffer(buffer);
          try {
            object = this.doDecodeSync();
            decoded = true;
          } catch (e) {
            if (!(e instanceof exports2.DataViewIndexOutOfBoundsError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
        if (decoded) {
          if (this.hasRemaining()) {
            throw this.createNoExtraBytesError(this.totalPos);
          }
          return object;
        }
        const { headByte, pos, totalPos } = this;
        throw new RangeError(`Insufficient data in parcing ${prettyByte_1.prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);
      }
      decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
      }
      decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
      }
      async *decodeMultiAsync(stream, isArray) {
        let isArrayHeaderRequired = isArray;
        let arrayItemsLeft = -1;
        for await (const buffer of stream) {
          if (isArray && arrayItemsLeft === 0) {
            throw this.createNoExtraBytesError(this.totalPos);
          }
          this.appendBuffer(buffer);
          if (isArrayHeaderRequired) {
            arrayItemsLeft = this.readArraySize();
            isArrayHeaderRequired = false;
            this.complete();
          }
          try {
            while (true) {
              yield this.doDecodeSync();
              if (--arrayItemsLeft === 0) {
                break;
              }
            }
          } catch (e) {
            if (!(e instanceof exports2.DataViewIndexOutOfBoundsError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
      }
      doDecodeSync() {
        DECODE:
          while (true) {
            const headByte = this.readHeadByte();
            let object;
            if (headByte >= 224) {
              object = headByte - 256;
            } else if (headByte < 192) {
              if (headByte < 128) {
                object = headByte;
              } else if (headByte < 144) {
                const size = headByte - 128;
                if (size !== 0) {
                  this.pushMapState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = {};
                }
              } else if (headByte < 160) {
                const size = headByte - 144;
                if (size !== 0) {
                  this.pushArrayState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = [];
                }
              } else {
                const byteLength = headByte - 160;
                object = this.decodeUtf8String(byteLength, 0);
              }
            } else if (headByte === 192) {
              object = null;
            } else if (headByte === 194) {
              object = false;
            } else if (headByte === 195) {
              object = true;
            } else if (headByte === 202) {
              object = this.readF32();
            } else if (headByte === 203) {
              object = this.readF64();
            } else if (headByte === 204) {
              object = this.readU8();
            } else if (headByte === 205) {
              object = this.readU16();
            } else if (headByte === 206) {
              object = this.readU32();
            } else if (headByte === 207) {
              object = this.readU64();
            } else if (headByte === 208) {
              object = this.readI8();
            } else if (headByte === 209) {
              object = this.readI16();
            } else if (headByte === 210) {
              object = this.readI32();
            } else if (headByte === 211) {
              object = this.readI64();
            } else if (headByte === 217) {
              const byteLength = this.lookU8();
              object = this.decodeUtf8String(byteLength, 1);
            } else if (headByte === 218) {
              const byteLength = this.lookU16();
              object = this.decodeUtf8String(byteLength, 2);
            } else if (headByte === 219) {
              const byteLength = this.lookU32();
              object = this.decodeUtf8String(byteLength, 4);
            } else if (headByte === 220) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 221) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 222) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 223) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 196) {
              const size = this.lookU8();
              object = this.decodeBinary(size, 1);
            } else if (headByte === 197) {
              const size = this.lookU16();
              object = this.decodeBinary(size, 2);
            } else if (headByte === 198) {
              const size = this.lookU32();
              object = this.decodeBinary(size, 4);
            } else if (headByte === 212) {
              object = this.decodeExtension(1, 0);
            } else if (headByte === 213) {
              object = this.decodeExtension(2, 0);
            } else if (headByte === 214) {
              object = this.decodeExtension(4, 0);
            } else if (headByte === 215) {
              object = this.decodeExtension(8, 0);
            } else if (headByte === 216) {
              object = this.decodeExtension(16, 0);
            } else if (headByte === 199) {
              const size = this.lookU8();
              object = this.decodeExtension(size, 1);
            } else if (headByte === 200) {
              const size = this.lookU16();
              object = this.decodeExtension(size, 2);
            } else if (headByte === 201) {
              const size = this.lookU32();
              object = this.decodeExtension(size, 4);
            } else {
              throw new Error(`Unrecognized type byte: ${prettyByte_1.prettyByte(headByte)}`);
            }
            this.complete();
            const stack = this.stack;
            while (stack.length > 0) {
              const state = stack[stack.length - 1];
              if (state.type === 0) {
                state.array[state.position] = object;
                state.position++;
                if (state.position === state.size) {
                  stack.pop();
                  object = state.array;
                } else {
                  continue DECODE;
                }
              } else if (state.type === 1) {
                if (!isValidMapKeyType(object)) {
                  throw new Error("The type of key must be string or number but " + typeof object);
                }
                state.key = object;
                state.type = 2;
                continue DECODE;
              } else {
                state.map[state.key] = object;
                state.readCount++;
                if (state.readCount === state.size) {
                  stack.pop();
                  object = state.map;
                } else {
                  state.key = null;
                  state.type = 1;
                  continue DECODE;
                }
              }
            }
            return object;
          }
      }
      readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      }
      complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
      }
      readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new Error(`Unrecognized array type byte: ${prettyByte_1.prettyByte(headByte)}`);
            }
          }
        }
      }
      pushMapState(size) {
        if (size > this.maxMapLength) {
          throw new Error(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.push({
          type: 1,
          size,
          key: null,
          readCount: 0,
          map: {}
        });
      }
      pushArrayState(size) {
        if (size > this.maxArrayLength) {
          throw new Error(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.push({
          type: 0,
          size,
          array: new Array(size),
          position: 0
        });
      }
      decodeUtf8String(byteLength, headerOffset) {
        var _a;
        if (byteLength > this.maxStrLength) {
          throw new Error(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else if (utf8_1.TEXT_ENCODING_AVAILABLE && byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {
          object = utf8_1.utf8DecodeTD(this.bytes, offset, byteLength);
        } else {
          object = utf8_1.utf8DecodeJs(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      }
      stateIsMapKey() {
        if (this.stack.length > 0) {
          const state = this.stack[this.stack.length - 1];
          return state.type === 1;
        }
        return false;
      }
      decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new Error(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      }
      decodeExtension(size, headOffset) {
        if (size > this.maxExtLength) {
          throw new Error(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(size, headOffset + 1);
        return this.extensionCodec.decode(data, extType, this.context);
      }
      lookU8() {
        return this.view.getUint8(this.pos);
      }
      lookU16() {
        return this.view.getUint16(this.pos);
      }
      lookU32() {
        return this.view.getUint32(this.pos);
      }
      readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      }
      readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      }
      readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      }
      readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      }
      readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      }
      readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      }
      readU64() {
        const value = int_1.getUint64(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readI64() {
        const value = int_1.getInt64(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      }
      readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      }
    };
    exports2.Decoder = Decoder;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/decode.js
var require_decode = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/decode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.defaultDecodeOptions = void 0;
    var Decoder_1 = require_Decoder();
    exports2.defaultDecodeOptions = {};
    function decode2(buffer, options = exports2.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decode(buffer);
    }
    exports2.decode = decode2;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/utils/stream.js
var require_stream = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureAsyncIterabe = exports2.asyncIterableFromStream = exports2.isAsyncIterable = void 0;
    function isAsyncIterable(object) {
      return object[Symbol.asyncIterator] != null;
    }
    exports2.isAsyncIterable = isAsyncIterable;
    function assertNonNull(value) {
      if (value == null) {
        throw new Error("Assertion Failure: value must not be null nor undefined");
      }
    }
    async function* asyncIterableFromStream(stream) {
      const reader = stream.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            return;
          }
          assertNonNull(value);
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }
    exports2.asyncIterableFromStream = asyncIterableFromStream;
    function ensureAsyncIterabe(streamLike) {
      if (isAsyncIterable(streamLike)) {
        return streamLike;
      } else {
        return asyncIterableFromStream(streamLike);
      }
    }
    exports2.ensureAsyncIterabe = ensureAsyncIterabe;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/decodeAsync.js
var require_decodeAsync = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/decodeAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeStream = exports2.decodeArrayStream = exports2.decodeAsync = void 0;
    var Decoder_1 = require_Decoder();
    var decode_1 = require_decode();
    var stream_1 = require_stream();
    async function decodeAsync(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = stream_1.ensureAsyncIterabe(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeAsync(stream);
    }
    exports2.decodeAsync = decodeAsync;
    function decodeArrayStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = stream_1.ensureAsyncIterabe(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeArrayStream(stream);
    }
    exports2.decodeArrayStream = decodeArrayStream;
    function decodeStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = stream_1.ensureAsyncIterabe(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeStream(stream);
    }
    exports2.decodeStream = decodeStream;
  }
});

// node_modules/algo-msgpack-with-bigint/dist/index.js
var require_dist = __commonJS({
  "node_modules/algo-msgpack-with-bigint/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeTimestampExtension = exports2.encodeTimestampExtension = exports2.decodeTimestampToTimeSpec = exports2.encodeTimeSpecToTimestamp = exports2.encodeDateToTimeSpec = exports2.EXT_TIMESTAMP = exports2.ExtData = exports2.ExtensionCodec = exports2.Encoder = exports2.Decoder = exports2.decodeStream = exports2.decodeArrayStream = exports2.decodeAsync = exports2.decode = exports2.encode = void 0;
    var encode_1 = require_encode();
    Object.defineProperty(exports2, "encode", { enumerable: true, get: function() {
      return encode_1.encode;
    } });
    var decode_1 = require_decode();
    Object.defineProperty(exports2, "decode", { enumerable: true, get: function() {
      return decode_1.decode;
    } });
    var decodeAsync_1 = require_decodeAsync();
    Object.defineProperty(exports2, "decodeAsync", { enumerable: true, get: function() {
      return decodeAsync_1.decodeAsync;
    } });
    Object.defineProperty(exports2, "decodeArrayStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeArrayStream;
    } });
    Object.defineProperty(exports2, "decodeStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeStream;
    } });
    var Decoder_1 = require_Decoder();
    Object.defineProperty(exports2, "Decoder", { enumerable: true, get: function() {
      return Decoder_1.Decoder;
    } });
    var Encoder_1 = require_Encoder();
    Object.defineProperty(exports2, "Encoder", { enumerable: true, get: function() {
      return Encoder_1.Encoder;
    } });
    var ExtensionCodec_1 = require_ExtensionCodec();
    Object.defineProperty(exports2, "ExtensionCodec", { enumerable: true, get: function() {
      return ExtensionCodec_1.ExtensionCodec;
    } });
    var ExtData_1 = require_ExtData();
    Object.defineProperty(exports2, "ExtData", { enumerable: true, get: function() {
      return ExtData_1.ExtData;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports2, "EXT_TIMESTAMP", { enumerable: true, get: function() {
      return timestamp_1.EXT_TIMESTAMP;
    } });
    Object.defineProperty(exports2, "encodeDateToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.encodeDateToTimeSpec;
    } });
    Object.defineProperty(exports2, "encodeTimeSpecToTimestamp", { enumerable: true, get: function() {
      return timestamp_1.encodeTimeSpecToTimestamp;
    } });
    Object.defineProperty(exports2, "decodeTimestampToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampToTimeSpec;
    } });
    Object.defineProperty(exports2, "encodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.encodeTimestampExtension;
    } });
    Object.defineProperty(exports2, "decodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampExtension;
    } });
  }
});

// node_modules/algosdk/dist/cjs/src/encoding/encoding.js
var require_encoding = __commonJS({
  "node_modules/algosdk/dist/cjs/src/encoding/encoding.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = exports2.ERROR_CONTAINS_EMPTY_STRING = void 0;
    var msgpack = __importStar(require_dist());
    exports2.ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
    function containsEmpty(obj) {
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          if (!obj[key] || obj[key].length === 0) {
            return { containsEmpty: true, firstEmptyKey: key };
          }
        }
      }
      return { containsEmpty: false, firstEmptyKey: void 0 };
    }
    function encode2(obj) {
      const emptyCheck = containsEmpty(obj);
      if (emptyCheck.containsEmpty) {
        throw new Error(exports2.ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
      }
      const options = { sortKeys: true };
      return msgpack.encode(obj, options);
    }
    exports2.encode = encode2;
    function decode2(buffer) {
      return msgpack.decode(buffer);
    }
    exports2.decode = decode2;
  }
});

// node_modules/algosdk/dist/cjs/src/types/transactions/base.js
var require_base = __commonJS({
  "node_modules/algosdk/dist/cjs/src/types/transactions/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OnApplicationComplete = exports2.isTransactionType = exports2.TransactionType = void 0;
    var TransactionType;
    (function(TransactionType2) {
      TransactionType2["pay"] = "pay";
      TransactionType2["keyreg"] = "keyreg";
      TransactionType2["acfg"] = "acfg";
      TransactionType2["axfer"] = "axfer";
      TransactionType2["afrz"] = "afrz";
      TransactionType2["appl"] = "appl";
    })(TransactionType = exports2.TransactionType || (exports2.TransactionType = {}));
    function isTransactionType(s) {
      return s === TransactionType.pay || s === TransactionType.keyreg || s === TransactionType.acfg || s === TransactionType.axfer || s === TransactionType.afrz || s === TransactionType.appl;
    }
    exports2.isTransactionType = isTransactionType;
    var OnApplicationComplete;
    (function(OnApplicationComplete2) {
      OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
      OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
      OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
      OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
      OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
      OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
    })(OnApplicationComplete = exports2.OnApplicationComplete || (exports2.OnApplicationComplete = {}));
  }
});

// node_modules/algosdk/dist/cjs/src/transaction.js
var require_transaction = __commonJS({
  "node_modules/algosdk/dist/cjs/src/transaction.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.instantiateTxnIfNeeded = exports2.decodeSignedTransaction = exports2.decodeUnsignedTransaction = exports2.encodeUnsignedTransaction = exports2.Transaction = exports2.ALGORAND_MIN_TX_FEE = void 0;
    var hi_base32_1 = __importDefault(require_base32());
    var address = __importStar(require_address());
    var encoding = __importStar(require_encoding());
    var nacl = __importStar(require_naclWrappers());
    var utils = __importStar(require_utils());
    var base_1 = require_base();
    var ALGORAND_TRANSACTION_LENGTH = 52;
    exports2.ALGORAND_MIN_TX_FEE = 1e3;
    var ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
    var ALGORAND_MAX_ASSET_DECIMALS = 19;
    var NUM_ADDL_BYTES_AFTER_SIGNING = 75;
    var ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH = 5;
    var ALGORAND_TRANSACTION_ADDRESS_LENGTH = 32;
    var ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH = 5;
    var ASSET_METADATA_HASH_LENGTH = 32;
    var KEYREG_VOTE_KEY_LENGTH = 32;
    var KEYREG_SELECTION_KEY_LENGTH = 32;
    var KEYREG_STATE_PROOF_KEY_LENGTH = 64;
    function getKeyregKey(input, inputName, length) {
      if (input == null) {
        return void 0;
      }
      let inputAsBuffer;
      if (typeof input === "string") {
        inputAsBuffer = Buffer.from(input, "base64");
      } else if (input.constructor === Uint8Array) {
        inputAsBuffer = Buffer.from(input);
      } else if (Buffer.isBuffer(input)) {
        inputAsBuffer = input;
      }
      if (inputAsBuffer == null || inputAsBuffer.byteLength !== length) {
        throw Error(`${inputName} must be a ${length} byte Uint8Array or Buffer or base64 string.`);
      }
      return inputAsBuffer;
    }
    var Transaction = class {
      constructor({ ...transaction }) {
        this.name = "Transaction";
        this.tag = Buffer.from("TX");
        const defaults = {
          type: base_1.TransactionType.pay,
          flatFee: false,
          nonParticipation: false
        };
        if (typeof transaction.type === "undefined") {
          transaction.type = defaults.type;
        }
        if (typeof transaction.flatFee === "undefined") {
          transaction.flatFee = defaults.flatFee;
        }
        if (transaction.type === base_1.TransactionType.keyreg && typeof transaction.voteKey !== "undefined" && typeof transaction.nonParticipation === "undefined") {
          transaction.nonParticipation = defaults.nonParticipation;
        }
        if (transaction.suggestedParams !== void 0) {
          const reference = transaction;
          reference.genesisHash = reference.suggestedParams.genesisHash;
          reference.fee = reference.suggestedParams.fee;
          if (reference.suggestedParams.flatFee !== void 0)
            reference.flatFee = reference.suggestedParams.flatFee;
          reference.firstRound = reference.suggestedParams.firstRound;
          reference.lastRound = reference.suggestedParams.lastRound;
          reference.genesisID = reference.suggestedParams.genesisID;
        }
        const txn = transaction;
        txn.from = address.decodeAddress(txn.from);
        if (txn.to !== void 0)
          txn.to = address.decodeAddress(txn.to);
        if (txn.closeRemainderTo !== void 0)
          txn.closeRemainderTo = address.decodeAddress(txn.closeRemainderTo);
        if (txn.assetManager !== void 0)
          txn.assetManager = address.decodeAddress(txn.assetManager);
        if (txn.assetReserve !== void 0)
          txn.assetReserve = address.decodeAddress(txn.assetReserve);
        if (txn.assetFreeze !== void 0)
          txn.assetFreeze = address.decodeAddress(txn.assetFreeze);
        if (txn.assetClawback !== void 0)
          txn.assetClawback = address.decodeAddress(txn.assetClawback);
        if (txn.assetRevocationTarget !== void 0)
          txn.assetRevocationTarget = address.decodeAddress(txn.assetRevocationTarget);
        if (txn.freezeAccount !== void 0)
          txn.freezeAccount = address.decodeAddress(txn.freezeAccount);
        if (txn.reKeyTo !== void 0)
          txn.reKeyTo = address.decodeAddress(txn.reKeyTo);
        if (txn.genesisHash === void 0)
          throw Error("genesis hash must be specified and in a base64 string.");
        txn.genesisHash = Buffer.from(txn.genesisHash, "base64");
        if (txn.amount !== void 0 && (!(Number.isSafeInteger(txn.amount) || typeof txn.amount === "bigint" && txn.amount <= BigInt("0xffffffffffffffff")) || txn.amount < 0))
          throw Error("Amount must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
        if (!Number.isSafeInteger(txn.fee) || txn.fee < 0)
          throw Error("fee must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(txn.firstRound) || txn.firstRound < 0)
          throw Error("firstRound must be a positive number");
        if (!Number.isSafeInteger(txn.lastRound) || txn.lastRound < 0)
          throw Error("lastRound must be a positive number");
        if (txn.extraPages !== void 0 && (!Number.isInteger(txn.extraPages) || txn.extraPages < 0 || txn.extraPages > 3))
          throw Error("extraPages must be an Integer between and including 0 to 3");
        if (txn.assetTotal !== void 0 && (!(Number.isSafeInteger(txn.assetTotal) || typeof txn.assetTotal === "bigint" && txn.assetTotal <= BigInt("0xffffffffffffffff")) || txn.assetTotal < 0))
          throw Error("Total asset issuance must be a positive number and smaller than 2^64-1. If the number is larger than 2^53-1, use bigint.");
        if (txn.assetDecimals !== void 0 && (!Number.isSafeInteger(txn.assetDecimals) || txn.assetDecimals < 0 || txn.assetDecimals > ALGORAND_MAX_ASSET_DECIMALS))
          throw Error(`assetDecimals must be a positive number and smaller than ${ALGORAND_MAX_ASSET_DECIMALS.toString()}`);
        if (txn.assetIndex !== void 0 && (!Number.isSafeInteger(txn.assetIndex) || txn.assetIndex < 0))
          throw Error("Asset index must be a positive number and smaller than 2^53-1");
        if (txn.appIndex !== void 0 && (!Number.isSafeInteger(txn.appIndex) || txn.appIndex < 0))
          throw Error("Application index must be a positive number and smaller than 2^53-1");
        if (txn.appLocalInts !== void 0 && (!Number.isSafeInteger(txn.appLocalInts) || txn.appLocalInts < 0))
          throw Error("Application local ints count must be a positive number and smaller than 2^53-1");
        if (txn.appLocalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appLocalByteSlices) || txn.appLocalByteSlices < 0))
          throw Error("Application local byte slices count must be a positive number and smaller than 2^53-1");
        if (txn.appGlobalInts !== void 0 && (!Number.isSafeInteger(txn.appGlobalInts) || txn.appGlobalInts < 0))
          throw Error("Application global ints count must be a positive number and smaller than 2^53-1");
        if (txn.appGlobalByteSlices !== void 0 && (!Number.isSafeInteger(txn.appGlobalByteSlices) || txn.appGlobalByteSlices < 0))
          throw Error("Application global byte slices count must be a positive number and smaller than 2^53-1");
        if (txn.appApprovalProgram !== void 0) {
          if (txn.appApprovalProgram.constructor !== Uint8Array)
            throw Error("appApprovalProgram must be a Uint8Array.");
        }
        if (txn.appClearProgram !== void 0) {
          if (txn.appClearProgram.constructor !== Uint8Array)
            throw Error("appClearProgram must be a Uint8Array.");
        }
        if (txn.appArgs !== void 0) {
          if (!Array.isArray(txn.appArgs))
            throw Error("appArgs must be an Array of Uint8Array.");
          txn.appArgs = txn.appArgs.slice();
          txn.appArgs.forEach((arg) => {
            if (arg.constructor !== Uint8Array)
              throw Error("each element of AppArgs must be a Uint8Array.");
          });
        } else {
          txn.appArgs = [];
        }
        if (txn.appAccounts !== void 0) {
          if (!Array.isArray(txn.appAccounts))
            throw Error("appAccounts must be an Array of addresses.");
          txn.appAccounts = txn.appAccounts.map((addressAsString) => address.decodeAddress(addressAsString));
        }
        if (txn.appForeignApps !== void 0) {
          if (!Array.isArray(txn.appForeignApps))
            throw Error("appForeignApps must be an Array of integers.");
          txn.appForeignApps = txn.appForeignApps.slice();
          txn.appForeignApps.forEach((foreignAppIndex) => {
            if (!Number.isSafeInteger(foreignAppIndex) || foreignAppIndex < 0)
              throw Error("each foreign application index must be a positive number and smaller than 2^53-1");
          });
        }
        if (txn.appForeignAssets !== void 0) {
          if (!Array.isArray(txn.appForeignAssets))
            throw Error("appForeignAssets must be an Array of integers.");
          txn.appForeignAssets = txn.appForeignAssets.slice();
          txn.appForeignAssets.forEach((foreignAssetIndex) => {
            if (!Number.isSafeInteger(foreignAssetIndex) || foreignAssetIndex < 0)
              throw Error("each foreign asset index must be a positive number and smaller than 2^53-1");
          });
        }
        if (txn.assetMetadataHash !== void 0 && txn.assetMetadataHash.length !== 0) {
          if (typeof txn.assetMetadataHash === "string") {
            txn.assetMetadataHash = new Uint8Array(Buffer.from(txn.assetMetadataHash));
          }
          if (txn.assetMetadataHash.constructor !== Uint8Array || txn.assetMetadataHash.byteLength !== ASSET_METADATA_HASH_LENGTH) {
            throw Error(`assetMetadataHash must be a ${ASSET_METADATA_HASH_LENGTH} byte Uint8Array or string.`);
          }
          if (txn.assetMetadataHash.every((value) => value === 0)) {
            txn.assetMetadataHash = void 0;
          }
        } else {
          txn.assetMetadataHash = void 0;
        }
        if (txn.note !== void 0) {
          if (txn.note.constructor !== Uint8Array)
            throw Error("note must be a Uint8Array.");
        } else {
          txn.note = new Uint8Array(0);
        }
        if (txn.lease !== void 0) {
          if (txn.lease.constructor !== Uint8Array)
            throw Error("lease must be a Uint8Array.");
          if (txn.lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
            throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
          if (txn.lease.every((value) => value === 0)) {
            txn.lease = new Uint8Array(0);
          }
        } else {
          txn.lease = new Uint8Array(0);
        }
        txn.voteKey = getKeyregKey(txn.voteKey, "voteKey", KEYREG_VOTE_KEY_LENGTH);
        txn.selectionKey = getKeyregKey(txn.selectionKey, "selectionKey", KEYREG_SELECTION_KEY_LENGTH);
        txn.stateProofKey = getKeyregKey(txn.stateProofKey, "stateProofKey", KEYREG_STATE_PROOF_KEY_LENGTH);
        if (txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.voteFirst || txn.stateProofKey || txn.voteLast || txn.voteKeyDilution)) {
          throw new Error("nonParticipation is true but participation params are present.");
        }
        if (!txn.nonParticipation && (txn.voteKey || txn.selectionKey || txn.stateProofKey || txn.voteFirst || txn.voteLast || txn.voteKeyDilution) && !(txn.voteKey && txn.selectionKey && txn.voteFirst && txn.voteLast && txn.voteKeyDilution)) {
          throw new Error("online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution");
        }
        delete txn.suggestedParams;
        Object.assign(this, utils.removeUndefinedProperties(txn));
        if (!txn.flatFee) {
          this.fee *= this.estimateSize();
          if (this.fee < exports2.ALGORAND_MIN_TX_FEE) {
            this.fee = exports2.ALGORAND_MIN_TX_FEE;
          }
        }
        this.group = void 0;
      }
      get_obj_for_encoding() {
        if (this.type === "pay") {
          const txn = {
            amt: this.amount,
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: "pay",
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group
          };
          if (this.closeRemainderTo !== void 0 && address.encodeAddress(this.closeRemainderTo.publicKey) !== address.ALGORAND_ZERO_ADDRESS_STRING) {
            txn.close = Buffer.from(this.closeRemainderTo.publicKey);
          }
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          if (this.to !== void 0)
            txn.rcv = Buffer.from(this.to.publicKey);
          if (!txn.note.length)
            delete txn.note;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (txn.grp === void 0)
            delete txn.grp;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.rekey)
            delete txn.rekey;
          return txn;
        }
        if (this.type === "keyreg") {
          const txn = {
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group,
            votekey: this.voteKey,
            selkey: this.selectionKey,
            sprfkey: this.stateProofKey,
            votefst: this.voteFirst,
            votelst: this.voteLast,
            votekd: this.voteKeyDilution
          };
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (txn.grp === void 0)
            delete txn.grp;
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          if (this.nonParticipation) {
            txn.nonpart = true;
          }
          if (!txn.selkey)
            delete txn.selkey;
          if (!txn.votekey)
            delete txn.votekey;
          if (!txn.sprfkey)
            delete txn.sprfkey;
          if (!txn.votefst)
            delete txn.votefst;
          if (!txn.votelst)
            delete txn.votelst;
          if (!txn.votekd)
            delete txn.votekd;
          return txn;
        }
        if (this.type === "acfg") {
          const txn = {
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group,
            caid: this.assetIndex,
            apar: {
              t: this.assetTotal,
              df: this.assetDefaultFrozen,
              dc: this.assetDecimals
            }
          };
          if (this.assetManager !== void 0)
            txn.apar.m = Buffer.from(this.assetManager.publicKey);
          if (this.assetReserve !== void 0)
            txn.apar.r = Buffer.from(this.assetReserve.publicKey);
          if (this.assetFreeze !== void 0)
            txn.apar.f = Buffer.from(this.assetFreeze.publicKey);
          if (this.assetClawback !== void 0)
            txn.apar.c = Buffer.from(this.assetClawback.publicKey);
          if (this.assetName !== void 0)
            txn.apar.an = this.assetName;
          if (this.assetUnitName !== void 0)
            txn.apar.un = this.assetUnitName;
          if (this.assetURL !== void 0)
            txn.apar.au = this.assetURL;
          if (this.assetMetadataHash !== void 0)
            txn.apar.am = Buffer.from(this.assetMetadataHash);
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          if (!txn.caid)
            delete txn.caid;
          if (!txn.apar.t && !txn.apar.un && !txn.apar.an && !txn.apar.df && !txn.apar.m && !txn.apar.r && !txn.apar.f && !txn.apar.c && !txn.apar.au && !txn.apar.am && !txn.apar.dc) {
            delete txn.apar;
          } else {
            if (!txn.apar.t)
              delete txn.apar.t;
            if (!txn.apar.dc)
              delete txn.apar.dc;
            if (!txn.apar.un)
              delete txn.apar.un;
            if (!txn.apar.an)
              delete txn.apar.an;
            if (!txn.apar.df)
              delete txn.apar.df;
            if (!txn.apar.m)
              delete txn.apar.m;
            if (!txn.apar.r)
              delete txn.apar.r;
            if (!txn.apar.f)
              delete txn.apar.f;
            if (!txn.apar.c)
              delete txn.apar.c;
            if (!txn.apar.au)
              delete txn.apar.au;
            if (!txn.apar.am)
              delete txn.apar.am;
          }
          if (txn.grp === void 0)
            delete txn.grp;
          return txn;
        }
        if (this.type === "axfer") {
          const txn = {
            aamt: this.amount,
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            arcv: Buffer.from(this.to.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group,
            xaid: this.assetIndex
          };
          if (this.closeRemainderTo !== void 0)
            txn.aclose = Buffer.from(this.closeRemainderTo.publicKey);
          if (this.assetRevocationTarget !== void 0)
            txn.asnd = Buffer.from(this.assetRevocationTarget.publicKey);
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.aamt)
            delete txn.aamt;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (txn.grp === void 0)
            delete txn.grp;
          if (!txn.aclose)
            delete txn.aclose;
          if (!txn.asnd)
            delete txn.asnd;
          if (!txn.rekey)
            delete txn.rekey;
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          return txn;
        }
        if (this.type === "afrz") {
          const txn = {
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group,
            faid: this.assetIndex,
            afrz: this.freezeState
          };
          if (this.freezeAccount !== void 0)
            txn.fadd = Buffer.from(this.freezeAccount.publicKey);
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (!txn.afrz)
            delete txn.afrz;
          if (txn.grp === void 0)
            delete txn.grp;
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          return txn;
        }
        if (this.type === "appl") {
          const txn = {
            fee: this.fee,
            fv: this.firstRound,
            lv: this.lastRound,
            note: Buffer.from(this.note),
            snd: Buffer.from(this.from.publicKey),
            type: this.type,
            gen: this.genesisID,
            gh: this.genesisHash,
            lx: Buffer.from(this.lease),
            grp: this.group,
            apid: this.appIndex,
            apan: this.appOnComplete,
            apls: {
              nui: this.appLocalInts,
              nbs: this.appLocalByteSlices
            },
            apgs: {
              nui: this.appGlobalInts,
              nbs: this.appGlobalByteSlices
            },
            apfa: this.appForeignApps,
            apas: this.appForeignAssets,
            apep: this.extraPages
          };
          if (this.reKeyTo !== void 0) {
            txn.rekey = Buffer.from(this.reKeyTo.publicKey);
          }
          if (this.appApprovalProgram !== void 0) {
            txn.apap = Buffer.from(this.appApprovalProgram);
          }
          if (this.appClearProgram !== void 0) {
            txn.apsu = Buffer.from(this.appClearProgram);
          }
          if (this.appArgs !== void 0) {
            txn.apaa = this.appArgs.map((arg) => Buffer.from(arg));
          }
          if (this.appAccounts !== void 0) {
            txn.apat = this.appAccounts.map((decodedAddress) => Buffer.from(decodedAddress.publicKey));
          }
          if (!txn.note.length)
            delete txn.note;
          if (!txn.lx.length)
            delete txn.lx;
          if (!txn.amt)
            delete txn.amt;
          if (!txn.fee)
            delete txn.fee;
          if (!txn.fv)
            delete txn.fv;
          if (!txn.gen)
            delete txn.gen;
          if (!txn.apid)
            delete txn.apid;
          if (!txn.apls.nui)
            delete txn.apls.nui;
          if (!txn.apls.nbs)
            delete txn.apls.nbs;
          if (!txn.apls.nui && !txn.apls.nbs)
            delete txn.apls;
          if (!txn.apgs.nui)
            delete txn.apgs.nui;
          if (!txn.apgs.nbs)
            delete txn.apgs.nbs;
          if (!txn.apaa || !txn.apaa.length)
            delete txn.apaa;
          if (!txn.apgs.nui && !txn.apgs.nbs)
            delete txn.apgs;
          if (!txn.apap)
            delete txn.apap;
          if (!txn.apsu)
            delete txn.apsu;
          if (!txn.apan)
            delete txn.apan;
          if (!txn.apfa || !txn.apfa.length)
            delete txn.apfa;
          if (!txn.apas || !txn.apas.length)
            delete txn.apas;
          if (!txn.apat || !txn.apat.length)
            delete txn.apat;
          if (!txn.apep)
            delete txn.apep;
          if (txn.grp === void 0)
            delete txn.grp;
          return txn;
        }
        return void 0;
      }
      static from_obj_for_encoding(txnForEnc) {
        const txn = Object.create(this.prototype);
        txn.name = "Transaction";
        txn.tag = Buffer.from("TX");
        txn.genesisID = txnForEnc.gen;
        txn.genesisHash = Buffer.from(txnForEnc.gh);
        if (!base_1.isTransactionType(txnForEnc.type)) {
          throw new Error(`Unrecognized transaction type: ${txnForEnc.type}`);
        }
        txn.type = txnForEnc.type;
        txn.fee = txnForEnc.fee;
        txn.firstRound = txnForEnc.fv;
        txn.lastRound = txnForEnc.lv;
        txn.note = new Uint8Array(txnForEnc.note);
        txn.lease = new Uint8Array(txnForEnc.lx);
        txn.from = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.snd)));
        if (txnForEnc.grp !== void 0)
          txn.group = Buffer.from(txnForEnc.grp);
        if (txnForEnc.rekey !== void 0)
          txn.reKeyTo = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.rekey)));
        if (txnForEnc.type === "pay") {
          txn.amount = txnForEnc.amt;
          txn.to = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.rcv)));
          if (txnForEnc.close !== void 0)
            txn.closeRemainderTo = address.decodeAddress(address.encodeAddress(txnForEnc.close));
        } else if (txnForEnc.type === "keyreg") {
          if (txnForEnc.votekey !== void 0) {
            txn.voteKey = Buffer.from(txnForEnc.votekey);
          }
          if (txnForEnc.selkey !== void 0) {
            txn.selectionKey = Buffer.from(txnForEnc.selkey);
          }
          if (txnForEnc.sprfkey !== void 0) {
            txn.stateProofKey = Buffer.from(txnForEnc.sprfkey);
          }
          if (txnForEnc.votekd !== void 0) {
            txn.voteKeyDilution = txnForEnc.votekd;
          }
          if (txnForEnc.votefst !== void 0) {
            txn.voteFirst = txnForEnc.votefst;
          }
          if (txnForEnc.votelst !== void 0) {
            txn.voteLast = txnForEnc.votelst;
          }
          if (txnForEnc.nonpart !== void 0) {
            txn.nonParticipation = txnForEnc.nonpart;
          }
        } else if (txnForEnc.type === "acfg") {
          if (txnForEnc.caid !== void 0) {
            txn.assetIndex = txnForEnc.caid;
          }
          if (txnForEnc.apar !== void 0) {
            txn.assetTotal = txnForEnc.apar.t;
            txn.assetDefaultFrozen = txnForEnc.apar.df;
            if (txnForEnc.apar.dc !== void 0)
              txn.assetDecimals = txnForEnc.apar.dc;
            if (txnForEnc.apar.m !== void 0)
              txn.assetManager = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.apar.m)));
            if (txnForEnc.apar.r !== void 0)
              txn.assetReserve = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.apar.r)));
            if (txnForEnc.apar.f !== void 0)
              txn.assetFreeze = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.apar.f)));
            if (txnForEnc.apar.c !== void 0)
              txn.assetClawback = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.apar.c)));
            if (txnForEnc.apar.un !== void 0)
              txn.assetUnitName = txnForEnc.apar.un;
            if (txnForEnc.apar.an !== void 0)
              txn.assetName = txnForEnc.apar.an;
            if (txnForEnc.apar.au !== void 0)
              txn.assetURL = txnForEnc.apar.au;
            if (txnForEnc.apar.am !== void 0)
              txn.assetMetadataHash = txnForEnc.apar.am;
          }
        } else if (txnForEnc.type === "axfer") {
          if (txnForEnc.xaid !== void 0) {
            txn.assetIndex = txnForEnc.xaid;
          }
          if (txnForEnc.aamt !== void 0)
            txn.amount = txnForEnc.aamt;
          if (txnForEnc.aclose !== void 0) {
            txn.closeRemainderTo = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.aclose)));
          }
          if (txnForEnc.asnd !== void 0) {
            txn.assetRevocationTarget = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.asnd)));
          }
          txn.to = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.arcv)));
        } else if (txnForEnc.type === "afrz") {
          if (txnForEnc.afrz !== void 0) {
            txn.freezeState = txnForEnc.afrz;
          }
          if (txnForEnc.faid !== void 0) {
            txn.assetIndex = txnForEnc.faid;
          }
          txn.freezeAccount = address.decodeAddress(address.encodeAddress(new Uint8Array(txnForEnc.fadd)));
        } else if (txnForEnc.type === "appl") {
          if (txnForEnc.apid !== void 0) {
            txn.appIndex = txnForEnc.apid;
          }
          if (txnForEnc.apan !== void 0) {
            txn.appOnComplete = txnForEnc.apan;
          }
          if (txnForEnc.apls !== void 0) {
            if (txnForEnc.apls.nui !== void 0)
              txn.appLocalInts = txnForEnc.apls.nui;
            if (txnForEnc.apls.nbs !== void 0)
              txn.appLocalByteSlices = txnForEnc.apls.nbs;
          }
          if (txnForEnc.apgs !== void 0) {
            if (txnForEnc.apgs.nui !== void 0)
              txn.appGlobalInts = txnForEnc.apgs.nui;
            if (txnForEnc.apgs.nbs !== void 0)
              txn.appGlobalByteSlices = txnForEnc.apgs.nbs;
          }
          if (txnForEnc.apep !== void 0) {
            txn.extraPages = txnForEnc.apep;
          }
          if (txnForEnc.apap !== void 0) {
            txn.appApprovalProgram = new Uint8Array(txnForEnc.apap);
          }
          if (txnForEnc.apsu !== void 0) {
            txn.appClearProgram = new Uint8Array(txnForEnc.apsu);
          }
          if (txnForEnc.apaa !== void 0) {
            txn.appArgs = txnForEnc.apaa.map((arg) => new Uint8Array(arg));
          }
          if (txnForEnc.apat !== void 0) {
            txn.appAccounts = txnForEnc.apat.map((addressBytes) => address.decodeAddress(address.encodeAddress(new Uint8Array(addressBytes))));
          }
          if (txnForEnc.apfa !== void 0) {
            txn.appForeignApps = txnForEnc.apfa;
          }
          if (txnForEnc.apas !== void 0) {
            txn.appForeignAssets = txnForEnc.apas;
          }
        }
        return txn;
      }
      estimateSize() {
        return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
      }
      bytesToSign() {
        const encodedMsg = this.toByte();
        return Buffer.from(utils.concatArrays(this.tag, encodedMsg));
      }
      toByte() {
        return encoding.encode(this.get_obj_for_encoding());
      }
      rawSignTxn(sk) {
        const toBeSigned = this.bytesToSign();
        const sig = nacl.sign(toBeSigned, sk);
        return Buffer.from(sig);
      }
      signTxn(sk) {
        const sTxn = {
          sig: this.rawSignTxn(sk),
          txn: this.get_obj_for_encoding()
        };
        const keypair = nacl.keyPairFromSecretKey(sk);
        const pubKeyFromSk = keypair.publicKey;
        if (address.encodeAddress(pubKeyFromSk) !== address.encodeAddress(this.from.publicKey)) {
          sTxn.sgnr = Buffer.from(pubKeyFromSk);
        }
        return new Uint8Array(encoding.encode(sTxn));
      }
      rawTxID() {
        const enMsg = this.toByte();
        const gh = Buffer.from(utils.concatArrays(this.tag, enMsg));
        return Buffer.from(nacl.genericHash(gh));
      }
      txID() {
        const hash = this.rawTxID();
        return hi_base32_1.default.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
      }
      addLease(lease, feePerByte = 0) {
        let mutableLease;
        if (lease !== void 0) {
          if (lease.constructor !== Uint8Array)
            throw Error("lease must be a Uint8Array.");
          if (lease.length !== ALGORAND_TRANSACTION_LEASE_LENGTH)
            throw Error(`lease must be of length ${ALGORAND_TRANSACTION_LEASE_LENGTH.toString()}.`);
          mutableLease = new Uint8Array(lease);
        } else {
          mutableLease = new Uint8Array(0);
        }
        this.lease = mutableLease;
        if (feePerByte !== 0) {
          this.fee += (ALGORAND_TRANSACTION_LEASE_LABEL_LENGTH + ALGORAND_TRANSACTION_LEASE_LENGTH) * feePerByte;
        }
      }
      addRekey(reKeyTo, feePerByte = 0) {
        if (reKeyTo !== void 0) {
          this.reKeyTo = address.decodeAddress(reKeyTo);
        }
        if (feePerByte !== 0) {
          this.fee += (ALGORAND_TRANSACTION_REKEY_LABEL_LENGTH + ALGORAND_TRANSACTION_ADDRESS_LENGTH) * feePerByte;
        }
      }
      _getDictForDisplay() {
        const forPrinting = {
          ...this
        };
        forPrinting.tag = forPrinting.tag.toString();
        forPrinting.from = address.encodeAddress(forPrinting.from.publicKey);
        if (forPrinting.to !== void 0)
          forPrinting.to = address.encodeAddress(forPrinting.to.publicKey);
        if (forPrinting.freezeAccount !== void 0)
          forPrinting.freezeAccount = address.encodeAddress(forPrinting.freezeAccount.publicKey);
        if (forPrinting.closeRemainderTo !== void 0)
          forPrinting.closeRemainderTo = address.encodeAddress(forPrinting.closeRemainderTo.publicKey);
        if (forPrinting.assetManager !== void 0)
          forPrinting.assetManager = address.encodeAddress(forPrinting.assetManager.publicKey);
        if (forPrinting.assetReserve !== void 0)
          forPrinting.assetReserve = address.encodeAddress(forPrinting.assetReserve.publicKey);
        if (forPrinting.assetFreeze !== void 0)
          forPrinting.assetFreeze = address.encodeAddress(forPrinting.assetFreeze.publicKey);
        if (forPrinting.assetClawback !== void 0)
          forPrinting.assetClawback = address.encodeAddress(forPrinting.assetClawback.publicKey);
        if (forPrinting.assetRevocationTarget !== void 0)
          forPrinting.assetRevocationTarget = address.encodeAddress(forPrinting.assetRevocationTarget.publicKey);
        if (forPrinting.reKeyTo !== void 0)
          forPrinting.reKeyTo = address.encodeAddress(forPrinting.reKeyTo.publicKey);
        forPrinting.genesisHash = forPrinting.genesisHash.toString("base64");
        return forPrinting;
      }
      prettyPrint() {
        console.log(this._getDictForDisplay());
      }
      toString() {
        return JSON.stringify(this._getDictForDisplay());
      }
    };
    exports2.Transaction = Transaction;
    function encodeUnsignedTransaction(transactionObject) {
      const objToEncode = transactionObject.get_obj_for_encoding();
      return encoding.encode(objToEncode);
    }
    exports2.encodeUnsignedTransaction = encodeUnsignedTransaction;
    function decodeUnsignedTransaction(transactionBuffer) {
      const partlyDecodedObject = encoding.decode(transactionBuffer);
      return Transaction.from_obj_for_encoding(partlyDecodedObject);
    }
    exports2.decodeUnsignedTransaction = decodeUnsignedTransaction;
    function decodeSignedTransaction(transactionBuffer) {
      const stxnDecoded = encoding.decode(transactionBuffer);
      const stxn = {
        ...stxnDecoded,
        txn: Transaction.from_obj_for_encoding(stxnDecoded.txn)
      };
      return stxn;
    }
    exports2.decodeSignedTransaction = decodeSignedTransaction;
    function instantiateTxnIfNeeded(transactionLike) {
      return transactionLike instanceof Transaction ? transactionLike : new Transaction(transactionLike);
    }
    exports2.instantiateTxnIfNeeded = instantiateTxnIfNeeded;
    exports2.default = Transaction;
  }
});

// node_modules/algosdk/dist/cjs/src/group.js
var require_group = __commonJS({
  "node_modules/algosdk/dist/cjs/src/group.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignGroupID = exports2.computeGroupID = exports2.TxGroup = void 0;
    var txnBuilder = __importStar(require_transaction());
    var nacl = __importStar(require_naclWrappers());
    var encoding = __importStar(require_encoding());
    var address = __importStar(require_address());
    var utils = __importStar(require_utils());
    var ALGORAND_MAX_TX_GROUP_SIZE = 16;
    var TxGroup = class {
      constructor(hashes) {
        this.name = "Transaction group";
        this.tag = Buffer.from("TG");
        if (hashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {
          const errorMsg = `${hashes.length.toString()} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE.toString()}`;
          throw Error(errorMsg);
        }
        this.txGroupHashes = hashes;
      }
      get_obj_for_encoding() {
        const txgroup = {
          txlist: this.txGroupHashes
        };
        return txgroup;
      }
      static from_obj_for_encoding(txgroupForEnc) {
        const txn = Object.create(this.prototype);
        txn.name = "Transaction group";
        txn.tag = Buffer.from("TG");
        txn.txGroupHashes = [];
        for (const hash of txgroupForEnc.txlist) {
          txn.txGroupHashes.push(Buffer.from(hash));
        }
        return txn;
      }
      toByte() {
        return encoding.encode(this.get_obj_for_encoding());
      }
    };
    exports2.TxGroup = TxGroup;
    function computeGroupID(txns) {
      const hashes = [];
      for (const txn of txns) {
        const tx = txnBuilder.instantiateTxnIfNeeded(txn);
        hashes.push(tx.rawTxID());
      }
      const txgroup = new TxGroup(hashes);
      const bytes = txgroup.toByte();
      const toBeHashed = Buffer.from(utils.concatArrays(txgroup.tag, bytes));
      const gid = nacl.genericHash(toBeHashed);
      return Buffer.from(gid);
    }
    exports2.computeGroupID = computeGroupID;
    function assignGroupID(txns, from) {
      const gid = computeGroupID(txns);
      const result = [];
      for (const txn of txns) {
        const tx = txnBuilder.instantiateTxnIfNeeded(txn);
        if (!from || address.encodeAddress(tx.from.publicKey) === from) {
          tx.group = gid;
          result.push(tx);
        }
      }
      return result;
    }
    exports2.assignGroupID = assignGroupID;
    exports2.default = TxGroup;
  }
});

// node_modules/algosdk/dist/cjs/src/logic/langspec.json
var require_langspec = __commonJS({
  "node_modules/algosdk/dist/cjs/src/logic/langspec.json"(exports2, module2) {
    module2.exports = {
      EvalMaxVersion: 6,
      LogicSigVersion: 5,
      Ops: [
        {
          Opcode: 0,
          Name: "err",
          Cost: 1,
          Size: 1,
          Doc: "Fail immediately.",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 1,
          Name: "sha256",
          Args: "B",
          Returns: "B",
          Cost: 35,
          Size: 1,
          Doc: "SHA256 hash of value A, yields [32]byte",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 2,
          Name: "keccak256",
          Args: "B",
          Returns: "B",
          Cost: 130,
          Size: 1,
          Doc: "Keccak256 hash of value A, yields [32]byte",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 3,
          Name: "sha512_256",
          Args: "B",
          Returns: "B",
          Cost: 45,
          Size: 1,
          Doc: "SHA512_256 hash of value A, yields [32]byte",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 4,
          Name: "ed25519verify",
          Args: "BBB",
          Returns: "U",
          Cost: 1900,
          Size: 1,
          Doc: 'for (data A, signature B, pubkey C) verify the signature of ("ProgData" || program_hash || data) against the pubkey => {0 or 1}',
          DocExtra: "The 32 byte public key is the last element on the stack, preceded by the 64 byte signature at the second-to-last element on the stack, preceded by the data which was signed at the third-to-last element on the stack.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 5,
          Name: "ecdsa_verify",
          Args: "BBBBB",
          Returns: "U",
          Cost: 1700,
          Size: 2,
          Doc: "for (data A, signature B, C and pubkey D, E) verify the signature of the data against the pubkey => {0 or 1}",
          DocExtra: "The 32 byte Y-component of a public key is the last element on the stack, preceded by X-component of a pubkey, preceded by S and R components of a signature, preceded by the data that is fifth element on the stack. All values are big-endian encoded. The signed data must be 32 bytes long, and signatures in lower-S form are only accepted.",
          ImmediateNote: "{uint8 curve index}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 6,
          Name: "ecdsa_pk_decompress",
          Args: "B",
          Returns: "BB",
          Cost: 650,
          Size: 2,
          Doc: "decompress pubkey A into components X, Y",
          DocExtra: "The 33 byte public key in a compressed form to be decompressed into X and Y (top) components. All values are big-endian encoded.",
          ImmediateNote: "{uint8 curve index}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 7,
          Name: "ecdsa_pk_recover",
          Args: "BUBB",
          Returns: "BB",
          Cost: 2e3,
          Size: 2,
          Doc: "for (data A, recovery id B, signature C, D) recover a public key",
          DocExtra: "S (top) and R elements of a signature, recovery id and data (bottom) are expected on the stack and used to deriver a public key. All values are big-endian encoded. The signed data must be 32 bytes long.",
          ImmediateNote: "{uint8 curve index}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 8,
          Name: "+",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A plus B. Fail on overflow.",
          DocExtra: "Overflow is an error condition which halts execution and fails the transaction. Full precision is available from `addw`.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 9,
          Name: "-",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A minus B. Fail if B > A.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 10,
          Name: "/",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A divided by B (truncated division). Fail if B == 0.",
          DocExtra: "`divmodw` is available to divide the two-element values produced by `mulw` and `addw`.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 11,
          Name: "*",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A times B. Fail on overflow.",
          DocExtra: "Overflow is an error condition which halts execution and fails the transaction. Full precision is available from `mulw`.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 12,
          Name: "<",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A less than B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 13,
          Name: ">",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A greater than B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 14,
          Name: "<=",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A less than or equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 15,
          Name: ">=",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A greater than or equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 16,
          Name: "&&",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is not zero and B is not zero => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 17,
          Name: "||",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is not zero or B is not zero => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 18,
          Name: "==",
          Args: "..",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 19,
          Name: "!=",
          Args: "..",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A is not equal to B => {0 or 1}",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 20,
          Name: "!",
          Args: "U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A == 0 yields 1; else 0",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 21,
          Name: "len",
          Args: "B",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "yields length of byte value A",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 22,
          Name: "itob",
          Args: "U",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "converts uint64 A to big endian bytes",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 23,
          Name: "btoi",
          Args: "B",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "converts bytes A as big endian to uint64",
          DocExtra: "`btoi` fails if the input is longer than 8 bytes.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 24,
          Name: "%",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A modulo B. Fail if B == 0.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 25,
          Name: "|",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A bitwise-or B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 26,
          Name: "&",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A bitwise-and B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 27,
          Name: "^",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A bitwise-xor B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 28,
          Name: "~",
          Args: "U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "bitwise invert value A",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 29,
          Name: "mulw",
          Args: "UU",
          Returns: "UU",
          Cost: 1,
          Size: 1,
          Doc: "A times B as a 128-bit result in two uint64s. X is the high 64 bits, Y is the low",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 30,
          Name: "addw",
          Args: "UU",
          Returns: "UU",
          Cost: 1,
          Size: 1,
          Doc: "A plus B as a 128-bit result. X is the carry-bit, Y is the low-order 64 bits.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 31,
          Name: "divmodw",
          Args: "UUUU",
          Returns: "UUUU",
          Cost: 20,
          Size: 1,
          Doc: "W,X = (A,B / C,D); Y,Z = (A,B modulo C,D)",
          DocExtra: "The notation J,K indicates that two uint64 values J and K are interpreted as a uint128 value, with J as the high uint64 and K the low.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 32,
          Name: "intcblock",
          Cost: 1,
          Size: 0,
          Doc: "prepare block of uint64 constants for use by intc",
          DocExtra: "`intcblock` loads following program bytes into an array of integer constants in the evaluator. These integer constants can be referred to by `intc` and `intc_*` which will push the value onto the stack. Subsequent calls to `intcblock` reset and replace the integer constants available to the script.",
          ImmediateNote: "{varuint length} [{varuint value}, ...]",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 33,
          Name: "intc",
          Returns: "U",
          Cost: 1,
          Size: 2,
          Doc: "Ith constant from intcblock",
          ImmediateNote: "{uint8 int constant index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 34,
          Name: "intc_0",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "constant 0 from intcblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 35,
          Name: "intc_1",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "constant 1 from intcblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 36,
          Name: "intc_2",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "constant 2 from intcblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 37,
          Name: "intc_3",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "constant 3 from intcblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 38,
          Name: "bytecblock",
          Cost: 1,
          Size: 0,
          Doc: "prepare block of byte-array constants for use by bytec",
          DocExtra: "`bytecblock` loads the following program bytes into an array of byte-array constants in the evaluator. These constants can be referred to by `bytec` and `bytec_*` which will push the value onto the stack. Subsequent calls to `bytecblock` reset and replace the bytes constants available to the script.",
          ImmediateNote: "{varuint length} [({varuint value length} bytes), ...]",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 39,
          Name: "bytec",
          Returns: "B",
          Cost: 1,
          Size: 2,
          Doc: "Ith constant from bytecblock",
          ImmediateNote: "{uint8 byte constant index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 40,
          Name: "bytec_0",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "constant 0 from bytecblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 41,
          Name: "bytec_1",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "constant 1 from bytecblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 42,
          Name: "bytec_2",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "constant 2 from bytecblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 43,
          Name: "bytec_3",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "constant 3 from bytecblock",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 44,
          Name: "arg",
          Returns: "B",
          Cost: 1,
          Size: 2,
          Doc: "Nth LogicSig argument",
          ImmediateNote: "{uint8 arg index N}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 45,
          Name: "arg_0",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "LogicSig argument 0",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 46,
          Name: "arg_1",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "LogicSig argument 1",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 47,
          Name: "arg_2",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "LogicSig argument 2",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 48,
          Name: "arg_3",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "LogicSig argument 3",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 49,
          Name: "txn",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "field F of current transaction",
          DocExtra: "FirstValidTime causes the program to fail. The field is reserved for future use.",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 50,
          Name: "global",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "global field F",
          ImmediateNote: "{uint8 global field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 51,
          Name: "gtxn",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "field F of the Tth transaction in the current group",
          DocExtra: "for notes on transaction fields available, see `txn`. If this transaction is _i_ in the group, `gtxn i field` is equivalent to `txn field`.",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 52,
          Name: "load",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "Ith scratch space value. All scratch spaces are 0 at program start.",
          ImmediateNote: "{uint8 position in scratch space to load from}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 53,
          Name: "store",
          Args: ".",
          Cost: 1,
          Size: 2,
          Doc: "store A to the Ith scratch space",
          ImmediateNote: "{uint8 position in scratch space to store to}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 54,
          Name: "txna",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ith value of the array field F of the current transaction",
          ImmediateNote: "{uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 55,
          Name: "gtxna",
          Returns: ".",
          Cost: 1,
          Size: 4,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ith value of the array field F from the Tth transaction in the current group",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 56,
          Name: "gtxns",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "field F of the Ath transaction in the current group",
          DocExtra: "for notes on transaction fields available, see `txn`. If top of stack is _i_, `gtxns field` is equivalent to `gtxn _i_ field`. gtxns exists so that _i_ can be calculated, often based on the index of the current transaction.",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 57,
          Name: "gtxnsa",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ith value of the array field F from the Ath transaction in the current group",
          ImmediateNote: "{uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 58,
          Name: "gload",
          Returns: ".",
          Cost: 1,
          Size: 3,
          Doc: "Ith scratch space value of the Tth transaction in the current group",
          DocExtra: "`gload` fails unless the requested transaction is an ApplicationCall and T < GroupIndex.",
          ImmediateNote: "{uint8 transaction group index} {uint8 position in scratch space to load from}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 59,
          Name: "gloads",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "Ith scratch space value of the Ath transaction in the current group",
          DocExtra: "`gloads` fails unless the requested transaction is an ApplicationCall and A < GroupIndex.",
          ImmediateNote: "{uint8 position in scratch space to load from}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 60,
          Name: "gaid",
          Returns: "U",
          Cost: 1,
          Size: 2,
          Doc: "ID of the asset or application created in the Tth transaction of the current group",
          DocExtra: "`gaid` fails unless the requested transaction created an asset or application and T < GroupIndex.",
          ImmediateNote: "{uint8 transaction group index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 61,
          Name: "gaids",
          Args: "U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "ID of the asset or application created in the Ath transaction of the current group",
          DocExtra: "`gaids` fails unless the requested transaction created an asset or application and A < GroupIndex.",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 62,
          Name: "loads",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "Ath scratch space value.  All scratch spaces are 0 at program start.",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 63,
          Name: "stores",
          Args: "U.",
          Cost: 1,
          Size: 1,
          Doc: "store B to the Ath scratch space",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 64,
          Name: "bnz",
          Args: "U",
          Cost: 1,
          Size: 3,
          Doc: "branch to TARGET if value A is not zero",
          DocExtra: "The `bnz` instruction opcode 0x40 is followed by two immediate data bytes which are a high byte first and low byte second which together form a 16 bit offset which the instruction may branch to. For a bnz instruction at `pc`, if the last element of the stack is not zero then branch to instruction at `pc + 3 + N`, else proceed to next instruction at `pc + 3`. Branch targets must be aligned instructions. (e.g. Branching to the second byte of a 2 byte op will be rejected.) Starting at v4, the offset is treated as a signed 16 bit integer allowing for backward branches and looping. In prior version (v1 to v3), branch offsets are limited to forward branches only, 0-0x7fff.\n\nAt v2 it became allowed to branch to the end of the program exactly after the last instruction: bnz to byte N (with 0-indexing) was illegal for a TEAL program with N bytes before v2, and is legal after it. This change eliminates the need for a last instruction of no-op as a branch target at the end. (Branching beyond the end--in other words, to a byte larger than N--is still illegal and will cause the program to fail.)",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 65,
          Name: "bz",
          Args: "U",
          Cost: 1,
          Size: 3,
          Doc: "branch to TARGET if value A is zero",
          DocExtra: "See `bnz` for details on how branches work. `bz` inverts the behavior of `bnz`.",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 66,
          Name: "b",
          Cost: 1,
          Size: 3,
          Doc: "branch unconditionally to TARGET",
          DocExtra: "See `bnz` for details on how branches work. `b` always jumps to the offset.",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 67,
          Name: "return",
          Args: "U",
          Cost: 1,
          Size: 1,
          Doc: "use A as success value; end",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 68,
          Name: "assert",
          Args: "U",
          Cost: 1,
          Size: 1,
          Doc: "immediately fail unless A is a non-zero number",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 72,
          Name: "pop",
          Args: ".",
          Cost: 1,
          Size: 1,
          Doc: "discard A",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 73,
          Name: "dup",
          Args: ".",
          Returns: "..",
          Cost: 1,
          Size: 1,
          Doc: "duplicate A",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 74,
          Name: "dup2",
          Args: "..",
          Returns: "....",
          Cost: 1,
          Size: 1,
          Doc: "duplicate A and B",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 75,
          Name: "dig",
          Args: ".",
          Returns: "..",
          Cost: 1,
          Size: 2,
          Doc: "Nth value from the top of the stack. dig 0 is equivalent to dup",
          ImmediateNote: "{uint8 depth}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 76,
          Name: "swap",
          Args: "..",
          Returns: "..",
          Cost: 1,
          Size: 1,
          Doc: "swaps A and B on stack",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 77,
          Name: "select",
          Args: "..U",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "selects one of two values based on top-of-stack: B if C != 0, else A",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 78,
          Name: "cover",
          Args: ".",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "remove top of stack, and place it deeper in the stack such that N elements are above it. Fails if stack depth <= N.",
          ImmediateNote: "{uint8 depth}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 79,
          Name: "uncover",
          Args: ".",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "remove the value at depth N in the stack and shift above items down so the Nth deep value is on top of the stack. Fails if stack depth <= N.",
          ImmediateNote: "{uint8 depth}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 80,
          Name: "concat",
          Args: "BB",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "join A and B",
          DocExtra: "`concat` fails if the result would be greater than 4096 bytes.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 81,
          Name: "substring",
          Args: "B",
          Returns: "B",
          Cost: 1,
          Size: 3,
          Doc: "A range of bytes from A starting at S up to but not including E. If E < S, or either is larger than the array length, the program fails",
          ImmediateNote: "{uint8 start position} {uint8 end position}",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 82,
          Name: "substring3",
          Args: "BUU",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "A range of bytes from A starting at B up to but not including C. If C < B, or either is larger than the array length, the program fails",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 83,
          Name: "getbit",
          Args: ".U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "Bth bit of (byte-array or integer) A.",
          DocExtra: "see explanation of bit ordering in setbit",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 84,
          Name: "setbit",
          Args: ".UU",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "Copy of (byte-array or integer) A, with the Bth bit set to (0 or 1) C",
          DocExtra: "When A is a uint64, index 0 is the least significant bit. Setting bit 3 to 1 on the integer 0 yields 8, or 2^3. When A is a byte array, index 0 is the leftmost bit of the leftmost byte. Setting bits 0 through 11 to 1 in a 4-byte-array of 0s yields the byte array 0xfff00000. Setting bit 3 to 1 on the 1-byte-array 0x00 yields the byte array 0x10.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 85,
          Name: "getbyte",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "Bth byte of A, as an integer",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 86,
          Name: "setbyte",
          Args: "BUU",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "Copy of A with the Bth byte set to small integer (between 0..255) C",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 87,
          Name: "extract",
          Args: "B",
          Returns: "B",
          Cost: 1,
          Size: 3,
          Doc: "A range of bytes from A starting at S up to but not including S+L. If L is 0, then extract to the end of the string. If S or S+L is larger than the array length, the program fails",
          ImmediateNote: "{uint8 start position} {uint8 length}",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 88,
          Name: "extract3",
          Args: "BUU",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "A range of bytes from A starting at B up to but not including B+C. If B+C is larger than the array length, the program fails",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 89,
          Name: "extract_uint16",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A uint16 formed from a range of big-endian bytes from A starting at B up to but not including B+2. If B+2 is larger than the array length, the program fails",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 90,
          Name: "extract_uint32",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A uint32 formed from a range of big-endian bytes from A starting at B up to but not including B+4. If B+4 is larger than the array length, the program fails",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 91,
          Name: "extract_uint64",
          Args: "BU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A uint64 formed from a range of big-endian bytes from A starting at B up to but not including B+8. If B+8 is larger than the array length, the program fails",
          Groups: ["Byte Array Manipulation"]
        },
        {
          Opcode: 96,
          Name: "balance",
          Args: ".",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "get balance for account A, in microalgos. The balance is observed after the effects of previous transactions in the group, and after the fee for the current transaction is deducted.",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset). Return: value.",
          Groups: ["State Access"]
        },
        {
          Opcode: 97,
          Name: "app_opted_in",
          Args: ".U",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if account A is opted in to application B, else 0",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset). Return: 1 if opted in and 0 otherwise.",
          Groups: ["State Access"]
        },
        {
          Opcode: 98,
          Name: "app_local_get",
          Args: ".B",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "local state of the key B in the current application in account A",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), state key. Return: value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 99,
          Name: "app_local_get_ex",
          Args: ".UB",
          Returns: ".U",
          Cost: 1,
          Size: 1,
          Doc: "X is the local state of application B, key C in account A. Y is 1 if key existed, else 0",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset), state key. Return: did_exist flag (top of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 100,
          Name: "app_global_get",
          Args: "B",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "global state of the key A in the current application",
          DocExtra: "params: state key. Return: value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 101,
          Name: "app_global_get_ex",
          Args: "UB",
          Returns: ".U",
          Cost: 1,
          Size: 1,
          Doc: "X is the global state of application A, key B. Y is 1 if key existed, else 0",
          DocExtra: "params: Txn.ForeignApps offset (or, since v4, an _available_ application id), state key. Return: did_exist flag (top of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero (of type uint64) if the key does not exist.",
          Groups: ["State Access"]
        },
        {
          Opcode: 102,
          Name: "app_local_put",
          Args: ".B.",
          Cost: 1,
          Size: 1,
          Doc: "write C to key B in account A's local state of the current application",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), state key, value.",
          Groups: ["State Access"]
        },
        {
          Opcode: 103,
          Name: "app_global_put",
          Args: "B.",
          Cost: 1,
          Size: 1,
          Doc: "write B to key A in the global state of the current application",
          Groups: ["State Access"]
        },
        {
          Opcode: 104,
          Name: "app_local_del",
          Args: ".B",
          Cost: 1,
          Size: 1,
          Doc: "delete key B from account A's local state of the current application",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), state key.\n\nDeleting a key which is already absent has no effect on the application local state. (In particular, it does _not_ cause the program to fail.)",
          Groups: ["State Access"]
        },
        {
          Opcode: 105,
          Name: "app_global_del",
          Args: "B",
          Cost: 1,
          Size: 1,
          Doc: "delete key A from the global state of the current application",
          DocExtra: "params: state key.\n\nDeleting a key which is already absent has no effect on the application global state. (In particular, it does _not_ cause the program to fail.)",
          Groups: ["State Access"]
        },
        {
          Opcode: 112,
          Name: "asset_holding_get",
          Args: ".U",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          ArgEnum: ["AssetBalance", "AssetFrozen"],
          ArgEnumTypes: "UU",
          Doc: "X is field F from account A's holding of asset B. Y is 1 if A is opted into B, else 0",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ address), asset id (or, since v4, a Txn.ForeignAssets offset). Return: did_exist flag (1 if the asset existed and 0 otherwise), value.",
          ImmediateNote: "{uint8 asset holding field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 113,
          Name: "asset_params_get",
          Args: "U",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "AssetTotal",
            "AssetDecimals",
            "AssetDefaultFrozen",
            "AssetUnitName",
            "AssetName",
            "AssetURL",
            "AssetMetadataHash",
            "AssetManager",
            "AssetReserve",
            "AssetFreeze",
            "AssetClawback",
            "AssetCreator"
          ],
          ArgEnumTypes: "UUUBBBBBBBBB",
          Doc: "X is field F from asset A. Y is 1 if A exists, else 0",
          DocExtra: "params: Txn.ForeignAssets offset (or, since v4, an _available_ asset id. Return: did_exist flag (1 if the asset existed and 0 otherwise), value.",
          ImmediateNote: "{uint8 asset params field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 114,
          Name: "app_params_get",
          Args: "U",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "AppApprovalProgram",
            "AppClearStateProgram",
            "AppGlobalNumUint",
            "AppGlobalNumByteSlice",
            "AppLocalNumUint",
            "AppLocalNumByteSlice",
            "AppExtraProgramPages",
            "AppCreator",
            "AppAddress"
          ],
          ArgEnumTypes: "BBUUUUUBB",
          Doc: "X is field F from app A. Y is 1 if A exists, else 0",
          DocExtra: "params: Txn.ForeignApps offset or an _available_ app id. Return: did_exist flag (1 if the application existed and 0 otherwise), value.",
          ImmediateNote: "{uint8 app params field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 115,
          Name: "acct_params_get",
          Args: ".",
          Returns: ".U",
          Cost: 1,
          Size: 2,
          Doc: "X is field F from account A. Y is 1 if A owns positive algos, else 0",
          ImmediateNote: "{uint8 account params field index}",
          Groups: ["State Access"]
        },
        {
          Opcode: 120,
          Name: "min_balance",
          Args: ".",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "get minimum required balance for account A, in microalgos. Required balance is affected by [ASA](https://developer.algorand.org/docs/features/asa/#assets-overview) and [App](https://developer.algorand.org/docs/features/asc1/stateful/#minimum-balance-requirement-for-a-smart-contract) usage. When creating or opting into an app, the minimum balance grows before the app code runs, therefore the increase is visible there. When deleting or closing out, the minimum balance decreases after the app executes.",
          DocExtra: "params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset). Return: value.",
          Groups: ["State Access"]
        },
        {
          Opcode: 128,
          Name: "pushbytes",
          Returns: "B",
          Cost: 1,
          Size: 0,
          Doc: "immediate BYTES",
          DocExtra: "pushbytes args are not added to the bytecblock during assembly processes",
          ImmediateNote: "{varuint length} {bytes}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 129,
          Name: "pushint",
          Returns: "U",
          Cost: 1,
          Size: 0,
          Doc: "immediate UINT",
          DocExtra: "pushint args are not added to the intcblock during assembly processes",
          ImmediateNote: "{varuint int}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 136,
          Name: "callsub",
          Cost: 1,
          Size: 3,
          Doc: "branch unconditionally to TARGET, saving the next instruction on the call stack",
          DocExtra: "The call stack is separate from the data stack. Only `callsub` and `retsub` manipulate it.",
          ImmediateNote: "{int16 branch offset, big endian}",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 137,
          Name: "retsub",
          Cost: 1,
          Size: 1,
          Doc: "pop the top instruction from the call stack and branch to it",
          DocExtra: "The call stack is separate from the data stack. Only `callsub` and `retsub` manipulate it.",
          Groups: ["Flow Control"]
        },
        {
          Opcode: 144,
          Name: "shl",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A times 2^B, modulo 2^64",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 145,
          Name: "shr",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A divided by 2^B",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 146,
          Name: "sqrt",
          Args: "U",
          Returns: "U",
          Cost: 4,
          Size: 1,
          Doc: "The largest integer I such that I^2 <= A",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 147,
          Name: "bitlen",
          Args: ".",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "The highest set bit in A. If A is a byte-array, it is interpreted as a big-endian unsigned integer. bitlen of 0 is 0, bitlen of 8 is 4",
          DocExtra: "bitlen interprets arrays as big-endian integers, unlike setbit/getbit",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 148,
          Name: "exp",
          Args: "UU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A raised to the Bth power. Fail if A == B == 0 and on overflow",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 149,
          Name: "expw",
          Args: "UU",
          Returns: "UU",
          Cost: 10,
          Size: 1,
          Doc: "A raised to the Bth power as a 128-bit result in two uint64s. X is the high 64 bits, Y is the low. Fail if A == B == 0 or if the results exceeds 2^128-1",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 150,
          Name: "bsqrt",
          Args: "B",
          Returns: "B",
          Cost: 40,
          Size: 1,
          Doc: "The largest integer I such that I^2 <= A. A and I are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 151,
          Name: "divw",
          Args: "UUU",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "A,B / C. Fail if C == 0 or if result overflows.",
          DocExtra: "The notation A,B indicates that A and B are interpreted as a uint128 value, with A as the high uint64 and B the low.",
          Groups: ["Arithmetic"]
        },
        {
          Opcode: 160,
          Name: "b+",
          Args: "BB",
          Returns: "B",
          Cost: 10,
          Size: 1,
          Doc: "A plus B. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 161,
          Name: "b-",
          Args: "BB",
          Returns: "B",
          Cost: 10,
          Size: 1,
          Doc: "A minus B. A and B are interpreted as big-endian unsigned integers. Fail on underflow.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 162,
          Name: "b/",
          Args: "BB",
          Returns: "B",
          Cost: 20,
          Size: 1,
          Doc: "A divided by B (truncated division). A and B are interpreted as big-endian unsigned integers. Fail if B is zero.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 163,
          Name: "b*",
          Args: "BB",
          Returns: "B",
          Cost: 20,
          Size: 1,
          Doc: "A times B. A and B are interpreted as big-endian unsigned integers.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 164,
          Name: "b<",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if A is less than B, else 0. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 165,
          Name: "b>",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if A is greater than B, else 0. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 166,
          Name: "b<=",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if A is less than or equal to B, else 0. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 167,
          Name: "b>=",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if A is greater than or equal to B, else 0. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 168,
          Name: "b==",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "1 if A is equal to B, else 0. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 169,
          Name: "b!=",
          Args: "BB",
          Returns: "U",
          Cost: 1,
          Size: 1,
          Doc: "0 if A is equal to B, else 1. A and B are interpreted as big-endian unsigned integers",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 170,
          Name: "b%",
          Args: "BB",
          Returns: "B",
          Cost: 20,
          Size: 1,
          Doc: "A modulo B. A and B are interpreted as big-endian unsigned integers. Fail if B is zero.",
          Groups: ["Byte Array Arithmetic"]
        },
        {
          Opcode: 171,
          Name: "b|",
          Args: "BB",
          Returns: "B",
          Cost: 6,
          Size: 1,
          Doc: "A bitwise-or B. A and B are zero-left extended to the greater of their lengths",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 172,
          Name: "b&",
          Args: "BB",
          Returns: "B",
          Cost: 6,
          Size: 1,
          Doc: "A bitwise-and B. A and B are zero-left extended to the greater of their lengths",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 173,
          Name: "b^",
          Args: "BB",
          Returns: "B",
          Cost: 6,
          Size: 1,
          Doc: "A bitwise-xor B. A and B are zero-left extended to the greater of their lengths",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 174,
          Name: "b~",
          Args: "B",
          Returns: "B",
          Cost: 4,
          Size: 1,
          Doc: "A with all bits inverted",
          Groups: ["Byte Array Logic"]
        },
        {
          Opcode: 175,
          Name: "bzero",
          Args: "U",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "zero filled byte-array of length A",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 176,
          Name: "log",
          Args: "B",
          Cost: 1,
          Size: 1,
          Doc: "write A to log state of the current application",
          DocExtra: "`log` fails if called more than MaxLogCalls times in a program, or if the sum of logged bytes exceeds 1024 bytes.",
          Groups: ["State Access"]
        },
        {
          Opcode: 177,
          Name: "itxn_begin",
          Cost: 1,
          Size: 1,
          Doc: "begin preparation of a new inner transaction in a new transaction group",
          DocExtra: "`itxn_begin` initializes Sender to the application address; Fee to the minimum allowable, taking into account MinTxnFee and credit from overpaying in earlier transactions; FirstValid/LastValid to the values in the invoking transaction, and all other fields to zero or empty values.",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 178,
          Name: "itxn_field",
          Args: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "set field F of the current inner transaction to A",
          DocExtra: "`itxn_field` fails if A is of the wrong type for F, including a byte array of the wrong size for use as an address when F is an address field. `itxn_field` also fails if A is an account, asset, or app that is not _available_, or an attempt is made extend an array field beyond the limit imposed by consensus parameters. (Addresses set into asset params of acfg transactions need not be _available_.)",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 179,
          Name: "itxn_submit",
          Cost: 1,
          Size: 1,
          Doc: "execute the current inner transaction group. Fail if executing this group would exceed the inner transaction limit, or if any transaction in the group fails.",
          DocExtra: "`itxn_submit` resets the current transaction so that it can not be resubmitted. A new `itxn_begin` is required to prepare another inner transaction.",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 180,
          Name: "itxn",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "field F of the last inner transaction",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 181,
          Name: "itxna",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ith value of the array field F of the last inner transaction",
          ImmediateNote: "{uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 182,
          Name: "itxn_next",
          Cost: 1,
          Size: 1,
          Doc: "begin preparation of a new inner transaction in the same transaction group",
          DocExtra: "`itxn_next` initializes the transaction exactly as `itxn_begin` does",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 183,
          Name: "gitxn",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "Sender",
            "Fee",
            "FirstValid",
            "FirstValidTime",
            "LastValid",
            "Note",
            "Lease",
            "Receiver",
            "Amount",
            "CloseRemainderTo",
            "VotePK",
            "SelectionPK",
            "VoteFirst",
            "VoteLast",
            "VoteKeyDilution",
            "Type",
            "TypeEnum",
            "XferAsset",
            "AssetAmount",
            "AssetSender",
            "AssetReceiver",
            "AssetCloseTo",
            "GroupIndex",
            "TxID",
            "ApplicationID",
            "OnCompletion",
            "ApplicationArgs",
            "NumAppArgs",
            "Accounts",
            "NumAccounts",
            "ApprovalProgram",
            "ClearStateProgram",
            "RekeyTo",
            "ConfigAsset",
            "ConfigAssetTotal",
            "ConfigAssetDecimals",
            "ConfigAssetDefaultFrozen",
            "ConfigAssetUnitName",
            "ConfigAssetName",
            "ConfigAssetURL",
            "ConfigAssetMetadataHash",
            "ConfigAssetManager",
            "ConfigAssetReserve",
            "ConfigAssetFreeze",
            "ConfigAssetClawback",
            "FreezeAsset",
            "FreezeAssetAccount",
            "FreezeAssetFrozen",
            "Assets",
            "NumAssets",
            "Applications",
            "NumApplications",
            "GlobalNumUint",
            "GlobalNumByteSlice",
            "LocalNumUint",
            "LocalNumByteSlice",
            "ExtraProgramPages",
            "Nonparticipation",
            "Logs",
            "NumLogs",
            "CreatedAssetID",
            "CreatedApplicationID",
            "LastLog",
            "StateProofPK"
          ],
          ArgEnumTypes: "BUUUUBBBUBBBUUUBUUUBBBUBUUBUBUBBBUUUUBBBBBBBBUBUUUUUUUUUUUBUUUBB",
          Doc: "field F of the Tth transaction in the last inner group submitted",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 184,
          Name: "gitxna",
          Returns: ".",
          Cost: 1,
          Size: 4,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ith value of the array field F from the Tth transaction in the last inner group submitted",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index} {uint8 transaction field array index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 192,
          Name: "txnas",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ath value of the array field F of the current transaction",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 193,
          Name: "gtxnas",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 3,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Ath value of the array field F from the Tth transaction in the current group",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 194,
          Name: "gtxnsas",
          Args: "UU",
          Returns: ".",
          Cost: 1,
          Size: 2,
          ArgEnum: [
            "ApplicationArgs",
            "Accounts",
            "Assets",
            "Applications",
            "Logs"
          ],
          ArgEnumTypes: "BBUUB",
          Doc: "Bth value of the array field F from the Ath transaction in the current group",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 195,
          Name: "args",
          Args: "U",
          Returns: "B",
          Cost: 1,
          Size: 1,
          Doc: "Ath LogicSig argument",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 196,
          Name: "gloadss",
          Args: "UU",
          Returns: ".",
          Cost: 1,
          Size: 1,
          Doc: "Bth scratch space value of the Ath transaction in the current group",
          Groups: ["Loading Values"]
        },
        {
          Opcode: 197,
          Name: "itxnas",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 2,
          Doc: "Ath value of the array field F of the last inner transaction",
          ImmediateNote: "{uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        },
        {
          Opcode: 198,
          Name: "gitxnas",
          Args: "U",
          Returns: ".",
          Cost: 1,
          Size: 3,
          Doc: "Ath value of the array field F from the Tth transaction in the last inner group submitted",
          ImmediateNote: "{uint8 transaction group index} {uint8 transaction field index}",
          Groups: ["Inner Transactions"]
        }
      ]
    };
  }
});

// node_modules/algosdk/dist/cjs/src/logic/logic.js
var require_logic = __commonJS({
  "node_modules/algosdk/dist/cjs/src/logic/logic.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.langspecLogicSigVersion = exports2.langspecEvalMaxVersion = exports2.checkPushByteOp = exports2.checkPushIntOp = exports2.checkByteConstBlock = exports2.checkIntConstBlock = exports2.checkProgram = exports2.readProgram = exports2.parseUvarint = void 0;
    var langspec_json_1 = __importDefault(require_langspec());
    var opcodes;
    var maxCost = 2e4;
    var maxLength = 1e3;
    function parseUvarint(array) {
      let x = 0;
      let s = 0;
      for (let i = 0; i < array.length; i++) {
        const b = array[i];
        if (b < 128) {
          if (i > 9 || i === 9 && b > 1) {
            return [0, -(i + 1)];
          }
          return [x | b << s, i + 1];
        }
        x += (b & 127) << s;
        s += 7;
      }
      return [0, 0];
    }
    exports2.parseUvarint = parseUvarint;
    function readIntConstBlock(program, pc) {
      let size = 1;
      const parsed = parseUvarint(program.slice(pc + size));
      const numInts = parsed[0];
      let bytesUsed = parsed[1];
      if (bytesUsed <= 0) {
        throw new Error(`could not decode int const block size at pc=${pc + size}`);
      }
      const ints = [];
      size += bytesUsed;
      for (let i = 0; i < numInts; i++) {
        if (pc + size >= program.length) {
          throw new Error("intcblock ran past end of program");
        }
        let numberFound;
        [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));
        if (bytesUsed <= 0) {
          throw new Error(`could not decode int const[${i}] block size at pc=${pc + size}`);
        }
        ints.push(numberFound);
        size += bytesUsed;
      }
      return [size, ints];
    }
    function readByteConstBlock(program, pc) {
      let size = 1;
      const parsed = parseUvarint(program.slice(pc + size));
      const numInts = parsed[0];
      let bytesUsed = parsed[1];
      if (bytesUsed <= 0) {
        throw new Error(`could not decode []byte const block size at pc=${pc + size}`);
      }
      const byteArrays = [];
      size += bytesUsed;
      for (let i = 0; i < numInts; i++) {
        if (pc + size >= program.length) {
          throw new Error("bytecblock ran past end of program");
        }
        let itemLen;
        [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));
        if (bytesUsed <= 0) {
          throw new Error(`could not decode []byte] const[${i}] block size at pc=${pc + size}`);
        }
        size += bytesUsed;
        if (pc + size + itemLen > program.length) {
          throw new Error("bytecblock ran past end of program");
        }
        const byteArray = program.slice(pc + size, pc + size + itemLen);
        byteArrays.push(byteArray);
        size += itemLen;
      }
      return [size, byteArrays];
    }
    function readPushIntOp(program, pc) {
      let size = 1;
      const [numberFound, bytesUsed] = parseUvarint(program.slice(pc + size));
      if (bytesUsed <= 0) {
        throw new Error(`could not decode push int const at pc=${pc + size}`);
      }
      size += bytesUsed;
      return [size, numberFound];
    }
    function readPushByteOp(program, pc) {
      let size = 1;
      const [itemLen, bytesUsed] = parseUvarint(program.slice(pc + size));
      if (bytesUsed <= 0) {
        throw new Error(`could not decode push []byte const size at pc=${pc + size}`);
      }
      size += bytesUsed;
      if (pc + size + itemLen > program.length) {
        throw new Error("pushbytes ran past end of program");
      }
      const byteArray = program.slice(pc + size, pc + size + itemLen);
      size += itemLen;
      return [size, byteArray];
    }
    function readProgram(program, args) {
      const intcblockOpcode = 32;
      const bytecblockOpcode = 38;
      const pushbytesOpcode = 128;
      const pushintOpcode = 129;
      if (!program) {
        throw new Error("empty program");
      }
      if (typeof args === "undefined") {
        args = [];
      }
      if (!Array.isArray(args)) {
        throw new Error("invalid arguments");
      }
      const [version, vlen] = parseUvarint(program);
      if (vlen <= 0) {
        throw new Error("version parsing error");
      }
      if (version > langspec_json_1.default.EvalMaxVersion) {
        throw new Error("unsupported version");
      }
      let cost = 0;
      let { length } = program;
      for (const arg of args) {
        length += arg.length;
      }
      if (length > maxLength) {
        throw new Error("program too long");
      }
      if (!opcodes) {
        opcodes = {};
        for (const op of langspec_json_1.default.Ops) {
          opcodes[op.Opcode] = op;
        }
      }
      let pc = vlen;
      let ints = [];
      let byteArrays = [];
      while (pc < program.length) {
        const op = opcodes[program[pc]];
        if (op === void 0) {
          throw new Error("invalid instruction");
        }
        cost += op.Cost;
        let size = op.Size;
        if (size === 0) {
          switch (op.Opcode) {
            case intcblockOpcode: {
              let foundInts;
              [size, foundInts] = readIntConstBlock(program, pc);
              ints = ints.concat(foundInts);
              break;
            }
            case bytecblockOpcode: {
              let foundByteArrays;
              [size, foundByteArrays] = readByteConstBlock(program, pc);
              byteArrays = byteArrays.concat(foundByteArrays);
              break;
            }
            case pushintOpcode: {
              let foundInt;
              [size, foundInt] = readPushIntOp(program, pc);
              ints.push(foundInt);
              break;
            }
            case pushbytesOpcode: {
              let foundByteArray;
              [size, foundByteArray] = readPushByteOp(program, pc);
              byteArrays.push(foundByteArray);
              break;
            }
            default: {
              throw new Error("invalid instruction");
            }
          }
        }
        pc += size;
      }
      if (version < 4 && cost > maxCost) {
        throw new Error("program too costly for Teal version < 4. consider using v4.");
      }
      return [ints, byteArrays, true];
    }
    exports2.readProgram = readProgram;
    function checkProgram(program, args) {
      const [, , success] = readProgram(program, args);
      return success;
    }
    exports2.checkProgram = checkProgram;
    function checkIntConstBlock(program, pc) {
      const [size] = readIntConstBlock(program, pc);
      return size;
    }
    exports2.checkIntConstBlock = checkIntConstBlock;
    function checkByteConstBlock(program, pc) {
      const [size] = readByteConstBlock(program, pc);
      return size;
    }
    exports2.checkByteConstBlock = checkByteConstBlock;
    function checkPushIntOp(program, pc) {
      const [size] = readPushIntOp(program, pc);
      return size;
    }
    exports2.checkPushIntOp = checkPushIntOp;
    function checkPushByteOp(program, pc) {
      const [size] = readPushByteOp(program, pc);
      return size;
    }
    exports2.checkPushByteOp = checkPushByteOp;
    exports2.langspecEvalMaxVersion = langspec_json_1.default.EvalMaxVersion;
    exports2.langspecLogicSigVersion = langspec_json_1.default.LogicSigVersion;
  }
});

// node_modules/algosdk/dist/cjs/src/multisig.js
var require_multisig = __commonJS({
  "node_modules/algosdk/dist/cjs/src/multisig.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.multisigAddress = exports2.appendSignMultisigTransaction = exports2.signMultisigTransaction = exports2.verifyMultisig = exports2.mergeMultisigTransactions = exports2.MultisigTransaction = exports2.MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = exports2.MULTISIG_NO_MUTATE_ERROR_MSG = exports2.MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = exports2.MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = exports2.MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = exports2.MULTISIG_MERGE_MISMATCH_ERROR_MSG = exports2.MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = void 0;
    var nacl = __importStar(require_naclWrappers());
    var address = __importStar(require_address());
    var encoding = __importStar(require_encoding());
    var txnBuilder = __importStar(require_transaction());
    var utils = __importStar(require_utils());
    exports2.MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = "Not enough multisig transactions to merge. Need at least two";
    exports2.MULTISIG_MERGE_MISMATCH_ERROR_MSG = "Cannot merge txs. txIDs differ";
    exports2.MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = "Cannot merge txs. Auth addrs differ";
    exports2.MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = "Cannot merge txs. Multisig preimages differ";
    exports2.MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = "Cannot merge txs. subsigs are mismatched.";
    var MULTISIG_KEY_NOT_EXIST_ERROR_MSG = "Key does not exist";
    exports2.MULTISIG_NO_MUTATE_ERROR_MSG = "Cannot mutate a multisig field as it would invalidate all existing signatures.";
    exports2.MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = "Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.";
    function createMultisigTransaction(txnForEncoding, { rawSig, myPk }, { version, threshold, pks }) {
      let keyExist = false;
      const subsigs = pks.map((pk) => {
        if (nacl.bytesEqual(pk, myPk)) {
          keyExist = true;
          return {
            pk: Buffer.from(pk),
            s: rawSig
          };
        }
        return { pk: Buffer.from(pk) };
      });
      if (keyExist === false) {
        throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);
      }
      const msig = {
        v: version,
        thr: threshold,
        subsig: subsigs
      };
      const signedTxn = {
        msig,
        txn: txnForEncoding
      };
      const msigAddr = address.fromMultisigPreImg({
        version,
        threshold,
        pks
      });
      if (address.encodeAddress(txnForEncoding.snd) !== address.encodeAddress(msigAddr)) {
        signedTxn.sgnr = Buffer.from(msigAddr);
      }
      return new Uint8Array(encoding.encode(signedTxn));
    }
    var MultisigTransaction = class extends txnBuilder.Transaction {
      addLease() {
        throw new Error(exports2.MULTISIG_NO_MUTATE_ERROR_MSG);
      }
      addRekey() {
        throw new Error(exports2.MULTISIG_NO_MUTATE_ERROR_MSG);
      }
      signTxn(sk) {
        throw new Error(exports2.MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);
      }
      partialSignTxn({ version, threshold, pks }, sk) {
        const myPk = nacl.keyPairFromSecretKey(sk).publicKey;
        return createMultisigTransaction(this.get_obj_for_encoding(), { rawSig: this.rawSignTxn(sk), myPk }, { version, threshold, pks });
      }
      static from_obj_for_encoding(txnForEnc) {
        return super.from_obj_for_encoding(txnForEnc);
      }
    };
    exports2.MultisigTransaction = MultisigTransaction;
    function mergeMultisigTransactions(multisigTxnBlobs) {
      if (multisigTxnBlobs.length < 2) {
        throw new Error(exports2.MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);
      }
      const refSigTx = encoding.decode(multisigTxnBlobs[0]);
      const refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();
      const refAuthAddr = refSigTx.sgnr ? address.encodeAddress(refSigTx.sgnr) : void 0;
      const refPreImage = {
        version: refSigTx.msig.v,
        threshold: refSigTx.msig.thr,
        pks: refSigTx.msig.subsig.map((subsig) => subsig.pk)
      };
      const refMsigAddr = address.encodeAddress(address.fromMultisigPreImg(refPreImage));
      let newSubsigs = refSigTx.msig.subsig;
      for (let i = 0; i < multisigTxnBlobs.length; i++) {
        const unisig = encoding.decode(multisigTxnBlobs[i]);
        const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);
        if (unisigAlgoTxn.txID() !== refTxID) {
          throw new Error(exports2.MULTISIG_MERGE_MISMATCH_ERROR_MSG);
        }
        const authAddr = unisig.sgnr ? address.encodeAddress(unisig.sgnr) : void 0;
        if (refAuthAddr !== authAddr) {
          throw new Error(exports2.MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);
        }
        if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
          throw new Error(exports2.MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
        }
        const preimg = {
          version: unisig.msig.v,
          threshold: unisig.msig.thr,
          pks: unisig.msig.subsig.map((subsig) => subsig.pk)
        };
        const msgigAddr = address.encodeAddress(address.fromMultisigPreImg(preimg));
        if (refMsigAddr !== msgigAddr) {
          throw new Error(exports2.MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
        }
        newSubsigs = unisig.msig.subsig.map((uniSubsig, index) => {
          const current = refSigTx.msig.subsig[index];
          if (current.s) {
            if (uniSubsig.s && Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0) {
              throw new Error(exports2.MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);
            }
            return {
              pk: current.pk,
              s: current.s
            };
          }
          if (uniSubsig.s) {
            return {
              pk: current.pk,
              s: uniSubsig.s
            };
          }
          return current;
        });
      }
      const msig = {
        v: refSigTx.msig.v,
        thr: refSigTx.msig.thr,
        subsig: newSubsigs
      };
      const signedTxn = {
        msig,
        txn: refSigTx.txn
      };
      if (typeof refAuthAddr !== "undefined") {
        signedTxn.sgnr = Buffer.from(address.decodeAddress(refAuthAddr).publicKey);
      }
      return new Uint8Array(encoding.encode(signedTxn));
    }
    exports2.mergeMultisigTransactions = mergeMultisigTransactions;
    function verifyMultisig(toBeVerified, msig, publicKey) {
      const version = msig.v;
      const threshold = msig.thr;
      const subsigs = msig.subsig;
      const pks = subsigs.map((subsig) => subsig.pk);
      if (msig.subsig.length < threshold) {
        return false;
      }
      let pk;
      try {
        pk = address.fromMultisigPreImg({ version, threshold, pks });
      } catch (e) {
        return false;
      }
      if (!utils.arrayEqual(pk, publicKey)) {
        return false;
      }
      let counter = 0;
      for (const subsig of subsigs) {
        if (subsig.s !== void 0) {
          counter += 1;
        }
      }
      if (counter < threshold) {
        return false;
      }
      let verifiedCounter = 0;
      for (const subsig of subsigs) {
        if (subsig.s !== void 0) {
          if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {
            verifiedCounter += 1;
          }
        }
      }
      if (verifiedCounter < threshold) {
        return false;
      }
      return true;
    }
    exports2.verifyMultisig = verifyMultisig;
    function signMultisigTransaction(txn, { version, threshold, addrs }, sk) {
      const expectedFromRaw = address.fromMultisigPreImgAddrs({
        version,
        threshold,
        addrs
      });
      if (!Object.prototype.hasOwnProperty.call(txn, "from")) {
        txn.from = expectedFromRaw;
      }
      const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);
      const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;
      let algoTxn;
      let blob;
      if (txnAlreadyBuilt) {
        algoTxn = txn;
        blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, { version, threshold, pks }, sk);
      } else {
        algoTxn = new MultisigTransaction(txn);
        blob = algoTxn.partialSignTxn({ version, threshold, pks }, sk);
      }
      return {
        txID: algoTxn.txID().toString(),
        blob
      };
    }
    exports2.signMultisigTransaction = signMultisigTransaction;
    function appendSignMultisigTransaction(multisigTxnBlob, { version, threshold, addrs }, sk) {
      const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);
      const multisigTxObj = encoding.decode(multisigTxnBlob);
      const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);
      const partialSignedBlob = msigTxn.partialSignTxn({ version, threshold, pks }, sk);
      return {
        txID: msigTxn.txID().toString(),
        blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
      };
    }
    exports2.appendSignMultisigTransaction = appendSignMultisigTransaction;
    function multisigAddress({ version, threshold, addrs }) {
      return address.fromMultisigPreImgAddrs({ version, threshold, addrs });
    }
    exports2.multisigAddress = multisigAddress;
  }
});

// node_modules/algosdk/dist/cjs/src/logicsig.js
var require_logicsig = __commonJS({
  "node_modules/algosdk/dist/cjs/src/logicsig.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tealSignFromProgram = exports2.tealSign = exports2.logicSigFromByte = exports2.signLogicSigTransaction = exports2.signLogicSigTransactionObject = exports2.makeLogicSig = exports2.LogicSigAccount = exports2.LogicSig = void 0;
    var nacl = __importStar(require_naclWrappers());
    var address = __importStar(require_address());
    var encoding = __importStar(require_encoding());
    var logic = __importStar(require_logic());
    var multisig_1 = require_multisig();
    var utils = __importStar(require_utils());
    var txnBuilder = __importStar(require_transaction());
    var LogicSig = class {
      constructor(program, programArgs) {
        this.tag = Buffer.from("Program");
        if (programArgs && (!Array.isArray(programArgs) || !programArgs.every((arg) => arg.constructor === Uint8Array || Buffer.isBuffer(arg)))) {
          throw new TypeError("Invalid arguments");
        }
        let args;
        if (programArgs != null)
          args = programArgs.map((arg) => new Uint8Array(arg));
        if (!logic.checkProgram(program, args)) {
          throw new Error("Invalid program");
        }
        this.logic = program;
        this.args = args;
        this.sig = void 0;
        this.msig = void 0;
      }
      get_obj_for_encoding() {
        const obj = {
          l: this.logic
        };
        if (this.args) {
          obj.arg = this.args;
        }
        if (this.sig) {
          obj.sig = this.sig;
        } else if (this.msig) {
          obj.msig = this.msig;
        }
        return obj;
      }
      static from_obj_for_encoding(encoded) {
        const lsig = new LogicSig(encoded.l, encoded.arg);
        lsig.sig = encoded.sig;
        lsig.msig = encoded.msig;
        return lsig;
      }
      verify(publicKey) {
        if (this.sig && this.msig) {
          return false;
        }
        try {
          logic.checkProgram(this.logic, this.args);
        } catch (e) {
          return false;
        }
        const toBeSigned = utils.concatArrays(this.tag, this.logic);
        if (!this.sig && !this.msig) {
          const hash = nacl.genericHash(toBeSigned);
          return utils.arrayEqual(hash, publicKey);
        }
        if (this.sig) {
          return nacl.verify(toBeSigned, this.sig, publicKey);
        }
        return multisig_1.verifyMultisig(toBeSigned, this.msig, publicKey);
      }
      address() {
        const toBeSigned = utils.concatArrays(this.tag, this.logic);
        const hash = nacl.genericHash(toBeSigned);
        return address.encodeAddress(new Uint8Array(hash));
      }
      sign(secretKey, msig) {
        if (msig == null) {
          this.sig = this.signProgram(secretKey);
        } else {
          const subsigs = msig.addrs.map((addr) => ({
            pk: address.decodeAddress(addr).publicKey
          }));
          this.msig = {
            v: msig.version,
            thr: msig.threshold,
            subsig: subsigs
          };
          const [sig, index] = this.singleSignMultisig(secretKey, this.msig);
          this.msig.subsig[index].s = sig;
        }
      }
      appendToMultisig(secretKey) {
        if (this.msig === void 0) {
          throw new Error("no multisig present");
        }
        const [sig, index] = this.singleSignMultisig(secretKey, this.msig);
        this.msig.subsig[index].s = sig;
      }
      signProgram(secretKey) {
        const toBeSigned = utils.concatArrays(this.tag, this.logic);
        const sig = nacl.sign(toBeSigned, secretKey);
        return sig;
      }
      singleSignMultisig(secretKey, msig) {
        let index = -1;
        const myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;
        for (let i = 0; i < msig.subsig.length; i++) {
          const { pk } = msig.subsig[i];
          if (utils.arrayEqual(pk, myPk)) {
            index = i;
            break;
          }
        }
        if (index === -1) {
          throw new Error("invalid secret key");
        }
        const sig = this.signProgram(secretKey);
        return [sig, index];
      }
      toByte() {
        return encoding.encode(this.get_obj_for_encoding());
      }
      static fromByte(encoded) {
        const decodedObj = encoding.decode(encoded);
        return LogicSig.from_obj_for_encoding(decodedObj);
      }
    };
    exports2.LogicSig = LogicSig;
    var LogicSigAccount = class {
      constructor(program, args) {
        this.lsig = new LogicSig(program, args);
        this.sigkey = void 0;
      }
      get_obj_for_encoding() {
        const obj = {
          lsig: this.lsig.get_obj_for_encoding()
        };
        if (this.sigkey) {
          obj.sigkey = this.sigkey;
        }
        return obj;
      }
      static from_obj_for_encoding(encoded) {
        const lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);
        lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);
        lsigAccount.sigkey = encoded.sigkey;
        return lsigAccount;
      }
      toByte() {
        return encoding.encode(this.get_obj_for_encoding());
      }
      static fromByte(encoded) {
        const decodedObj = encoding.decode(encoded);
        return LogicSigAccount.from_obj_for_encoding(decodedObj);
      }
      isDelegated() {
        return !!(this.lsig.sig || this.lsig.msig);
      }
      verify() {
        const addr = this.address();
        return this.lsig.verify(address.decodeAddress(addr).publicKey);
      }
      address() {
        if (this.lsig.sig && this.lsig.msig) {
          throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
        }
        if (this.lsig.sig) {
          if (!this.sigkey) {
            throw new Error("Signing key for delegated account is missing");
          }
          return address.encodeAddress(this.sigkey);
        }
        if (this.lsig.msig) {
          const msigMetadata = {
            version: this.lsig.msig.v,
            threshold: this.lsig.msig.thr,
            pks: this.lsig.msig.subsig.map((subsig) => subsig.pk)
          };
          return address.encodeAddress(address.fromMultisigPreImg(msigMetadata));
        }
        return this.lsig.address();
      }
      signMultisig(msig, secretKey) {
        this.lsig.sign(secretKey, msig);
      }
      appendToMultisig(secretKey) {
        this.lsig.appendToMultisig(secretKey);
      }
      sign(secretKey) {
        this.lsig.sign(secretKey);
        this.sigkey = nacl.keyPairFromSecretKey(secretKey).publicKey;
      }
    };
    exports2.LogicSigAccount = LogicSigAccount;
    function makeLogicSig(program, args) {
      return new LogicSig(program, args);
    }
    exports2.makeLogicSig = makeLogicSig;
    function signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {
      if (!lsig.verify(lsigAddress)) {
        throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
      }
      const signedTxn = {
        lsig: lsig.get_obj_for_encoding(),
        txn: txn.get_obj_for_encoding()
      };
      if (!nacl.bytesEqual(lsigAddress, txn.from.publicKey)) {
        signedTxn.sgnr = Buffer.from(lsigAddress);
      }
      return {
        txID: txn.txID().toString(),
        blob: encoding.encode(signedTxn)
      };
    }
    function signLogicSigTransactionObject(txn, lsigObject) {
      let lsig;
      let lsigAddress;
      if (lsigObject instanceof LogicSigAccount) {
        lsig = lsigObject.lsig;
        lsigAddress = address.decodeAddress(lsigObject.address()).publicKey;
      } else {
        lsig = lsigObject;
        if (lsig.sig) {
          lsigAddress = txn.from.publicKey;
        } else if (lsig.msig) {
          const msigMetadata = {
            version: lsig.msig.v,
            threshold: lsig.msig.thr,
            pks: lsig.msig.subsig.map((subsig) => subsig.pk)
          };
          lsigAddress = address.fromMultisigPreImg(msigMetadata);
        } else {
          lsigAddress = address.decodeAddress(lsig.address()).publicKey;
        }
      }
      return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);
    }
    exports2.signLogicSigTransactionObject = signLogicSigTransactionObject;
    function signLogicSigTransaction(txn, lsigObject) {
      const algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);
      return signLogicSigTransactionObject(algoTxn, lsigObject);
    }
    exports2.signLogicSigTransaction = signLogicSigTransaction;
    function logicSigFromByte(encoded) {
      return LogicSig.fromByte(encoded);
    }
    exports2.logicSigFromByte = logicSigFromByte;
    var SIGN_PROGRAM_DATA_PREFIX = Buffer.from("ProgData");
    function tealSign(sk, data, contractAddress) {
      const parts = utils.concatArrays(address.decodeAddress(contractAddress).publicKey, data);
      const toBeSigned = Buffer.from(utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));
      return nacl.sign(toBeSigned, sk);
    }
    exports2.tealSign = tealSign;
    function tealSignFromProgram(sk, data, program) {
      const lsig = new LogicSig(program);
      const contractAddress = lsig.address();
      return tealSign(sk, data, contractAddress);
    }
    exports2.tealSignFromProgram = tealSignFromProgram;
  }
});

// node_modules/algosdk/dist/cjs/src/logicTemplates/templates.js
var require_templates = __commonJS({
  "node_modules/algosdk/dist/cjs/src/logicTemplates/templates.js"(exports2, module2) {
    var address = require_address();
    function putUvarint(buf, x) {
      let i = 0;
      while (x > 128) {
        buf.push(x & 255 | 128);
        x >>= 7;
        i += 1;
      }
      buf.push(x & 255);
      return i + 1;
    }
    var valTypes = {
      INT: 1,
      ADDRESS: 2,
      BASE64: 3
    };
    function inject(orig, offsets, values, valueTypes) {
      if (offsets.length !== values.length || offsets.length !== valueTypes.length) {
        throw new Error("Lengths do not match");
      }
      let res = orig;
      function replace(arr, newVal, offset, placeholderLength) {
        const beforeReplacement = arr.slice(0, offset);
        const afterReplacement = arr.slice(offset + placeholderLength, arr.length);
        const chunks = [beforeReplacement, Buffer.from(newVal), afterReplacement];
        return Buffer.concat(chunks);
      }
      for (let i = 0; i < offsets.length; i++) {
        let decodedLength = 0;
        let val = values[i];
        const valType = valueTypes[i];
        switch (valType) {
          case valTypes.INT:
            const intBuf = [];
            decodedLength = putUvarint(intBuf, val);
            res = replace(res, intBuf, offsets[i], 1);
            break;
          case valTypes.ADDRESS:
            val = address.decodeAddress(val);
            res = replace(res, val.publicKey, offsets[i], 32);
            break;
          case valTypes.BASE64:
            const lenBuf = [];
            val = Buffer.from(val, "base64");
            putUvarint(lenBuf, val.length);
            val = Buffer.concat([Buffer.from(lenBuf), val]);
            res = replace(res, val, offsets[i], 33);
            break;
          default:
            throw new Error("unrecognized value type");
        }
        if (decodedLength !== 0) {
          for (let o = 0; o < offsets.length; o++) {
            offsets[o] += decodedLength - 1;
          }
        }
      }
      return res;
    }
    module2.exports = { inject, valTypes };
  }
});

// node_modules/algosdk/dist/cjs/src/logicTemplates/dynamicfee.js
var require_dynamicfee = __commonJS({
  "node_modules/algosdk/dist/cjs/src/logicTemplates/dynamicfee.js"(exports2, module2) {
    var address = require_address();
    var encoding = require_encoding();
    var group = require_group();
    var logic = require_logic();
    var logicSig = require_logicsig();
    var nacl = require_naclWrappers();
    var templates = require_templates();
    var transaction = require_transaction();
    var DynamicFee = class {
      constructor(receiver, amount, firstValid, lastValid, closeRemainder, lease) {
        if (!Number.isSafeInteger(amount) || amount < 0)
          throw Error("amount must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(firstValid) || firstValid < 0)
          throw Error("firstValid must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(lastValid) || lastValid < 0)
          throw Error("lastValid must be a positive number and smaller than 2^53-1");
        if (typeof closeRemainder === "undefined") {
          closeRemainder = address.ALGORAND_ZERO_ADDRESS_STRING;
        }
        if (typeof lease === "undefined") {
          const leaseBytes = nacl.randomBytes(32);
          lease = Buffer.from(leaseBytes).toString("base64");
        }
        const referenceProgramB64 = "ASAFAgEHBgUmAyD+vKC7FEpaTqe0OKRoGsgObKEFvLYH/FZTJclWlfaiEyDmmpYeby1feshmB5JlUr6YI17TM2PKiJGLuck4qRW2+SB/g7Flf/H8U7ktwYFIodZd/C1LH6PWdyhK3dIAEm2QaTIEIhIzABAjEhAzAAcxABIQMwAIMQESEDEWIxIQMRAjEhAxBygSEDEJKRIQMQgkEhAxAiUSEDEEIQQSEDEGKhIQ";
        const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
        const referenceOffsets = [
          5,
          6,
          7,
          11,
          44,
          76
        ];
        const injectionVector = [
          amount,
          firstValid,
          lastValid,
          receiver,
          closeRemainder,
          lease
        ];
        const injectionTypes = [
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.ADDRESS,
          templates.valTypes.ADDRESS,
          templates.valTypes.BASE64
        ];
        const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
        this.programBytes = injectedBytes;
        const lsig = new logicSig.LogicSig(injectedBytes, void 0);
        this.address = lsig.address();
      }
      getProgram() {
        return this.programBytes;
      }
      getAddress() {
        return this.address;
      }
    };
    function signDynamicFee(contract, secretKey, genesisHash) {
      const programOutputs = logic.readProgram(contract, void 0);
      const ints = programOutputs[0];
      const byteArrays = programOutputs[1];
      const keys = nacl.keyPairFromSecretKey(secretKey);
      const from = address.encodeAddress(keys.publicKey);
      const to = address.encodeAddress(byteArrays[0]);
      const fee = 0;
      const amount = ints[2];
      const closeRemainderTo = address.encodeAddress(byteArrays[1]);
      const firstRound = ints[3];
      const lastRound = ints[4];
      const lease = new Uint8Array(byteArrays[2]);
      const txn = {
        from,
        to,
        fee,
        amount,
        closeRemainderTo,
        firstRound,
        lastRound,
        genesisHash,
        type: "pay",
        lease
      };
      const lsig = new logicSig.LogicSig(contract, void 0);
      lsig.sign(secretKey);
      return { txn, lsig };
    }
    function getDynamicFeeTransactions(txn, lsig, privateKey, fee) {
      if (!lsig.verify(address.decodeAddress(txn.from).publicKey)) {
        throw new Error("invalid signature");
      }
      txn.fee = fee;
      if (txn.fee < transaction.ALGORAND_MIN_TX_FEE) {
        txn.fee = transaction.ALGORAND_MIN_TX_FEE;
      }
      const keys = nacl.keyPairFromSecretKey(privateKey);
      const from = address.encodeAddress(keys.publicKey);
      const { lease } = txn;
      delete txn.lease;
      const txnObj = new transaction.Transaction(txn);
      txnObj.addLease(lease, fee);
      const feePayTxn = {
        from,
        to: txn.from,
        fee,
        amount: txnObj.fee,
        firstRound: txn.firstRound,
        lastRound: txn.lastRound,
        genesisHash: txn.genesisHash,
        type: "pay"
      };
      const feePayTxnObj = new transaction.Transaction(feePayTxn);
      feePayTxnObj.addLease(lease, fee);
      const txnGroup = group.assignGroupID([feePayTxnObj, txnObj], void 0);
      const feePayTxnWithGroup = txnGroup[0];
      const txnObjWithGroup = txnGroup[1];
      const lstx = {
        lsig: lsig.get_obj_for_encoding(),
        txn: txnObjWithGroup.get_obj_for_encoding()
      };
      const stx1 = feePayTxnWithGroup.signTxn(privateKey);
      const stx2 = encoding.encode(lstx);
      const concatStx = new Uint8Array(stx1.length + stx2.length);
      concatStx.set(stx1);
      concatStx.set(stx2, stx1.length);
      return concatStx;
    }
    module2.exports = {
      DynamicFee,
      getDynamicFeeTransactions,
      signDynamicFee
    };
  }
});

// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS({
  "node_modules/js-sha256/src/sha256.js"(exports, module) {
    (function() {
      "use strict";
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is2242) {
        return function(message) {
          return new Sha256(is2242, true).update(message)[outputType]();
        };
      };
      var createMethod = function(is2242) {
        var method2 = createOutputMethod("hex", is2242);
        if (NODE_JS) {
          method2 = nodeWrap(method2, is2242);
        }
        method2.create = function() {
          return new Sha256(is2242);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createOutputMethod(type, is2242);
        }
        return method2;
      };
      var nodeWrap = function(method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? "sha224" : "sha256";
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
            return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is2242) {
        return function(key, message) {
          return new HmacSha256(key, is2242, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(is2242) {
        var method2 = createHmacOutputMethod("hex", is2242);
        method2.create = function(key) {
          return new HmacSha256(key, is2242);
        };
        method2.update = function(key, message) {
          return method2.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createHmacOutputMethod(type, is2242);
        }
        return method2;
      };
      function Sha256(is2242, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is2242) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is2242;
      }
      Sha256.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index = 0, i, length = message.length, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
        for (j = 16; j < 64; ++j) {
          t1 = blocks2[j - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks2[j - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
        }
        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks2[0] - 1413257819;
              h = t1 - 150054599 << 0;
              d = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks2[0] - 210244248;
              h = t1 - 1521486534 << 0;
              d = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ab = a & b;
            maj = ab ^ a & c ^ bc;
            ch = e & f ^ ~e & g;
            t1 = h + s1 + ch + K[j] + blocks2[j];
            t2 = s0 + maj;
            h = d + t1 << 0;
            d = t1 + t2 << 0;
          }
          s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
          s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
          da = d & a;
          maj = da ^ d & b ^ ab;
          ch = h & e ^ ~h & f;
          t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
          t2 = s0 + maj;
          g = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
          s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
          cd = c & d;
          maj = cd ^ c & a ^ da;
          ch = g & h ^ ~g & e;
          t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
          t2 = s0 + maj;
          f = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
          s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
          bc = b & c;
          maj = bc ^ b & d ^ cd;
          ch = f & g ^ ~f & h;
          t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
          t2 = s0 + maj;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f << 0;
        this.h6 = this.h6 + g << 0;
        this.h7 = this.h7 + h << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >> 24 & 255,
          h0 >> 16 & 255,
          h0 >> 8 & 255,
          h0 & 255,
          h1 >> 24 & 255,
          h1 >> 16 & 255,
          h1 >> 8 & 255,
          h1 & 255,
          h2 >> 24 & 255,
          h2 >> 16 & 255,
          h2 >> 8 & 255,
          h2 & 255,
          h3 >> 24 & 255,
          h3 >> 16 & 255,
          h3 >> 8 & 255,
          h3 & 255,
          h4 >> 24 & 255,
          h4 >> 16 & 255,
          h4 >> 8 & 255,
          h4 & 255,
          h5 >> 24 & 255,
          h5 >> 16 & 255,
          h5 >> 8 & 255,
          h5 & 255,
          h6 >> 24 & 255,
          h6 >> 16 & 255,
          h6 >> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };
      function HmacSha256(key, is2242, sharedMemory) {
        var i, type = typeof key;
        if (type === "string") {
          var bytes = [], length = key.length, index = 0, code;
          for (i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >> 12;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes[index++] = 240 | code >> 18;
              bytes[index++] = 128 | code >> 12 & 63;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        } else {
          if (type === "object") {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key.length > 64) {
          key = new Sha256(is2242, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha256.call(this, is2242, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
        if (AMD) {
          define(function() {
            return exports;
          });
        }
      }
    })();
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW2 = typeof window === "object";
      var root2 = WINDOW2 ? window : {};
      if (root2.JS_SHA3_NO_WINDOW) {
        WINDOW2 = false;
      }
      var WEB_WORKER2 = !WINDOW2 && typeof self === "object";
      var NODE_JS2 = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS2) {
        root2 = global;
      } else if (WEB_WORKER2) {
        root2 = self;
      }
      var COMMON_JS2 = !root2.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD2 = typeof define === "function" && define.amd;
      var ARRAY_BUFFER2 = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS2 = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT2 = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES2 = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER2 && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod2 = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n, s) {
          return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s) {
          return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method2, createMethod3, bits2, padding) {
        for (var i2 = 0; i2 < OUTPUT_TYPES2.length; ++i2) {
          var type = OUTPUT_TYPES2[i2];
          method2[type] = createMethod3(bits2, padding, type);
        }
        return method2;
      };
      var createMethod2 = function(bits2, padding) {
        var method2 = createOutputMethod2(bits2, padding, "hex");
        method2.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        return createOutputMethods(method2, createOutputMethod2, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method2 = createShakeOutputMethod(bits2, padding, "hex");
        method2.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method2.update = function(message, outputBits) {
          return method2.create(outputBits).update(message);
        };
        return createOutputMethods(method2, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method2 = createCshakeOutputMethod(bits2, padding, "hex");
        method2.create = function(outputBits, n, s) {
          if (!n && !s) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
          }
        };
        method2.update = function(message, outputBits, n, s) {
          return method2.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method2, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method2 = createKmacOutputMethod(bits2, padding, "hex");
        method2.create = function(key, outputBits, s) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method2.update = function(key, message, outputBits, s) {
          return method2.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method2, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod2 },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod: createMethod2 },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm2 = algorithms[i];
        var bits = algorithm2.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm2.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm2.createMethod(bits[j], algorithm2.padding);
          if (algorithm2.name !== "sha3") {
            var newMethodName = algorithm2.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks2 = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks2[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks2[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks2[i2 >> 2] |= message[index] << SHIFT2[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i2 >> 2] |= code << SHIFT2[i2++ & 3];
              } else if (code < 2048) {
                blocks2[i2 >> 2] |= (192 | code >> 6) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT2[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i2 >> 2] |= (224 | code >> 12) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT2[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i2 >> 2] |= (240 | code >> 18) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT2[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks2[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks2[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER2 && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks2[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks2[0] = blocks2[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks2[i2] = 0;
          }
        }
        blocks2[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks2[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15] + HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15] + HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15] + HEX_CHARS2[block >> 28 & 15] + HEX_CHARS2[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS2) {
        module2.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root2[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD2) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/algosdk/dist/cjs/src/logicTemplates/htlc.js
var require_htlc = __commonJS({
  "node_modules/algosdk/dist/cjs/src/logicTemplates/htlc.js"(exports2, module2) {
    var sha256 = require_sha256();
    var { keccak256 } = require_sha3();
    var logic = require_logic();
    var logicSig = require_logicsig();
    var templates = require_templates();
    var transaction = require_transaction();
    var HTLC = class {
      constructor(owner, receiver, hashFunction, hashImage, expiryRound, maxFee) {
        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
          throw Error("expiryRound must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(maxFee) || maxFee < 0)
          throw Error("maxFee must be a positive number and smaller than 2^53-1");
        let referenceProgramB64 = "";
        if (hashFunction === "sha256") {
          referenceProgramB64 = "ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQEpEhAxCSoSMQIlDRAREA==";
        } else if (hashFunction === "keccak256") {
          referenceProgramB64 = "ASAECAEACSYDIOaalh5vLV96yGYHkmVSvpgjXtMzY8qIkYu5yTipFbb5IH+DsWV/8fxTuS3BgUih1l38LUsfo9Z3KErd0gASbZBpIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMQEiDjEQIxIQMQcyAxIQMQgkEhAxCSgSLQIpEhAxCSoSMQIlDRAREA==";
        } else {
          throw Error("hash function unrecognized");
        }
        const hashImageBytes = Buffer.from(hashImage, "base64");
        if (hashImageBytes.length !== 32)
          throw Error("hash image must be 32 bytes");
        const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
        const referenceOffsets = [
          3,
          6,
          10,
          42,
          76
        ];
        const injectionVector = [maxFee, expiryRound, receiver, hashImage, owner];
        const injectionTypes = [
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.ADDRESS,
          templates.valTypes.BASE64,
          templates.valTypes.ADDRESS
        ];
        const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
        this.programBytes = injectedBytes;
        const lsig = new logicSig.LogicSig(injectedBytes, void 0);
        this.address = lsig.address();
      }
      getProgram() {
        return this.programBytes;
      }
      getAddress() {
        return this.address;
      }
    };
    function signTransactionWithHTLCUnlock(contract, txn, preImageAsBase64) {
      const preImageBytes = Buffer.from(preImageAsBase64, "base64");
      const readResult = logic.readProgram(contract, void 0);
      const ints = readResult[0];
      const byteArrays = readResult[1];
      const expectedHashedOutput = byteArrays[1];
      const hashFunction = contract[contract.length - 15];
      if (hashFunction === 1) {
        const hash = sha256.create();
        hash.update(preImageBytes);
        const actualHashedOutput = Buffer.from(hash.hex(), "hex");
        if (!actualHashedOutput.equals(expectedHashedOutput)) {
          throw new Error("sha256 hash of preimage did not match stored contract hash");
        }
      } else if (hashFunction === 2) {
        const hash = keccak256.create();
        hash.update(preImageBytes);
        const actualHashedOutput = Buffer.from(hash.hex(), "hex");
        if (!actualHashedOutput.equals(expectedHashedOutput)) {
          throw new Error("keccak256 hash of preimage did not match stored contract hash");
        }
      } else {
        throw new Error("hash function in contract unrecognized");
      }
      const args = [preImageBytes];
      const lsig = new logicSig.LogicSig(contract, args);
      delete txn.to;
      const maxFee = ints[0];
      const tempTxn = new transaction.Transaction(txn);
      if (tempTxn.fee > maxFee) {
        throw new Error(`final fee of payment transaction${tempTxn.fee.toString()}greater than transaction max fee${maxFee.toString()}`);
      }
      return logicSig.signLogicSigTransaction(txn, lsig);
    }
    module2.exports = {
      HTLC,
      signTransactionWithHTLCUnlock
    };
  }
});

// node_modules/algosdk/dist/cjs/src/types/transactions/encoded.js
var require_encoded = __commonJS({
  "node_modules/algosdk/dist/cjs/src/types/transactions/encoded.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/algosdk/dist/cjs/src/types/transactions/index.js
var require_transactions = __commonJS({
  "node_modules/algosdk/dist/cjs/src/types/transactions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransactionType = void 0;
    var base_1 = require_base();
    Object.defineProperty(exports2, "TransactionType", { enumerable: true, get: function() {
      return base_1.TransactionType;
    } });
    __exportStar(require_encoded(), exports2);
  }
});

// node_modules/algosdk/dist/cjs/src/makeTxn.js
var require_makeTxn = __commonJS({
  "node_modules/algosdk/dist/cjs/src/makeTxn.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeApplicationCallTxnFromObject = exports2.OnApplicationComplete = exports2.makeApplicationNoOpTxnFromObject = exports2.makeApplicationNoOpTxn = exports2.makeApplicationClearStateTxnFromObject = exports2.makeApplicationClearStateTxn = exports2.makeApplicationCloseOutTxnFromObject = exports2.makeApplicationCloseOutTxn = exports2.makeApplicationOptInTxnFromObject = exports2.makeApplicationOptInTxn = exports2.makeApplicationDeleteTxnFromObject = exports2.makeApplicationDeleteTxn = exports2.makeApplicationUpdateTxnFromObject = exports2.makeApplicationUpdateTxn = exports2.makeApplicationCreateTxnFromObject = exports2.makeApplicationCreateTxn = exports2.makeAssetTransferTxnWithSuggestedParamsFromObject = exports2.makeAssetTransferTxn = exports2.makeAssetTransferTxnWithSuggestedParams = exports2.makeAssetFreezeTxnWithSuggestedParamsFromObject = exports2.makeAssetFreezeTxn = exports2.makeAssetFreezeTxnWithSuggestedParams = exports2.makeAssetDestroyTxnWithSuggestedParamsFromObject = exports2.makeAssetDestroyTxn = exports2.makeAssetDestroyTxnWithSuggestedParams = exports2.makeAssetConfigTxnWithSuggestedParamsFromObject = exports2.makeAssetConfigTxn = exports2.makeAssetConfigTxnWithSuggestedParams = exports2.makeAssetCreateTxnWithSuggestedParamsFromObject = exports2.makeAssetCreateTxn = exports2.makeAssetCreateTxnWithSuggestedParams = exports2.makeKeyRegistrationTxnWithSuggestedParamsFromObject = exports2.makeKeyRegistrationTxn = exports2.makeKeyRegistrationTxnWithSuggestedParams = exports2.makePaymentTxnWithSuggestedParamsFromObject = exports2.makePaymentTxn = exports2.makePaymentTxnWithSuggestedParams = void 0;
    var txnBuilder = __importStar(require_transaction());
    var base_1 = require_base();
    var transactions_1 = require_transactions();
    function makePaymentTxnWithSuggestedParams(from, to, amount, closeRemainderTo, note, suggestedParams, rekeyTo) {
      const o = {
        from,
        to,
        amount,
        closeRemainderTo,
        note,
        suggestedParams,
        type: transactions_1.TransactionType.pay,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makePaymentTxnWithSuggestedParams = makePaymentTxnWithSuggestedParams;
    function makePaymentTxn(from, to, fee, amount, closeRemainderTo, firstRound, lastRound, note, genesisHash, genesisID, rekeyTo) {
      const suggestedParams = {
        genesisHash,
        genesisID,
        firstRound,
        lastRound,
        fee
      };
      return makePaymentTxnWithSuggestedParams(from, to, amount, closeRemainderTo, note, suggestedParams, rekeyTo);
    }
    exports2.makePaymentTxn = makePaymentTxn;
    function makePaymentTxnWithSuggestedParamsFromObject(o) {
      return makePaymentTxnWithSuggestedParams(o.from, o.to, o.amount, o.closeRemainderTo, o.note, o.suggestedParams, o.rekeyTo);
    }
    exports2.makePaymentTxnWithSuggestedParamsFromObject = makePaymentTxnWithSuggestedParamsFromObject;
    function makeKeyRegistrationTxnWithSuggestedParams(from, note, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, suggestedParams, rekeyTo, nonParticipation = false, stateProofKey = void 0) {
      const o = {
        from,
        note,
        voteKey,
        selectionKey,
        voteFirst,
        voteLast,
        voteKeyDilution,
        suggestedParams,
        type: transactions_1.TransactionType.keyreg,
        reKeyTo: rekeyTo,
        nonParticipation,
        stateProofKey
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeKeyRegistrationTxnWithSuggestedParams = makeKeyRegistrationTxnWithSuggestedParams;
    function makeKeyRegistrationTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, rekeyTo, nonParticipation = false, stateProofKey = void 0) {
      const suggestedParams = {
        genesisHash,
        genesisID,
        firstRound,
        lastRound,
        fee
      };
      return makeKeyRegistrationTxnWithSuggestedParams(from, note, voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution, suggestedParams, rekeyTo, nonParticipation, stateProofKey);
    }
    exports2.makeKeyRegistrationTxn = makeKeyRegistrationTxn;
    function makeKeyRegistrationTxnWithSuggestedParamsFromObject(o) {
      return makeKeyRegistrationTxnWithSuggestedParams(o.from, o.note, o.voteKey, o.selectionKey, o.voteFirst, o.voteLast, o.voteKeyDilution, o.suggestedParams, o.rekeyTo, o.nonParticipation, o.stateProofKey);
    }
    exports2.makeKeyRegistrationTxnWithSuggestedParamsFromObject = makeKeyRegistrationTxnWithSuggestedParamsFromObject;
    function makeAssetCreateTxnWithSuggestedParams(from, note, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, suggestedParams, rekeyTo) {
      const o = {
        from,
        note,
        suggestedParams,
        assetTotal: total,
        assetDecimals: decimals,
        assetDefaultFrozen: defaultFrozen,
        assetUnitName: unitName,
        assetName,
        assetURL,
        assetMetadataHash,
        assetManager: manager,
        assetReserve: reserve,
        assetFreeze: freeze,
        assetClawback: clawback,
        type: transactions_1.TransactionType.acfg,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeAssetCreateTxnWithSuggestedParams = makeAssetCreateTxnWithSuggestedParams;
    function makeAssetCreateTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, rekeyTo) {
      const suggestedParams = {
        genesisHash,
        genesisID,
        firstRound,
        lastRound,
        fee
      };
      return makeAssetCreateTxnWithSuggestedParams(from, note, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, suggestedParams, rekeyTo);
    }
    exports2.makeAssetCreateTxn = makeAssetCreateTxn;
    function makeAssetCreateTxnWithSuggestedParamsFromObject(o) {
      return makeAssetCreateTxnWithSuggestedParams(o.from, o.note, o.total, o.decimals, o.defaultFrozen, o.manager, o.reserve, o.freeze, o.clawback, o.unitName, o.assetName, o.assetURL, o.assetMetadataHash, o.suggestedParams, o.rekeyTo);
    }
    exports2.makeAssetCreateTxnWithSuggestedParamsFromObject = makeAssetCreateTxnWithSuggestedParamsFromObject;
    function makeAssetConfigTxnWithSuggestedParams(from, note, assetIndex, manager, reserve, freeze, clawback, suggestedParams, strictEmptyAddressChecking = true, rekeyTo) {
      if (strictEmptyAddressChecking && (manager === void 0 || reserve === void 0 || freeze === void 0 || clawback === void 0)) {
        throw Error("strict empty address checking was turned on, but at least one empty address was provided");
      }
      const o = {
        from,
        suggestedParams,
        assetIndex,
        assetManager: manager,
        assetReserve: reserve,
        assetFreeze: freeze,
        assetClawback: clawback,
        type: transactions_1.TransactionType.acfg,
        note,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeAssetConfigTxnWithSuggestedParams = makeAssetConfigTxnWithSuggestedParams;
    function makeAssetConfigTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, manager, reserve, freeze, clawback, strictEmptyAddressChecking = true, rekeyTo) {
      const suggestedParams = {
        genesisHash,
        genesisID,
        firstRound,
        lastRound,
        fee
      };
      return makeAssetConfigTxnWithSuggestedParams(from, note, assetIndex, manager, reserve, freeze, clawback, suggestedParams, strictEmptyAddressChecking, rekeyTo);
    }
    exports2.makeAssetConfigTxn = makeAssetConfigTxn;
    function makeAssetConfigTxnWithSuggestedParamsFromObject(o) {
      return makeAssetConfigTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.manager, o.reserve, o.freeze, o.clawback, o.suggestedParams, o.strictEmptyAddressChecking, o.rekeyTo);
    }
    exports2.makeAssetConfigTxnWithSuggestedParamsFromObject = makeAssetConfigTxnWithSuggestedParamsFromObject;
    function makeAssetDestroyTxnWithSuggestedParams(from, note, assetIndex, suggestedParams, rekeyTo) {
      const o = {
        from,
        suggestedParams,
        assetIndex,
        type: transactions_1.TransactionType.acfg,
        note,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeAssetDestroyTxnWithSuggestedParams = makeAssetDestroyTxnWithSuggestedParams;
    function makeAssetDestroyTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, rekeyTo) {
      const suggestedParams = {
        genesisHash,
        genesisID,
        firstRound,
        lastRound,
        fee
      };
      return makeAssetDestroyTxnWithSuggestedParams(from, note, assetIndex, suggestedParams, rekeyTo);
    }
    exports2.makeAssetDestroyTxn = makeAssetDestroyTxn;
    function makeAssetDestroyTxnWithSuggestedParamsFromObject(o) {
      return makeAssetDestroyTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
    }
    exports2.makeAssetDestroyTxnWithSuggestedParamsFromObject = makeAssetDestroyTxnWithSuggestedParamsFromObject;
    function makeAssetFreezeTxnWithSuggestedParams(from, note, assetIndex, freezeTarget, freezeState, suggestedParams, rekeyTo) {
      const o = {
        from,
        type: transactions_1.TransactionType.afrz,
        freezeAccount: freezeTarget,
        assetIndex,
        freezeState,
        note,
        suggestedParams,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeAssetFreezeTxnWithSuggestedParams = makeAssetFreezeTxnWithSuggestedParams;
    function makeAssetFreezeTxn(from, fee, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, freezeTarget, freezeState, rekeyTo) {
      const suggestedParams = {
        genesisHash,
        genesisID,
        firstRound,
        lastRound,
        fee
      };
      return makeAssetFreezeTxnWithSuggestedParams(from, note, assetIndex, freezeTarget, freezeState, suggestedParams, rekeyTo);
    }
    exports2.makeAssetFreezeTxn = makeAssetFreezeTxn;
    function makeAssetFreezeTxnWithSuggestedParamsFromObject(o) {
      return makeAssetFreezeTxnWithSuggestedParams(o.from, o.note, o.assetIndex, o.freezeTarget, o.freezeState, o.suggestedParams, o.rekeyTo);
    }
    exports2.makeAssetFreezeTxnWithSuggestedParamsFromObject = makeAssetFreezeTxnWithSuggestedParamsFromObject;
    function makeAssetTransferTxnWithSuggestedParams(from, to, closeRemainderTo, revocationTarget, amount, note, assetIndex, suggestedParams, rekeyTo) {
      const o = {
        type: transactions_1.TransactionType.axfer,
        from,
        to,
        amount,
        suggestedParams,
        assetIndex,
        note,
        assetRevocationTarget: revocationTarget,
        closeRemainderTo,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeAssetTransferTxnWithSuggestedParams = makeAssetTransferTxnWithSuggestedParams;
    function makeAssetTransferTxn(from, to, closeRemainderTo, revocationTarget, fee, amount, firstRound, lastRound, note, genesisHash, genesisID, assetIndex, rekeyTo) {
      const suggestedParams = {
        genesisHash,
        genesisID,
        firstRound,
        lastRound,
        fee
      };
      return makeAssetTransferTxnWithSuggestedParams(from, to, closeRemainderTo, revocationTarget, amount, note, assetIndex, suggestedParams, rekeyTo);
    }
    exports2.makeAssetTransferTxn = makeAssetTransferTxn;
    function makeAssetTransferTxnWithSuggestedParamsFromObject(o) {
      return makeAssetTransferTxnWithSuggestedParams(o.from, o.to, o.closeRemainderTo, o.revocationTarget, o.amount, o.note, o.assetIndex, o.suggestedParams, o.rekeyTo);
    }
    exports2.makeAssetTransferTxnWithSuggestedParamsFromObject = makeAssetTransferTxnWithSuggestedParamsFromObject;
    function makeApplicationCreateTxn(from, suggestedParams, onComplete, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo, extraPages) {
      const o = {
        type: transactions_1.TransactionType.appl,
        from,
        suggestedParams,
        appIndex: 0,
        appOnComplete: onComplete,
        appLocalInts: numLocalInts,
        appLocalByteSlices: numLocalByteSlices,
        appGlobalInts: numGlobalInts,
        appGlobalByteSlices: numGlobalByteSlices,
        appApprovalProgram: approvalProgram,
        appClearProgram: clearProgram,
        appArgs,
        appAccounts: accounts,
        appForeignApps: foreignApps,
        appForeignAssets: foreignAssets,
        note,
        lease,
        reKeyTo: rekeyTo,
        extraPages
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeApplicationCreateTxn = makeApplicationCreateTxn;
    function makeApplicationCreateTxnFromObject(o) {
      return makeApplicationCreateTxn(o.from, o.suggestedParams, o.onComplete, o.approvalProgram, o.clearProgram, o.numLocalInts, o.numLocalByteSlices, o.numGlobalInts, o.numGlobalByteSlices, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo, o.extraPages);
    }
    exports2.makeApplicationCreateTxnFromObject = makeApplicationCreateTxnFromObject;
    function makeApplicationUpdateTxn(from, suggestedParams, appIndex, approvalProgram, clearProgram, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
      const o = {
        type: transactions_1.TransactionType.appl,
        from,
        suggestedParams,
        appIndex,
        appApprovalProgram: approvalProgram,
        appOnComplete: base_1.OnApplicationComplete.UpdateApplicationOC,
        appClearProgram: clearProgram,
        appArgs,
        appAccounts: accounts,
        appForeignApps: foreignApps,
        appForeignAssets: foreignAssets,
        note,
        lease,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeApplicationUpdateTxn = makeApplicationUpdateTxn;
    function makeApplicationUpdateTxnFromObject(o) {
      return makeApplicationUpdateTxn(o.from, o.suggestedParams, o.appIndex, o.approvalProgram, o.clearProgram, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
    }
    exports2.makeApplicationUpdateTxnFromObject = makeApplicationUpdateTxnFromObject;
    function makeApplicationDeleteTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
      const o = {
        type: transactions_1.TransactionType.appl,
        from,
        suggestedParams,
        appIndex,
        appOnComplete: base_1.OnApplicationComplete.DeleteApplicationOC,
        appArgs,
        appAccounts: accounts,
        appForeignApps: foreignApps,
        appForeignAssets: foreignAssets,
        note,
        lease,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeApplicationDeleteTxn = makeApplicationDeleteTxn;
    function makeApplicationDeleteTxnFromObject(o) {
      return makeApplicationDeleteTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
    }
    exports2.makeApplicationDeleteTxnFromObject = makeApplicationDeleteTxnFromObject;
    function makeApplicationOptInTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
      const o = {
        type: transactions_1.TransactionType.appl,
        from,
        suggestedParams,
        appIndex,
        appOnComplete: base_1.OnApplicationComplete.OptInOC,
        appArgs,
        appAccounts: accounts,
        appForeignApps: foreignApps,
        appForeignAssets: foreignAssets,
        note,
        lease,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeApplicationOptInTxn = makeApplicationOptInTxn;
    function makeApplicationOptInTxnFromObject(o) {
      return makeApplicationOptInTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
    }
    exports2.makeApplicationOptInTxnFromObject = makeApplicationOptInTxnFromObject;
    function makeApplicationCloseOutTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
      const o = {
        type: transactions_1.TransactionType.appl,
        from,
        suggestedParams,
        appIndex,
        appOnComplete: base_1.OnApplicationComplete.CloseOutOC,
        appArgs,
        appAccounts: accounts,
        appForeignApps: foreignApps,
        appForeignAssets: foreignAssets,
        note,
        lease,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeApplicationCloseOutTxn = makeApplicationCloseOutTxn;
    function makeApplicationCloseOutTxnFromObject(o) {
      return makeApplicationCloseOutTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
    }
    exports2.makeApplicationCloseOutTxnFromObject = makeApplicationCloseOutTxnFromObject;
    function makeApplicationClearStateTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
      const o = {
        type: transactions_1.TransactionType.appl,
        from,
        suggestedParams,
        appIndex,
        appOnComplete: base_1.OnApplicationComplete.ClearStateOC,
        appArgs,
        appAccounts: accounts,
        appForeignApps: foreignApps,
        appForeignAssets: foreignAssets,
        note,
        lease,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeApplicationClearStateTxn = makeApplicationClearStateTxn;
    function makeApplicationClearStateTxnFromObject(o) {
      return makeApplicationClearStateTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
    }
    exports2.makeApplicationClearStateTxnFromObject = makeApplicationClearStateTxnFromObject;
    function makeApplicationNoOpTxn(from, suggestedParams, appIndex, appArgs, accounts, foreignApps, foreignAssets, note, lease, rekeyTo) {
      const o = {
        type: transactions_1.TransactionType.appl,
        from,
        suggestedParams,
        appIndex,
        appOnComplete: base_1.OnApplicationComplete.NoOpOC,
        appArgs,
        appAccounts: accounts,
        appForeignApps: foreignApps,
        appForeignAssets: foreignAssets,
        note,
        lease,
        reKeyTo: rekeyTo
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeApplicationNoOpTxn = makeApplicationNoOpTxn;
    function makeApplicationNoOpTxnFromObject(o) {
      return makeApplicationNoOpTxn(o.from, o.suggestedParams, o.appIndex, o.appArgs, o.accounts, o.foreignApps, o.foreignAssets, o.note, o.lease, o.rekeyTo);
    }
    exports2.makeApplicationNoOpTxnFromObject = makeApplicationNoOpTxnFromObject;
    var base_2 = require_base();
    Object.defineProperty(exports2, "OnApplicationComplete", { enumerable: true, get: function() {
      return base_2.OnApplicationComplete;
    } });
    function makeApplicationCallTxnFromObject(options) {
      const o = {
        type: transactions_1.TransactionType.appl,
        from: options.from,
        suggestedParams: options.suggestedParams,
        appIndex: options.appIndex,
        appOnComplete: options.onComplete,
        appLocalInts: options.numLocalInts,
        appLocalByteSlices: options.numLocalByteSlices,
        appGlobalInts: options.numGlobalInts,
        appGlobalByteSlices: options.numGlobalByteSlices,
        appApprovalProgram: options.approvalProgram,
        appClearProgram: options.clearProgram,
        appArgs: options.appArgs,
        appAccounts: options.accounts,
        appForeignApps: options.foreignApps,
        appForeignAssets: options.foreignAssets,
        note: options.note,
        lease: options.lease,
        reKeyTo: options.rekeyTo,
        extraPages: options.extraPages
      };
      return new txnBuilder.Transaction(o);
    }
    exports2.makeApplicationCallTxnFromObject = makeApplicationCallTxnFromObject;
  }
});

// node_modules/algosdk/dist/cjs/src/logicTemplates/limitorder.js
var require_limitorder = __commonJS({
  "node_modules/algosdk/dist/cjs/src/logicTemplates/limitorder.js"(exports2, module2) {
    var address = require_address();
    var makeTxn = require_makeTxn();
    var group = require_group();
    var logic = require_logic();
    var logicSig = require_logicsig();
    var nacl = require_naclWrappers();
    var templates = require_templates();
    var utils = require_utils();
    var LimitOrder = class {
      constructor(owner, assetid, ratn, ratd, expiryRound, minTrade, maxFee) {
        if (!Number.isSafeInteger(assetid) || assetid < 0)
          throw Error("assetid must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(ratn) || ratn < 0)
          throw Error("ratn must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(ratd) || ratd < 0)
          throw Error("ratd must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
          throw Error("expiryRound must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(minTrade) || minTrade < 0)
          throw Error("minTrade must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(maxFee) || maxFee < 0)
          throw Error("maxFee must be a positive number and smaller than 2^53-1");
        const referenceProgramB64 = "ASAKAAEFAgYEBwgJCiYBIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMRYiEjEQIxIQMQEkDhAyBCMSQABVMgQlEjEIIQQNEDEJMgMSEDMBECEFEhAzAREhBhIQMwEUKBIQMwETMgMSEDMBEiEHHTUCNQExCCEIHTUENQM0ATQDDUAAJDQBNAMSNAI0BA8QQAAWADEJKBIxAiEJDRAxBzIDEhAxCCISEBA=";
        const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
        const referenceOffsets = [
          5,
          7,
          9,
          10,
          11,
          12,
          16
        ];
        const injectionVector = [
          maxFee,
          minTrade,
          assetid,
          ratd,
          ratn,
          expiryRound,
          owner
        ];
        const injectionTypes = [
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.ADDRESS
        ];
        const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
        this.programBytes = injectedBytes;
        const lsig = new logicSig.LogicSig(injectedBytes, void 0);
        this.address = lsig.address();
        this.owner = owner;
        this.assetid = assetid;
      }
      getProgram() {
        return this.programBytes;
      }
      getAddress() {
        return this.address;
      }
    };
    function getSwapAssetsTransaction(contract, assetAmount, microAlgoAmount, secretKey, fee, firstRound, lastRound, genesisHash) {
      const buyerKeyPair = nacl.keyPairFromSecretKey(secretKey);
      const buyerAddr = address.encodeAddress(buyerKeyPair.publicKey);
      const programOutputs = logic.readProgram(contract, void 0);
      const ints = programOutputs[0];
      const byteArrays = programOutputs[1];
      let noCloseRemainder;
      let noAssetRevocationTarget;
      const contractAssetID = ints[6];
      const contractOwner = address.encodeAddress(byteArrays[0]);
      const lsig = logicSig.makeLogicSig(contract, void 0);
      const contractAddress = lsig.address();
      const algosForAssets = makeTxn.makePaymentTxn(contractAddress, buyerAddr, fee, microAlgoAmount, noCloseRemainder, firstRound, lastRound, void 0, genesisHash, void 0);
      const assetsForAlgos = makeTxn.makeAssetTransferTxn(buyerAddr, contractOwner, noCloseRemainder, noAssetRevocationTarget, fee, assetAmount, firstRound, lastRound, void 0, genesisHash, void 0, contractAssetID);
      const txns = [algosForAssets, assetsForAlgos];
      const txGroup = group.assignGroupID(txns);
      const ratd = ints[7];
      const ratn = ints[8];
      if (assetAmount * ratd < microAlgoAmount * ratn) {
        throw new Error(`bad payment ratio, ${assetAmount.toString()}*${ratd.toString()} !>= ${microAlgoAmount.toString()}*${ratn.toString()}`);
      }
      const minTrade = ints[4];
      if (microAlgoAmount < minTrade) {
        throw new Error(`payment amount ${microAlgoAmount.toString()} less than minimum trade ${minTrade.toString()}`);
      }
      const maxFee = ints[2];
      if (txGroup[0].fee > maxFee) {
        throw new Error(`final fee of payment transaction ${txGroup[0].fee.toString()} greater than transaction max fee ${maxFee.toString()}`);
      }
      if (txGroup[1].fee > maxFee) {
        throw new Error(`final fee of asset transaction ${txGroup[1].fee.toString()} greater than transaction max fee ${maxFee.toString()}`);
      }
      const algosForAssetsSigned = logicSig.signLogicSigTransactionObject(txGroup[0], lsig);
      const assetsForAlgosSigned = txGroup[1].signTxn(secretKey);
      return utils.concatArrays(algosForAssetsSigned.blob, assetsForAlgosSigned);
    }
    module2.exports = {
      LimitOrder,
      getSwapAssetsTransaction
    };
  }
});

// node_modules/algosdk/dist/cjs/src/logicTemplates/split.js
var require_split = __commonJS({
  "node_modules/algosdk/dist/cjs/src/logicTemplates/split.js"(exports2, module2) {
    var address = require_address();
    var makeTxn = require_makeTxn();
    var group = require_group();
    var logicsig = require_logicsig();
    var logic = require_logic();
    var templates = require_templates();
    var utils = require_utils();
    var Split = class {
      constructor(owner, receiverOne, receiverTwo, rat1, rat2, expiryRound, minPay, maxFee) {
        if (!Number.isSafeInteger(rat2) || rat2 < 0)
          throw Error("rat2 must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(rat1) || rat1 < 0)
          throw Error("rat1 must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
          throw Error("expiryRound must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(minPay) || minPay < 0)
          throw Error("minPay must be a positive number and smaller than 2^53-1");
        if (!Number.isSafeInteger(maxFee) || maxFee < 0)
          throw Error("maxFee must be a positive number and smaller than 2^53-1");
        const referenceProgramB64 = "ASAIAQUCAAYHCAkmAyCztwQn0+DycN+vsk+vJWcsoz/b7NDS6i33HOkvTpf+YiC3qUpIgHGWE8/1LPh9SGCalSN7IaITeeWSXbfsS5wsXyC4kBQ38Z8zcwWVAym4S8vpFB/c0XC6R4mnPi9EBADsPDEQIhIxASMMEDIEJBJAABkxCSgSMQcyAxIQMQglEhAxAiEEDRAiQAAuMwAAMwEAEjEJMgMSEDMABykSEDMBByoSEDMACCEFCzMBCCEGCxIQMwAIIQcPEBA=";
        const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
        const referenceOffsets = [
          4,
          7,
          8,
          9,
          10,
          14,
          47,
          80
        ];
        const injectionVector = [
          maxFee,
          expiryRound,
          rat2,
          rat1,
          minPay,
          owner,
          receiverOne,
          receiverTwo
        ];
        const injectionTypes = [
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.ADDRESS,
          templates.valTypes.ADDRESS,
          templates.valTypes.ADDRESS
        ];
        const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
        this.programBytes = injectedBytes;
        const lsig = logicsig.makeLogicSig(injectedBytes, void 0);
        this.address = lsig.address();
      }
      getProgram() {
        return this.programBytes;
      }
      getAddress() {
        return this.address;
      }
    };
    function getSplitFundsTransaction(contract, amount, firstRound, lastRound, fee, genesisHash) {
      const programOutputs = logic.readProgram(contract, void 0);
      const ints = programOutputs[0];
      const byteArrays = programOutputs[1];
      let rat2 = ints[6];
      let rat1 = ints[5];
      let amountForReceiverOne = 0;
      const gcdFn = (a, b) => {
        if (typeof a !== "number" || typeof b !== "number")
          throw new Error("gcd operates only on positive integers");
        if (!b) {
          return a;
        }
        return gcdFn(b, a % b);
      };
      const gcd = gcdFn(rat2, rat1);
      rat2 = Math.floor(rat2 / gcd);
      rat1 = Math.floor(rat1 / gcd);
      const ratio = rat1 / rat2;
      amountForReceiverOne = Math.round(amount / (1 + ratio));
      const amountForReceiverTwo = amount - amountForReceiverOne;
      if (rat1 * amountForReceiverOne !== rat2 * amountForReceiverTwo) {
        throw Error("could not split funds in a way that satisfied the contract ratio");
      }
      const logicSig = logicsig.makeLogicSig(contract, void 0);
      const from = logicSig.address();
      const receiverOne = address.encodeAddress(byteArrays[1]);
      const receiverTwo = address.encodeAddress(byteArrays[2]);
      const tx1 = makeTxn.makePaymentTxn(from, receiverOne, fee, amountForReceiverOne, void 0, firstRound, lastRound, void 0, genesisHash);
      const tx2 = makeTxn.makePaymentTxn(from, receiverTwo, fee, amountForReceiverTwo, void 0, firstRound, lastRound, void 0, genesisHash);
      const txns = [tx1, tx2];
      const txGroup = group.assignGroupID(txns);
      const signedTxns = txGroup.map((txn) => logicsig.signLogicSigTransactionObject(txn, logicsig).blob);
      return utils.concatArrays(signedTxns[0], signedTxns[1]);
    }
    module2.exports = {
      Split,
      getSplitFundsTransaction
    };
  }
});

// node_modules/algosdk/dist/cjs/src/logicTemplates/periodicpayment.js
var require_periodicpayment = __commonJS({
  "node_modules/algosdk/dist/cjs/src/logicTemplates/periodicpayment.js"(exports2, module2) {
    var address = require_address();
    var makeTxn = require_makeTxn();
    var logic = require_logic();
    var logicSig = require_logicsig();
    var nacl = require_naclWrappers();
    var templates = require_templates();
    var PeriodicPayment = class {
      constructor(receiver, amount, withdrawalWindow, period, expiryRound, maxFee, lease) {
        this.receiver = receiver;
        if (!Number.isSafeInteger(amount) || amount < 0)
          throw Error("amount must be a positive number and smaller than 2^53-1");
        this.amount = amount;
        if (!Number.isSafeInteger(withdrawalWindow) || withdrawalWindow < 0)
          throw Error("withdrawalWindow must be a positive number and smaller than 2^53-1");
        this.withdrawalWindow = withdrawalWindow;
        if (!Number.isSafeInteger(period) || period < 0)
          throw Error("period must be a positive number and smaller than 2^53-1");
        this.period = period;
        if (!Number.isSafeInteger(expiryRound) || expiryRound < 0)
          throw Error("expiryRound must be a positive number and smaller than 2^53-1");
        this.expiryRound = expiryRound;
        if (!Number.isSafeInteger(maxFee) || maxFee < 0)
          throw Error("maxFee must be a positive number and smaller than 2^53-1");
        this.maxFee = maxFee;
        if (lease === void 0) {
          const leaseBytes = nacl.randomBytes(32);
          this.lease = Buffer.from(leaseBytes).toString("base64");
        } else {
          this.lease = lease;
        }
        this.programBytes = this.getProgram();
        const lsig = new logicSig.LogicSig(this.programBytes, void 0);
        this.address = lsig.address();
      }
      getProgram() {
        const referenceProgramB64 = "ASAHAQYFAAQDByYCIAECAwQFBgcIAQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIIJKvkYTkEzwJf2arzJOxERsSogG9nQzKPkpIoc4TzPTFMRAiEjEBIw4QMQIkGCUSEDEEIQQxAggSEDEGKBIQMQkyAxIxBykSEDEIIQUSEDEJKRIxBzIDEhAxAiEGDRAxCCUSEBEQ";
        const referenceProgramBytes = Buffer.from(referenceProgramB64, "base64");
        const referenceOffsets = [
          4,
          5,
          7,
          8,
          9,
          12,
          46
        ];
        const injectionVector = [
          this.maxFee,
          this.period,
          this.withdrawalWindow,
          this.amount,
          this.expiryRound,
          this.lease,
          this.receiver
        ];
        const injectionTypes = [
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.INT,
          templates.valTypes.BASE64,
          templates.valTypes.ADDRESS
        ];
        return templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);
      }
      getAddress() {
        return this.address;
      }
    };
    function getPeriodicPaymentWithdrawalTransaction(contract, fee, firstValid, genesisHash) {
      const readResult = logic.readProgram(contract, void 0);
      const ints = readResult[0];
      const byteArrays = readResult[1];
      const period = ints[2];
      const duration = ints[4];
      const amount = ints[5];
      if (firstValid % period !== 0) {
        throw new Error(`firstValid round ${firstValid.toString()} was not a multiple of contract period ${period.toString()}`);
      }
      const receiverBytes = byteArrays[1];
      const receiver = address.encodeAddress(receiverBytes);
      const leaseBuffer = byteArrays[0];
      const lease = new Uint8Array(leaseBuffer);
      const lastValid = firstValid + duration;
      const to = receiver;
      let noCloseRemainder;
      let noNote;
      const lsig = logicSig.makeLogicSig(contract, void 0);
      const from = lsig.address();
      const txn = {
        from,
        to,
        fee,
        amount,
        closeRemainderTo: noCloseRemainder,
        firstRound: firstValid,
        lastRound: lastValid,
        note: noNote,
        genesisHash,
        genesisID: "",
        type: "pay",
        lease
      };
      const tempTxn = makeTxn.makePaymentTxn(from, to, fee, amount, noCloseRemainder, firstValid, lastValid, noNote, genesisHash, "");
      if (tempTxn.fee > ints[1]) {
        throw new Error(`final fee of payment transaction${tempTxn.fee.toString()}greater than transaction max fee${ints[1].toString()}`);
      }
      return logicSig.signLogicSigTransaction(txn, lsig);
    }
    module2.exports = {
      PeriodicPayment,
      getPeriodicPaymentWithdrawalTransaction
    };
  }
});

// node_modules/algosdk/dist/cjs/src/logicTemplates/index.js
var require_logicTemplates = __commonJS({
  "node_modules/algosdk/dist/cjs/src/logicTemplates/index.js"(exports2, module2) {
    var dynamicFeeTemplate = require_dynamicfee();
    var htlcTemplate = require_htlc();
    var limitOrderTemplate = require_limitorder();
    var splitTemplate = require_split();
    var periodicPayTemplate = require_periodicpayment();
    module2.exports = {
      DynamicFee: dynamicFeeTemplate.DynamicFee,
      getDynamicFeeTransactions: dynamicFeeTemplate.getDynamicFeeTransactions,
      signDynamicFee: dynamicFeeTemplate.signDynamicFee,
      HTLC: htlcTemplate.HTLC,
      signTransactionWithHTLCUnlock: htlcTemplate.signTransactionWithHTLCUnlock,
      LimitOrder: limitOrderTemplate.LimitOrder,
      getSwapAssetsTransaction: limitOrderTemplate.getSwapAssetsTransaction,
      Split: splitTemplate.Split,
      getSplitFundsTransaction: splitTemplate.getSplitFundsTransaction,
      PeriodicPayment: periodicPayTemplate.PeriodicPayment,
      getPeriodicPaymentWithdrawalTransaction: periodicPayTemplate.getPeriodicPaymentWithdrawalTransaction
    };
  }
});

// node_modules/algosdk/dist/cjs/src/bid.js
var require_bid = __commonJS({
  "node_modules/algosdk/dist/cjs/src/bid.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var address = __importStar(require_address());
    var encoding = __importStar(require_encoding());
    var nacl = __importStar(require_naclWrappers());
    var utils = __importStar(require_utils());
    var Bid = class {
      constructor({ bidderKey, bidAmount, bidID, auctionKey, auctionID, maxPrice }) {
        this.name = "Bid";
        this.tag = Buffer.from([97, 66]);
        const decodedBidderKey = address.decodeAddress(bidderKey);
        const decodedAuctionKey = address.decodeAddress(auctionKey);
        if (!Number.isSafeInteger(bidAmount) || bidAmount < 0)
          throw Error("Bid amount must be positive and 2^53-1");
        if (!Number.isSafeInteger(bidID) || bidID < 0)
          throw Error("BidID must be positive and 2^53-1");
        if (!Number.isSafeInteger(auctionID) || auctionID < 0)
          throw Error("auctionID must be positive");
        Object.assign(this, {
          bidderKey: decodedBidderKey,
          bidAmount,
          bidID,
          auctionKey: decodedAuctionKey,
          auctionID,
          maxPrice
        });
      }
      get_obj_for_encoding() {
        return {
          bidder: Buffer.from(this.bidderKey.publicKey),
          cur: this.bidAmount,
          price: this.maxPrice,
          id: this.bidID,
          auc: Buffer.from(this.auctionKey.publicKey),
          aid: this.auctionID
        };
      }
      signBid(sk) {
        const encodedMsg = encoding.encode(this.get_obj_for_encoding());
        const toBeSigned = Buffer.from(utils.concatArrays(this.tag, encodedMsg));
        const sig = nacl.sign(toBeSigned, sk);
        const sBid = {
          sig: Buffer.from(sig),
          bid: this.get_obj_for_encoding()
        };
        const note = {
          t: "b",
          b: sBid
        };
        return new Uint8Array(encoding.encode(note));
      }
    };
    exports2.default = Bid;
  }
});

// node_modules/algosdk/dist/cjs/src/convert.js
var require_convert = __commonJS({
  "node_modules/algosdk/dist/cjs/src/convert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.algosToMicroalgos = exports2.microalgosToAlgos = exports2.INVALID_MICROALGOS_ERROR_MSG = void 0;
    var MICROALGOS_TO_ALGOS_RATIO = 1e6;
    exports2.INVALID_MICROALGOS_ERROR_MSG = "Microalgos should be positive and less than 2^53 - 1.";
    function microalgosToAlgos(microalgos) {
      if (microalgos < 0 || !Number.isSafeInteger(microalgos)) {
        throw new Error(exports2.INVALID_MICROALGOS_ERROR_MSG);
      }
      return microalgos / MICROALGOS_TO_ALGOS_RATIO;
    }
    exports2.microalgosToAlgos = microalgosToAlgos;
    function algosToMicroalgos(algos) {
      const microalgos = algos * MICROALGOS_TO_ALGOS_RATIO;
      return Math.round(microalgos);
    }
    exports2.algosToMicroalgos = algosToMicroalgos;
  }
});

// node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "node_modules/requires-port/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "node_modules/querystringify/index.js"(exports2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty, undef;
    function decode2(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e) {
        return null;
      }
    }
    function encode2(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query)) {
        var key = decode2(part[1]), value = decode2(part[2]);
        if (key === null || value === null || key in result)
          continue;
        result[key] = value;
      }
      return result;
    }
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key;
      if (typeof prefix !== "string")
        prefix = "?";
      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key = encode2(key);
          value = encode2(value);
          if (key === null || value === null)
            continue;
          pairs.push(key + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    exports2.stringify = querystringify;
    exports2.parse = querystring;
  }
});

// node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "node_modules/url-parse/index.js"(exports2, module2) {
    "use strict";
    var required = require_requires_port(), qs = require_querystringify(), controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, CRHTLF = /[\n\r\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, port = /:\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      ["?", "query"],
      function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      ["@", "auth", 1],
      [NaN, "host", void 0, 1, 1],
      [/:(\d*)$/, "port", void 0, 1],
      [NaN, "hostname", void 0, 1, 1]
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined")
        globalVar = window;
      else if (typeof global !== "undefined")
        globalVar = global;
      else if (typeof self !== "undefined")
        globalVar = self;
      else
        globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type = typeof loc, key;
      if (loc.protocol === "blob:") {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if (type === "string") {
        finaldestination = new Url(loc, {});
        for (key in ignore)
          delete finaldestination[key];
      } else if (type === "object") {
        for (key in loc) {
          if (key in ignore)
            continue;
          finaldestination[key] = loc[key];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve(relative, base) {
      if (relative === "")
        return base;
      var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
      while (i--) {
        if (path[i] === ".") {
          path.splice(i, 1);
        } else if (path[i] === "..") {
          path.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0)
            unshift = true;
          path.splice(i, 1);
          up--;
        }
      }
      if (unshift)
        path.unshift("");
      if (last === "." || last === "..")
        path.push("");
      return path.join("/");
    }
    function Url(address, location, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }
      var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
      if (type !== "object" && type !== "string") {
        parser = location;
        location = null;
      }
      if (parser && typeof parser !== "function")
        parser = qs.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i < instructions.length; i++) {
        instruction = instructions[i];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse = instruction[0];
        key = instruction[1];
        if (parse !== parse) {
          url[key] = address;
        } else if (typeof parse === "string") {
          index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
          if (~index) {
            if (typeof instruction[2] === "number") {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse.exec(address)) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }
        url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
        if (instruction[4])
          url[key] = url[key].toLowerCase();
      }
      if (parser)
        url.query = parser(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if (typeof value === "string" && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port)
            value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];
        if (ins[4])
          url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString(stringify) {
      if (!stringify || typeof stringify !== "function")
        stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":")
        protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password)
          result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query = typeof url.query === "object" ? stringify(url.query) : url.query;
      if (query)
        result += query.charAt(0) !== "?" ? "?" + query : query;
      if (url.hash)
        result += url.hash;
      return result;
    }
    Url.prototype = { set, toString };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module2.exports = Url;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "node_modules/object-inspect/util.inspect.js"(exports2, module2) {
    module2.exports = require("util").inspect;
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var match = String.prototype.match;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    var inspectCustom = require_util_inspect().custom;
    var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
    var toStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag !== "undefined" ? Symbol.toStringTag : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        return String(obj);
      }
      if (typeof obj === "bigint") {
        return String(obj) + "n";
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = seen.slice();
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function") {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + keys.join(", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? String(obj).replace(/^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + String(obj.nodeName).toLowerCase() + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + xs.join(", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + parts.join(", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
          return obj[inspectSymbol]();
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? toStr(obj).slice(8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + [].concat(stringTag || [], protoTag || []).join(": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + ys.join(", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return String(s).replace(/"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
      }
      var s = str.replace(/(['\\])/g, "\\$1").replace(/[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + n.toString(16).toUpperCase();
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = Array(opts.indent + 1).join(" ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: Array(depth + 1).join(baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + xs.join("," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if (/[^\w$]/.test(key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode2 = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode2 = function encode3(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode: decode2,
      encode: encode2,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils2();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var stringify = function stringify2(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      if (sideChannel.has(object)) {
        throw new RangeError("Cyclic object value");
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = typeof key === "object" && key.value !== void 0 ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, true);
        var valueSideChannel = getSideChannel();
        pushToArray(values, stringify2(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && opts.encoder !== void 0 && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
            return options.decoder(encodedVal, defaults.decoder, charset, "value");
          });
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root2 = chain[i];
        if (root2 === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root2 !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify2();
    var parse = require_parse2();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports2, module2) {
    "use strict";
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/mime/types/other.js
var require_other = __commonJS({
  "node_modules/mime/types/other.js"(exports2, module2) {
    module2.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/index.js
var require_mime = __commonJS({
  "node_modules/mime/index.js"(exports2, module2) {
    "use strict";
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard(), require_other());
  }
});

// node_modules/methods/index.js
var require_methods = __commonJS({
  "node_modules/methods/index.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    module2.exports = getCurrentNodeMethods() || getBasicNodeMethods();
    function getCurrentNodeMethods() {
      return http.METHODS && http.METHODS.map(function lowerCaseMethod(method2) {
        return method2.toLowerCase();
      });
    }
    function getBasicNodeMethods() {
      return [
        "get",
        "post",
        "put",
        "head",
        "delete",
        "options",
        "trace",
        "copy",
        "lock",
        "mkcol",
        "move",
        "purge",
        "propfind",
        "proppatch",
        "unlock",
        "report",
        "mkactivity",
        "checkout",
        "merge",
        "m-search",
        "notify",
        "subscribe",
        "unsubscribe",
        "patch",
        "search",
        "connect"
      ];
    }
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana"
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana"
      },
      "image/avcs": {
        source: "iana"
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async(), abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort(), async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate(), initState = require_state(), terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate(), initState = require_state(), terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData;
    util.inherits(FormData, CombinedStream);
    function FormData(options) {
      if (!(this instanceof FormData)) {
        return new FormData(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData.LINE_BREAK = "\r\n";
    FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion"))) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
    };
    FormData.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
    };
    FormData.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err) {
          this._error(err);
          return;
        }
        request.setHeader("Content-Length", length);
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/formidable/lib/file.js
var require_file = __commonJS({
  "node_modules/formidable/lib/file.js"(exports2, module2) {
    if (global.GENTLY)
      require = GENTLY.hijack(require);
    var util = require("util"), fs = require("fs"), EventEmitter = require("events").EventEmitter, crypto2 = require("crypto");
    function File(properties) {
      EventEmitter.call(this);
      this.size = 0;
      this.path = null;
      this.name = null;
      this.type = null;
      this.hash = null;
      this.lastModifiedDate = null;
      this._writeStream = null;
      for (var key in properties) {
        this[key] = properties[key];
      }
      if (typeof this.hash === "string") {
        this.hash = crypto2.createHash(properties.hash);
      } else {
        this.hash = null;
      }
    }
    module2.exports = File;
    util.inherits(File, EventEmitter);
    File.prototype.open = function() {
      this._writeStream = new fs.WriteStream(this.path);
    };
    File.prototype.toJSON = function() {
      var json = {
        size: this.size,
        path: this.path,
        name: this.name,
        type: this.type,
        mtime: this.lastModifiedDate,
        length: this.length,
        filename: this.filename,
        mime: this.mime
      };
      if (this.hash && this.hash != "") {
        json.hash = this.hash;
      }
      return json;
    };
    File.prototype.write = function(buffer, cb) {
      var self2 = this;
      if (self2.hash) {
        self2.hash.update(buffer);
      }
      if (this._writeStream.closed) {
        return cb();
      }
      this._writeStream.write(buffer, function() {
        self2.lastModifiedDate = new Date();
        self2.size += buffer.length;
        self2.emit("progress", self2.size);
        cb();
      });
    };
    File.prototype.end = function(cb) {
      var self2 = this;
      if (self2.hash) {
        self2.hash = self2.hash.digest("hex");
      }
      this._writeStream.end(function() {
        self2.emit("end");
        cb();
      });
    };
  }
});

// node_modules/formidable/lib/multipart_parser.js
var require_multipart_parser = __commonJS({
  "node_modules/formidable/lib/multipart_parser.js"(exports2) {
    var Buffer3 = require("buffer").Buffer, s = 0, S = {
      PARSER_UNINITIALIZED: s++,
      START: s++,
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      PART_END: s++,
      END: s++
    }, f = 1, F = {
      PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    }, LF = 10, CR = 13, SPACE = 32, HYPHEN = 45, COLON = 58, A = 97, Z = 122, lower = function(c) {
      return c | 32;
    };
    for (s in S) {
      exports2[s] = S[s];
    }
    function MultipartParser() {
      this.boundary = null;
      this.boundaryChars = null;
      this.lookbehind = null;
      this.state = S.PARSER_UNINITIALIZED;
      this.index = null;
      this.flags = 0;
    }
    exports2.MultipartParser = MultipartParser;
    MultipartParser.stateToString = function(stateNumber) {
      for (var state in S) {
        var number = S[state];
        if (number === stateNumber)
          return state;
      }
    };
    MultipartParser.prototype.initWithBoundary = function(str) {
      this.boundary = new Buffer3(str.length + 4);
      this.boundary.write("\r\n--", 0);
      this.boundary.write(str, 4);
      this.lookbehind = new Buffer3(this.boundary.length + 8);
      this.state = S.START;
      this.boundaryChars = {};
      for (var i = 0; i < this.boundary.length; i++) {
        this.boundaryChars[this.boundary[i]] = true;
      }
    };
    MultipartParser.prototype.write = function(buffer) {
      var self2 = this, i = 0, len = buffer.length, prevIndex = this.index, index = this.index, state = this.state, flags = this.flags, lookbehind = this.lookbehind, boundary = this.boundary, boundaryChars = this.boundaryChars, boundaryLength = this.boundary.length, boundaryEnd = boundaryLength - 1, bufferLength = buffer.length, c, cl, mark = function(name) {
        self2[name + "Mark"] = i;
      }, clear = function(name) {
        delete self2[name + "Mark"];
      }, callback = function(name, buffer2, start, end) {
        if (start !== void 0 && start === end) {
          return;
        }
        var callbackSymbol = "on" + name.substr(0, 1).toUpperCase() + name.substr(1);
        if (callbackSymbol in self2) {
          self2[callbackSymbol](buffer2, start, end);
        }
      }, dataCallback = function(name, clear2) {
        var markSymbol = name + "Mark";
        if (!(markSymbol in self2)) {
          return;
        }
        if (!clear2) {
          callback(name, buffer, self2[markSymbol], buffer.length);
          self2[markSymbol] = 0;
        } else {
          callback(name, buffer, self2[markSymbol], i);
          delete self2[markSymbol];
        }
      };
      for (i = 0; i < len; i++) {
        c = buffer[i];
        switch (state) {
          case S.PARSER_UNINITIALIZED:
            return i;
          case S.START:
            index = 0;
            state = S.START_BOUNDARY;
          case S.START_BOUNDARY:
            if (index == boundary.length - 2) {
              if (c == HYPHEN) {
                flags |= F.LAST_BOUNDARY;
              } else if (c != CR) {
                return i;
              }
              index++;
              break;
            } else if (index - 1 == boundary.length - 2) {
              if (flags & F.LAST_BOUNDARY && c == HYPHEN) {
                callback("end");
                state = S.END;
                flags = 0;
              } else if (!(flags & F.LAST_BOUNDARY) && c == LF) {
                index = 0;
                callback("partBegin");
                state = S.HEADER_FIELD_START;
              } else {
                return i;
              }
              break;
            }
            if (c != boundary[index + 2]) {
              index = -2;
            }
            if (c == boundary[index + 2]) {
              index++;
            }
            break;
          case S.HEADER_FIELD_START:
            state = S.HEADER_FIELD;
            mark("headerField");
            index = 0;
          case S.HEADER_FIELD:
            if (c == CR) {
              clear("headerField");
              state = S.HEADERS_ALMOST_DONE;
              break;
            }
            index++;
            if (c == HYPHEN) {
              break;
            }
            if (c == COLON) {
              if (index == 1) {
                return i;
              }
              dataCallback("headerField", true);
              state = S.HEADER_VALUE_START;
              break;
            }
            cl = lower(c);
            if (cl < A || cl > Z) {
              return i;
            }
            break;
          case S.HEADER_VALUE_START:
            if (c == SPACE) {
              break;
            }
            mark("headerValue");
            state = S.HEADER_VALUE;
          case S.HEADER_VALUE:
            if (c == CR) {
              dataCallback("headerValue", true);
              callback("headerEnd");
              state = S.HEADER_VALUE_ALMOST_DONE;
            }
            break;
          case S.HEADER_VALUE_ALMOST_DONE:
            if (c != LF) {
              return i;
            }
            state = S.HEADER_FIELD_START;
            break;
          case S.HEADERS_ALMOST_DONE:
            if (c != LF) {
              return i;
            }
            callback("headersEnd");
            state = S.PART_DATA_START;
            break;
          case S.PART_DATA_START:
            state = S.PART_DATA;
            mark("partData");
          case S.PART_DATA:
            prevIndex = index;
            if (index === 0) {
              i += boundaryEnd;
              while (i < bufferLength && !(buffer[i] in boundaryChars)) {
                i += boundaryLength;
              }
              i -= boundaryEnd;
              c = buffer[i];
            }
            if (index < boundary.length) {
              if (boundary[index] == c) {
                if (index === 0) {
                  dataCallback("partData", true);
                }
                index++;
              } else {
                index = 0;
              }
            } else if (index == boundary.length) {
              index++;
              if (c == CR) {
                flags |= F.PART_BOUNDARY;
              } else if (c == HYPHEN) {
                flags |= F.LAST_BOUNDARY;
              } else {
                index = 0;
              }
            } else if (index - 1 == boundary.length) {
              if (flags & F.PART_BOUNDARY) {
                index = 0;
                if (c == LF) {
                  flags &= ~F.PART_BOUNDARY;
                  callback("partEnd");
                  callback("partBegin");
                  state = S.HEADER_FIELD_START;
                  break;
                }
              } else if (flags & F.LAST_BOUNDARY) {
                if (c == HYPHEN) {
                  callback("partEnd");
                  callback("end");
                  state = S.END;
                  flags = 0;
                } else {
                  index = 0;
                }
              } else {
                index = 0;
              }
            }
            if (index > 0) {
              lookbehind[index - 1] = c;
            } else if (prevIndex > 0) {
              callback("partData", lookbehind, 0, prevIndex);
              prevIndex = 0;
              mark("partData");
              i--;
            }
            break;
          case S.END:
            break;
          default:
            return i;
        }
      }
      dataCallback("headerField");
      dataCallback("headerValue");
      dataCallback("partData");
      this.index = index;
      this.state = state;
      this.flags = flags;
      return len;
    };
    MultipartParser.prototype.end = function() {
      var callback = function(self2, name) {
        var callbackSymbol = "on" + name.substr(0, 1).toUpperCase() + name.substr(1);
        if (callbackSymbol in self2) {
          self2[callbackSymbol]();
        }
      };
      if (this.state == S.HEADER_FIELD_START && this.index === 0 || this.state == S.PART_DATA && this.index == this.boundary.length) {
        callback(this, "partEnd");
        callback(this, "end");
      } else if (this.state != S.END) {
        return new Error("MultipartParser.end(): stream ended unexpectedly: " + this.explain());
      }
    };
    MultipartParser.prototype.explain = function() {
      return "state = " + MultipartParser.stateToString(this.state);
    };
  }
});

// node_modules/formidable/lib/querystring_parser.js
var require_querystring_parser = __commonJS({
  "node_modules/formidable/lib/querystring_parser.js"(exports2) {
    if (global.GENTLY)
      require = GENTLY.hijack(require);
    var querystring = require("querystring");
    function QuerystringParser(maxKeys) {
      this.maxKeys = maxKeys;
      this.buffer = "";
    }
    exports2.QuerystringParser = QuerystringParser;
    QuerystringParser.prototype.write = function(buffer) {
      this.buffer += buffer.toString("ascii");
      return buffer.length;
    };
    QuerystringParser.prototype.end = function() {
      var fields = querystring.parse(this.buffer, "&", "=", { maxKeys: this.maxKeys });
      for (var field in fields) {
        this.onField(field, fields[field]);
      }
      this.buffer = "";
      this.onEnd();
    };
  }
});

// node_modules/formidable/lib/octet_parser.js
var require_octet_parser = __commonJS({
  "node_modules/formidable/lib/octet_parser.js"(exports2) {
    var EventEmitter = require("events").EventEmitter, util = require("util");
    function OctetParser(options) {
      if (!(this instanceof OctetParser))
        return new OctetParser(options);
      EventEmitter.call(this);
    }
    util.inherits(OctetParser, EventEmitter);
    exports2.OctetParser = OctetParser;
    OctetParser.prototype.write = function(buffer) {
      this.emit("data", buffer);
      return buffer.length;
    };
    OctetParser.prototype.end = function() {
      this.emit("end");
    };
  }
});

// node_modules/formidable/lib/json_parser.js
var require_json_parser = __commonJS({
  "node_modules/formidable/lib/json_parser.js"(exports2) {
    if (global.GENTLY)
      require = GENTLY.hijack(require);
    var Buffer3 = require("buffer").Buffer;
    function JSONParser(parent) {
      this.parent = parent;
      this.chunks = [];
      this.bytesWritten = 0;
    }
    exports2.JSONParser = JSONParser;
    JSONParser.prototype.write = function(buffer) {
      this.bytesWritten += buffer.length;
      this.chunks.push(buffer);
      return buffer.length;
    };
    JSONParser.prototype.end = function() {
      try {
        var fields = JSON.parse(Buffer3.concat(this.chunks));
        for (var field in fields) {
          this.onField(field, fields[field]);
        }
      } catch (e) {
        this.parent.emit("error", e);
      }
      this.data = null;
      this.onEnd();
    };
  }
});

// node_modules/formidable/lib/incoming_form.js
var require_incoming_form = __commonJS({
  "node_modules/formidable/lib/incoming_form.js"(exports2) {
    if (global.GENTLY)
      require = GENTLY.hijack(require);
    var crypto2 = require("crypto");
    var fs = require("fs");
    var util = require("util"), path = require("path"), File = require_file(), MultipartParser = require_multipart_parser().MultipartParser, QuerystringParser = require_querystring_parser().QuerystringParser, OctetParser = require_octet_parser().OctetParser, JSONParser = require_json_parser().JSONParser, StringDecoder = require("string_decoder").StringDecoder, EventEmitter = require("events").EventEmitter, Stream = require("stream").Stream, os = require("os");
    function IncomingForm(opts) {
      if (!(this instanceof IncomingForm))
        return new IncomingForm(opts);
      EventEmitter.call(this);
      opts = opts || {};
      this.error = null;
      this.ended = false;
      this.maxFields = opts.maxFields || 1e3;
      this.maxFieldsSize = opts.maxFieldsSize || 20 * 1024 * 1024;
      this.maxFileSize = opts.maxFileSize || 200 * 1024 * 1024;
      this.keepExtensions = opts.keepExtensions || false;
      this.uploadDir = opts.uploadDir || os.tmpdir && os.tmpdir() || os.tmpDir();
      this.encoding = opts.encoding || "utf-8";
      this.headers = null;
      this.type = null;
      this.hash = opts.hash || false;
      this.multiples = opts.multiples || false;
      this.bytesReceived = null;
      this.bytesExpected = null;
      this._parser = null;
      this._flushing = 0;
      this._fieldsSize = 0;
      this._fileSize = 0;
      this.openedFiles = [];
      return this;
    }
    util.inherits(IncomingForm, EventEmitter);
    exports2.IncomingForm = IncomingForm;
    IncomingForm.prototype.parse = function(req, cb) {
      this.pause = function() {
        try {
          req.pause();
        } catch (err) {
          if (!this.ended) {
            this._error(err);
          }
          return false;
        }
        return true;
      };
      this.resume = function() {
        try {
          req.resume();
        } catch (err) {
          if (!this.ended) {
            this._error(err);
          }
          return false;
        }
        return true;
      };
      if (cb) {
        var fields = {}, files = {};
        this.on("field", function(name, value) {
          fields[name] = value;
        }).on("file", function(name, file) {
          if (this.multiples) {
            if (files[name]) {
              if (!Array.isArray(files[name])) {
                files[name] = [files[name]];
              }
              files[name].push(file);
            } else {
              files[name] = file;
            }
          } else {
            files[name] = file;
          }
        }).on("error", function(err) {
          cb(err, fields, files);
        }).on("end", function() {
          cb(null, fields, files);
        });
      }
      this.writeHeaders(req.headers);
      var self2 = this;
      req.on("error", function(err) {
        self2._error(err);
      }).on("aborted", function() {
        self2.emit("aborted");
        self2._error(new Error("Request aborted"));
      }).on("data", function(buffer) {
        self2.write(buffer);
      }).on("end", function() {
        if (self2.error) {
          return;
        }
        var err = self2._parser.end();
        if (err) {
          self2._error(err);
        }
      });
      return this;
    };
    IncomingForm.prototype.writeHeaders = function(headers) {
      this.headers = headers;
      this._parseContentLength();
      this._parseContentType();
    };
    IncomingForm.prototype.write = function(buffer) {
      if (this.error) {
        return;
      }
      if (!this._parser) {
        this._error(new Error("uninitialized parser"));
        return;
      }
      if (typeof this._parser.write !== "function") {
        this._error(new Error("did not expect data"));
        return;
      }
      this.bytesReceived += buffer.length;
      this.emit("progress", this.bytesReceived, this.bytesExpected);
      var bytesParsed = this._parser.write(buffer);
      if (bytesParsed !== buffer.length) {
        this._error(new Error("parser error, " + bytesParsed + " of " + buffer.length + " bytes parsed"));
      }
      return bytesParsed;
    };
    IncomingForm.prototype.pause = function() {
      return false;
    };
    IncomingForm.prototype.resume = function() {
      return false;
    };
    IncomingForm.prototype.onPart = function(part) {
      this.handlePart(part);
    };
    IncomingForm.prototype.handlePart = function(part) {
      var self2 = this;
      if (part.filename === void 0) {
        var value = "", decoder = new StringDecoder(this.encoding);
        part.on("data", function(buffer) {
          self2._fieldsSize += buffer.length;
          if (self2._fieldsSize > self2.maxFieldsSize) {
            self2._error(new Error("maxFieldsSize exceeded, received " + self2._fieldsSize + " bytes of field data"));
            return;
          }
          value += decoder.write(buffer);
        });
        part.on("end", function() {
          self2.emit("field", part.name, value);
        });
        return;
      }
      this._flushing++;
      var file = new File({
        path: this._uploadPath(part.filename),
        name: part.filename,
        type: part.mime,
        hash: self2.hash
      });
      this.emit("fileBegin", part.name, file);
      file.open();
      this.openedFiles.push(file);
      part.on("data", function(buffer) {
        self2._fileSize += buffer.length;
        if (self2._fileSize > self2.maxFileSize) {
          self2._error(new Error("maxFileSize exceeded, received " + self2._fileSize + " bytes of file data"));
          return;
        }
        if (buffer.length == 0) {
          return;
        }
        self2.pause();
        file.write(buffer, function() {
          self2.resume();
        });
      });
      part.on("end", function() {
        file.end(function() {
          self2._flushing--;
          self2.emit("file", part.name, file);
          self2._maybeEnd();
        });
      });
    };
    function dummyParser(self2) {
      return {
        end: function() {
          self2.ended = true;
          self2._maybeEnd();
          return null;
        }
      };
    }
    IncomingForm.prototype._parseContentType = function() {
      if (this.bytesExpected === 0) {
        this._parser = dummyParser(this);
        return;
      }
      if (!this.headers["content-type"]) {
        this._error(new Error("bad content-type header, no content-type"));
        return;
      }
      if (this.headers["content-type"].match(/octet-stream/i)) {
        this._initOctetStream();
        return;
      }
      if (this.headers["content-type"].match(/urlencoded/i)) {
        this._initUrlencoded();
        return;
      }
      if (this.headers["content-type"].match(/multipart/i)) {
        var m = this.headers["content-type"].match(/boundary=(?:"([^"]+)"|([^;]+))/i);
        if (m) {
          this._initMultipart(m[1] || m[2]);
        } else {
          this._error(new Error("bad content-type header, no multipart boundary"));
        }
        return;
      }
      if (this.headers["content-type"].match(/json/i)) {
        this._initJSONencoded();
        return;
      }
      this._error(new Error("bad content-type header, unknown content-type: " + this.headers["content-type"]));
    };
    IncomingForm.prototype._error = function(err) {
      if (this.error || this.ended) {
        return;
      }
      this.error = err;
      this.emit("error", err);
      if (Array.isArray(this.openedFiles)) {
        this.openedFiles.forEach(function(file) {
          file._writeStream.on("error", function() {
          }).destroy();
          setTimeout(fs.unlink, 0, file.path, function(error) {
          });
        });
      }
    };
    IncomingForm.prototype._parseContentLength = function() {
      this.bytesReceived = 0;
      if (this.headers["content-length"]) {
        this.bytesExpected = parseInt(this.headers["content-length"], 10);
      } else if (this.headers["transfer-encoding"] === void 0) {
        this.bytesExpected = 0;
      }
      if (this.bytesExpected !== null) {
        this.emit("progress", this.bytesReceived, this.bytesExpected);
      }
    };
    IncomingForm.prototype._newParser = function() {
      return new MultipartParser();
    };
    IncomingForm.prototype._initMultipart = function(boundary) {
      this.type = "multipart";
      var parser = new MultipartParser(), self2 = this, headerField, headerValue, part;
      parser.initWithBoundary(boundary);
      parser.onPartBegin = function() {
        part = new Stream();
        part.readable = true;
        part.headers = {};
        part.name = null;
        part.filename = null;
        part.mime = null;
        part.transferEncoding = "binary";
        part.transferBuffer = "";
        headerField = "";
        headerValue = "";
      };
      parser.onHeaderField = function(b, start, end) {
        headerField += b.toString(self2.encoding, start, end);
      };
      parser.onHeaderValue = function(b, start, end) {
        headerValue += b.toString(self2.encoding, start, end);
      };
      parser.onHeaderEnd = function() {
        headerField = headerField.toLowerCase();
        part.headers[headerField] = headerValue;
        var m = headerValue.match(/\bname=("([^"]*)"|([^\(\)<>@,;:\\"\/\[\]\?=\{\}\s\t/]+))/i);
        if (headerField == "content-disposition") {
          if (m) {
            part.name = m[2] || m[3] || "";
          }
          part.filename = self2._fileName(headerValue);
        } else if (headerField == "content-type") {
          part.mime = headerValue;
        } else if (headerField == "content-transfer-encoding") {
          part.transferEncoding = headerValue.toLowerCase();
        }
        headerField = "";
        headerValue = "";
      };
      parser.onHeadersEnd = function() {
        switch (part.transferEncoding) {
          case "binary":
          case "7bit":
          case "8bit":
            parser.onPartData = function(b, start, end) {
              part.emit("data", b.slice(start, end));
            };
            parser.onPartEnd = function() {
              part.emit("end");
            };
            break;
          case "base64":
            parser.onPartData = function(b, start, end) {
              part.transferBuffer += b.slice(start, end).toString("ascii");
              var offset = parseInt(part.transferBuffer.length / 4, 10) * 4;
              part.emit("data", new Buffer(part.transferBuffer.substring(0, offset), "base64"));
              part.transferBuffer = part.transferBuffer.substring(offset);
            };
            parser.onPartEnd = function() {
              part.emit("data", new Buffer(part.transferBuffer, "base64"));
              part.emit("end");
            };
            break;
          default:
            return self2._error(new Error("unknown transfer-encoding"));
        }
        self2.onPart(part);
      };
      parser.onEnd = function() {
        self2.ended = true;
        self2._maybeEnd();
      };
      this._parser = parser;
    };
    IncomingForm.prototype._fileName = function(headerValue) {
      var m = headerValue.match(/\bfilename=("(.*?)"|([^\(\)<>@,;:\\"\/\[\]\?=\{\}\s\t/]+))($|;\s)/i);
      if (!m)
        return;
      var match = m[2] || m[3] || "";
      var filename = match.substr(match.lastIndexOf("\\") + 1);
      filename = filename.replace(/%22/g, '"');
      filename = filename.replace(/&#([\d]{4});/g, function(m2, code) {
        return String.fromCharCode(code);
      });
      return filename;
    };
    IncomingForm.prototype._initUrlencoded = function() {
      this.type = "urlencoded";
      var parser = new QuerystringParser(this.maxFields), self2 = this;
      parser.onField = function(key, val) {
        self2.emit("field", key, val);
      };
      parser.onEnd = function() {
        self2.ended = true;
        self2._maybeEnd();
      };
      this._parser = parser;
    };
    IncomingForm.prototype._initOctetStream = function() {
      this.type = "octet-stream";
      var filename = this.headers["x-file-name"];
      var mime = this.headers["content-type"];
      var file = new File({
        path: this._uploadPath(filename),
        name: filename,
        type: mime
      });
      this.emit("fileBegin", filename, file);
      file.open();
      this.openedFiles.push(file);
      this._flushing++;
      var self2 = this;
      self2._parser = new OctetParser();
      var outstandingWrites = 0;
      self2._parser.on("data", function(buffer) {
        self2.pause();
        outstandingWrites++;
        file.write(buffer, function() {
          outstandingWrites--;
          self2.resume();
          if (self2.ended) {
            self2._parser.emit("doneWritingFile");
          }
        });
      });
      self2._parser.on("end", function() {
        self2._flushing--;
        self2.ended = true;
        var done = function() {
          file.end(function() {
            self2.emit("file", "file", file);
            self2._maybeEnd();
          });
        };
        if (outstandingWrites === 0) {
          done();
        } else {
          self2._parser.once("doneWritingFile", done);
        }
      });
    };
    IncomingForm.prototype._initJSONencoded = function() {
      this.type = "json";
      var parser = new JSONParser(this), self2 = this;
      parser.onField = function(key, val) {
        self2.emit("field", key, val);
      };
      parser.onEnd = function() {
        self2.ended = true;
        self2._maybeEnd();
      };
      this._parser = parser;
    };
    IncomingForm.prototype._uploadPath = function(filename) {
      var buf = crypto2.randomBytes(16);
      var name = "upload_" + buf.toString("hex");
      if (this.keepExtensions) {
        var ext = path.extname(filename);
        ext = ext.replace(/(\.[a-z0-9]+).*/i, "$1");
        name += ext;
      }
      return path.join(this.uploadDir, name);
    };
    IncomingForm.prototype._maybeEnd = function() {
      if (!this.ended || this._flushing || this.error) {
        return;
      }
      this.emit("end");
    };
  }
});

// node_modules/formidable/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/formidable/lib/index.js"(exports2, module2) {
    var IncomingForm = require_incoming_form().IncomingForm;
    IncomingForm.IncomingForm = IncomingForm;
    module2.exports = IncomingForm;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/cookiejar/cookiejar.js
var require_cookiejar = __commonJS({
  "node_modules/cookiejar/cookiejar.js"(exports2) {
    (function() {
      "use strict";
      function CookieAccessInfo(domain, path, secure, script) {
        if (this instanceof CookieAccessInfo) {
          this.domain = domain || void 0;
          this.path = path || "/";
          this.secure = !!secure;
          this.script = !!script;
          return this;
        }
        return new CookieAccessInfo(domain, path, secure, script);
      }
      CookieAccessInfo.All = Object.freeze(/* @__PURE__ */ Object.create(null));
      exports2.CookieAccessInfo = CookieAccessInfo;
      function Cookie(cookiestr, request_domain, request_path) {
        if (cookiestr instanceof Cookie) {
          return cookiestr;
        }
        if (this instanceof Cookie) {
          this.name = null;
          this.value = null;
          this.expiration_date = Infinity;
          this.path = String(request_path || "/");
          this.explicit_path = false;
          this.domain = request_domain || null;
          this.explicit_domain = false;
          this.secure = false;
          this.noscript = false;
          if (cookiestr) {
            this.parse(cookiestr, request_domain, request_path);
          }
          return this;
        }
        return new Cookie(cookiestr, request_domain, request_path);
      }
      exports2.Cookie = Cookie;
      Cookie.prototype.toString = function toString() {
        var str = [this.name + "=" + this.value];
        if (this.expiration_date !== Infinity) {
          str.push("expires=" + new Date(this.expiration_date).toGMTString());
        }
        if (this.domain) {
          str.push("domain=" + this.domain);
        }
        if (this.path) {
          str.push("path=" + this.path);
        }
        if (this.secure) {
          str.push("secure");
        }
        if (this.noscript) {
          str.push("httponly");
        }
        return str.join("; ");
      };
      Cookie.prototype.toValueString = function toValueString() {
        return this.name + "=" + this.value;
      };
      var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
      Cookie.prototype.parse = function parse(str, request_domain, request_path) {
        if (this instanceof Cookie) {
          var parts = str.split(";").filter(function(value2) {
            return !!value2;
          });
          var i;
          var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
          if (!pair) {
            console.warn("Invalid cookie header encountered. Header: '" + str + "'");
            return;
          }
          var key = pair[1];
          var value = pair[2];
          if (typeof key !== "string" || key.length === 0 || typeof value !== "string") {
            console.warn("Unable to extract values from cookie header. Cookie: '" + str + "'");
            return;
          }
          this.name = key;
          this.value = value;
          for (i = 1; i < parts.length; i += 1) {
            pair = parts[i].match(/([^=]+)(?:=([\s\S]*))?/);
            key = pair[1].trim().toLowerCase();
            value = pair[2];
            switch (key) {
              case "httponly":
                this.noscript = true;
                break;
              case "expires":
                this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
                break;
              case "path":
                this.path = value ? value.trim() : "";
                this.explicit_path = true;
                break;
              case "domain":
                this.domain = value ? value.trim() : "";
                this.explicit_domain = !!this.domain;
                break;
              case "secure":
                this.secure = true;
                break;
            }
          }
          if (!this.explicit_path) {
            this.path = request_path || "/";
          }
          if (!this.explicit_domain) {
            this.domain = request_domain;
          }
          return this;
        }
        return new Cookie().parse(str, request_domain, request_path);
      };
      Cookie.prototype.matches = function matches(access_info) {
        if (access_info === CookieAccessInfo.All) {
          return true;
        }
        if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
          return false;
        }
        return true;
      };
      Cookie.prototype.collidesWith = function collidesWith(access_info) {
        if (this.path && !access_info.path || this.domain && !access_info.domain) {
          return false;
        }
        if (this.path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        if (this.explicit_path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, "");
        var cookie_domain = this.domain && this.domain.replace(/^[\.]/, "");
        if (cookie_domain === access_domain) {
          return true;
        }
        if (cookie_domain) {
          if (!this.explicit_domain) {
            return false;
          }
          var wildcard = access_domain.indexOf(cookie_domain);
          if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
            return false;
          }
          return true;
        }
        return true;
      };
      function CookieJar() {
        var cookies, cookies_list, collidable_cookie;
        if (this instanceof CookieJar) {
          cookies = /* @__PURE__ */ Object.create(null);
          this.setCookie = function setCookie(cookie, request_domain, request_path) {
            var remove, i;
            cookie = new Cookie(cookie, request_domain, request_path);
            remove = cookie.expiration_date <= Date.now();
            if (cookies[cookie.name] !== void 0) {
              cookies_list = cookies[cookie.name];
              for (i = 0; i < cookies_list.length; i += 1) {
                collidable_cookie = cookies_list[i];
                if (collidable_cookie.collidesWith(cookie)) {
                  if (remove) {
                    cookies_list.splice(i, 1);
                    if (cookies_list.length === 0) {
                      delete cookies[cookie.name];
                    }
                    return false;
                  }
                  cookies_list[i] = cookie;
                  return cookie;
                }
              }
              if (remove) {
                return false;
              }
              cookies_list.push(cookie);
              return cookie;
            }
            if (remove) {
              return false;
            }
            cookies[cookie.name] = [cookie];
            return cookies[cookie.name];
          };
          this.getCookie = function getCookie(cookie_name, access_info) {
            var cookie, i;
            cookies_list = cookies[cookie_name];
            if (!cookies_list) {
              return;
            }
            for (i = 0; i < cookies_list.length; i += 1) {
              cookie = cookies_list[i];
              if (cookie.expiration_date <= Date.now()) {
                if (cookies_list.length === 0) {
                  delete cookies[cookie.name];
                }
                continue;
              }
              if (cookie.matches(access_info)) {
                return cookie;
              }
            }
          };
          this.getCookies = function getCookies(access_info) {
            var matches = [], cookie_name, cookie;
            for (cookie_name in cookies) {
              cookie = this.getCookie(cookie_name, access_info);
              if (cookie) {
                matches.push(cookie);
              }
            }
            matches.toString = function toString() {
              return matches.join(":");
            };
            matches.toValueString = function toValueString() {
              return matches.map(function(c) {
                return c.toValueString();
              }).join("; ");
            };
            return matches;
          };
          return this;
        }
        return new CookieJar();
      }
      exports2.CookieJar = CookieJar;
      CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
        cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
        var successful = [], i, cookie;
        cookies = cookies.map(function(item) {
          return new Cookie(item, request_domain, request_path);
        });
        for (i = 0; i < cookies.length; i += 1) {
          cookie = cookies[i];
          if (this.setCookie(cookie, request_domain, request_path)) {
            successful.push(cookie);
          }
        }
        return successful;
      };
    })();
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
      options2[k] = true;
      return options2;
    }, {});
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse3 = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    var { MAX_LENGTH } = require_constants();
    var { re, t } = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse = (version, options) => {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse = require_parse3();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse = require_parse3();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse = require_parse3();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse(version1);
        const v2 = parse(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse = require_parse3();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = require_parse3();
    var { re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null)
        return null;
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached;
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range, re[t.COMPARATORTRIM]);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
        const l = rangeList.length;
        const rangeMap = /* @__PURE__ */ new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp];
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(""))
          rangeMap.delete("");
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin)))
          minver = setMin;
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!min)
            min = version;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom)
        return true;
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom)
        return true;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true;
        else if (options.includePrerelease)
          sub = [new Comparator(">=0.0.0-0")];
        else
          sub = [new Comparator(">=0.0.0")];
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease)
          return true;
        else
          dom = [new Comparator(">=0.0.0")];
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null;
        if (lt && !satisfies(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      if (needDomGTPre || needDomLTPre)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse3(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports2, module2) {
    module2.exports = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/superagent/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/superagent/lib/utils.js"(exports2) {
    "use strict";
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    exports2.type = function(str) {
      return str.split(/ *; */).shift();
    };
    exports2.params = function(val) {
      var obj = {};
      var _iterator = _createForOfIteratorHelper(val.split(/ *; */)), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var str = _step.value;
          var parts = str.split(/ *= */);
          var key = parts.shift();
          var _val = parts.shift();
          if (key && _val)
            obj[key] = _val;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return obj;
    };
    exports2.parseLinks = function(val) {
      var obj = {};
      var _iterator2 = _createForOfIteratorHelper(val.split(/ *, */)), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var str = _step2.value;
          var parts = str.split(/ *; */);
          var url = parts[0].slice(1, -1);
          var rel = parts[1].split(/ *= */)[1].slice(1, -1);
          obj[rel] = url;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return obj;
    };
    exports2.cleanHeader = function(header, changesOrigin) {
      delete header["content-type"];
      delete header["content-length"];
      delete header["transfer-encoding"];
      delete header.host;
      if (changesOrigin) {
        delete header.authorization;
        delete header.cookie;
      }
      return header;
    };
  }
});

// node_modules/superagent/lib/is-object.js
var require_is_object = __commonJS({
  "node_modules/superagent/lib/is-object.js"(exports2, module2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function isObject(obj) {
      return obj !== null && _typeof(obj) === "object";
    }
    module2.exports = isObject;
  }
});

// node_modules/superagent/lib/request-base.js
var require_request_base = __commonJS({
  "node_modules/superagent/lib/request-base.js"(exports2, module2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var isObject = require_is_object();
    module2.exports = RequestBase;
    function RequestBase(object) {
      if (object)
        return mixin(object);
    }
    function mixin(object) {
      for (var key in RequestBase.prototype) {
        if (Object.prototype.hasOwnProperty.call(RequestBase.prototype, key))
          object[key] = RequestBase.prototype[key];
      }
      return object;
    }
    RequestBase.prototype.clearTimeout = function() {
      clearTimeout(this._timer);
      clearTimeout(this._responseTimeoutTimer);
      clearTimeout(this._uploadTimeoutTimer);
      delete this._timer;
      delete this._responseTimeoutTimer;
      delete this._uploadTimeoutTimer;
      return this;
    };
    RequestBase.prototype.parse = function(fn) {
      this._parser = fn;
      return this;
    };
    RequestBase.prototype.responseType = function(value) {
      this._responseType = value;
      return this;
    };
    RequestBase.prototype.serialize = function(fn) {
      this._serializer = fn;
      return this;
    };
    RequestBase.prototype.timeout = function(options) {
      if (!options || _typeof(options) !== "object") {
        this._timeout = options;
        this._responseTimeout = 0;
        this._uploadTimeout = 0;
        return this;
      }
      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option)) {
          switch (option) {
            case "deadline":
              this._timeout = options.deadline;
              break;
            case "response":
              this._responseTimeout = options.response;
              break;
            case "upload":
              this._uploadTimeout = options.upload;
              break;
            default:
              console.warn("Unknown timeout option", option);
          }
        }
      }
      return this;
    };
    RequestBase.prototype.retry = function(count, fn) {
      if (arguments.length === 0 || count === true)
        count = 1;
      if (count <= 0)
        count = 0;
      this._maxRetries = count;
      this._retries = 0;
      this._retryCallback = fn;
      return this;
    };
    var ERROR_CODES = /* @__PURE__ */ new Set(["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"]);
    var STATUS_CODES = /* @__PURE__ */ new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]);
    RequestBase.prototype._shouldRetry = function(err, res) {
      if (!this._maxRetries || this._retries++ >= this._maxRetries) {
        return false;
      }
      if (this._retryCallback) {
        try {
          var override = this._retryCallback(err, res);
          if (override === true)
            return true;
          if (override === false)
            return false;
        } catch (err_) {
          console.error(err_);
        }
      }
      if (res && res.status && STATUS_CODES.has(res.status))
        return true;
      if (err) {
        if (err.code && ERROR_CODES.has(err.code))
          return true;
        if (err.timeout && err.code === "ECONNABORTED")
          return true;
        if (err.crossDomain)
          return true;
      }
      return false;
    };
    RequestBase.prototype._retry = function() {
      this.clearTimeout();
      if (this.req) {
        this.req = null;
        this.req = this.request();
      }
      this._aborted = false;
      this.timedout = false;
      this.timedoutError = null;
      return this._end();
    };
    RequestBase.prototype.then = function(resolve, reject) {
      var _this = this;
      if (!this._fullfilledPromise) {
        var self2 = this;
        if (this._endCalled) {
          console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
        }
        this._fullfilledPromise = new Promise(function(resolve2, reject2) {
          self2.on("abort", function() {
            if (_this._maxRetries && _this._maxRetries > _this._retries) {
              return;
            }
            if (_this.timedout && _this.timedoutError) {
              reject2(_this.timedoutError);
              return;
            }
            var err = new Error("Aborted");
            err.code = "ABORTED";
            err.status = _this.status;
            err.method = _this.method;
            err.url = _this.url;
            reject2(err);
          });
          self2.end(function(err, res) {
            if (err)
              reject2(err);
            else
              resolve2(res);
          });
        });
      }
      return this._fullfilledPromise.then(resolve, reject);
    };
    RequestBase.prototype.catch = function(cb) {
      return this.then(void 0, cb);
    };
    RequestBase.prototype.use = function(fn) {
      fn(this);
      return this;
    };
    RequestBase.prototype.ok = function(cb) {
      if (typeof cb !== "function")
        throw new Error("Callback required");
      this._okCallback = cb;
      return this;
    };
    RequestBase.prototype._isResponseOK = function(res) {
      if (!res) {
        return false;
      }
      if (this._okCallback) {
        return this._okCallback(res);
      }
      return res.status >= 200 && res.status < 300;
    };
    RequestBase.prototype.get = function(field) {
      return this._header[field.toLowerCase()];
    };
    RequestBase.prototype.getHeader = RequestBase.prototype.get;
    RequestBase.prototype.set = function(field, value) {
      if (isObject(field)) {
        for (var key in field) {
          if (Object.prototype.hasOwnProperty.call(field, key))
            this.set(key, field[key]);
        }
        return this;
      }
      this._header[field.toLowerCase()] = value;
      this.header[field] = value;
      return this;
    };
    RequestBase.prototype.unset = function(field) {
      delete this._header[field.toLowerCase()];
      delete this.header[field];
      return this;
    };
    RequestBase.prototype.field = function(name, value) {
      if (name === null || name === void 0) {
        throw new Error(".field(name, val) name can not be empty");
      }
      if (this._data) {
        throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
      }
      if (isObject(name)) {
        for (var key in name) {
          if (Object.prototype.hasOwnProperty.call(name, key))
            this.field(key, name[key]);
        }
        return this;
      }
      if (Array.isArray(value)) {
        for (var i in value) {
          if (Object.prototype.hasOwnProperty.call(value, i))
            this.field(name, value[i]);
        }
        return this;
      }
      if (value === null || value === void 0) {
        throw new Error(".field(name, val) val can not be empty");
      }
      if (typeof value === "boolean") {
        value = String(value);
      }
      this._getFormData().append(name, value);
      return this;
    };
    RequestBase.prototype.abort = function() {
      if (this._aborted) {
        return this;
      }
      this._aborted = true;
      if (this.xhr)
        this.xhr.abort();
      if (this.req)
        this.req.abort();
      this.clearTimeout();
      this.emit("abort");
      return this;
    };
    RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
      switch (options.type) {
        case "basic":
          this.set("Authorization", "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
          break;
        case "auto":
          this.username = user;
          this.password = pass;
          break;
        case "bearer":
          this.set("Authorization", "Bearer ".concat(user));
          break;
        default:
          break;
      }
      return this;
    };
    RequestBase.prototype.withCredentials = function(on) {
      if (on === void 0)
        on = true;
      this._withCredentials = on;
      return this;
    };
    RequestBase.prototype.redirects = function(n) {
      this._maxRedirects = n;
      return this;
    };
    RequestBase.prototype.maxResponseSize = function(n) {
      if (typeof n !== "number") {
        throw new TypeError("Invalid argument");
      }
      this._maxResponseSize = n;
      return this;
    };
    RequestBase.prototype.toJSON = function() {
      return {
        method: this.method,
        url: this.url,
        data: this._data,
        headers: this._header
      };
    };
    RequestBase.prototype.send = function(data) {
      var isObject_ = isObject(data);
      var type = this._header["content-type"];
      if (this._formData) {
        throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
      }
      if (isObject_ && !this._data) {
        if (Array.isArray(data)) {
          this._data = [];
        } else if (!this._isHost(data)) {
          this._data = {};
        }
      } else if (data && this._data && this._isHost(this._data)) {
        throw new Error("Can't merge these send calls");
      }
      if (isObject_ && isObject(this._data)) {
        for (var key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key))
            this._data[key] = data[key];
        }
      } else if (typeof data === "string") {
        if (!type)
          this.type("form");
        type = this._header["content-type"];
        if (type)
          type = type.toLowerCase().trim();
        if (type === "application/x-www-form-urlencoded") {
          this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
        } else {
          this._data = (this._data || "") + data;
        }
      } else {
        this._data = data;
      }
      if (!isObject_ || this._isHost(data)) {
        return this;
      }
      if (!type)
        this.type("json");
      return this;
    };
    RequestBase.prototype.sortQuery = function(sort) {
      this._sort = typeof sort === "undefined" ? true : sort;
      return this;
    };
    RequestBase.prototype._finalizeQueryString = function() {
      var query = this._query.join("&");
      if (query) {
        this.url += (this.url.includes("?") ? "&" : "?") + query;
      }
      this._query.length = 0;
      if (this._sort) {
        var index = this.url.indexOf("?");
        if (index >= 0) {
          var queryArray = this.url.slice(index + 1).split("&");
          if (typeof this._sort === "function") {
            queryArray.sort(this._sort);
          } else {
            queryArray.sort();
          }
          this.url = this.url.slice(0, index) + "?" + queryArray.join("&");
        }
      }
    };
    RequestBase.prototype._appendQueryString = function() {
      console.warn("Unsupported");
    };
    RequestBase.prototype._timeoutError = function(reason, timeout, errno) {
      if (this._aborted) {
        return;
      }
      var err = new Error("".concat(reason + timeout, "ms exceeded"));
      err.timeout = timeout;
      err.code = "ECONNABORTED";
      err.errno = errno;
      this.timedout = true;
      this.timedoutError = err;
      this.abort();
      this.callback(err);
    };
    RequestBase.prototype._setTimeouts = function() {
      var self2 = this;
      if (this._timeout && !this._timer) {
        this._timer = setTimeout(function() {
          self2._timeoutError("Timeout of ", self2._timeout, "ETIME");
        }, this._timeout);
      }
      if (this._responseTimeout && !this._responseTimeoutTimer) {
        this._responseTimeoutTimer = setTimeout(function() {
          self2._timeoutError("Response timeout of ", self2._responseTimeout, "ETIMEDOUT");
        }, this._responseTimeout);
      }
    };
  }
});

// node_modules/superagent/lib/node/unzip.js
var require_unzip = __commonJS({
  "node_modules/superagent/lib/node/unzip.js"(exports2) {
    "use strict";
    var _require = require("string_decoder"), StringDecoder = _require.StringDecoder;
    var Stream = require("stream");
    var zlib = require("zlib");
    exports2.unzip = function(req, res) {
      var unzip = zlib.createUnzip();
      var stream = new Stream();
      var decoder;
      stream.req = req;
      unzip.on("error", function(err) {
        if (err && err.code === "Z_BUF_ERROR") {
          stream.emit("end");
          return;
        }
        stream.emit("error", err);
      });
      res.pipe(unzip);
      res.setEncoding = function(type) {
        decoder = new StringDecoder(type);
      };
      unzip.on("data", function(buf) {
        if (decoder) {
          var str = decoder.write(buf);
          if (str.length > 0)
            stream.emit("data", str);
        } else {
          stream.emit("data", buf);
        }
      });
      unzip.on("end", function() {
        stream.emit("end");
      });
      var _on = res.on;
      res.on = function(type, fn) {
        if (type === "data" || type === "end") {
          stream.on(type, fn.bind(res));
        } else if (type === "error") {
          stream.on(type, fn.bind(res));
          _on.call(res, type, fn);
        } else {
          _on.call(res, type, fn);
        }
        return this;
      };
    };
  }
});

// node_modules/superagent/lib/response-base.js
var require_response_base = __commonJS({
  "node_modules/superagent/lib/response-base.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = ResponseBase;
    function ResponseBase(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in ResponseBase.prototype) {
        if (Object.prototype.hasOwnProperty.call(ResponseBase.prototype, key))
          obj[key] = ResponseBase.prototype[key];
      }
      return obj;
    }
    ResponseBase.prototype.get = function(field) {
      return this.header[field.toLowerCase()];
    };
    ResponseBase.prototype._setHeaderProperties = function(header) {
      var ct = header["content-type"] || "";
      this.type = utils.type(ct);
      var params = utils.params(ct);
      for (var key in params) {
        if (Object.prototype.hasOwnProperty.call(params, key))
          this[key] = params[key];
      }
      this.links = {};
      try {
        if (header.link) {
          this.links = utils.parseLinks(header.link);
        }
      } catch (_unused) {
      }
    };
    ResponseBase.prototype._setStatusProperties = function(status) {
      var type = status / 100 | 0;
      this.statusCode = status;
      this.status = this.statusCode;
      this.statusType = type;
      this.info = type === 1;
      this.ok = type === 2;
      this.redirect = type === 3;
      this.clientError = type === 4;
      this.serverError = type === 5;
      this.error = type === 4 || type === 5 ? this.toError() : false;
      this.created = status === 201;
      this.accepted = status === 202;
      this.noContent = status === 204;
      this.badRequest = status === 400;
      this.unauthorized = status === 401;
      this.notAcceptable = status === 406;
      this.forbidden = status === 403;
      this.notFound = status === 404;
      this.unprocessableEntity = status === 422;
    };
  }
});

// node_modules/superagent/lib/node/response.js
var require_response = __commonJS({
  "node_modules/superagent/lib/node/response.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var ResponseBase = require_response_base();
    module2.exports = Response;
    function Response(req) {
      Stream.call(this);
      this.res = req.res;
      var res = this.res;
      this.request = req;
      this.req = req.req;
      this.text = res.text;
      this.body = res.body === void 0 ? {} : res.body;
      this.files = res.files || {};
      this.buffered = req._resBuffered;
      this.headers = res.headers;
      this.header = this.headers;
      this._setStatusProperties(res.statusCode);
      this._setHeaderProperties(this.header);
      this.setEncoding = res.setEncoding.bind(res);
      res.on("data", this.emit.bind(this, "data"));
      res.on("end", this.emit.bind(this, "end"));
      res.on("close", this.emit.bind(this, "close"));
      res.on("error", this.emit.bind(this, "error"));
    }
    util.inherits(Response, Stream);
    ResponseBase(Response.prototype);
    Response.prototype.destroy = function(err) {
      this.res.destroy(err);
    };
    Response.prototype.pause = function() {
      this.res.pause();
    };
    Response.prototype.resume = function() {
      this.res.resume();
    };
    Response.prototype.toError = function() {
      var req = this.req;
      var method2 = req.method;
      var path = req.path;
      var msg = "cannot ".concat(method2, " ").concat(path, " (").concat(this.status, ")");
      var err = new Error(msg);
      err.status = this.status;
      err.text = this.text;
      err.method = method2;
      err.path = path;
      return err;
    };
    Response.prototype.setStatusProperties = function(status) {
      console.warn("In superagent 2.x setStatusProperties is a private method");
      return this._setStatusProperties(status);
    };
    Response.prototype.toJSON = function() {
      return {
        req: this.request.toJSON(),
        header: this.header,
        status: this.status,
        text: this.text
      };
    };
  }
});

// node_modules/superagent/lib/node/http2wrapper.js
var require_http2wrapper = __commonJS({
  "node_modules/superagent/lib/node/http2wrapper.js"(exports2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Stream = require("stream");
    var util = require("util");
    var net = require("net");
    var tls = require("tls");
    var _require = require("url"), parse = _require.parse;
    var semver = require_semver2();
    var http2;
    if (semver.gte(process.version, "v10.10.0"))
      http2 = require("http2");
    else
      throw new Error("superagent: this version of Node.js does not support http2");
    var _http2$constants = http2.constants, HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH, HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS, HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD, HTTP2_HEADER_AUTHORITY = _http2$constants.HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_HOST = _http2$constants.HTTP2_HEADER_HOST, HTTP2_HEADER_SET_COOKIE = _http2$constants.HTTP2_HEADER_SET_COOKIE, NGHTTP2_CANCEL = _http2$constants.NGHTTP2_CANCEL;
    function setProtocol(protocol) {
      return {
        request: function request(options) {
          return new Request(protocol, options);
        }
      };
    }
    function Request(protocol, options) {
      var _this = this;
      Stream.call(this);
      var defaultPort = protocol === "https:" ? 443 : 80;
      var defaultHost = "localhost";
      var port = options.port || defaultPort;
      var host = options.host || defaultHost;
      delete options.port;
      delete options.host;
      this.method = options.method;
      this.path = options.path;
      this.protocol = protocol;
      this.host = host;
      delete options.method;
      delete options.path;
      var sessionOptions = _objectSpread({}, options);
      if (options.socketPath) {
        sessionOptions.socketPath = options.socketPath;
        sessionOptions.createConnection = this.createUnixConnection.bind(this);
      }
      this._headers = {};
      var session = http2.connect("".concat(protocol, "//").concat(host, ":").concat(port), sessionOptions);
      this.setHeader("host", "".concat(host, ":").concat(port));
      session.on("error", function(err) {
        return _this.emit("error", err);
      });
      this.session = session;
    }
    util.inherits(Request, Stream);
    Request.prototype.createUnixConnection = function(authority, options) {
      switch (this.protocol) {
        case "http:":
          return net.connect(options.socketPath);
        case "https:":
          options.ALPNProtocols = ["h2"];
          options.servername = this.host;
          options.allowHalfOpen = true;
          return tls.connect(options.socketPath, options);
        default:
          throw new Error("Unsupported protocol", this.protocol);
      }
    };
    Request.prototype.setNoDelay = function(bool) {
    };
    Request.prototype.getFrame = function() {
      var _method, _this2 = this;
      if (this.frame) {
        return this.frame;
      }
      var method2 = (_method = {}, _defineProperty(_method, HTTP2_HEADER_PATH, this.path), _defineProperty(_method, HTTP2_HEADER_METHOD, this.method), _method);
      var headers = this.mapToHttp2Header(this._headers);
      headers = Object.assign(headers, method2);
      var frame = this.session.request(headers);
      frame.once("response", function(headers2, flags) {
        headers2 = _this2.mapToHttpHeader(headers2);
        frame.headers = headers2;
        frame.statusCode = headers2[HTTP2_HEADER_STATUS];
        frame.status = frame.statusCode;
        _this2.emit("response", frame);
      });
      this._headerSent = true;
      frame.once("drain", function() {
        return _this2.emit("drain");
      });
      frame.on("error", function(err) {
        return _this2.emit("error", err);
      });
      frame.on("close", function() {
        return _this2.session.close();
      });
      this.frame = frame;
      return frame;
    };
    Request.prototype.mapToHttpHeader = function(headers) {
      var keys = Object.keys(headers);
      var http2Headers = {};
      for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
        var key = _keys[_i];
        var value = headers[key];
        key = key.toLowerCase();
        switch (key) {
          case HTTP2_HEADER_SET_COOKIE:
            value = Array.isArray(value) ? value : [value];
            break;
          default:
            break;
        }
        http2Headers[key] = value;
      }
      return http2Headers;
    };
    Request.prototype.mapToHttp2Header = function(headers) {
      var keys = Object.keys(headers);
      var http2Headers = {};
      for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {
        var key = _keys2[_i2];
        var value = headers[key];
        key = key.toLowerCase();
        switch (key) {
          case HTTP2_HEADER_HOST:
            key = HTTP2_HEADER_AUTHORITY;
            value = /^http:\/\/|^https:\/\//.test(value) ? parse(value).host : value;
            break;
          default:
            break;
        }
        http2Headers[key] = value;
      }
      return http2Headers;
    };
    Request.prototype.setHeader = function(name, value) {
      this._headers[name.toLowerCase()] = value;
    };
    Request.prototype.getHeader = function(name) {
      return this._headers[name.toLowerCase()];
    };
    Request.prototype.write = function(data, encoding) {
      var frame = this.getFrame();
      return frame.write(data, encoding);
    };
    Request.prototype.pipe = function(stream, options) {
      var frame = this.getFrame();
      return frame.pipe(stream, options);
    };
    Request.prototype.end = function(data) {
      var frame = this.getFrame();
      frame.end(data);
    };
    Request.prototype.abort = function(data) {
      var frame = this.getFrame();
      frame.close(NGHTTP2_CANCEL);
      this.session.destroy();
    };
    exports2.setProtocol = setProtocol;
  }
});

// node_modules/superagent/lib/agent-base.js
var require_agent_base = __commonJS({
  "node_modules/superagent/lib/agent-base.js"(exports2, module2) {
    "use strict";
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function Agent() {
      this._defaults = [];
    }
    ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"].forEach(function(fn) {
      Agent.prototype[fn] = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        this._defaults.push({
          fn,
          args
        });
        return this;
      };
    });
    Agent.prototype._setDefaults = function(req) {
      this._defaults.forEach(function(def) {
        req[def.fn].apply(req, _toConsumableArray(def.args));
      });
    };
    module2.exports = Agent;
  }
});

// node_modules/superagent/lib/node/agent.js
var require_agent = __commonJS({
  "node_modules/superagent/lib/node/agent.js"(exports2, module2) {
    "use strict";
    var _require = require("url"), parse = _require.parse;
    var _require2 = require_cookiejar(), CookieJar = _require2.CookieJar;
    var _require3 = require_cookiejar(), CookieAccessInfo = _require3.CookieAccessInfo;
    var methods = require_methods();
    var request = require_node2();
    var AgentBase = require_agent_base();
    module2.exports = Agent;
    function Agent(options) {
      if (!(this instanceof Agent)) {
        return new Agent(options);
      }
      AgentBase.call(this);
      this.jar = new CookieJar();
      if (options) {
        if (options.ca) {
          this.ca(options.ca);
        }
        if (options.key) {
          this.key(options.key);
        }
        if (options.pfx) {
          this.pfx(options.pfx);
        }
        if (options.cert) {
          this.cert(options.cert);
        }
        if (options.rejectUnauthorized === false) {
          this.disableTLSCerts();
        }
      }
    }
    Agent.prototype = Object.create(AgentBase.prototype);
    Agent.prototype._saveCookies = function(res) {
      var cookies = res.headers["set-cookie"];
      if (cookies)
        this.jar.setCookies(cookies);
    };
    Agent.prototype._attachCookies = function(req) {
      var url = parse(req.url);
      var access = new CookieAccessInfo(url.hostname, url.pathname, url.protocol === "https:");
      var cookies = this.jar.getCookies(access).toValueString();
      req.cookies = cookies;
    };
    methods.forEach(function(name) {
      var method2 = name.toUpperCase();
      Agent.prototype[name] = function(url, fn) {
        var req = new request.Request(method2, url);
        req.on("response", this._saveCookies.bind(this));
        req.on("redirect", this._saveCookies.bind(this));
        req.on("redirect", this._attachCookies.bind(this, req));
        this._setDefaults(req);
        this._attachCookies(req);
        if (fn) {
          req.end(fn);
        }
        return req;
      };
    });
    Agent.prototype.del = Agent.prototype.delete;
  }
});

// node_modules/superagent/lib/node/parsers/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/superagent/lib/node/parsers/urlencoded.js"(exports2, module2) {
    "use strict";
    var qs = require_lib();
    module2.exports = function(res, fn) {
      res.text = "";
      res.setEncoding("ascii");
      res.on("data", function(chunk) {
        res.text += chunk;
      });
      res.on("end", function() {
        try {
          fn(null, qs.parse(res.text));
        } catch (err) {
          fn(err);
        }
      });
    };
  }
});

// node_modules/superagent/lib/node/parsers/json.js
var require_json = __commonJS({
  "node_modules/superagent/lib/node/parsers/json.js"(exports2, module2) {
    "use strict";
    module2.exports = function(res, fn) {
      res.text = "";
      res.setEncoding("utf8");
      res.on("data", function(chunk) {
        res.text += chunk;
      });
      res.on("end", function() {
        var body;
        var err;
        try {
          body = res.text && JSON.parse(res.text);
        } catch (err_) {
          err = err_;
          err.rawResponse = res.text || null;
          err.statusCode = res.statusCode;
        } finally {
          fn(err, body);
        }
      });
    };
  }
});

// node_modules/superagent/lib/node/parsers/text.js
var require_text = __commonJS({
  "node_modules/superagent/lib/node/parsers/text.js"(exports2, module2) {
    "use strict";
    module2.exports = function(res, fn) {
      res.text = "";
      res.setEncoding("utf8");
      res.on("data", function(chunk) {
        res.text += chunk;
      });
      res.on("end", fn);
    };
  }
});

// node_modules/superagent/lib/node/parsers/image.js
var require_image = __commonJS({
  "node_modules/superagent/lib/node/parsers/image.js"(exports2, module2) {
    "use strict";
    module2.exports = function(res, fn) {
      var data = [];
      res.on("data", function(chunk) {
        data.push(chunk);
      });
      res.on("end", function() {
        fn(null, Buffer.concat(data));
      });
    };
  }
});

// node_modules/superagent/lib/node/parsers/index.js
var require_parsers = __commonJS({
  "node_modules/superagent/lib/node/parsers/index.js"(exports2) {
    "use strict";
    exports2["application/x-www-form-urlencoded"] = require_urlencoded();
    exports2["application/json"] = require_json();
    exports2.text = require_text();
    var binary = require_image();
    exports2["application/octet-stream"] = binary;
    exports2["application/pdf"] = binary;
    exports2.image = binary;
  }
});

// node_modules/superagent/lib/node/index.js
var require_node2 = __commonJS({
  "node_modules/superagent/lib/node/index.js"(exports2, module2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var _require = require("url"), parse = _require.parse, format = _require.format, resolve = _require.resolve;
    var Stream = require("stream");
    var https = require("https");
    var http = require("http");
    var fs = require("fs");
    var zlib = require("zlib");
    var util = require("util");
    var qs = require_lib();
    var mime = require_mime();
    var methods = require_methods();
    var FormData = require_form_data();
    var formidable = require_lib2();
    var debug = require_src2()("superagent");
    var CookieJar = require_cookiejar();
    var semver = require_semver2();
    var safeStringify = require_fast_safe_stringify();
    var utils = require_utils3();
    var RequestBase = require_request_base();
    var _require2 = require_unzip(), unzip = _require2.unzip;
    var Response = require_response();
    var http2;
    if (semver.gte(process.version, "v10.10.0"))
      http2 = require_http2wrapper();
    function request(method2, url) {
      if (typeof url === "function") {
        return new exports2.Request("GET", method2).end(url);
      }
      if (arguments.length === 1) {
        return new exports2.Request("GET", method2);
      }
      return new exports2.Request(method2, url);
    }
    module2.exports = request;
    exports2 = module2.exports;
    exports2.Request = Request;
    exports2.agent = require_agent();
    function noop() {
    }
    exports2.Response = Response;
    mime.define({
      "application/x-www-form-urlencoded": ["form", "urlencoded", "form-data"]
    }, true);
    exports2.protocols = {
      "http:": http,
      "https:": https,
      "http2:": http2
    };
    exports2.serialize = {
      "application/x-www-form-urlencoded": qs.stringify,
      "application/json": safeStringify
    };
    exports2.parse = require_parsers();
    exports2.buffer = {};
    function _initHeaders(req) {
      req._header = {};
      req.header = {};
    }
    function Request(method2, url) {
      Stream.call(this);
      if (typeof url !== "string")
        url = format(url);
      this._enableHttp2 = Boolean(process.env.HTTP2_TEST);
      this._agent = false;
      this._formData = null;
      this.method = method2;
      this.url = url;
      _initHeaders(this);
      this.writable = true;
      this._redirects = 0;
      this.redirects(method2 === "HEAD" ? 0 : 5);
      this.cookies = "";
      this.qs = {};
      this._query = [];
      this.qsRaw = this._query;
      this._redirectList = [];
      this._streamRequest = false;
      this.once("end", this.clearTimeout.bind(this));
    }
    util.inherits(Request, Stream);
    RequestBase(Request.prototype);
    Request.prototype.http2 = function(bool) {
      if (exports2.protocols["http2:"] === void 0) {
        throw new Error("superagent: this version of Node.js does not support http2");
      }
      this._enableHttp2 = bool === void 0 ? true : bool;
      return this;
    };
    Request.prototype.attach = function(field, file, options) {
      if (file) {
        if (this._data) {
          throw new Error("superagent can't mix .send() and .attach()");
        }
        var o = options || {};
        if (typeof options === "string") {
          o = {
            filename: options
          };
        }
        if (typeof file === "string") {
          if (!o.filename)
            o.filename = file;
          debug("creating `fs.ReadStream` instance for file: %s", file);
          file = fs.createReadStream(file);
        } else if (!o.filename && file.path) {
          o.filename = file.path;
        }
        this._getFormData().append(field, file, o);
      }
      return this;
    };
    Request.prototype._getFormData = function() {
      var _this = this;
      if (!this._formData) {
        this._formData = new FormData();
        this._formData.on("error", function(err) {
          debug("FormData error", err);
          if (_this.called) {
            return;
          }
          _this.callback(err);
          _this.abort();
        });
      }
      return this._formData;
    };
    Request.prototype.agent = function(agent) {
      if (arguments.length === 0)
        return this._agent;
      this._agent = agent;
      return this;
    };
    Request.prototype.type = function(type) {
      return this.set("Content-Type", type.includes("/") ? type : mime.getType(type));
    };
    Request.prototype.accept = function(type) {
      return this.set("Accept", type.includes("/") ? type : mime.getType(type));
    };
    Request.prototype.query = function(val) {
      if (typeof val === "string") {
        this._query.push(val);
      } else {
        Object.assign(this.qs, val);
      }
      return this;
    };
    Request.prototype.write = function(data, encoding) {
      var req = this.request();
      if (!this._streamRequest) {
        this._streamRequest = true;
      }
      return req.write(data, encoding);
    };
    Request.prototype.pipe = function(stream, options) {
      this.piped = true;
      this.buffer(false);
      this.end();
      return this._pipeContinue(stream, options);
    };
    Request.prototype._pipeContinue = function(stream, options) {
      var _this2 = this;
      this.req.once("response", function(res) {
        if (isRedirect(res.statusCode) && _this2._redirects++ !== _this2._maxRedirects) {
          return _this2._redirect(res) === _this2 ? _this2._pipeContinue(stream, options) : void 0;
        }
        _this2.res = res;
        _this2._emitResponse();
        if (_this2._aborted)
          return;
        if (_this2._shouldUnzip(res)) {
          var unzipObj = zlib.createUnzip();
          unzipObj.on("error", function(err) {
            if (err && err.code === "Z_BUF_ERROR") {
              stream.emit("end");
              return;
            }
            stream.emit("error", err);
          });
          res.pipe(unzipObj).pipe(stream, options);
        } else {
          res.pipe(stream, options);
        }
        res.once("end", function() {
          _this2.emit("end");
        });
      });
      return stream;
    };
    Request.prototype.buffer = function(val) {
      this._buffer = val !== false;
      return this;
    };
    Request.prototype._redirect = function(res) {
      var url = res.headers.location;
      if (!url) {
        return this.callback(new Error("No location header for redirect"), res);
      }
      debug("redirect %s -> %s", this.url, url);
      url = resolve(this.url, url);
      res.resume();
      var headers = this.req.getHeaders ? this.req.getHeaders() : this.req._headers;
      var changesOrigin = parse(url).host !== parse(this.url).host;
      if (res.statusCode === 301 || res.statusCode === 302) {
        headers = utils.cleanHeader(headers, changesOrigin);
        this.method = this.method === "HEAD" ? "HEAD" : "GET";
        this._data = null;
      }
      if (res.statusCode === 303) {
        headers = utils.cleanHeader(headers, changesOrigin);
        this.method = "GET";
        this._data = null;
      }
      delete headers.host;
      delete this.req;
      delete this._formData;
      _initHeaders(this);
      this._endCalled = false;
      this.url = url;
      this.qs = {};
      this._query.length = 0;
      this.set(headers);
      this.emit("redirect", res);
      this._redirectList.push(this.url);
      this.end(this._callback);
      return this;
    };
    Request.prototype.auth = function(user, pass, options) {
      if (arguments.length === 1)
        pass = "";
      if (_typeof(pass) === "object" && pass !== null) {
        options = pass;
        pass = "";
      }
      if (!options) {
        options = {
          type: "basic"
        };
      }
      var encoder = function encoder2(string) {
        return Buffer.from(string).toString("base64");
      };
      return this._auth(user, pass, options, encoder);
    };
    Request.prototype.ca = function(cert) {
      this._ca = cert;
      return this;
    };
    Request.prototype.key = function(cert) {
      this._key = cert;
      return this;
    };
    Request.prototype.pfx = function(cert) {
      if (_typeof(cert) === "object" && !Buffer.isBuffer(cert)) {
        this._pfx = cert.pfx;
        this._passphrase = cert.passphrase;
      } else {
        this._pfx = cert;
      }
      return this;
    };
    Request.prototype.cert = function(cert) {
      this._cert = cert;
      return this;
    };
    Request.prototype.disableTLSCerts = function() {
      this._disableTLSCerts = true;
      return this;
    };
    Request.prototype.request = function() {
      var _this3 = this;
      if (this.req)
        return this.req;
      var options = {};
      try {
        var query = qs.stringify(this.qs, {
          indices: false,
          strictNullHandling: true
        });
        if (query) {
          this.qs = {};
          this._query.push(query);
        }
        this._finalizeQueryString();
      } catch (err) {
        return this.emit("error", err);
      }
      var url = this.url;
      var retries = this._retries;
      var queryStringBackticks;
      if (url.includes("`")) {
        var queryStartIndex = url.indexOf("?");
        if (queryStartIndex !== -1) {
          var queryString = url.slice(queryStartIndex + 1);
          queryStringBackticks = queryString.match(/`|%60/g);
        }
      }
      if (url.indexOf("http") !== 0)
        url = "http://".concat(url);
      url = parse(url);
      if (queryStringBackticks) {
        var i = 0;
        url.query = url.query.replace(/%60/g, function() {
          return queryStringBackticks[i++];
        });
        url.search = "?".concat(url.query);
        url.path = url.pathname + url.search;
      }
      if (/^https?\+unix:/.test(url.protocol) === true) {
        url.protocol = "".concat(url.protocol.split("+")[0], ":");
        var unixParts = url.path.match(/^([^/]+)(.+)$/);
        options.socketPath = unixParts[1].replace(/%2F/g, "/");
        url.path = unixParts[2];
      }
      if (this._connectOverride) {
        var _url = url, hostname = _url.hostname;
        var match = hostname in this._connectOverride ? this._connectOverride[hostname] : this._connectOverride["*"];
        if (match) {
          if (!this._header.host) {
            this.set("host", url.host);
          }
          var newHost;
          var newPort;
          if (_typeof(match) === "object") {
            newHost = match.host;
            newPort = match.port;
          } else {
            newHost = match;
            newPort = url.port;
          }
          url.host = /:/.test(newHost) ? "[".concat(newHost, "]") : newHost;
          if (newPort) {
            url.host += ":".concat(newPort);
            url.port = newPort;
          }
          url.hostname = newHost;
        }
      }
      options.method = this.method;
      options.port = url.port;
      options.path = url.path;
      options.host = url.hostname;
      options.ca = this._ca;
      options.key = this._key;
      options.pfx = this._pfx;
      options.cert = this._cert;
      options.passphrase = this._passphrase;
      options.agent = this._agent;
      options.rejectUnauthorized = typeof this._disableTLSCerts === "boolean" ? !this._disableTLSCerts : process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0";
      if (this._header.host) {
        options.servername = this._header.host.replace(/:\d+$/, "");
      }
      if (this._trustLocalhost && /^(?:localhost|127\.0\.0\.\d+|(0*:)+:0*1)$/.test(url.hostname)) {
        options.rejectUnauthorized = false;
      }
      var mod = this._enableHttp2 ? exports2.protocols["http2:"].setProtocol(url.protocol) : exports2.protocols[url.protocol];
      this.req = mod.request(options);
      var req = this.req;
      req.setNoDelay(true);
      if (options.method !== "HEAD") {
        req.setHeader("Accept-Encoding", "gzip, deflate");
      }
      this.protocol = url.protocol;
      this.host = url.host;
      req.once("drain", function() {
        _this3.emit("drain");
      });
      req.on("error", function(err) {
        if (_this3._aborted)
          return;
        if (_this3._retries !== retries)
          return;
        if (_this3.response)
          return;
        _this3.callback(err);
      });
      if (url.auth) {
        var auth = url.auth.split(":");
        this.auth(auth[0], auth[1]);
      }
      if (this.username && this.password) {
        this.auth(this.username, this.password);
      }
      for (var key in this.header) {
        if (Object.prototype.hasOwnProperty.call(this.header, key))
          req.setHeader(key, this.header[key]);
      }
      if (this.cookies) {
        if (Object.prototype.hasOwnProperty.call(this._header, "cookie")) {
          var tmpJar = new CookieJar.CookieJar();
          tmpJar.setCookies(this._header.cookie.split(";"));
          tmpJar.setCookies(this.cookies.split(";"));
          req.setHeader("Cookie", tmpJar.getCookies(CookieJar.CookieAccessInfo.All).toValueString());
        } else {
          req.setHeader("Cookie", this.cookies);
        }
      }
      return req;
    };
    Request.prototype.callback = function(err, res) {
      if (this._shouldRetry(err, res)) {
        return this._retry();
      }
      var fn = this._callback || noop;
      this.clearTimeout();
      if (this.called)
        return console.warn("superagent: double callback bug");
      this.called = true;
      if (!err) {
        try {
          if (!this._isResponseOK(res)) {
            var msg = "Unsuccessful HTTP response";
            if (res) {
              msg = http.STATUS_CODES[res.status] || msg;
            }
            err = new Error(msg);
            err.status = res ? res.status : void 0;
          }
        } catch (err_) {
          err = err_;
        }
      }
      if (!err) {
        return fn(null, res);
      }
      err.response = res;
      if (this._maxRetries)
        err.retries = this._retries - 1;
      if (err && this.listeners("error").length > 0) {
        this.emit("error", err);
      }
      fn(err, res);
    };
    Request.prototype._isHost = function(obj) {
      return Buffer.isBuffer(obj) || obj instanceof Stream || obj instanceof FormData;
    };
    Request.prototype._emitResponse = function(body, files) {
      var response = new Response(this);
      this.response = response;
      response.redirects = this._redirectList;
      if (body !== void 0) {
        response.body = body;
      }
      response.files = files;
      if (this._endCalled) {
        response.pipe = function() {
          throw new Error("end() has already been called, so it's too late to start piping");
        };
      }
      this.emit("response", response);
      return response;
    };
    Request.prototype.end = function(fn) {
      this.request();
      debug("%s %s", this.method, this.url);
      if (this._endCalled) {
        throw new Error(".end() was called twice. This is not supported in superagent");
      }
      this._endCalled = true;
      this._callback = fn || noop;
      this._end();
    };
    Request.prototype._end = function() {
      var _this4 = this;
      if (this._aborted)
        return this.callback(new Error("The request has been aborted even before .end() was called"));
      var data = this._data;
      var req = this.req;
      var method2 = this.method;
      this._setTimeouts();
      if (method2 !== "HEAD" && !req._headerSent) {
        if (typeof data !== "string") {
          var contentType = req.getHeader("Content-Type");
          if (contentType)
            contentType = contentType.split(";")[0];
          var serialize = this._serializer || exports2.serialize[contentType];
          if (!serialize && isJSON(contentType)) {
            serialize = exports2.serialize["application/json"];
          }
          if (serialize)
            data = serialize(data);
        }
        if (data && !req.getHeader("Content-Length")) {
          req.setHeader("Content-Length", Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data));
        }
      }
      req.once("response", function(res) {
        debug("%s %s -> %s", _this4.method, _this4.url, res.statusCode);
        if (_this4._responseTimeoutTimer) {
          clearTimeout(_this4._responseTimeoutTimer);
        }
        if (_this4.piped) {
          return;
        }
        var max = _this4._maxRedirects;
        var mime2 = utils.type(res.headers["content-type"] || "") || "text/plain";
        var type = mime2.split("/")[0];
        if (type)
          type = type.toLowerCase().trim();
        var multipart = type === "multipart";
        var redirect = isRedirect(res.statusCode);
        var responseType = _this4._responseType;
        _this4.res = res;
        if (redirect && _this4._redirects++ !== max) {
          return _this4._redirect(res);
        }
        if (_this4.method === "HEAD") {
          _this4.emit("end");
          _this4.callback(null, _this4._emitResponse());
          return;
        }
        if (_this4._shouldUnzip(res)) {
          unzip(req, res);
        }
        var buffer = _this4._buffer;
        if (buffer === void 0 && mime2 in exports2.buffer) {
          buffer = Boolean(exports2.buffer[mime2]);
        }
        var parser = _this4._parser;
        if (buffer === void 0) {
          if (parser) {
            console.warn("A custom superagent parser has been set, but buffering strategy for the parser hasn't been configured. Call `req.buffer(true or false)` or set `superagent.buffer[mime] = true or false`");
            buffer = true;
          }
        }
        if (!parser) {
          if (responseType) {
            parser = exports2.parse.image;
            buffer = true;
          } else if (multipart) {
            var form = new formidable.IncomingForm();
            parser = form.parse.bind(form);
            buffer = true;
          } else if (isImageOrVideo(mime2)) {
            parser = exports2.parse.image;
            buffer = true;
          } else if (exports2.parse[mime2]) {
            parser = exports2.parse[mime2];
          } else if (type === "text") {
            parser = exports2.parse.text;
            buffer = buffer !== false;
          } else if (isJSON(mime2)) {
            parser = exports2.parse["application/json"];
            buffer = buffer !== false;
          } else if (buffer) {
            parser = exports2.parse.text;
          } else if (buffer === void 0) {
            parser = exports2.parse.image;
            buffer = true;
          }
        }
        if (buffer === void 0 && isText(mime2) || isJSON(mime2)) {
          buffer = true;
        }
        _this4._resBuffered = buffer;
        var parserHandlesEnd = false;
        if (buffer) {
          var responseBytesLeft = _this4._maxResponseSize || 2e8;
          res.on("data", function(buf) {
            responseBytesLeft -= buf.byteLength || buf.length;
            if (responseBytesLeft < 0) {
              var err = new Error("Maximum response size reached");
              err.code = "ETOOLARGE";
              parserHandlesEnd = false;
              res.destroy(err);
            }
          });
        }
        if (parser) {
          try {
            parserHandlesEnd = buffer;
            parser(res, function(err, obj, files) {
              if (_this4.timedout) {
                return;
              }
              if (err && !_this4._aborted) {
                return _this4.callback(err);
              }
              if (parserHandlesEnd) {
                _this4.emit("end");
                _this4.callback(null, _this4._emitResponse(obj, files));
              }
            });
          } catch (err) {
            _this4.callback(err);
            return;
          }
        }
        _this4.res = res;
        if (!buffer) {
          debug("unbuffered %s %s", _this4.method, _this4.url);
          _this4.callback(null, _this4._emitResponse());
          if (multipart)
            return;
          res.once("end", function() {
            debug("end %s %s", _this4.method, _this4.url);
            _this4.emit("end");
          });
          return;
        }
        res.once("error", function(err) {
          parserHandlesEnd = false;
          _this4.callback(err, null);
        });
        if (!parserHandlesEnd)
          res.once("end", function() {
            debug("end %s %s", _this4.method, _this4.url);
            _this4.emit("end");
            _this4.callback(null, _this4._emitResponse());
          });
      });
      this.emit("request", this);
      var getProgressMonitor = function getProgressMonitor2() {
        var lengthComputable = true;
        var total = req.getHeader("Content-Length");
        var loaded = 0;
        var progress = new Stream.Transform();
        progress._transform = function(chunk, encoding, cb) {
          loaded += chunk.length;
          _this4.emit("progress", {
            direction: "upload",
            lengthComputable,
            loaded,
            total
          });
          cb(null, chunk);
        };
        return progress;
      };
      var bufferToChunks = function bufferToChunks2(buffer) {
        var chunkSize = 16 * 1024;
        var chunking = new Stream.Readable();
        var totalLength = buffer.length;
        var remainder = totalLength % chunkSize;
        var cutoff = totalLength - remainder;
        for (var i2 = 0; i2 < cutoff; i2 += chunkSize) {
          var chunk = buffer.slice(i2, i2 + chunkSize);
          chunking.push(chunk);
        }
        if (remainder > 0) {
          var remainderBuffer = buffer.slice(-remainder);
          chunking.push(remainderBuffer);
        }
        chunking.push(null);
        return chunking;
      };
      var formData = this._formData;
      if (formData) {
        var headers = formData.getHeaders();
        for (var i in headers) {
          if (Object.prototype.hasOwnProperty.call(headers, i)) {
            debug('setting FormData header: "%s: %s"', i, headers[i]);
            req.setHeader(i, headers[i]);
          }
        }
        formData.getLength(function(err, length) {
          if (err)
            debug("formData.getLength had error", err, length);
          debug("got FormData Content-Length: %s", length);
          if (typeof length === "number") {
            req.setHeader("Content-Length", length);
          }
          formData.pipe(getProgressMonitor()).pipe(req);
        });
      } else if (Buffer.isBuffer(data)) {
        bufferToChunks(data).pipe(getProgressMonitor()).pipe(req);
      } else {
        req.end(data);
      }
    };
    Request.prototype._shouldUnzip = function(res) {
      if (res.statusCode === 204 || res.statusCode === 304) {
        return false;
      }
      if (res.headers["content-length"] === "0") {
        return false;
      }
      return /^\s*(?:deflate|gzip)\s*$/.test(res.headers["content-encoding"]);
    };
    Request.prototype.connect = function(connectOverride) {
      if (typeof connectOverride === "string") {
        this._connectOverride = {
          "*": connectOverride
        };
      } else if (_typeof(connectOverride) === "object") {
        this._connectOverride = connectOverride;
      } else {
        this._connectOverride = void 0;
      }
      return this;
    };
    Request.prototype.trustLocalhost = function(toggle) {
      this._trustLocalhost = toggle === void 0 ? true : toggle;
      return this;
    };
    if (!methods.includes("del")) {
      methods = methods.slice(0);
      methods.push("del");
    }
    methods.forEach(function(method2) {
      var name = method2;
      method2 = method2 === "del" ? "delete" : method2;
      method2 = method2.toUpperCase();
      request[name] = function(url, data, fn) {
        var req = request(method2, url);
        if (typeof data === "function") {
          fn = data;
          data = null;
        }
        if (data) {
          if (method2 === "GET" || method2 === "HEAD") {
            req.query(data);
          } else {
            req.send(data);
          }
        }
        if (fn)
          req.end(fn);
        return req;
      };
    });
    function isText(mime2) {
      var parts = mime2.split("/");
      var type = parts[0];
      if (type)
        type = type.toLowerCase().trim();
      var subtype = parts[1];
      if (subtype)
        subtype = subtype.toLowerCase().trim();
      return type === "text" || subtype === "x-www-form-urlencoded";
    }
    function isImageOrVideo(mime2) {
      var type = mime2.split("/")[0];
      if (type)
        type = type.toLowerCase().trim();
      return type === "image" || type === "video";
    }
    function isJSON(mime2) {
      return /[/+]json($|[^-\w])/i.test(mime2);
    }
    function isRedirect(code) {
      return [301, 302, 303, 305, 307, 308].includes(code);
    }
  }
});

// node_modules/algosdk/dist/cjs/src/client/urlTokenBaseHTTPClient.js
var require_urlTokenBaseHTTPClient = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/urlTokenBaseHTTPClient.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLTokenBaseHTTPClient = void 0;
    var url_parse_1 = __importDefault(require_url_parse());
    var path_1 = __importDefault(require("path"));
    var request = __importStar(require_node2());
    var URLTokenBaseHTTPClient = class {
      constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {
        this.defaultHeaders = defaultHeaders;
        const baseServerURL = new url_parse_1.default(baseServer, {});
        if (typeof port !== "undefined") {
          baseServerURL.set("port", port.toString());
        }
        if (baseServerURL.protocol.length === 0) {
          throw new Error("Invalid base server URL, protocol must be defined.");
        }
        this.baseURL = baseServerURL;
        this.tokenHeader = tokenHeader;
      }
      addressWithPath(relativePath) {
        const address = new url_parse_1.default(path_1.default.posix.join(this.baseURL.pathname, relativePath), this.baseURL);
        return address.toString();
      }
      static superagentToHTTPClientResponse(res) {
        if (res.body instanceof ArrayBuffer) {
          res.body = new Uint8Array(res.body);
        }
        return res;
      }
      static formatSuperagentError(err) {
        if (err.response) {
          try {
            const decoded = JSON.parse(Buffer.from(err.response.body).toString());
            err.message = `Network request error. Received status ${err.response.status}: ${decoded.message}`;
          } catch (err2) {
          }
        }
        return err;
      }
      async get(relativePath, query, requestHeaders = {}) {
        const r = request.get(this.addressWithPath(relativePath)).set(this.tokenHeader).set(this.defaultHeaders).set(requestHeaders).responseType("arraybuffer").query(query);
        try {
          const res = await r;
          return URLTokenBaseHTTPClient.superagentToHTTPClientResponse(res);
        } catch (err) {
          throw URLTokenBaseHTTPClient.formatSuperagentError(err);
        }
      }
      async post(relativePath, data, query, requestHeaders = {}) {
        const r = request.post(this.addressWithPath(relativePath)).set(this.tokenHeader).set(this.defaultHeaders).set(requestHeaders).query(query).serialize((o) => o).responseType("arraybuffer").send(Buffer.from(data));
        try {
          const res = await r;
          return URLTokenBaseHTTPClient.superagentToHTTPClientResponse(res);
        } catch (err) {
          throw URLTokenBaseHTTPClient.formatSuperagentError(err);
        }
      }
      async delete(relativePath, data, query, requestHeaders = {}) {
        const r = request.delete(this.addressWithPath(relativePath)).set(this.tokenHeader).set(this.defaultHeaders).set(requestHeaders).query(query).serialize((o) => o).responseType("arraybuffer").send(Buffer.from(data));
        try {
          const res = await r;
          return URLTokenBaseHTTPClient.superagentToHTTPClientResponse(res);
        } catch (err) {
          throw URLTokenBaseHTTPClient.formatSuperagentError(err);
        }
      }
    };
    exports2.URLTokenBaseHTTPClient = URLTokenBaseHTTPClient;
  }
});

// node_modules/algosdk/dist/cjs/src/client/client.js
var require_client = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/client.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = __importStar(require_utils());
    var urlTokenBaseHTTPClient_1 = require_urlTokenBaseHTTPClient();
    function removeFalsyOrEmpty(obj) {
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          if (!obj[key] || obj[key].length === 0)
            delete obj[key];
        }
      }
      return obj;
    }
    function tolowerCaseKeys(o) {
      return Object.keys(o).reduce((c, k) => (c[k.toLowerCase()] = o[k], c), {});
    }
    function getAcceptFormat(query) {
      if (query !== void 0 && Object.prototype.hasOwnProperty.call(query, "format")) {
        switch (query.format) {
          case "msgpack":
            return "application/msgpack";
          case "json":
          default:
            return "application/json";
        }
      } else
        return "application/json";
    }
    var HTTPClient = class {
      constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {
        if (baseServer !== void 0) {
          this.bc = new urlTokenBaseHTTPClient_1.URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);
        } else {
          this.bc = bcOrTokenHeader;
        }
      }
      static parseJSON(text, status, jsonOptions = {}) {
        try {
          if (Object.keys(jsonOptions).length === 0) {
            return text && JSON.parse(text);
          }
          return text && utils.parseJSON(text, jsonOptions);
        } catch (err_) {
          const err = err_;
          err.rawResponse = text || null;
          err.statusCode = status;
          throw err;
        }
      }
      static serializeData(data, requestHeaders) {
        if (!data) {
          return new Uint8Array(0);
        }
        if (requestHeaders["content-type"] === "application/json") {
          return new Uint8Array(Buffer.from(JSON.stringify(data)));
        }
        if (typeof data === "string") {
          return new Uint8Array(Buffer.from(data));
        }
        if (data instanceof Uint8Array) {
          return data;
        }
        throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
      }
      static prepareResponse(res, format, jsonOptions = {}) {
        let { body } = res;
        let text;
        if (format !== "application/msgpack") {
          text = body && Buffer.from(body).toString() || "";
        }
        if (format === "application/json") {
          body = HTTPClient.parseJSON(text, res.status, jsonOptions);
        }
        return {
          ...res,
          body,
          text,
          ok: Math.trunc(res.status / 100) === 2
        };
      }
      static prepareResponseError(err) {
        if (err.response) {
          err.response = HTTPClient.prepareResponse(err.response, "application/json");
          err.status = err.response.status;
        }
        return err;
      }
      async get(relativePath, query, requestHeaders = {}, jsonOptions = {}) {
        const format = getAcceptFormat(query);
        const fullHeaders = { ...requestHeaders, accept: format };
        try {
          const res = await this.bc.get(relativePath, removeFalsyOrEmpty(query), fullHeaders);
          return HTTPClient.prepareResponse(res, format, jsonOptions);
        } catch (err) {
          throw HTTPClient.prepareResponseError(err);
        }
      }
      async post(relativePath, data, requestHeaders = {}) {
        const fullHeaders = {
          "content-type": "application/json",
          ...tolowerCaseKeys(requestHeaders)
        };
        try {
          const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), void 0, fullHeaders);
          return HTTPClient.prepareResponse(res, "application/json");
        } catch (err) {
          throw HTTPClient.prepareResponseError(err);
        }
      }
      async delete(relativePath, data, requestHeaders = {}) {
        const fullHeaders = {
          "content-type": "application/json",
          ...tolowerCaseKeys(requestHeaders)
        };
        const res = await this.bc.delete(relativePath, HTTPClient.serializeData(data, fullHeaders), void 0, fullHeaders);
        return HTTPClient.prepareResponse(res, "application/json");
      }
    };
    exports2.default = HTTPClient;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/jsonrequest.js
var require_jsonrequest = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/jsonrequest.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var intDecoding_1 = __importDefault(require_intDecoding());
    var JSONRequest = class {
      constructor(client, intDecoding) {
        this.c = client;
        this.query = {};
        this.intDecoding = intDecoding || intDecoding_1.default.DEFAULT;
      }
      prepare(body) {
        return body;
      }
      async do(headers = {}) {
        const jsonOptions = {};
        if (this.intDecoding !== "default") {
          jsonOptions.intDecoding = this.intDecoding;
        }
        const res = await this.c.get(this.path(), this.query, headers, jsonOptions);
        return this.prepare(res.body);
      }
      setIntDecoding(method2) {
        if (method2 !== "default" && method2 !== "safe" && method2 !== "mixed" && method2 !== "bigint")
          throw new Error(`Invalid method for int decoding: ${method2}`);
        this.intDecoding = method2;
        return this;
      }
    };
    exports2.default = JSONRequest;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/sendRawTransaction.js
var require_sendRawTransaction = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/sendRawTransaction.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setSendTransactionHeaders = void 0;
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var utils_1 = require_utils();
    function setSendTransactionHeaders(headers = {}) {
      let hdrs = headers;
      if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
        hdrs = { ...headers };
        hdrs["Content-Type"] = "application/x-binary";
      }
      return hdrs;
    }
    exports2.setSendTransactionHeaders = setSendTransactionHeaders;
    function isByteArray(array) {
      return array && array.byteLength !== void 0;
    }
    var SendRawTransaction = class extends jsonrequest_1.default {
      constructor(c, stxOrStxs) {
        super(c);
        let forPosting = stxOrStxs;
        if (Array.isArray(stxOrStxs)) {
          if (!stxOrStxs.every(isByteArray)) {
            throw new TypeError("Array elements must be byte arrays");
          }
          forPosting = utils_1.concatArrays(...stxOrStxs);
        } else if (!isByteArray(forPosting)) {
          throw new TypeError("Argument must be byte array");
        }
        this.txnBytesToPost = forPosting;
      }
      path() {
        return "/v2/transactions";
      }
      async do(headers = {}) {
        const txHeaders = setSendTransactionHeaders(headers);
        const res = await this.c.post(this.path(), Buffer.from(this.txnBytesToPost), txHeaders);
        return res.body;
      }
    };
    exports2.default = SendRawTransaction;
  }
});

// node_modules/algosdk/dist/cjs/src/client/algod.js
var require_algod = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/algod.js"(exports2, module2) {
    var { default: HTTPClient } = require_client();
    var { setSendTransactionHeaders } = require_sendRawTransaction();
    function Algod(token = "", baseServer = "http://r2.algorand.network", port = 4180, headers = {}) {
      let tokenHeader = token;
      if (typeof tokenHeader === "string") {
        tokenHeader = { "X-Algo-API-Token": tokenHeader };
      }
      const c = new HTTPClient(tokenHeader, baseServer, port, headers);
      function noteb64ToNote(o) {
        if (!(o.noteb64 === void 0 || o.noteb64 === null)) {
          o.note = Buffer.from(o.noteb64, "base64");
        }
        return o;
      }
      this.status = async (headerObj = {}) => {
        const res = await c.get("/v1/status", {}, headerObj);
        return res.body;
      };
      this.healthCheck = async (headerObj = {}) => {
        const res = await c.get("/health", {}, headerObj);
        if (!res.ok) {
          throw new Error(`Health response: ${res.status}`);
        }
        return {};
      };
      this.statusAfterBlock = async (roundNumber, headerObj = {}) => {
        if (!Number.isInteger(roundNumber))
          throw Error("roundNumber should be an integer");
        const res = await c.get(`/v1/status/wait-for-block-after/${roundNumber}`, {}, headerObj);
        return res.body;
      };
      this.pendingTransactions = async (maxTxns, headerObj = {}) => {
        if (!Number.isInteger(maxTxns))
          throw Error("maxTxns should be an integer");
        const res = await c.get("/v1/transactions/pending", { max: maxTxns }, headerObj);
        if (res.statusCode === 200 && res.body.truncatedTxns.transactions !== void 0) {
          for (let i = 0; i < res.body.truncatedTxns.transactions.length; i++) {
            res.body.truncatedTxns.transactions[i] = noteb64ToNote(res.body.truncatedTxns.transactions[i]);
          }
        }
        return res.body;
      };
      this.versions = async (headerObj = {}) => {
        const res = await c.get("/versions", {}, headerObj);
        return res.body;
      };
      this.ledgerSupply = async (headerObj = {}) => {
        const res = await c.get("/v1/ledger/supply", {}, headerObj);
        return res.body;
      };
      this.transactionByAddress = async (addr, first = null, last = null, maxTxns = null, headerObj = {}) => {
        if (first !== null && !Number.isInteger(first)) {
          throw Error("first round should be an integer");
        }
        if (last !== null && !Number.isInteger(last)) {
          throw Error("last round should be an integer");
        }
        const res = await c.get(`/v1/account/${addr}/transactions`, { firstRound: first, lastRound: last, max: maxTxns }, headerObj);
        if (res.statusCode === 200 && res.body.transactions !== void 0) {
          for (let i = 0; i < res.body.transactions.length; i++) {
            res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);
          }
        }
        return res.body;
      };
      this.transactionByAddressAndDate = async (addr, fromDate, toDate, maxTxns = null, headerObj = {}) => {
        const res = await c.get(`/v1/account/${addr}/transactions`, { fromDate, toDate, max: maxTxns }, headerObj);
        if (res.statusCode === 200 && res.body.transactions !== void 0) {
          for (let i = 0; i < res.body.transactions.length; i++) {
            res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);
          }
        }
        return res.body;
      };
      this.transactionById = async (txid, headerObj = {}) => {
        const res = await c.get(`/v1/transaction/${txid}`, {}, headerObj);
        if (res.statusCode === 200) {
          res.body = noteb64ToNote(res.body);
        }
        return res.body;
      };
      this.transactionInformation = async (addr, txid, headerObj = {}) => {
        const res = await c.get(`/v1/account/${addr}/transaction/${txid}`, {}, headerObj);
        if (res.statusCode === 200) {
          res.body = noteb64ToNote(res.body);
        }
        return res.body;
      };
      this.pendingTransactionInformation = async (txid, headerObj = {}) => {
        const res = await c.get(`/v1/transactions/pending/${txid}`, {}, headerObj);
        if (res.statusCode === 200) {
          res.body = noteb64ToNote(res.body);
        }
        return res.body;
      };
      this.accountInformation = async (addr, headerObj = {}) => {
        const res = await c.get(`/v1/account/${addr}`, {}, headerObj);
        return res.body;
      };
      this.assetInformation = async (index, headerObj = {}) => {
        const res = await c.get(`/v1/asset/${index}`, {}, headerObj);
        return res.body;
      };
      this.suggestedFee = async (headerObj = {}) => {
        const res = await c.get("/v1/transactions/fee", {}, headerObj);
        return res.body;
      };
      this.sendRawTransaction = async (txn, headerObj = {}) => {
        const txHeaders = setSendTransactionHeaders(headerObj);
        const res = await c.post("/v1/transactions", Buffer.from(txn), txHeaders);
        return res.body;
      };
      this.sendRawTransactions = async (txns, headerObj = {}) => {
        const txHeaders = setSendTransactionHeaders(headerObj);
        const merged = Array.prototype.concat(...txns.map((arr) => Array.from(arr)));
        const res = await c.post("/v1/transactions", Buffer.from(merged), txHeaders);
        return res.body;
      };
      this.getTransactionParams = async (headerObj = {}) => {
        const res = await c.get("/v1/transactions/params", {}, headerObj);
        return res.body;
      };
      this.suggestParams = async (headerObj = {}) => {
        const result = await this.getTransactionParams(headerObj);
        return {
          flatFee: false,
          fee: result.fee,
          firstRound: result.lastRound,
          lastRound: result.lastRound + 1e3,
          genesisID: result.genesisID,
          genesisHash: result.genesishashb64
        };
      };
      this.block = async (roundNumber, headerObj = {}) => {
        if (!Number.isInteger(roundNumber))
          throw Error("roundNumber should be an integer");
        const res = await c.get(`/v1/block/${roundNumber}`, {}, headerObj);
        if (res.statusCode === 200 && res.body.txns.transactions !== void 0) {
          for (let i = 0; i < res.body.txns.transactions.length; i++) {
            res.body.txns.transactions[i] = noteb64ToNote(res.body.txns.transactions[i]);
          }
        }
        return res.body;
      };
    }
    module2.exports = { Algod };
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/serviceClient.js
var require_serviceClient = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/serviceClient.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var client_1 = __importDefault(require_client());
    var intDecoding_1 = __importDefault(require_intDecoding());
    function convertTokenStringToTokenHeader(token = "", headerIdentifier) {
      const tokenHeader = {};
      tokenHeader[headerIdentifier] = token;
      return tokenHeader;
    }
    function isBaseHTTPClient(tbc) {
      return typeof tbc.get === "function";
    }
    var ServiceClient = class {
      constructor(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient, baseServer, port, defaultHeaders = {}) {
        if (isBaseHTTPClient(tokenHeaderOrStrOrBaseClient)) {
          this.c = new client_1.default(tokenHeaderOrStrOrBaseClient);
        } else {
          let tokenHeader;
          if (typeof tokenHeaderOrStrOrBaseClient === "string") {
            tokenHeader = convertTokenStringToTokenHeader(tokenHeaderOrStrOrBaseClient, tokenHeaderIdentifier);
          } else {
            tokenHeader = tokenHeaderOrStrOrBaseClient;
          }
          this.c = new client_1.default(tokenHeader, baseServer, port, defaultHeaders);
        }
        this.intDecoding = intDecoding_1.default.DEFAULT;
      }
      setIntEncoding(method2) {
        this.intDecoding = method2;
      }
      getIntEncoding() {
        return this.intDecoding;
      }
    };
    exports2.default = ServiceClient;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/accountInformation.js
var require_accountInformation = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/accountInformation.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var AccountInformation = class extends jsonrequest_1.default {
      constructor(c, intDecoding, account) {
        super(c, intDecoding);
        this.account = account;
        this.account = account;
      }
      path() {
        return `/v2/accounts/${this.account}`;
      }
    };
    exports2.default = AccountInformation;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/block.js
var require_block = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/block.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var encoding = __importStar(require_encoding());
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var Block = class extends jsonrequest_1.default {
      constructor(c, roundNumber) {
        super(c);
        if (!Number.isInteger(roundNumber))
          throw Error("roundNumber should be an integer");
        this.round = roundNumber;
        this.query = { format: "msgpack" };
      }
      path() {
        return `/v2/blocks/${this.round}`;
      }
      prepare(body) {
        if (body && body.byteLength > 0) {
          return encoding.decode(body);
        }
        return void 0;
      }
    };
    exports2.default = Block;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/compile.js
var require_compile = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/compile.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setHeaders = void 0;
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    function setHeaders(headers = {}) {
      let hdrs = headers;
      if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
        hdrs = { ...headers };
        hdrs["Content-Type"] = "text/plain";
      }
      return hdrs;
    }
    exports2.setHeaders = setHeaders;
    var Compile = class extends jsonrequest_1.default {
      constructor(c, source) {
        super(c);
        this.source = source;
        this.source = source;
      }
      path() {
        return `/v2/teal/compile`;
      }
      async do(headers = {}) {
        const txHeaders = setHeaders(headers);
        const res = await this.c.post(this.path(), Buffer.from(this.source), txHeaders);
        return res.body;
      }
    };
    exports2.default = Compile;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/dryrun.js
var require_dryrun = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/dryrun.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var encoding = __importStar(require_encoding());
    var compile_1 = require_compile();
    var Dryrun = class extends jsonrequest_1.default {
      constructor(c, dr) {
        super(c);
        this.blob = encoding.encode(dr.get_obj_for_encoding(true));
      }
      path() {
        return "/v2/teal/dryrun";
      }
      async do(headers = {}) {
        const txHeaders = compile_1.setHeaders(headers);
        const res = await this.c.post(this.path(), Buffer.from(this.blob), txHeaders);
        return res.body;
      }
    };
    exports2.default = Dryrun;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/getAssetByID.js
var require_getAssetByID = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/getAssetByID.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var GetAssetByID = class extends jsonrequest_1.default {
      constructor(c, intDecoding, index) {
        super(c, intDecoding);
        this.index = index;
        this.index = index;
      }
      path() {
        return `/v2/assets/${this.index}`;
      }
    };
    exports2.default = GetAssetByID;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/getApplicationByID.js
var require_getApplicationByID = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/getApplicationByID.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var GetApplicationByID = class extends jsonrequest_1.default {
      constructor(c, intDecoding, index) {
        super(c, intDecoding);
        this.index = index;
        this.index = index;
      }
      path() {
        return `/v2/applications/${this.index}`;
      }
    };
    exports2.default = GetApplicationByID;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/healthCheck.js
var require_healthCheck = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/healthCheck.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var HealthCheck = class extends jsonrequest_1.default {
      path() {
        return "/health";
      }
      async do(headers = {}) {
        const res = await this.c.get(this.path(), {}, headers);
        if (!res.ok) {
          throw new Error(`Health response: ${res.status}`);
        }
        return {};
      }
    };
    exports2.default = HealthCheck;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/pendingTransactionInformation.js
var require_pendingTransactionInformation = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/pendingTransactionInformation.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var encoding = __importStar(require_encoding());
    var PendingTransactionInformation = class extends jsonrequest_1.default {
      constructor(c, txid) {
        super(c);
        this.txid = txid;
        this.txid = txid;
        this.query.format = "msgpack";
      }
      prepare(body) {
        if (body && body.byteLength > 0) {
          return encoding.decode(body);
        }
        return void 0;
      }
      path() {
        return `/v2/transactions/pending/${this.txid}`;
      }
      max(max) {
        this.query.max = max;
        return this;
      }
    };
    exports2.default = PendingTransactionInformation;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/pendingTransactions.js
var require_pendingTransactions = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/pendingTransactions.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var encoding = __importStar(require_encoding());
    var PendingTransactions = class extends jsonrequest_1.default {
      constructor(c) {
        super(c);
        this.query.format = "msgpack";
      }
      path() {
        return "/v2/transactions/pending";
      }
      prepare(body) {
        if (body && body.byteLength > 0) {
          return encoding.decode(body);
        }
        return void 0;
      }
      max(max) {
        this.query.max = max;
        return this;
      }
    };
    exports2.default = PendingTransactions;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/pendingTransactionsByAddress.js
var require_pendingTransactionsByAddress = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/pendingTransactionsByAddress.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var encoding = __importStar(require_encoding());
    var PendingTransactionsByAddress = class extends jsonrequest_1.default {
      constructor(c, address) {
        super(c);
        this.address = address;
        this.address = address;
        this.query.format = "msgpack";
      }
      prepare(body) {
        if (body && body.byteLength > 0) {
          return encoding.decode(body);
        }
        return void 0;
      }
      path() {
        return `/v2/accounts/${this.address}/transactions/pending`;
      }
      max(max) {
        this.query.max = max;
        return this;
      }
    };
    exports2.default = PendingTransactionsByAddress;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/status.js
var require_status = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/status.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var Status = class extends jsonrequest_1.default {
      path() {
        return "/v2/status";
      }
    };
    exports2.default = Status;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/statusAfterBlock.js
var require_statusAfterBlock = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/statusAfterBlock.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var StatusAfterBlock = class extends jsonrequest_1.default {
      constructor(c, intDecoding, round) {
        super(c, intDecoding);
        this.round = round;
        if (!Number.isInteger(round))
          throw Error("round should be an integer");
        this.round = round;
      }
      path() {
        return `/v2/status/wait-for-block-after/${this.round}`;
      }
    };
    exports2.default = StatusAfterBlock;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/suggestedParams.js
var require_suggestedParams = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/suggestedParams.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var SuggestedParamsRequest = class extends jsonrequest_1.default {
      path() {
        return "/v2/transactions/params";
      }
      prepare(body) {
        return {
          flatFee: false,
          fee: body.fee,
          firstRound: body["last-round"],
          lastRound: body["last-round"] + 1e3,
          genesisID: body["genesis-id"],
          genesisHash: body["genesis-hash"]
        };
      }
    };
    exports2.default = SuggestedParamsRequest;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/supply.js
var require_supply = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/supply.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var Supply = class extends jsonrequest_1.default {
      path() {
        return "/v2/ledger/supply";
      }
    };
    exports2.default = Supply;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/versions.js
var require_versions = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/versions.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var Versions = class extends jsonrequest_1.default {
      path() {
        return "/versions";
      }
    };
    exports2.default = Versions;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/genesis.js
var require_genesis = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/genesis.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var Genesis = class extends jsonrequest_1.default {
      path() {
        return "/genesis";
      }
    };
    exports2.default = Genesis;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/proof.js
var require_proof = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/proof.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var Proof = class extends jsonrequest_1.default {
      constructor(c, intDecoding, round, txID) {
        super(c, intDecoding);
        this.round = round;
        this.txID = txID;
        this.round = round;
        this.txID = txID;
      }
      path() {
        return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
      }
    };
    exports2.default = Proof;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/algod.js
var require_algod2 = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/algod.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var serviceClient_1 = __importDefault(require_serviceClient());
    var accountInformation_1 = __importDefault(require_accountInformation());
    var block_1 = __importDefault(require_block());
    var compile_1 = __importDefault(require_compile());
    var dryrun_1 = __importDefault(require_dryrun());
    var getAssetByID_1 = __importDefault(require_getAssetByID());
    var getApplicationByID_1 = __importDefault(require_getApplicationByID());
    var healthCheck_1 = __importDefault(require_healthCheck());
    var pendingTransactionInformation_1 = __importDefault(require_pendingTransactionInformation());
    var pendingTransactions_1 = __importDefault(require_pendingTransactions());
    var pendingTransactionsByAddress_1 = __importDefault(require_pendingTransactionsByAddress());
    var sendRawTransaction_1 = __importDefault(require_sendRawTransaction());
    var status_1 = __importDefault(require_status());
    var statusAfterBlock_1 = __importDefault(require_statusAfterBlock());
    var suggestedParams_1 = __importDefault(require_suggestedParams());
    var supply_1 = __importDefault(require_supply());
    var versions_1 = __importDefault(require_versions());
    var genesis_1 = __importDefault(require_genesis());
    var proof_1 = __importDefault(require_proof());
    var AlgodClient = class extends serviceClient_1.default {
      constructor(tokenOrBaseClient, baseServer = "http://r2.algorand.network", port = 4180, headers = {}) {
        super("X-Algo-API-Token", tokenOrBaseClient, baseServer, port, headers);
      }
      healthCheck() {
        return new healthCheck_1.default(this.c);
      }
      versionsCheck() {
        return new versions_1.default(this.c);
      }
      sendRawTransaction(stxOrStxs) {
        return new sendRawTransaction_1.default(this.c, stxOrStxs);
      }
      accountInformation(account) {
        return new accountInformation_1.default(this.c, this.intDecoding, account);
      }
      block(roundNumber) {
        return new block_1.default(this.c, roundNumber);
      }
      pendingTransactionInformation(txid) {
        return new pendingTransactionInformation_1.default(this.c, txid);
      }
      pendingTransactionsInformation() {
        return new pendingTransactions_1.default(this.c);
      }
      pendingTransactionByAddress(address) {
        return new pendingTransactionsByAddress_1.default(this.c, address);
      }
      status() {
        return new status_1.default(this.c, this.intDecoding);
      }
      statusAfterBlock(round) {
        return new statusAfterBlock_1.default(this.c, this.intDecoding, round);
      }
      getTransactionParams() {
        return new suggestedParams_1.default(this.c);
      }
      supply() {
        return new supply_1.default(this.c, this.intDecoding);
      }
      compile(source) {
        return new compile_1.default(this.c, source);
      }
      dryrun(dr) {
        return new dryrun_1.default(this.c, dr);
      }
      getAssetByID(index) {
        return new getAssetByID_1.default(this.c, this.intDecoding, index);
      }
      getApplicationByID(index) {
        return new getApplicationByID_1.default(this.c, this.intDecoding, index);
      }
      genesis() {
        return new genesis_1.default(this.c, this.intDecoding);
      }
      getProof(round, txID) {
        return new proof_1.default(this.c, this.intDecoding, round, txID);
      }
    };
    exports2.default = AlgodClient;
  }
});

// node_modules/algosdk/dist/cjs/src/client/kmd.js
var require_kmd = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/kmd.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var serviceClient_1 = __importDefault(require_serviceClient());
    var txn = __importStar(require_transaction());
    var Kmd = class extends serviceClient_1.default {
      constructor(token, baseServer = "http://127.0.0.1", port = 7833, headers = {}) {
        super("X-KMD-API-Token", token, baseServer, port, headers);
      }
      async versions() {
        const res = await this.c.get("/versions");
        return res.body;
      }
      async listWallets() {
        const res = await this.c.get("/v1/wallets");
        return res.body;
      }
      async createWallet(walletName, walletPassword, walletMDK = "", walletDriverName = "sqlite") {
        const req = {
          wallet_name: walletName,
          wallet_driver_name: walletDriverName,
          wallet_password: walletPassword,
          master_derivation_key: Buffer.from(walletMDK).toString("base64")
        };
        const res = await this.c.post("/v1/wallet", req);
        return res.body;
      }
      async initWalletHandle(walletID, walletPassword) {
        const req = {
          wallet_id: walletID,
          wallet_password: walletPassword
        };
        const res = await this.c.post("/v1/wallet/init", req);
        return res.body;
      }
      async releaseWalletHandle(walletHandle) {
        const req = {
          wallet_handle_token: walletHandle
        };
        const res = await this.c.post("/v1/wallet/release", req);
        return res.body;
      }
      async renewWalletHandle(walletHandle) {
        const req = {
          wallet_handle_token: walletHandle
        };
        const res = await this.c.post("/v1/wallet/renew", req);
        return res.body;
      }
      async renameWallet(walletID, walletPassword, newWalletName) {
        const req = {
          wallet_id: walletID,
          wallet_password: walletPassword,
          wallet_name: newWalletName
        };
        const res = await this.c.post("/v1/wallet/rename", req);
        return res.body;
      }
      async getWallet(walletHandle) {
        const req = {
          wallet_handle_token: walletHandle
        };
        const res = await this.c.post("/v1/wallet/info", req);
        return res.body;
      }
      async exportMasterDerivationKey(walletHandle, walletPassword) {
        const req = {
          wallet_handle_token: walletHandle,
          wallet_password: walletPassword
        };
        const res = await this.c.post("/v1/master-key/export", req);
        return {
          master_derivation_key: Buffer.from(res.body.master_derivation_key, "base64")
        };
      }
      async importKey(walletHandle, secretKey) {
        const req = {
          wallet_handle_token: walletHandle,
          private_key: Buffer.from(secretKey).toString("base64")
        };
        const res = await this.c.post("/v1/key/import", req);
        return res.body;
      }
      async exportKey(walletHandle, walletPassword, addr) {
        const req = {
          wallet_handle_token: walletHandle,
          address: addr,
          wallet_password: walletPassword
        };
        const res = await this.c.post("/v1/key/export", req);
        return { private_key: Buffer.from(res.body.private_key, "base64") };
      }
      async generateKey(walletHandle) {
        const req = {
          wallet_handle_token: walletHandle,
          display_mnemonic: false
        };
        const res = await this.c.post("/v1/key", req);
        return res.body;
      }
      async deleteKey(walletHandle, walletPassword, addr) {
        const req = {
          wallet_handle_token: walletHandle,
          address: addr,
          wallet_password: walletPassword
        };
        const res = await this.c.delete("/v1/key", req);
        return res.body;
      }
      async listKeys(walletHandle) {
        const req = {
          wallet_handle_token: walletHandle
        };
        const res = await this.c.post("/v1/key/list", req);
        return res.body;
      }
      async signTransaction(walletHandle, walletPassword, transaction) {
        const tx = txn.instantiateTxnIfNeeded(transaction);
        const req = {
          wallet_handle_token: walletHandle,
          wallet_password: walletPassword,
          transaction: Buffer.from(tx.toByte()).toString("base64")
        };
        const res = await this.c.post("/v1/transaction/sign", req);
        if (res.status === 200) {
          return Buffer.from(res.body.signed_transaction, "base64");
        }
        return res.body;
      }
      async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction, publicKey) {
        const tx = txn.instantiateTxnIfNeeded(transaction);
        const req = {
          wallet_handle_token: walletHandle,
          wallet_password: walletPassword,
          transaction: Buffer.from(tx.toByte()).toString("base64"),
          public_key: Buffer.from(publicKey).toString("base64")
        };
        const res = await this.c.post("/v1/transaction/sign", req);
        if (res.status === 200) {
          return Buffer.from(res.body.signed_transaction, "base64");
        }
        return res.body;
      }
      async listMultisig(walletHandle) {
        const req = {
          wallet_handle_token: walletHandle
        };
        const res = await this.c.post("/v1/multisig/list", req);
        return res.body;
      }
      async importMultisig(walletHandle, version, threshold, pks) {
        const req = {
          wallet_handle_token: walletHandle,
          multisig_version: version,
          threshold,
          pks
        };
        const res = await this.c.post("/v1/multisig/import", req);
        return res.body;
      }
      async exportMultisig(walletHandle, addr) {
        const req = {
          wallet_handle_token: walletHandle,
          address: addr
        };
        const res = await this.c.post("/v1/multisig/export", req);
        return res.body;
      }
      async signMultisigTransaction(walletHandle, pw, transaction, pk, partial) {
        const tx = txn.instantiateTxnIfNeeded(transaction);
        const req = {
          wallet_handle_token: walletHandle,
          transaction: Buffer.from(tx.toByte()).toString("base64"),
          public_key: Buffer.from(pk).toString("base64"),
          partial_multisig: partial,
          wallet_password: pw
        };
        const res = await this.c.post("/v1/multisig/sign", req);
        return res.body;
      }
      async deleteMultisig(walletHandle, walletPassword, addr) {
        const req = {
          wallet_handle_token: walletHandle,
          address: addr,
          wallet_password: walletPassword
        };
        const res = await this.c.delete("/v1/multisig", req);
        return res.body;
      }
    };
    exports2.default = Kmd;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/makeHealthCheck.js
var require_makeHealthCheck = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/makeHealthCheck.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var MakeHealthCheck = class extends jsonrequest_1.default {
      path() {
        return "/health";
      }
    };
    exports2.default = MakeHealthCheck;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupAssetBalances.js
var require_lookupAssetBalances = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupAssetBalances.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var LookupAssetBalances = class extends jsonrequest_1.default {
      constructor(c, intDecoding, index) {
        super(c, intDecoding);
        this.index = index;
        this.index = index;
      }
      path() {
        return `/v2/assets/${this.index}/balances`;
      }
      limit(limit) {
        this.query.limit = limit;
        return this;
      }
      round(round) {
        this.query.round = round;
        return this;
      }
      currencyGreaterThan(greater) {
        this.query["currency-greater-than"] = greater;
        return this;
      }
      currencyLessThan(lesser) {
        this.query["currency-less-than"] = lesser;
        return this;
      }
      nextToken(nextToken) {
        this.query.next = nextToken;
        return this;
      }
      includeAll(value = true) {
        this.query["include-all"] = value;
        return this;
      }
    };
    exports2.default = LookupAssetBalances;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupAccountTransactions.js
var require_lookupAccountTransactions = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupAccountTransactions.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.base64StringFunnel = void 0;
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    function base64StringFunnel(data) {
      if (typeof data === "string") {
        return data;
      }
      return Buffer.from(data).toString("base64");
    }
    exports2.base64StringFunnel = base64StringFunnel;
    var LookupAccountTransactions = class extends jsonrequest_1.default {
      constructor(c, intDecoding, account) {
        super(c, intDecoding);
        this.account = account;
        this.account = account;
      }
      path() {
        return `/v2/accounts/${this.account}/transactions`;
      }
      notePrefix(prefix) {
        this.query["note-prefix"] = base64StringFunnel(prefix);
        return this;
      }
      txType(type) {
        this.query["tx-type"] = type;
        return this;
      }
      sigType(type) {
        this.query["sig-type"] = type;
        return this;
      }
      txid(txid) {
        this.query.txid = txid;
        return this;
      }
      round(round) {
        this.query.round = round;
        return this;
      }
      minRound(round) {
        this.query["min-round"] = round;
        return this;
      }
      maxRound(round) {
        this.query["max-round"] = round;
        return this;
      }
      assetID(id) {
        this.query["asset-id"] = id;
        return this;
      }
      limit(limit) {
        this.query.limit = limit;
        return this;
      }
      beforeTime(before) {
        this.query["before-time"] = before;
        return this;
      }
      afterTime(after) {
        this.query["after-time"] = after;
        return this;
      }
      currencyGreaterThan(greater) {
        this.query["currency-greater-than"] = greater;
        return this;
      }
      currencyLessThan(lesser) {
        this.query["currency-less-than"] = lesser;
        return this;
      }
      nextToken(nextToken) {
        this.query.next = nextToken;
        return this;
      }
      rekeyTo(rekeyTo) {
        this.query["rekey-to"] = rekeyTo;
        return this;
      }
    };
    exports2.default = LookupAccountTransactions;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupAssetTransactions.js
var require_lookupAssetTransactions = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupAssetTransactions.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var lookupAccountTransactions_1 = require_lookupAccountTransactions();
    var LookupAssetTransactions = class extends jsonrequest_1.default {
      constructor(c, intDecoding, index) {
        super(c, intDecoding);
        this.index = index;
        this.index = index;
      }
      path() {
        return `/v2/assets/${this.index}/transactions`;
      }
      notePrefix(prefix) {
        this.query["note-prefix"] = lookupAccountTransactions_1.base64StringFunnel(prefix);
        return this;
      }
      txType(type) {
        this.query["tx-type"] = type;
        return this;
      }
      sigType(type) {
        this.query["sig-type"] = type;
        return this;
      }
      txid(txid) {
        this.query.txid = txid;
        return this;
      }
      round(round) {
        this.query.round = round;
        return this;
      }
      minRound(round) {
        this.query["min-round"] = round;
        return this;
      }
      maxRound(round) {
        this.query["max-round"] = round;
        return this;
      }
      assetID(id) {
        this.query["asset-id"] = id;
        return this;
      }
      limit(limit) {
        this.query.limit = limit;
        return this;
      }
      beforeTime(before) {
        this.query["before-time"] = before;
        return this;
      }
      afterTime(after) {
        this.query["after-time"] = after;
        return this;
      }
      currencyGreaterThan(greater) {
        this.query["currency-greater-than"] = greater;
        return this;
      }
      currencyLessThan(lesser) {
        this.query["currency-less-than"] = lesser;
        return this;
      }
      addressRole(role) {
        this.query["address-role"] = role;
        return this;
      }
      address(address) {
        this.query.address = address;
        return this;
      }
      excludeCloseTo(exclude) {
        this.query["exclude-close-to"] = exclude;
        return this;
      }
      nextToken(nextToken) {
        this.query.next = nextToken;
        return this;
      }
      rekeyTo(rekeyTo) {
        this.query["rekey-to"] = rekeyTo;
        return this;
      }
    };
    exports2.default = LookupAssetTransactions;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupBlock.js
var require_lookupBlock = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupBlock.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var LookupBlock = class extends jsonrequest_1.default {
      constructor(c, intDecoding, round) {
        super(c, intDecoding);
        this.round = round;
        this.round = round;
      }
      path() {
        return `/v2/blocks/${this.round}`;
      }
    };
    exports2.default = LookupBlock;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupTransactionByID.js
var require_lookupTransactionByID = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupTransactionByID.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var LookupTransactionByID = class extends jsonrequest_1.default {
      constructor(c, intDecoding, txID) {
        super(c, intDecoding);
        this.txID = txID;
        this.txID = txID;
      }
      path() {
        return `/v2/transactions/${this.txID}`;
      }
    };
    exports2.default = LookupTransactionByID;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupAccountByID.js
var require_lookupAccountByID = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupAccountByID.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var LookupAccountByID = class extends jsonrequest_1.default {
      constructor(c, intDecoding, account) {
        super(c, intDecoding);
        this.account = account;
        this.account = account;
      }
      path() {
        return `/v2/accounts/${this.account}`;
      }
      round(round) {
        this.query.round = round;
        return this;
      }
      includeAll(value = true) {
        this.query["include-all"] = value;
        return this;
      }
    };
    exports2.default = LookupAccountByID;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupAssetByID.js
var require_lookupAssetByID = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupAssetByID.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var LookupAssetByID = class extends jsonrequest_1.default {
      constructor(c, intDecoding, index) {
        super(c, intDecoding);
        this.index = index;
        this.index = index;
      }
      path() {
        return `/v2/assets/${this.index}`;
      }
      includeAll(value = true) {
        this.query["include-all"] = value;
        return this;
      }
    };
    exports2.default = LookupAssetByID;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupApplications.js
var require_lookupApplications = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupApplications.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var LookupApplications = class extends jsonrequest_1.default {
      constructor(c, intDecoding, index) {
        super(c, intDecoding);
        this.index = index;
        this.index = index;
      }
      path() {
        return `/v2/applications/${this.index}`;
      }
      includeAll(value = true) {
        this.query["include-all"] = value;
        return this;
      }
    };
    exports2.default = LookupApplications;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupApplicationLogs.js
var require_lookupApplicationLogs = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/lookupApplicationLogs.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var LookupApplicationLogs = class extends jsonrequest_1.default {
      constructor(c, intDecoding, appID) {
        super(c, intDecoding);
        this.appID = appID;
        this.appID = appID;
      }
      path() {
        return `/v2/applications/${this.appID}/logs`;
      }
      limit(limit) {
        this.query.limit = limit;
        return this;
      }
      minRound(round) {
        this.query["min-round"] = round;
        return this;
      }
      maxRound(round) {
        this.query["max-round"] = round;
        return this;
      }
      nextToken(nextToken) {
        this.query.next = nextToken;
        return this;
      }
      sender(senderAddress) {
        this.query["sender-address"] = senderAddress;
        return this;
      }
      txid(txid) {
        this.query.txid = txid;
        return this;
      }
    };
    exports2.default = LookupApplicationLogs;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/searchAccounts.js
var require_searchAccounts = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/searchAccounts.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var SearchAccounts = class extends jsonrequest_1.default {
      path() {
        return "/v2/accounts";
      }
      currencyGreaterThan(greater) {
        this.query["currency-greater-than"] = greater;
        return this;
      }
      currencyLessThan(lesser) {
        this.query["currency-less-than"] = lesser;
        return this;
      }
      limit(limit) {
        this.query.limit = limit;
        return this;
      }
      assetID(id) {
        this.query["asset-id"] = id;
        return this;
      }
      nextToken(nextToken) {
        this.query.next = nextToken;
        return this;
      }
      round(round) {
        this.query.round = round;
        return this;
      }
      authAddr(authAddr) {
        this.query["auth-addr"] = authAddr;
        return this;
      }
      applicationID(applicationID) {
        this.query["application-id"] = applicationID;
        return this;
      }
      includeAll(value = true) {
        this.query["include-all"] = value;
        return this;
      }
    };
    exports2.default = SearchAccounts;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/searchForTransactions.js
var require_searchForTransactions = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/searchForTransactions.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var lookupAccountTransactions_1 = require_lookupAccountTransactions();
    var SearchForTransactions = class extends jsonrequest_1.default {
      path() {
        return "/v2/transactions";
      }
      notePrefix(prefix) {
        this.query["note-prefix"] = lookupAccountTransactions_1.base64StringFunnel(prefix);
        return this;
      }
      txType(type) {
        this.query["tx-type"] = type;
        return this;
      }
      sigType(type) {
        this.query["sig-type"] = type;
        return this;
      }
      txid(txid) {
        this.query.txid = txid;
        return this;
      }
      round(round) {
        this.query.round = round;
        return this;
      }
      minRound(round) {
        this.query["min-round"] = round;
        return this;
      }
      maxRound(round) {
        this.query["max-round"] = round;
        return this;
      }
      assetID(id) {
        this.query["asset-id"] = id;
        return this;
      }
      limit(limit) {
        this.query.limit = limit;
        return this;
      }
      beforeTime(before) {
        this.query["before-time"] = before;
        return this;
      }
      afterTime(after) {
        this.query["after-time"] = after;
        return this;
      }
      currencyGreaterThan(greater) {
        this.query["currency-greater-than"] = greater;
        return this;
      }
      currencyLessThan(lesser) {
        this.query["currency-less-than"] = lesser;
        return this;
      }
      addressRole(role) {
        this.query["address-role"] = role;
        return this;
      }
      address(address) {
        this.query.address = address;
        return this;
      }
      excludeCloseTo(exclude) {
        this.query["exclude-close-to"] = exclude;
        return this;
      }
      nextToken(nextToken) {
        this.query.next = nextToken;
        return this;
      }
      rekeyTo(rekeyTo) {
        this.query["rekey-to"] = rekeyTo;
        return this;
      }
      applicationID(applicationID) {
        this.query["application-id"] = applicationID;
        return this;
      }
    };
    exports2.default = SearchForTransactions;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/searchForAssets.js
var require_searchForAssets = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/searchForAssets.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var SearchForAssets = class extends jsonrequest_1.default {
      path() {
        return "/v2/assets";
      }
      limit(limit) {
        this.query.limit = limit;
        return this;
      }
      creator(creator) {
        this.query.creator = creator;
        return this;
      }
      name(name) {
        this.query.name = name;
        return this;
      }
      unit(unit) {
        this.query.unit = unit;
        return this;
      }
      index(index) {
        this.query["asset-id"] = index;
        return this;
      }
      nextToken(nextToken) {
        this.query.next = nextToken;
        return this;
      }
      includeAll(value = true) {
        this.query["include-all"] = value;
        return this;
      }
    };
    exports2.default = SearchForAssets;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/searchForApplications.js
var require_searchForApplications = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/searchForApplications.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var jsonrequest_1 = __importDefault(require_jsonrequest());
    var SearchForApplications = class extends jsonrequest_1.default {
      path() {
        return "/v2/applications";
      }
      index(index) {
        this.query["application-id"] = index;
        return this;
      }
      nextToken(next) {
        this.query.next = next;
        return this;
      }
      limit(limit) {
        this.query.limit = limit;
        return this;
      }
      includeAll(value = true) {
        this.query["include-all"] = value;
        return this;
      }
    };
    exports2.default = SearchForApplications;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/indexer/indexer.js
var require_indexer = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/indexer/indexer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var serviceClient_1 = __importDefault(require_serviceClient());
    var makeHealthCheck_1 = __importDefault(require_makeHealthCheck());
    var lookupAssetBalances_1 = __importDefault(require_lookupAssetBalances());
    var lookupAssetTransactions_1 = __importDefault(require_lookupAssetTransactions());
    var lookupAccountTransactions_1 = __importDefault(require_lookupAccountTransactions());
    var lookupBlock_1 = __importDefault(require_lookupBlock());
    var lookupTransactionByID_1 = __importDefault(require_lookupTransactionByID());
    var lookupAccountByID_1 = __importDefault(require_lookupAccountByID());
    var lookupAssetByID_1 = __importDefault(require_lookupAssetByID());
    var lookupApplications_1 = __importDefault(require_lookupApplications());
    var lookupApplicationLogs_1 = __importDefault(require_lookupApplicationLogs());
    var searchAccounts_1 = __importDefault(require_searchAccounts());
    var searchForTransactions_1 = __importDefault(require_searchForTransactions());
    var searchForAssets_1 = __importDefault(require_searchForAssets());
    var searchForApplications_1 = __importDefault(require_searchForApplications());
    var IndexerClient = class extends serviceClient_1.default {
      constructor(tokenOrBaseClient, baseServer = "http://127.0.0.1", port = 8080, headers = {}) {
        super("X-Indexer-API-Token", tokenOrBaseClient, baseServer, port, headers);
      }
      makeHealthCheck() {
        return new makeHealthCheck_1.default(this.c, this.intDecoding);
      }
      lookupAssetBalances(index) {
        return new lookupAssetBalances_1.default(this.c, this.intDecoding, index);
      }
      lookupAssetTransactions(index) {
        return new lookupAssetTransactions_1.default(this.c, this.intDecoding, index);
      }
      lookupAccountTransactions(account) {
        return new lookupAccountTransactions_1.default(this.c, this.intDecoding, account);
      }
      lookupBlock(round) {
        return new lookupBlock_1.default(this.c, this.intDecoding, round);
      }
      lookupTransactionByID(txID) {
        return new lookupTransactionByID_1.default(this.c, this.intDecoding, txID);
      }
      lookupAccountByID(account) {
        return new lookupAccountByID_1.default(this.c, this.intDecoding, account);
      }
      lookupAssetByID(index) {
        return new lookupAssetByID_1.default(this.c, this.intDecoding, index);
      }
      lookupApplications(index) {
        return new lookupApplications_1.default(this.c, this.intDecoding, index);
      }
      lookupApplicationLogs(appID) {
        return new lookupApplicationLogs_1.default(this.c, this.intDecoding, appID);
      }
      searchAccounts() {
        return new searchAccounts_1.default(this.c, this.intDecoding);
      }
      searchForTransactions() {
        return new searchForTransactions_1.default(this.c, this.intDecoding);
      }
      searchForAssets() {
        return new searchForAssets_1.default(this.c, this.intDecoding);
      }
      searchForApplications() {
        return new searchForApplications_1.default(this.c, this.intDecoding);
      }
    };
    exports2.default = IndexerClient;
  }
});

// node_modules/algosdk/dist/cjs/src/wait.js
var require_wait = __commonJS({
  "node_modules/algosdk/dist/cjs/src/wait.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.waitForConfirmation = void 0;
    async function waitForConfirmation(client, txid, waitRounds) {
      const status = await client.status().do();
      if (typeof status === "undefined") {
        throw new Error("Unable to get node status");
      }
      const startRound = status["last-round"] + 1;
      let currentRound = startRound;
      while (currentRound < startRound + waitRounds) {
        let poolError = false;
        try {
          const pendingInfo = await client.pendingTransactionInformation(txid).do();
          if (pendingInfo["confirmed-round"]) {
            return pendingInfo;
          }
          if (pendingInfo["pool-error"]) {
            poolError = true;
            throw new Error(`Transaction Rejected: ${pendingInfo["pool-error"]}`);
          }
        } catch (err) {
          if (poolError) {
            throw err;
          }
        }
        await client.statusAfterBlock(currentRound).do();
        currentRound += 1;
      }
      throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);
    }
    exports2.waitForConfirmation = waitForConfirmation;
  }
});

// node_modules/algosdk/dist/cjs/src/encoding/bigint.js
var require_bigint = __commonJS({
  "node_modules/algosdk/dist/cjs/src/encoding/bigint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bytesToBigInt = exports2.bigIntToBytes = void 0;
    function bigIntToBytes(bi, size) {
      let hex = bi.toString(16);
      if (hex.length !== size * 2) {
        hex = hex.padStart(size * 2, "0");
      }
      const byteArray = new Uint8Array(hex.length / 2);
      for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {
        byteArray[i] = parseInt(hex.slice(j, j + 2), 16);
      }
      return byteArray;
    }
    exports2.bigIntToBytes = bigIntToBytes;
    function bytesToBigInt(bytes) {
      let res = BigInt(0);
      const buf = Buffer.from(bytes);
      for (let i = 0; i < bytes.length; i++) {
        res = BigInt(Number(buf.readUIntBE(i, 1))) + res * BigInt(256);
      }
      return res;
    }
    exports2.bytesToBigInt = bytesToBigInt;
  }
});

// node_modules/algosdk/dist/cjs/src/account.js
var require_account = __commonJS({
  "node_modules/algosdk/dist/cjs/src/account.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var nacl = __importStar(require_naclWrappers());
    var address = __importStar(require_address());
    function generateAccount() {
      const keys = nacl.keyPair();
      const encodedPk = address.encodeAddress(keys.publicKey);
      return { addr: encodedPk, sk: keys.secretKey };
    }
    exports2.default = generateAccount;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/models/base.js
var require_base2 = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/models/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _is_primitive(val) {
      return val === void 0 || val == null || typeof val !== "object" && typeof val !== "function";
    }
    function _get_obj_for_encoding(val, binary) {
      let targetPropValue;
      if (val instanceof Uint8Array) {
        targetPropValue = binary ? val : Buffer.from(val).toString("base64");
      } else if (typeof val.get_obj_for_encoding === "function") {
        targetPropValue = val.get_obj_for_encoding(binary);
      } else if (Array.isArray(val)) {
        targetPropValue = [];
        for (const elem of val) {
          targetPropValue.push(_get_obj_for_encoding(elem, binary));
        }
      } else if (typeof val === "object") {
        const obj = {};
        for (const prop of Object.keys(val)) {
          obj[prop] = _get_obj_for_encoding(val[prop], binary);
        }
        targetPropValue = obj;
      } else if (_is_primitive(val)) {
        targetPropValue = val;
      } else {
        throw new Error(`Unsupported value: ${String(val)}`);
      }
      return targetPropValue;
    }
    var BaseModel = class {
      get_obj_for_encoding(binary = false) {
        const obj = {};
        for (const prop of Object.keys(this.attribute_map)) {
          const name = this.attribute_map[prop];
          const value = this[prop];
          if (typeof value !== "undefined") {
            obj[name] = value === null ? null : _get_obj_for_encoding(value, binary);
          }
        }
        return obj;
      }
    };
    exports2.default = BaseModel;
  }
});

// node_modules/algosdk/dist/cjs/src/client/v2/algod/models/types.js
var require_types = __commonJS({
  "node_modules/algosdk/dist/cjs/src/client/v2/algod/models/types.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Version = exports2.TransactionParametersResponse = exports2.TealValue = exports2.TealKeyValue = exports2.SupplyResponse = exports2.ProofResponse = exports2.PostTransactionsResponse = exports2.PendingTransactionsResponse = exports2.PendingTransactionResponse = exports2.NodeStatusResponse = exports2.EvalDeltaKeyValue = exports2.EvalDelta = exports2.ErrorResponse = exports2.DryrunTxnResult = exports2.DryrunState = exports2.DryrunSource = exports2.DryrunResponse = exports2.DryrunRequest = exports2.CompileResponse = exports2.CatchpointStartResponse = exports2.CatchpointAbortResponse = exports2.BuildVersion = exports2.BlockResponse = exports2.AssetParams = exports2.AssetHolding = exports2.Asset = exports2.ApplicationStateSchema = exports2.ApplicationParams = exports2.ApplicationLocalState = exports2.Application = exports2.AccountStateDelta = exports2.AccountParticipation = exports2.Account = void 0;
    var base_1 = __importDefault(require_base2());
    var Account = class extends base_1.default {
      constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, createdApps, createdAssets, participation, rewardBase, sigType }) {
        super();
        this.address = address;
        this.amount = amount;
        this.amountWithoutPendingRewards = amountWithoutPendingRewards;
        this.minBalance = minBalance;
        this.pendingRewards = pendingRewards;
        this.rewards = rewards;
        this.round = round;
        this.status = status;
        this.appsLocalState = appsLocalState;
        this.appsTotalExtraPages = appsTotalExtraPages;
        this.appsTotalSchema = appsTotalSchema;
        this.assets = assets;
        this.authAddr = authAddr;
        this.createdApps = createdApps;
        this.createdAssets = createdAssets;
        this.participation = participation;
        this.rewardBase = rewardBase;
        this.sigType = sigType;
        this.attribute_map = {
          address: "address",
          amount: "amount",
          amountWithoutPendingRewards: "amount-without-pending-rewards",
          minBalance: "min-balance",
          pendingRewards: "pending-rewards",
          rewards: "rewards",
          round: "round",
          status: "status",
          appsLocalState: "apps-local-state",
          appsTotalExtraPages: "apps-total-extra-pages",
          appsTotalSchema: "apps-total-schema",
          assets: "assets",
          authAddr: "auth-addr",
          createdApps: "created-apps",
          createdAssets: "created-assets",
          participation: "participation",
          rewardBase: "reward-base",
          sigType: "sig-type"
        };
      }
    };
    exports2.Account = Account;
    var AccountParticipation = class extends base_1.default {
      constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
        super();
        this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? new Uint8Array(Buffer.from(selectionParticipationKey, "base64")) : selectionParticipationKey;
        this.voteFirstValid = voteFirstValid;
        this.voteKeyDilution = voteKeyDilution;
        this.voteLastValid = voteLastValid;
        this.voteParticipationKey = typeof voteParticipationKey === "string" ? new Uint8Array(Buffer.from(voteParticipationKey, "base64")) : voteParticipationKey;
        this.stateProofKey = typeof stateProofKey === "string" ? new Uint8Array(Buffer.from(stateProofKey, "base64")) : stateProofKey;
        this.attribute_map = {
          selectionParticipationKey: "selection-participation-key",
          voteFirstValid: "vote-first-valid",
          voteKeyDilution: "vote-key-dilution",
          voteLastValid: "vote-last-valid",
          voteParticipationKey: "vote-participation-key",
          stateProofKey: "state-proof-key"
        };
      }
    };
    exports2.AccountParticipation = AccountParticipation;
    var AccountStateDelta = class extends base_1.default {
      constructor(address, delta) {
        super();
        this.address = address;
        this.delta = delta;
        this.attribute_map = {
          address: "address",
          delta: "delta"
        };
      }
    };
    exports2.AccountStateDelta = AccountStateDelta;
    var Application = class extends base_1.default {
      constructor(id, params) {
        super();
        this.id = id;
        this.params = params;
        this.attribute_map = {
          id: "id",
          params: "params"
        };
      }
    };
    exports2.Application = Application;
    var ApplicationLocalState = class extends base_1.default {
      constructor(id, schema, keyValue) {
        super();
        this.id = id;
        this.schema = schema;
        this.keyValue = keyValue;
        this.attribute_map = {
          id: "id",
          schema: "schema",
          keyValue: "key-value"
        };
      }
    };
    exports2.ApplicationLocalState = ApplicationLocalState;
    var ApplicationParams = class extends base_1.default {
      constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema }) {
        super();
        this.approvalProgram = typeof approvalProgram === "string" ? new Uint8Array(Buffer.from(approvalProgram, "base64")) : approvalProgram;
        this.clearStateProgram = typeof clearStateProgram === "string" ? new Uint8Array(Buffer.from(clearStateProgram, "base64")) : clearStateProgram;
        this.creator = creator;
        this.extraProgramPages = extraProgramPages;
        this.globalState = globalState;
        this.globalStateSchema = globalStateSchema;
        this.localStateSchema = localStateSchema;
        this.attribute_map = {
          approvalProgram: "approval-program",
          clearStateProgram: "clear-state-program",
          creator: "creator",
          extraProgramPages: "extra-program-pages",
          globalState: "global-state",
          globalStateSchema: "global-state-schema",
          localStateSchema: "local-state-schema"
        };
      }
    };
    exports2.ApplicationParams = ApplicationParams;
    var ApplicationStateSchema = class extends base_1.default {
      constructor(numUint, numByteSlice) {
        super();
        this.numUint = numUint;
        this.numByteSlice = numByteSlice;
        this.attribute_map = {
          numUint: "num-uint",
          numByteSlice: "num-byte-slice"
        };
      }
    };
    exports2.ApplicationStateSchema = ApplicationStateSchema;
    var Asset = class extends base_1.default {
      constructor(index, params) {
        super();
        this.index = index;
        this.params = params;
        this.attribute_map = {
          index: "index",
          params: "params"
        };
      }
    };
    exports2.Asset = Asset;
    var AssetHolding = class extends base_1.default {
      constructor(amount, assetId, creator, isFrozen) {
        super();
        this.amount = amount;
        this.assetId = assetId;
        this.creator = creator;
        this.isFrozen = isFrozen;
        this.attribute_map = {
          amount: "amount",
          assetId: "asset-id",
          creator: "creator",
          isFrozen: "is-frozen"
        };
      }
    };
    exports2.AssetHolding = AssetHolding;
    var AssetParams = class extends base_1.default {
      constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
        super();
        this.creator = creator;
        this.decimals = decimals;
        this.total = total;
        this.clawback = clawback;
        this.defaultFrozen = defaultFrozen;
        this.freeze = freeze;
        this.manager = manager;
        this.metadataHash = typeof metadataHash === "string" ? new Uint8Array(Buffer.from(metadataHash, "base64")) : metadataHash;
        this.name = name;
        this.nameB64 = typeof nameB64 === "string" ? new Uint8Array(Buffer.from(nameB64, "base64")) : nameB64;
        this.reserve = reserve;
        this.unitName = unitName;
        this.unitNameB64 = typeof unitNameB64 === "string" ? new Uint8Array(Buffer.from(unitNameB64, "base64")) : unitNameB64;
        this.url = url;
        this.urlB64 = typeof urlB64 === "string" ? new Uint8Array(Buffer.from(urlB64, "base64")) : urlB64;
        this.attribute_map = {
          creator: "creator",
          decimals: "decimals",
          total: "total",
          clawback: "clawback",
          defaultFrozen: "default-frozen",
          freeze: "freeze",
          manager: "manager",
          metadataHash: "metadata-hash",
          name: "name",
          nameB64: "name-b64",
          reserve: "reserve",
          unitName: "unit-name",
          unitNameB64: "unit-name-b64",
          url: "url",
          urlB64: "url-b64"
        };
      }
    };
    exports2.AssetParams = AssetParams;
    var BlockResponse = class extends base_1.default {
      constructor(block, cert) {
        super();
        this.block = block;
        this.cert = cert;
        this.attribute_map = {
          block: "block",
          cert: "cert"
        };
      }
    };
    exports2.BlockResponse = BlockResponse;
    var BuildVersion = class extends base_1.default {
      constructor({ branch, buildNumber, channel, commitHash, major, minor }) {
        super();
        this.branch = branch;
        this.buildNumber = buildNumber;
        this.channel = channel;
        this.commitHash = commitHash;
        this.major = major;
        this.minor = minor;
        this.attribute_map = {
          branch: "branch",
          buildNumber: "build_number",
          channel: "channel",
          commitHash: "commit_hash",
          major: "major",
          minor: "minor"
        };
      }
    };
    exports2.BuildVersion = BuildVersion;
    var CatchpointAbortResponse = class extends base_1.default {
      constructor(catchupMessage) {
        super();
        this.catchupMessage = catchupMessage;
        this.attribute_map = {
          catchupMessage: "catchup-message"
        };
      }
    };
    exports2.CatchpointAbortResponse = CatchpointAbortResponse;
    var CatchpointStartResponse = class extends base_1.default {
      constructor(catchupMessage) {
        super();
        this.catchupMessage = catchupMessage;
        this.attribute_map = {
          catchupMessage: "catchup-message"
        };
      }
    };
    exports2.CatchpointStartResponse = CatchpointStartResponse;
    var CompileResponse = class extends base_1.default {
      constructor(hash, result) {
        super();
        this.hash = hash;
        this.result = result;
        this.attribute_map = {
          hash: "hash",
          result: "result"
        };
      }
    };
    exports2.CompileResponse = CompileResponse;
    var DryrunRequest = class extends base_1.default {
      constructor({ accounts, apps, latestTimestamp, protocolVersion, round, sources, txns }) {
        super();
        this.accounts = accounts;
        this.apps = apps;
        this.latestTimestamp = latestTimestamp;
        this.protocolVersion = protocolVersion;
        this.round = round;
        this.sources = sources;
        this.txns = txns;
        this.attribute_map = {
          accounts: "accounts",
          apps: "apps",
          latestTimestamp: "latest-timestamp",
          protocolVersion: "protocol-version",
          round: "round",
          sources: "sources",
          txns: "txns"
        };
      }
    };
    exports2.DryrunRequest = DryrunRequest;
    var DryrunResponse = class extends base_1.default {
      constructor(error, protocolVersion, txns) {
        super();
        this.error = error;
        this.protocolVersion = protocolVersion;
        this.txns = txns;
        this.attribute_map = {
          error: "error",
          protocolVersion: "protocol-version",
          txns: "txns"
        };
      }
    };
    exports2.DryrunResponse = DryrunResponse;
    var DryrunSource = class extends base_1.default {
      constructor(fieldName, source, txnIndex, appIndex) {
        super();
        this.fieldName = fieldName;
        this.source = source;
        this.txnIndex = txnIndex;
        this.appIndex = appIndex;
        this.attribute_map = {
          fieldName: "field-name",
          source: "source",
          txnIndex: "txn-index",
          appIndex: "app-index"
        };
      }
    };
    exports2.DryrunSource = DryrunSource;
    var DryrunState = class extends base_1.default {
      constructor({ line, pc, stack, error, scratch }) {
        super();
        this.line = line;
        this.pc = pc;
        this.stack = stack;
        this.error = error;
        this.scratch = scratch;
        this.attribute_map = {
          line: "line",
          pc: "pc",
          stack: "stack",
          error: "error",
          scratch: "scratch"
        };
      }
    };
    exports2.DryrunState = DryrunState;
    var DryrunTxnResult = class extends base_1.default {
      constructor({ disassembly, appCallMessages, appCallTrace, cost, globalDelta, localDeltas, logicSigDisassembly, logicSigMessages, logicSigTrace, logs }) {
        super();
        this.disassembly = disassembly;
        this.appCallMessages = appCallMessages;
        this.appCallTrace = appCallTrace;
        this.cost = cost;
        this.globalDelta = globalDelta;
        this.localDeltas = localDeltas;
        this.logicSigDisassembly = logicSigDisassembly;
        this.logicSigMessages = logicSigMessages;
        this.logicSigTrace = logicSigTrace;
        this.logs = logs;
        this.attribute_map = {
          disassembly: "disassembly",
          appCallMessages: "app-call-messages",
          appCallTrace: "app-call-trace",
          cost: "cost",
          globalDelta: "global-delta",
          localDeltas: "local-deltas",
          logicSigDisassembly: "logic-sig-disassembly",
          logicSigMessages: "logic-sig-messages",
          logicSigTrace: "logic-sig-trace",
          logs: "logs"
        };
      }
    };
    exports2.DryrunTxnResult = DryrunTxnResult;
    var ErrorResponse = class extends base_1.default {
      constructor(message, data) {
        super();
        this.message = message;
        this.data = data;
        this.attribute_map = {
          message: "message",
          data: "data"
        };
      }
    };
    exports2.ErrorResponse = ErrorResponse;
    var EvalDelta = class extends base_1.default {
      constructor(action, bytes, uint) {
        super();
        this.action = action;
        this.bytes = bytes;
        this.uint = uint;
        this.attribute_map = {
          action: "action",
          bytes: "bytes",
          uint: "uint"
        };
      }
    };
    exports2.EvalDelta = EvalDelta;
    var EvalDeltaKeyValue = class extends base_1.default {
      constructor(key, value) {
        super();
        this.key = key;
        this.value = value;
        this.attribute_map = {
          key: "key",
          value: "value"
        };
      }
    };
    exports2.EvalDeltaKeyValue = EvalDeltaKeyValue;
    var NodeStatusResponse = class extends base_1.default {
      constructor({ catchupTime, lastRound, lastVersion, nextVersion, nextVersionRound, nextVersionSupported, stoppedAtUnsupportedRound, timeSinceLastRound, catchpoint, catchpointAcquiredBlocks, catchpointProcessedAccounts, catchpointTotalAccounts, catchpointTotalBlocks, catchpointVerifiedAccounts, lastCatchpoint }) {
        super();
        this.catchupTime = catchupTime;
        this.lastRound = lastRound;
        this.lastVersion = lastVersion;
        this.nextVersion = nextVersion;
        this.nextVersionRound = nextVersionRound;
        this.nextVersionSupported = nextVersionSupported;
        this.stoppedAtUnsupportedRound = stoppedAtUnsupportedRound;
        this.timeSinceLastRound = timeSinceLastRound;
        this.catchpoint = catchpoint;
        this.catchpointAcquiredBlocks = catchpointAcquiredBlocks;
        this.catchpointProcessedAccounts = catchpointProcessedAccounts;
        this.catchpointTotalAccounts = catchpointTotalAccounts;
        this.catchpointTotalBlocks = catchpointTotalBlocks;
        this.catchpointVerifiedAccounts = catchpointVerifiedAccounts;
        this.lastCatchpoint = lastCatchpoint;
        this.attribute_map = {
          catchupTime: "catchup-time",
          lastRound: "last-round",
          lastVersion: "last-version",
          nextVersion: "next-version",
          nextVersionRound: "next-version-round",
          nextVersionSupported: "next-version-supported",
          stoppedAtUnsupportedRound: "stopped-at-unsupported-round",
          timeSinceLastRound: "time-since-last-round",
          catchpoint: "catchpoint",
          catchpointAcquiredBlocks: "catchpoint-acquired-blocks",
          catchpointProcessedAccounts: "catchpoint-processed-accounts",
          catchpointTotalAccounts: "catchpoint-total-accounts",
          catchpointTotalBlocks: "catchpoint-total-blocks",
          catchpointVerifiedAccounts: "catchpoint-verified-accounts",
          lastCatchpoint: "last-catchpoint"
        };
      }
    };
    exports2.NodeStatusResponse = NodeStatusResponse;
    var PendingTransactionResponse = class extends base_1.default {
      constructor({ poolError, txn, applicationIndex, assetClosingAmount, assetIndex, closeRewards, closingAmount, confirmedRound, globalStateDelta, innerTxns, localStateDelta, logs, receiverRewards, senderRewards }) {
        super();
        this.poolError = poolError;
        this.txn = txn;
        this.applicationIndex = applicationIndex;
        this.assetClosingAmount = assetClosingAmount;
        this.assetIndex = assetIndex;
        this.closeRewards = closeRewards;
        this.closingAmount = closingAmount;
        this.confirmedRound = confirmedRound;
        this.globalStateDelta = globalStateDelta;
        this.innerTxns = innerTxns;
        this.localStateDelta = localStateDelta;
        this.logs = logs;
        this.receiverRewards = receiverRewards;
        this.senderRewards = senderRewards;
        this.attribute_map = {
          poolError: "pool-error",
          txn: "txn",
          applicationIndex: "application-index",
          assetClosingAmount: "asset-closing-amount",
          assetIndex: "asset-index",
          closeRewards: "close-rewards",
          closingAmount: "closing-amount",
          confirmedRound: "confirmed-round",
          globalStateDelta: "global-state-delta",
          innerTxns: "inner-txns",
          localStateDelta: "local-state-delta",
          logs: "logs",
          receiverRewards: "receiver-rewards",
          senderRewards: "sender-rewards"
        };
      }
    };
    exports2.PendingTransactionResponse = PendingTransactionResponse;
    var PendingTransactionsResponse = class extends base_1.default {
      constructor(topTransactions, totalTransactions) {
        super();
        this.topTransactions = topTransactions;
        this.totalTransactions = totalTransactions;
        this.attribute_map = {
          topTransactions: "top-transactions",
          totalTransactions: "total-transactions"
        };
      }
    };
    exports2.PendingTransactionsResponse = PendingTransactionsResponse;
    var PostTransactionsResponse = class extends base_1.default {
      constructor(txid) {
        super();
        this.txid = txid;
        this.attribute_map = {
          txid: "txId"
        };
      }
    };
    exports2.PostTransactionsResponse = PostTransactionsResponse;
    var ProofResponse = class extends base_1.default {
      constructor({ idx, proof, stibhash, treedepth, hashtype }) {
        super();
        this.idx = idx;
        this.proof = typeof proof === "string" ? new Uint8Array(Buffer.from(proof, "base64")) : proof;
        this.stibhash = typeof stibhash === "string" ? new Uint8Array(Buffer.from(stibhash, "base64")) : stibhash;
        this.treedepth = treedepth;
        this.hashtype = hashtype;
        this.attribute_map = {
          idx: "idx",
          proof: "proof",
          stibhash: "stibhash",
          treedepth: "treedepth",
          hashtype: "hashtype"
        };
      }
    };
    exports2.ProofResponse = ProofResponse;
    var SupplyResponse = class extends base_1.default {
      constructor(currentRound, onlineMoney, totalMoney) {
        super();
        this.currentRound = currentRound;
        this.onlineMoney = onlineMoney;
        this.totalMoney = totalMoney;
        this.attribute_map = {
          currentRound: "current_round",
          onlineMoney: "online-money",
          totalMoney: "total-money"
        };
      }
    };
    exports2.SupplyResponse = SupplyResponse;
    var TealKeyValue = class extends base_1.default {
      constructor(key, value) {
        super();
        this.key = key;
        this.value = value;
        this.attribute_map = {
          key: "key",
          value: "value"
        };
      }
    };
    exports2.TealKeyValue = TealKeyValue;
    var TealValue = class extends base_1.default {
      constructor(type, bytes, uint) {
        super();
        this.type = type;
        this.bytes = bytes;
        this.uint = uint;
        this.attribute_map = {
          type: "type",
          bytes: "bytes",
          uint: "uint"
        };
      }
    };
    exports2.TealValue = TealValue;
    var TransactionParametersResponse = class extends base_1.default {
      constructor({ consensusVersion, fee, genesisHash, genesisId, lastRound, minFee }) {
        super();
        this.consensusVersion = consensusVersion;
        this.fee = fee;
        this.genesisHash = typeof genesisHash === "string" ? new Uint8Array(Buffer.from(genesisHash, "base64")) : genesisHash;
        this.genesisId = genesisId;
        this.lastRound = lastRound;
        this.minFee = minFee;
        this.attribute_map = {
          consensusVersion: "consensus-version",
          fee: "fee",
          genesisHash: "genesis-hash",
          genesisId: "genesis-id",
          lastRound: "last-round",
          minFee: "min-fee"
        };
      }
    };
    exports2.TransactionParametersResponse = TransactionParametersResponse;
    var Version = class extends base_1.default {
      constructor(build, genesisHashB64, genesisId, versions) {
        super();
        this.build = build;
        this.genesisHashB64 = typeof genesisHashB64 === "string" ? new Uint8Array(Buffer.from(genesisHashB64, "base64")) : genesisHashB64;
        this.genesisId = genesisId;
        this.versions = versions;
        this.attribute_map = {
          build: "build",
          genesisHashB64: "genesis_hash_b64",
          genesisId: "genesis_id",
          versions: "versions"
        };
      }
    };
    exports2.Version = Version;
  }
});

// node_modules/algosdk/dist/cjs/src/mnemonic/wordlists/english.js
var require_english = __commonJS({
  "node_modules/algosdk/dist/cjs/src/mnemonic/wordlists/english.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var english = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
    exports2.default = english;
  }
});

// node_modules/algosdk/dist/cjs/src/mnemonic/mnemonic.js
var require_mnemonic = __commonJS({
  "node_modules/algosdk/dist/cjs/src/mnemonic/mnemonic.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.masterDerivationKeyToMnemonic = exports2.mnemonicToMasterDerivationKey = exports2.secretKeyToMnemonic = exports2.mnemonicToSecretKey = exports2.seedFromMnemonic = exports2.mnemonicFromSeed = exports2.NOT_IN_WORDS_LIST_ERROR_MSG = exports2.FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = void 0;
    var english_1 = __importDefault(require_english());
    var nacl = __importStar(require_naclWrappers());
    var address = __importStar(require_address());
    exports2.FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = "failed to decode mnemonic";
    exports2.NOT_IN_WORDS_LIST_ERROR_MSG = "the mnemonic contains a word that is not in the wordlist";
    function toUint11Array(buffer8) {
      const buffer11 = [];
      let acc = 0;
      let accBits = 0;
      function add(octet) {
        acc |= octet << accBits;
        accBits += 8;
        if (accBits >= 11) {
          buffer11.push(acc & 2047);
          acc >>= 11;
          accBits -= 11;
        }
      }
      function flush() {
        if (accBits) {
          buffer11.push(acc);
        }
      }
      buffer8.forEach(add);
      flush();
      return buffer11;
    }
    function applyWords(nums) {
      return nums.map((n) => english_1.default[n]);
    }
    function computeChecksum(seed) {
      const hashBuffer = nacl.genericHash(seed);
      const uint11Hash = toUint11Array(hashBuffer);
      const words = applyWords(uint11Hash);
      return words[0];
    }
    function mnemonicFromSeed(seed) {
      if (seed.length !== nacl.SEED_BTYES_LENGTH) {
        throw new RangeError(`Seed length must be ${nacl.SEED_BTYES_LENGTH}`);
      }
      const uint11Array = toUint11Array(seed);
      const words = applyWords(uint11Array);
      const checksumWord = computeChecksum(seed);
      return `${words.join(" ")} ${checksumWord}`;
    }
    exports2.mnemonicFromSeed = mnemonicFromSeed;
    function toUint8Array(buffer11) {
      const buffer8 = [];
      let acc = 0;
      let accBits = 0;
      function add(ui11) {
        acc |= ui11 << accBits;
        accBits += 11;
        while (accBits >= 8) {
          buffer8.push(acc & 255);
          acc >>= 8;
          accBits -= 8;
        }
      }
      function flush() {
        if (accBits) {
          buffer8.push(acc);
        }
      }
      buffer11.forEach(add);
      flush();
      return new Uint8Array(buffer8);
    }
    function seedFromMnemonic(mnemonic) {
      const words = mnemonic.split(" ");
      const key = words.slice(0, 24);
      for (const w of key) {
        if (english_1.default.indexOf(w) === -1)
          throw new Error(exports2.NOT_IN_WORDS_LIST_ERROR_MSG);
      }
      const checksum = words[words.length - 1];
      const uint11Array = key.map((word) => english_1.default.indexOf(word));
      let uint8Array = toUint8Array(uint11Array);
      if (uint8Array.length !== 33)
        throw new Error(exports2.FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
      if (uint8Array[uint8Array.length - 1] !== 0)
        throw new Error(exports2.FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
      uint8Array = uint8Array.slice(0, uint8Array.length - 1);
      const cs = computeChecksum(uint8Array);
      if (cs === checksum)
        return uint8Array;
      throw new Error(exports2.FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
    }
    exports2.seedFromMnemonic = seedFromMnemonic;
    function mnemonicToSecretKey(mn) {
      const seed = seedFromMnemonic(mn);
      const keys = nacl.keyPairFromSeed(seed);
      const encodedPk = address.encodeAddress(keys.publicKey);
      return { addr: encodedPk, sk: keys.secretKey };
    }
    exports2.mnemonicToSecretKey = mnemonicToSecretKey;
    function secretKeyToMnemonic(sk) {
      const seed = sk.slice(0, nacl.SEED_BTYES_LENGTH);
      return mnemonicFromSeed(seed);
    }
    exports2.secretKeyToMnemonic = secretKeyToMnemonic;
    function mnemonicToMasterDerivationKey(mn) {
      return seedFromMnemonic(mn);
    }
    exports2.mnemonicToMasterDerivationKey = mnemonicToMasterDerivationKey;
    function masterDerivationKeyToMnemonic(mdk) {
      return mnemonicFromSeed(mdk);
    }
    exports2.masterDerivationKeyToMnemonic = masterDerivationKeyToMnemonic;
  }
});

// node_modules/algosdk/dist/cjs/src/dryrun.js
var require_dryrun2 = __commonJS({
  "node_modules/algosdk/dist/cjs/src/dryrun.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDryrun = void 0;
    var types_1 = require_types();
    var transactions_1 = require_transactions();
    var address_1 = require_address();
    var defaultAppId = 1380011588;
    function decodePrograms(ap) {
      ap.params["approval-program"] = Buffer.from(ap.params["approval-program"].toString(), "base64");
      ap.params["clear-state-program"] = Buffer.from(ap.params["clear-state-program"].toString(), "base64");
      return ap;
    }
    async function createDryrun({ client, txns, protocolVersion, latestTimestamp, round, sources }) {
      const appInfos = [];
      const acctInfos = [];
      const apps = [];
      const assets = [];
      const accts = [];
      for (const t of txns) {
        if (t.txn.type === transactions_1.TransactionType.appl) {
          accts.push(address_1.encodeAddress(t.txn.from.publicKey));
          if (t.txn.appAccounts)
            accts.push(...t.txn.appAccounts.map((a) => address_1.encodeAddress(a.publicKey)));
          if (t.txn.appForeignApps)
            apps.push(...t.txn.appForeignApps);
          if (t.txn.appForeignAssets)
            assets.push(...t.txn.appForeignAssets);
          if (t.txn.appIndex === 0) {
            appInfos.push(new types_1.Application(defaultAppId, new types_1.ApplicationParams({
              creator: address_1.encodeAddress(t.txn.from.publicKey),
              approvalProgram: t.txn.appApprovalProgram,
              clearStateProgram: t.txn.appClearProgram,
              localStateSchema: new types_1.ApplicationStateSchema(t.txn.appLocalInts, t.txn.appLocalByteSlices),
              globalStateSchema: new types_1.ApplicationStateSchema(t.txn.appGlobalInts, t.txn.appGlobalByteSlices)
            })));
          } else {
            apps.push(t.txn.appIndex);
            accts.push(address_1.getApplicationAddress(t.txn.appIndex));
          }
        }
      }
      const assetPromises = [];
      for (const assetId of [...new Set(assets)]) {
        assetPromises.push(client.getAssetByID(assetId).do().then((assetInfo) => {
          accts.push(assetInfo.params.creator);
        }));
      }
      await Promise.all(assetPromises);
      const appPromises = [];
      for (const appId of [...new Set(apps)]) {
        appPromises.push(client.getApplicationByID(appId).do().then((appInfo) => {
          const ai = decodePrograms(appInfo);
          appInfos.push(ai);
          accts.push(ai.params.creator);
        }));
      }
      await Promise.all(appPromises);
      const acctPromises = [];
      for (const acct of [...new Set(accts)]) {
        acctPromises.push(client.accountInformation(acct).do().then((acctInfo) => {
          if ("created-apps" in acctInfo) {
            acctInfo["created-apps"] = acctInfo["created-apps"].map((app) => decodePrograms(app));
          }
          acctInfos.push(acctInfo);
        }));
      }
      await Promise.all(acctPromises);
      return new types_1.DryrunRequest({
        txns: txns.map((st) => ({ ...st, txn: st.txn.get_obj_for_encoding() })),
        accounts: acctInfos,
        apps: appInfos,
        latestTimestamp,
        round,
        protocolVersion,
        sources
      });
    }
    exports2.createDryrun = createDryrun;
  }
});

// node_modules/algosdk/dist/cjs/src/signer.js
var require_signer = __commonJS({
  "node_modules/algosdk/dist/cjs/src/signer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTransactionWithSigner = exports2.makeMultiSigAccountTransactionSigner = exports2.makeLogicSigAccountTransactionSigner = exports2.makeBasicAccountTransactionSigner = void 0;
    var logicsig_1 = require_logicsig();
    var multisig_1 = require_multisig();
    function makeBasicAccountTransactionSigner(account) {
      return (txnGroup, indexesToSign) => {
        const signed = [];
        for (const index of indexesToSign) {
          signed.push(txnGroup[index].signTxn(account.sk));
        }
        return Promise.resolve(signed);
      };
    }
    exports2.makeBasicAccountTransactionSigner = makeBasicAccountTransactionSigner;
    function makeLogicSigAccountTransactionSigner(account) {
      return (txnGroup, indexesToSign) => {
        const signed = [];
        for (const index of indexesToSign) {
          const { blob } = logicsig_1.signLogicSigTransactionObject(txnGroup[index], account);
          signed.push(blob);
        }
        return Promise.resolve(signed);
      };
    }
    exports2.makeLogicSigAccountTransactionSigner = makeLogicSigAccountTransactionSigner;
    function makeMultiSigAccountTransactionSigner(msig, sks) {
      return (txnGroup, indexesToSign) => {
        const signed = [];
        for (const index of indexesToSign) {
          const txn = txnGroup[index];
          const partialSigs = [];
          for (const sk of sks) {
            const { blob } = multisig_1.signMultisigTransaction(txn, msig, sk);
            partialSigs.push(blob);
          }
          signed.push(multisig_1.mergeMultisigTransactions(partialSigs));
        }
        return Promise.resolve(signed);
      };
    }
    exports2.makeMultiSigAccountTransactionSigner = makeMultiSigAccountTransactionSigner;
    function isTransactionWithSigner(value) {
      return typeof value === "object" && Object.keys(value).length === 2 && typeof value.txn === "object" && typeof value.signer === "function";
    }
    exports2.isTransactionWithSigner = isTransactionWithSigner;
  }
});

// node_modules/algosdk/dist/cjs/src/abi/abi_type.js
var require_abi_type = __commonJS({
  "node_modules/algosdk/dist/cjs/src/abi/abi_type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ABITupleType = exports2.ABIArrayDynamicType = exports2.ABIArrayStaticType = exports2.ABIStringType = exports2.ABIByteType = exports2.ABIBoolType = exports2.ABIAddressType = exports2.ABIUfixedType = exports2.ABIUintType = exports2.ABIType = exports2.LENGTH_ENCODE_BYTE_SIZE = exports2.SINGLE_BOOL_SIZE = exports2.SINGLE_BYTE_SIZE = exports2.ADDR_BYTE_SIZE = exports2.MAX_LEN = void 0;
    var address_1 = require_address();
    var bigint_1 = require_bigint();
    var utils_1 = require_utils();
    exports2.MAX_LEN = 2 ** 16 - 1;
    exports2.ADDR_BYTE_SIZE = 32;
    exports2.SINGLE_BYTE_SIZE = 1;
    exports2.SINGLE_BOOL_SIZE = 1;
    exports2.LENGTH_ENCODE_BYTE_SIZE = 2;
    var staticArrayRegexp = /^([a-z\d[\](),]+)\[([1-9][\d]*)]$/;
    var ufixedRegexp = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/;
    var ABIType = class {
      static from(str) {
        if (str.endsWith("[]")) {
          const arrayArgType = ABIType.from(str.slice(0, str.length - 2));
          return new ABIArrayDynamicType(arrayArgType);
        }
        if (str.endsWith("]")) {
          const stringMatches = str.match(staticArrayRegexp);
          if (stringMatches.length !== 3) {
            throw new Error(`malformed static array string: ${str}`);
          }
          const arrayLengthStr = stringMatches[2];
          const arrayLength = parseInt(arrayLengthStr, 10);
          if (arrayLength > exports2.MAX_LEN) {
            throw new Error(`array length exceeds limit ${exports2.MAX_LEN}`);
          }
          const arrayType = ABIType.from(stringMatches[1]);
          return new ABIArrayStaticType(arrayType, arrayLength);
        }
        if (str.startsWith("uint")) {
          const digitsOnly = (string) => [...string].every((c) => "0123456789".includes(c));
          const typeSizeStr = str.slice(4, str.length);
          if (!digitsOnly(typeSizeStr)) {
            throw new Error(`malformed uint string: ${typeSizeStr}`);
          }
          const typeSize = parseInt(typeSizeStr, 10);
          if (typeSize > exports2.MAX_LEN) {
            throw new Error(`malformed uint string: ${typeSize}`);
          }
          return new ABIUintType(typeSize);
        }
        if (str === "byte") {
          return new ABIByteType();
        }
        if (str.startsWith("ufixed")) {
          const stringMatches = str.match(ufixedRegexp);
          if (stringMatches.length !== 3) {
            throw new Error(`malformed ufixed type: ${str}`);
          }
          const ufixedSize = parseInt(stringMatches[1], 10);
          const ufixedPrecision = parseInt(stringMatches[2], 10);
          return new ABIUfixedType(ufixedSize, ufixedPrecision);
        }
        if (str === "bool") {
          return new ABIBoolType();
        }
        if (str === "address") {
          return new ABIAddressType();
        }
        if (str === "string") {
          return new ABIStringType();
        }
        if (str.length >= 2 && str[0] === "(" && str[str.length - 1] === ")") {
          const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));
          const tupleTypes = [];
          for (let i = 0; i < tupleContent.length; i++) {
            const ti = ABIType.from(tupleContent[i]);
            tupleTypes.push(ti);
          }
          return new ABITupleType(tupleTypes);
        }
        throw new Error(`cannot convert a string ${str} to an ABI type`);
      }
    };
    exports2.ABIType = ABIType;
    var ABIUintType = class extends ABIType {
      constructor(size) {
        super();
        if (size % 8 !== 0 || size < 8 || size > 512) {
          throw new Error(`unsupported uint type bitSize: ${size}`);
        }
        this.bitSize = size;
      }
      toString() {
        return `uint${this.bitSize}`;
      }
      equals(other) {
        return other instanceof ABIUintType && this.bitSize === other.bitSize;
      }
      isDynamic() {
        return false;
      }
      byteLen() {
        return this.bitSize / 8;
      }
      encode(value) {
        if (typeof value !== "bigint" && typeof value !== "number") {
          throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);
        }
        if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
          throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
        }
        if (typeof value === "number" && !Number.isSafeInteger(value)) {
          throw new Error(`${value} should be converted into a BigInt before it is encoded`);
        }
        return bigint_1.bigIntToBytes(value, this.bitSize / 8);
      }
      decode(byteString) {
        if (byteString.length !== this.bitSize / 8) {
          throw new Error(`byte string must correspond to a uint${this.bitSize}`);
        }
        return bigint_1.bytesToBigInt(byteString);
      }
    };
    exports2.ABIUintType = ABIUintType;
    var ABIUfixedType = class extends ABIType {
      constructor(size, denominator) {
        super();
        if (size % 8 !== 0 || size < 8 || size > 512) {
          throw new Error(`unsupported ufixed type bitSize: ${size}`);
        }
        if (denominator > 160 || denominator < 1) {
          throw new Error(`unsupported ufixed type precision: ${denominator}`);
        }
        this.bitSize = size;
        this.precision = denominator;
      }
      toString() {
        return `ufixed${this.bitSize}x${this.precision}`;
      }
      equals(other) {
        return other instanceof ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;
      }
      isDynamic() {
        return false;
      }
      byteLen() {
        return this.bitSize / 8;
      }
      encode(value) {
        if (typeof value !== "bigint" && typeof value !== "number") {
          throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
        }
        if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
          throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);
        }
        if (typeof value === "number" && !Number.isSafeInteger(value)) {
          throw new Error(`${value} should be converted into a BigInt before it is encoded`);
        }
        return bigint_1.bigIntToBytes(value, this.bitSize / 8);
      }
      decode(byteString) {
        if (byteString.length !== this.bitSize / 8) {
          throw new Error(`byte string must correspond to a ${this.toString()}`);
        }
        return bigint_1.bytesToBigInt(byteString);
      }
    };
    exports2.ABIUfixedType = ABIUfixedType;
    var ABIAddressType = class extends ABIType {
      toString() {
        return "address";
      }
      equals(other) {
        return other instanceof ABIAddressType;
      }
      isDynamic() {
        return false;
      }
      byteLen() {
        return exports2.ADDR_BYTE_SIZE;
      }
      encode(value) {
        if (typeof value !== "string" && !(value instanceof Uint8Array)) {
          throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
        }
        if (typeof value === "string") {
          const decodedAddress = address_1.decodeAddress(value);
          return decodedAddress.publicKey;
        }
        if (value.byteLength !== 32) {
          throw new Error(`byte string must be 32 bytes long for an address`);
        }
        return value;
      }
      decode(byteString) {
        if (byteString.byteLength !== 32) {
          throw new Error(`byte string must be 32 bytes long for an address`);
        }
        return address_1.encodeAddress(byteString);
      }
    };
    exports2.ABIAddressType = ABIAddressType;
    var ABIBoolType = class extends ABIType {
      toString() {
        return "bool";
      }
      equals(other) {
        return other instanceof ABIBoolType;
      }
      isDynamic() {
        return false;
      }
      byteLen() {
        return exports2.SINGLE_BOOL_SIZE;
      }
      encode(value) {
        if (typeof value !== "boolean") {
          throw new Error(`Cannot encode value as bool: ${value}`);
        }
        if (value) {
          return new Uint8Array([128]);
        }
        return new Uint8Array([0]);
      }
      decode(byteString) {
        if (byteString.byteLength !== 1) {
          throw new Error(`bool string must be 1 byte long`);
        }
        const value = byteString[0];
        if (value === 128) {
          return true;
        }
        if (value === 0) {
          return false;
        }
        throw new Error(`boolean could not be decoded from the byte string`);
      }
    };
    exports2.ABIBoolType = ABIBoolType;
    var ABIByteType = class extends ABIType {
      toString() {
        return "byte";
      }
      equals(other) {
        return other instanceof ABIByteType;
      }
      isDynamic() {
        return false;
      }
      byteLen() {
        return exports2.SINGLE_BYTE_SIZE;
      }
      encode(value) {
        if (typeof value !== "number" && typeof value !== "bigint") {
          throw new Error(`Cannot encode value as byte: ${value}`);
        }
        if (typeof value === "bigint") {
          value = Number(value);
        }
        if (value < 0 || value > 255) {
          throw new Error(`${value} cannot be encoded into a byte`);
        }
        return new Uint8Array([value]);
      }
      decode(byteString) {
        if (byteString.byteLength !== 1) {
          throw new Error(`byte string must be 1 byte long`);
        }
        return byteString[0];
      }
    };
    exports2.ABIByteType = ABIByteType;
    var ABIStringType = class extends ABIType {
      toString() {
        return "string";
      }
      equals(other) {
        return other instanceof ABIStringType;
      }
      isDynamic() {
        return true;
      }
      byteLen() {
        throw new Error(`${this.toString()} is a dynamic type`);
      }
      encode(value) {
        if (typeof value !== "string" && !(value instanceof Uint8Array)) {
          throw new Error(`Cannot encode value as string: ${value}`);
        }
        const encodedBytes = Buffer.from(value);
        const encodedLength = bigint_1.bigIntToBytes(value.length, exports2.LENGTH_ENCODE_BYTE_SIZE);
        const mergedBytes = new Uint8Array(value.length + exports2.LENGTH_ENCODE_BYTE_SIZE);
        mergedBytes.set(encodedLength);
        mergedBytes.set(encodedBytes, exports2.LENGTH_ENCODE_BYTE_SIZE);
        return mergedBytes;
      }
      decode(byteString) {
        if (byteString.length < exports2.LENGTH_ENCODE_BYTE_SIZE) {
          throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${exports2.LENGTH_ENCODE_BYTE_SIZE}`);
        }
        const buf = Buffer.from(byteString);
        const byteLength = buf.readUIntBE(0, exports2.LENGTH_ENCODE_BYTE_SIZE);
        const byteValue = byteString.slice(exports2.LENGTH_ENCODE_BYTE_SIZE, byteString.length);
        if (byteLength !== byteValue.length) {
          throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`);
        }
        return Buffer.from(byteValue).toString("utf-8");
      }
    };
    exports2.ABIStringType = ABIStringType;
    var ABIArrayStaticType = class extends ABIType {
      constructor(argType, arrayLength) {
        super();
        if (arrayLength < 1) {
          throw new Error(`static array must have a length greater than 0: ${arrayLength}`);
        }
        this.childType = argType;
        this.staticLength = arrayLength;
      }
      toString() {
        return `${this.childType.toString()}[${this.staticLength}]`;
      }
      equals(other) {
        return other instanceof ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);
      }
      isDynamic() {
        return this.childType.isDynamic();
      }
      byteLen() {
        if (this.childType.constructor === ABIBoolType) {
          return Math.ceil(this.staticLength / 8);
        }
        return this.staticLength * this.childType.byteLen();
      }
      encode(value) {
        if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
          throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
        }
        if (value.length !== this.staticLength) {
          throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);
        }
        const convertedTuple = this.toABITupleType();
        return convertedTuple.encode(value);
      }
      decode(byteString) {
        const convertedTuple = this.toABITupleType();
        return convertedTuple.decode(byteString);
      }
      toABITupleType() {
        return new ABITupleType(Array(this.staticLength).fill(this.childType));
      }
    };
    exports2.ABIArrayStaticType = ABIArrayStaticType;
    var ABIArrayDynamicType = class extends ABIType {
      constructor(argType) {
        super();
        this.childType = argType;
      }
      toString() {
        return `${this.childType.toString()}[]`;
      }
      equals(other) {
        return other instanceof ABIArrayDynamicType && this.childType.equals(other.childType);
      }
      isDynamic() {
        return true;
      }
      byteLen() {
        throw new Error(`${this.toString()} is a dynamic type`);
      }
      encode(value) {
        if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
          throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
        }
        const convertedTuple = this.toABITupleType(value.length);
        const encodedTuple = convertedTuple.encode(value);
        const encodedLength = bigint_1.bigIntToBytes(convertedTuple.childTypes.length, exports2.LENGTH_ENCODE_BYTE_SIZE);
        const mergedBytes = utils_1.concatArrays(encodedLength, encodedTuple);
        return mergedBytes;
      }
      decode(byteString) {
        const buf = Buffer.from(byteString);
        const byteLength = buf.readUIntBE(0, exports2.LENGTH_ENCODE_BYTE_SIZE);
        const convertedTuple = this.toABITupleType(byteLength);
        return convertedTuple.decode(byteString.slice(exports2.LENGTH_ENCODE_BYTE_SIZE, byteString.length));
      }
      toABITupleType(length) {
        return new ABITupleType(Array(length).fill(this.childType));
      }
    };
    exports2.ABIArrayDynamicType = ABIArrayDynamicType;
    var ABITupleType = class extends ABIType {
      constructor(argTypes) {
        super();
        if (argTypes.length >= exports2.MAX_LEN) {
          throw new Error("tuple type child type number larger than maximum uint16 error");
        }
        this.childTypes = argTypes;
      }
      toString() {
        const typeStrings = [];
        for (let i = 0; i < this.childTypes.length; i++) {
          typeStrings[i] = this.childTypes[i].toString();
        }
        return `(${typeStrings.join(",")})`;
      }
      equals(other) {
        return other instanceof ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index) => child.equals(other.childTypes[index]));
      }
      isDynamic() {
        const isDynamic = (child) => child.isDynamic();
        return this.childTypes.some(isDynamic);
      }
      byteLen() {
        let size = 0;
        for (let i = 0; i < this.childTypes.length; i++) {
          if (this.childTypes[i].constructor === ABIBoolType) {
            const after = findBoolLR(this.childTypes, i, 1);
            const boolNum = after + 1;
            i += after;
            size += Math.trunc((boolNum + 7) / 8);
          } else {
            const childByteSize = this.childTypes[i].byteLen();
            size += childByteSize;
          }
        }
        return size;
      }
      encode(value) {
        if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
          throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
        }
        const values = Array.from(value);
        if (value.length > exports2.MAX_LEN) {
          throw new Error("length of tuple array should not exceed a uint16");
        }
        const tupleTypes = this.childTypes;
        const heads = [];
        const tails = [];
        const isDynamicIndex = /* @__PURE__ */ new Map();
        let i = 0;
        while (i < tupleTypes.length) {
          const tupleType = tupleTypes[i];
          if (tupleType.isDynamic()) {
            isDynamicIndex.set(heads.length, true);
            heads.push(new Uint8Array([0, 0]));
            tails.push(tupleType.encode(values[i]));
          } else {
            if (tupleType.constructor === ABIBoolType) {
              const before = findBoolLR(tupleTypes, i, -1);
              let after = findBoolLR(tupleTypes, i, 1);
              if (before % 8 !== 0) {
                throw new Error("expected before index should have number of bool mod 8 equal 0");
              }
              after = Math.min(7, after);
              const compressedInt = compressMultipleBool(values.slice(i, i + after + 1));
              heads.push(bigint_1.bigIntToBytes(compressedInt, 1));
              i += after;
            } else {
              const encodedTupleValue = tupleType.encode(values[i]);
              heads.push(encodedTupleValue);
            }
            isDynamicIndex.set(i, false);
            tails.push(new Uint8Array());
          }
          i += 1;
        }
        let headLength = 0;
        for (const headElement of heads) {
          headLength += headElement.length;
        }
        let tailLength = 0;
        for (let j = 0; j < heads.length; j++) {
          if (isDynamicIndex.get(j)) {
            const headValue = headLength + tailLength;
            if (headValue > exports2.MAX_LEN) {
              throw new Error(`byte length of ${headValue} should not exceed a uint16`);
            }
            heads[j] = bigint_1.bigIntToBytes(headValue, exports2.LENGTH_ENCODE_BYTE_SIZE);
          }
          tailLength += tails[j].length;
        }
        return utils_1.concatArrays(...heads, ...tails);
      }
      decode(byteString) {
        const tupleTypes = this.childTypes;
        const dynamicSegments = [];
        const valuePartition = [];
        let i = 0;
        let iterIndex = 0;
        const buf = Buffer.from(byteString);
        while (i < tupleTypes.length) {
          const tupleType = tupleTypes[i];
          if (tupleType.isDynamic()) {
            if (byteString.slice(iterIndex, byteString.length).length < exports2.LENGTH_ENCODE_BYTE_SIZE) {
              throw new Error("dynamic type in tuple is too short to be decoded");
            }
            const dynamicIndex = buf.readUIntBE(iterIndex, exports2.LENGTH_ENCODE_BYTE_SIZE);
            if (dynamicSegments.length > 0) {
              dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;
              if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {
                throw new Error("dynamic index segment miscalculation: left is greater than right index");
              }
            }
            const seg = {
              left: dynamicIndex,
              right: -1
            };
            dynamicSegments.push(seg);
            valuePartition.push(null);
            iterIndex += exports2.LENGTH_ENCODE_BYTE_SIZE;
          } else {
            if (tupleType.constructor === ABIBoolType) {
              const before = findBoolLR(this.childTypes, i, -1);
              let after = findBoolLR(this.childTypes, i, 1);
              if (before % 8 !== 0) {
                throw new Error("expected before bool number mod 8 === 0");
              }
              after = Math.min(7, after);
              for (let boolIndex = 0; boolIndex <= after; boolIndex++) {
                const boolMask = 128 >> boolIndex;
                if ((byteString[iterIndex] & boolMask) > 0) {
                  valuePartition.push(new Uint8Array([128]));
                } else {
                  valuePartition.push(new Uint8Array([0]));
                }
              }
              i += after;
              iterIndex += 1;
            } else {
              const currLen = tupleType.byteLen();
              valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));
              iterIndex += currLen;
            }
          }
          if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {
            throw new Error("input byte not enough to decode");
          }
          i += 1;
        }
        if (dynamicSegments.length > 0) {
          dynamicSegments[dynamicSegments.length - 1].right = byteString.length;
          iterIndex = byteString.length;
        }
        if (iterIndex < byteString.length) {
          throw new Error("input byte not fully consumed");
        }
        for (let j = 0; j < dynamicSegments.length; j++) {
          const seg = dynamicSegments[j];
          if (seg.left > seg.right) {
            throw new Error("dynamic segment should display a [l, r] space with l <= r");
          }
          if (j !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j + 1].left) {
            throw new Error("dynamic segment should be consecutive");
          }
        }
        let segIndex = 0;
        for (let j = 0; j < tupleTypes.length; j++) {
          if (tupleTypes[j].isDynamic()) {
            valuePartition[j] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);
            segIndex += 1;
          }
        }
        const returnValues = [];
        for (let j = 0; j < tupleTypes.length; j++) {
          const valueTi = tupleTypes[j].decode(valuePartition[j]);
          returnValues.push(valueTi);
        }
        return returnValues;
      }
      static parseTupleContent(str) {
        if (str.length === 0) {
          return [];
        }
        if (str.endsWith(",") || str.startsWith(",")) {
          throw new Error("tuple string should not start with comma");
        }
        if (str.includes(",,")) {
          throw new Error("tuple string should not have consecutive commas");
        }
        const tupleStrings = [];
        let depth = 0;
        let word = "";
        for (const char of str) {
          word += char;
          if (char === "(") {
            depth += 1;
          } else if (char === ")") {
            depth -= 1;
          } else if (char === ",") {
            if (depth === 0) {
              tupleStrings.push(word.slice(0, word.length - 1));
              word = "";
            }
          }
        }
        if (word.length !== 0) {
          tupleStrings.push(word);
        }
        if (depth !== 0) {
          throw new Error("tuple string has mismatched parentheses");
        }
        return tupleStrings;
      }
    };
    exports2.ABITupleType = ABITupleType;
    function compressMultipleBool(valueList) {
      let res = 0;
      if (valueList.length > 8) {
        throw new Error("value list passed in should be no greater than length 8");
      }
      for (let i = 0; i < valueList.length; i++) {
        const boolVal = valueList[i];
        if (typeof boolVal !== "boolean") {
          throw new Error("non-boolean values cannot be compressed into a byte");
        }
        if (boolVal) {
          res |= 1 << 7 - i;
        }
      }
      return res;
    }
    function findBoolLR(typeList, index, delta) {
      let until = 0;
      while (true) {
        const curr = index + delta * until;
        if (typeList[curr].constructor === ABIBoolType) {
          if (curr !== typeList.length - 1 && delta === 1) {
            until += 1;
          } else if (curr > 0 && delta === -1) {
            until += 1;
          } else {
            break;
          }
        } else {
          until -= 1;
          break;
        }
      }
      return until;
    }
  }
});

// node_modules/algosdk/dist/cjs/src/abi/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/algosdk/dist/cjs/src/abi/transaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.abiCheckTransactionType = exports2.abiTypeIsTransaction = exports2.ABITransactionType = void 0;
    var ABITransactionType;
    (function(ABITransactionType2) {
      ABITransactionType2["any"] = "txn";
      ABITransactionType2["pay"] = "pay";
      ABITransactionType2["keyreg"] = "keyreg";
      ABITransactionType2["acfg"] = "acfg";
      ABITransactionType2["axfer"] = "axfer";
      ABITransactionType2["afrz"] = "afrz";
      ABITransactionType2["appl"] = "appl";
    })(ABITransactionType = exports2.ABITransactionType || (exports2.ABITransactionType = {}));
    function abiTypeIsTransaction(type) {
      return type === ABITransactionType.any || type === ABITransactionType.pay || type === ABITransactionType.keyreg || type === ABITransactionType.acfg || type === ABITransactionType.axfer || type === ABITransactionType.afrz || type === ABITransactionType.appl;
    }
    exports2.abiTypeIsTransaction = abiTypeIsTransaction;
    function abiCheckTransactionType(type, txn) {
      if (type === ABITransactionType.any) {
        return true;
      }
      return txn.type && txn.type.toString() === type.toString();
    }
    exports2.abiCheckTransactionType = abiCheckTransactionType;
  }
});

// node_modules/algosdk/dist/cjs/src/abi/reference.js
var require_reference = __commonJS({
  "node_modules/algosdk/dist/cjs/src/abi/reference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.abiTypeIsReference = exports2.ABIReferenceType = void 0;
    var ABIReferenceType;
    (function(ABIReferenceType2) {
      ABIReferenceType2["account"] = "account";
      ABIReferenceType2["application"] = "application";
      ABIReferenceType2["asset"] = "asset";
    })(ABIReferenceType = exports2.ABIReferenceType || (exports2.ABIReferenceType = {}));
    function abiTypeIsReference(type) {
      return type === ABIReferenceType.account || type === ABIReferenceType.application || type === ABIReferenceType.asset;
    }
    exports2.abiTypeIsReference = abiTypeIsReference;
  }
});

// node_modules/algosdk/dist/cjs/src/abi/method.js
var require_method = __commonJS({
  "node_modules/algosdk/dist/cjs/src/abi/method.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ABIMethod = void 0;
    var naclWrappers_1 = require_naclWrappers();
    var abi_type_1 = require_abi_type();
    var transaction_1 = require_transaction2();
    var reference_1 = require_reference();
    function parseMethodSignature(signature) {
      const argsStart = signature.indexOf("(");
      if (argsStart === -1) {
        throw new Error(`Invalid method signature: ${signature}`);
      }
      let argsEnd = -1;
      let depth = 0;
      for (let i = argsStart; i < signature.length; i++) {
        const char = signature[i];
        if (char === "(") {
          depth += 1;
        } else if (char === ")") {
          if (depth === 0) {
            break;
          }
          depth -= 1;
          if (depth === 0) {
            argsEnd = i;
            break;
          }
        }
      }
      if (argsEnd === -1) {
        throw new Error(`Invalid method signature: ${signature}`);
      }
      return {
        name: signature.slice(0, argsStart),
        args: abi_type_1.ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),
        returns: signature.slice(argsEnd + 1)
      };
    }
    var ABIMethod = class {
      constructor(params) {
        if (typeof params.name !== "string" || typeof params.returns !== "object" || !Array.isArray(params.args)) {
          throw new Error("Invalid ABIMethod parameters");
        }
        this.name = params.name;
        this.description = params.desc;
        this.args = params.args.map(({ type, name, desc }) => {
          if (transaction_1.abiTypeIsTransaction(type) || reference_1.abiTypeIsReference(type)) {
            return {
              type,
              name,
              description: desc
            };
          }
          return {
            type: abi_type_1.ABIType.from(type),
            name,
            description: desc
          };
        });
        this.returns = {
          type: params.returns.type === "void" ? params.returns.type : abi_type_1.ABIType.from(params.returns.type),
          description: params.returns.desc
        };
      }
      getSignature() {
        const args = this.args.map((arg) => arg.type.toString()).join(",");
        const returns = this.returns.type.toString();
        return `${this.name}(${args})${returns}`;
      }
      getSelector() {
        const hash = naclWrappers_1.genericHash(this.getSignature());
        return new Uint8Array(hash.slice(0, 4));
      }
      txnCount() {
        let count = 1;
        for (const arg of this.args) {
          if (typeof arg.type === "string" && transaction_1.abiTypeIsTransaction(arg.type)) {
            count += 1;
          }
        }
        return count;
      }
      toJSON() {
        return {
          name: this.name,
          desc: this.description,
          args: this.args.map(({ type, name, description }) => ({
            type: type.toString(),
            name,
            desc: description
          })),
          returns: {
            type: this.returns.type.toString(),
            desc: this.returns.description
          }
        };
      }
      static fromSignature(signature) {
        const { name, args, returns } = parseMethodSignature(signature);
        return new ABIMethod({
          name,
          args: args.map((arg) => ({ type: arg })),
          returns: { type: returns }
        });
      }
    };
    exports2.ABIMethod = ABIMethod;
  }
});

// node_modules/algosdk/dist/cjs/src/abi/contract.js
var require_contract = __commonJS({
  "node_modules/algosdk/dist/cjs/src/abi/contract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ABIContract = void 0;
    var method_1 = require_method();
    var ABIContract = class {
      constructor(params) {
        if (typeof params.name !== "string" || !Array.isArray(params.methods) || params.networks && typeof params.networks !== "object") {
          throw new Error("Invalid ABIContract parameters");
        }
        this.name = params.name;
        this.description = params.desc;
        this.networks = params.networks ? { ...params.networks } : {};
        this.methods = params.methods.map((method2) => new method_1.ABIMethod(method2));
      }
      toJSON() {
        return {
          name: this.name,
          desc: this.description,
          networks: this.networks,
          methods: this.methods.map((method2) => method2.toJSON())
        };
      }
    };
    exports2.ABIContract = ABIContract;
  }
});

// node_modules/algosdk/dist/cjs/src/abi/interface.js
var require_interface = __commonJS({
  "node_modules/algosdk/dist/cjs/src/abi/interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ABIInterface = void 0;
    var method_1 = require_method();
    var ABIInterface = class {
      constructor(params) {
        if (typeof params.name !== "string" || !Array.isArray(params.methods)) {
          throw new Error("Invalid ABIInterface parameters");
        }
        this.name = params.name;
        this.description = params.desc;
        this.methods = params.methods.map((method2) => new method_1.ABIMethod(method2));
      }
      toJSON() {
        return {
          name: this.name,
          desc: this.description,
          methods: this.methods.map((method2) => method2.toJSON())
        };
      }
    };
    exports2.ABIInterface = ABIInterface;
  }
});

// node_modules/algosdk/dist/cjs/src/abi/index.js
var require_abi = __commonJS({
  "node_modules/algosdk/dist/cjs/src/abi/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_abi_type(), exports2);
    __exportStar(require_contract(), exports2);
    __exportStar(require_interface(), exports2);
    __exportStar(require_method(), exports2);
    __exportStar(require_transaction2(), exports2);
    __exportStar(require_reference(), exports2);
  }
});

// node_modules/algosdk/dist/cjs/src/composer.js
var require_composer = __commonJS({
  "node_modules/algosdk/dist/cjs/src/composer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AtomicTransactionComposer = exports2.AtomicTransactionComposerStatus = void 0;
    var abi_1 = require_abi();
    var transaction_1 = require_transaction();
    var makeTxn_1 = require_makeTxn();
    var group_1 = require_group();
    var wait_1 = require_wait();
    var signer_1 = require_signer();
    var base_1 = require_base();
    var RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);
    var MAX_APP_ARGS = 16;
    var AtomicTransactionComposerStatus;
    (function(AtomicTransactionComposerStatus2) {
      AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
      AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
      AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
      AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
      AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
    })(AtomicTransactionComposerStatus = exports2.AtomicTransactionComposerStatus || (exports2.AtomicTransactionComposerStatus = {}));
    function populateForeignArray(valueToAdd, array, zeroValue) {
      if (zeroValue != null && valueToAdd === zeroValue) {
        return 0;
      }
      const offset = zeroValue == null ? 0 : 1;
      for (let i = 0; i < array.length; i++) {
        if (valueToAdd === array[i]) {
          return i + offset;
        }
      }
      array.push(valueToAdd);
      return array.length - 1 + offset;
    }
    var AtomicTransactionComposer = class {
      constructor() {
        this.status = AtomicTransactionComposerStatus.BUILDING;
        this.transactions = [];
        this.methodCalls = /* @__PURE__ */ new Map();
        this.signedTxns = [];
        this.txIDs = [];
      }
      getStatus() {
        return this.status;
      }
      count() {
        return this.transactions.length;
      }
      clone() {
        const theClone = new AtomicTransactionComposer();
        theClone.transactions = this.transactions.map(({ txn, signer }) => ({
          txn: transaction_1.Transaction.from_obj_for_encoding({
            ...txn.get_obj_for_encoding(),
            grp: void 0
          }),
          signer
        }));
        theClone.methodCalls = new Map(this.methodCalls);
        return theClone;
      }
      addTransaction(txnAndSigner) {
        if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
          throw new Error("Cannot add transactions when composer status is not BUILDING");
        }
        if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {
          throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
        }
        if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v) => v !== 0)) {
          throw new Error("Cannot add a transaction with nonzero group ID");
        }
        this.transactions.push(txnAndSigner);
      }
      addMethodCall({ appID, method: method2, methodArgs, sender, suggestedParams, onComplete, approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages, note, lease, rekeyTo, signer }) {
        if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
          throw new Error("Cannot add transactions when composer status is not BUILDING");
        }
        if (this.transactions.length + method2.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {
          throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);
        }
        if (appID === 0) {
          if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {
            throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
          }
        } else if (onComplete === base_1.OnApplicationComplete.UpdateApplicationOC) {
          if (approvalProgram == null || clearProgram == null) {
            throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
          }
          if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
            throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
          }
        } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
          throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
        }
        if (methodArgs == null) {
          methodArgs = [];
        }
        if (methodArgs.length !== method2.args.length) {
          throw new Error(`Incorrect number of method arguments. Expected ${method2.args.length}, got ${methodArgs.length}`);
        }
        let basicArgTypes = [];
        let basicArgValues = [];
        const txnArgs = [];
        const refArgTypes = [];
        const refArgValues = [];
        const refArgIndexToBasicArgIndex = /* @__PURE__ */ new Map();
        for (let i = 0; i < methodArgs.length; i++) {
          let argType = method2.args[i].type;
          const argValue = methodArgs[i];
          if (abi_1.abiTypeIsTransaction(argType)) {
            if (!signer_1.isTransactionWithSigner(argValue) || !abi_1.abiCheckTransactionType(argType, argValue.txn)) {
              throw new Error(`Expected ${argType} transaction for argument at index ${i}`);
            }
            if (argValue.txn.group && argValue.txn.group.some((v) => v !== 0)) {
              throw new Error("Cannot add a transaction with nonzero group ID");
            }
            txnArgs.push(argValue);
            continue;
          }
          if (signer_1.isTransactionWithSigner(argValue)) {
            throw new Error(`Expected non-transaction value for argument at index ${i}`);
          }
          if (abi_1.abiTypeIsReference(argType)) {
            refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);
            refArgTypes.push(argType);
            refArgValues.push(argValue);
            argType = new abi_1.ABIUintType(8);
          }
          if (typeof argType === "string") {
            throw new Error(`Unknown ABI type: ${argType}`);
          }
          basicArgTypes.push(argType);
          basicArgValues.push(argValue);
        }
        const resolvedRefIndexes = [];
        const foreignAccounts = [];
        const foreignApps = [];
        const foreignAssets = [];
        for (let i = 0; i < refArgTypes.length; i++) {
          const refType = refArgTypes[i];
          const refValue = refArgValues[i];
          let resolved = 0;
          switch (refType) {
            case abi_1.ABIReferenceType.account: {
              const addressType = new abi_1.ABIAddressType();
              const address = addressType.decode(addressType.encode(refValue));
              resolved = populateForeignArray(address, foreignAccounts, sender);
              break;
            }
            case abi_1.ABIReferenceType.application: {
              const uint64Type = new abi_1.ABIUintType(64);
              const refAppID = uint64Type.decode(uint64Type.encode(refValue));
              if (refAppID > Number.MAX_SAFE_INTEGER) {
                throw new Error(`Expected safe integer for application value, got ${refAppID}`);
              }
              resolved = populateForeignArray(Number(refAppID), foreignApps, appID);
              break;
            }
            case abi_1.ABIReferenceType.asset: {
              const uint64Type = new abi_1.ABIUintType(64);
              const refAssetID = uint64Type.decode(uint64Type.encode(refValue));
              if (refAssetID > Number.MAX_SAFE_INTEGER) {
                throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);
              }
              resolved = populateForeignArray(Number(refAssetID), foreignAssets);
              break;
            }
            default:
              throw new Error(`Unknown reference type: ${refType}`);
          }
          resolvedRefIndexes.push(resolved);
        }
        for (let i = 0; i < resolvedRefIndexes.length; i++) {
          const basicArgIndex = refArgIndexToBasicArgIndex.get(i);
          basicArgValues[basicArgIndex] = resolvedRefIndexes[i];
        }
        if (basicArgTypes.length > MAX_APP_ARGS - 1) {
          const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);
          const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);
          basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);
          basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);
          basicArgTypes.push(new abi_1.ABITupleType(lastArgTupleTypes));
          basicArgValues.push(lastArgTupleValues);
        }
        const appArgsEncoded = [method2.getSelector()];
        for (let i = 0; i < basicArgTypes.length; i++) {
          appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));
        }
        const appCall = {
          txn: makeTxn_1.makeApplicationCallTxnFromObject({
            from: sender,
            appIndex: appID,
            appArgs: appArgsEncoded,
            accounts: foreignAccounts,
            foreignApps,
            foreignAssets,
            onComplete: onComplete == null ? base_1.OnApplicationComplete.NoOpOC : onComplete,
            approvalProgram,
            clearProgram,
            numGlobalInts,
            numGlobalByteSlices,
            numLocalInts,
            numLocalByteSlices,
            extraPages,
            lease,
            note,
            rekeyTo,
            suggestedParams
          }),
          signer
        };
        this.transactions.push(...txnArgs, appCall);
        this.methodCalls.set(this.transactions.length - 1, method2);
      }
      buildGroup() {
        if (this.status === AtomicTransactionComposerStatus.BUILDING) {
          if (this.transactions.length === 0) {
            throw new Error("Cannot build a group with 0 transactions");
          }
          if (this.transactions.length > 1) {
            group_1.assignGroupID(this.transactions.map((txnWithSigner) => txnWithSigner.txn));
          }
          this.status = AtomicTransactionComposerStatus.BUILT;
        }
        return this.transactions;
      }
      async gatherSignatures() {
        if (this.status >= AtomicTransactionComposerStatus.SIGNED) {
          return this.signedTxns;
        }
        const txnsWithSigners = this.buildGroup();
        const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);
        const indexesPerSigner = /* @__PURE__ */ new Map();
        for (let i = 0; i < txnsWithSigners.length; i++) {
          const { signer } = txnsWithSigners[i];
          if (!indexesPerSigner.has(signer)) {
            indexesPerSigner.set(signer, []);
          }
          indexesPerSigner.get(signer).push(i);
        }
        const orderedSigners = Array.from(indexesPerSigner);
        const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));
        const signedTxns = txnsWithSigners.map(() => null);
        for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {
          const indexes = orderedSigners[signerIndex][1];
          const sigs = batchedSigs[signerIndex];
          for (let i = 0; i < indexes.length; i++) {
            signedTxns[indexes[i]] = sigs[i];
          }
        }
        if (!signedTxns.every((sig) => sig != null)) {
          throw new Error(`Missing signatures. Got ${signedTxns}`);
        }
        const txIDs = signedTxns.map((stxn, index) => {
          try {
            return transaction_1.decodeSignedTransaction(stxn).txn.txID();
          } catch (err) {
            throw new Error(`Cannot decode signed transaction at index ${index}. ${err}`);
          }
        });
        this.signedTxns = signedTxns;
        this.txIDs = txIDs;
        this.status = AtomicTransactionComposerStatus.SIGNED;
        return signedTxns;
      }
      async submit(client) {
        if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
          throw new Error("Transaction group cannot be resubmitted");
        }
        const stxns = await this.gatherSignatures();
        await client.sendRawTransaction(stxns).do();
        this.status = AtomicTransactionComposerStatus.SUBMITTED;
        return this.txIDs;
      }
      async execute(client, waitRounds) {
        if (this.status === AtomicTransactionComposerStatus.COMMITTED) {
          throw new Error("Transaction group has already been executed successfully");
        }
        const txIDs = await this.submit(client);
        this.status = AtomicTransactionComposerStatus.SUBMITTED;
        const firstMethodCallIndex = this.transactions.findIndex((_, index) => this.methodCalls.has(index));
        const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;
        const confirmedTxnInfo = await wait_1.waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);
        this.status = AtomicTransactionComposerStatus.COMMITTED;
        const confirmedRound = confirmedTxnInfo["confirmed-round"];
        const methodResults = [];
        for (const [txnIndex, method2] of this.methodCalls) {
          const txID = txIDs[txnIndex];
          const methodResult = {
            txID,
            rawReturnValue: new Uint8Array()
          };
          try {
            const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo : await client.pendingTransactionInformation(txID).do();
            methodResult.txInfo = pendingInfo;
            if (method2.returns.type !== "void") {
              const logs = pendingInfo.logs || [];
              if (logs.length === 0) {
                throw new Error("App call transaction did not log a return value");
              }
              const lastLog = Buffer.from(logs[logs.length - 1], "base64");
              if (lastLog.byteLength < 4 || !lastLog.slice(0, 4).equals(RETURN_PREFIX)) {
                throw new Error("App call transaction did not log a return value");
              }
              methodResult.rawReturnValue = new Uint8Array(lastLog.slice(4));
              methodResult.returnValue = method2.returns.type.decode(methodResult.rawReturnValue);
            }
          } catch (err) {
            methodResult.decodeError = err;
          }
          methodResults.push(methodResult);
        }
        return {
          confirmedRound,
          txIDs,
          methodResults
        };
      }
    };
    exports2.AtomicTransactionComposer = AtomicTransactionComposer;
    AtomicTransactionComposer.MAX_GROUP_SIZE = 16;
  }
});

// node_modules/algosdk/dist/cjs/src/types/multisig.js
var require_multisig2 = __commonJS({
  "node_modules/algosdk/dist/cjs/src/types/multisig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/algosdk/dist/cjs/src/types/address.js
var require_address2 = __commonJS({
  "node_modules/algosdk/dist/cjs/src/types/address.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/algosdk/dist/cjs/src/types/index.js
var require_types2 = __commonJS({
  "node_modules/algosdk/dist/cjs/src/types/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_transactions(), exports2);
    __exportStar(require_multisig2(), exports2);
    __exportStar(require_address2(), exports2);
  }
});

// node_modules/algosdk/dist/cjs/src/main.js
var require_main = __commonJS({
  "node_modules/algosdk/dist/cjs/src/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogicTemplates = exports2.multisigAddress = exports2.appendSignMultisigTransaction = exports2.mergeMultisigTransactions = exports2.signMultisigTransaction = exports2.tealSignFromProgram = exports2.tealSign = exports2.logicSigFromByte = exports2.signLogicSigTransactionObject = exports2.signLogicSigTransaction = exports2.makeLogicSig = exports2.LogicSigAccount = exports2.assignGroupID = exports2.computeGroupID = exports2.INVALID_MICROALGOS_ERROR_MSG = exports2.algosToMicroalgos = exports2.microalgosToAlgos = exports2.mnemonicFromSeed = exports2.seedFromMnemonic = exports2.mnemonicToSecretKey = exports2.secretKeyToMnemonic = exports2.masterDerivationKeyToMnemonic = exports2.mnemonicToMasterDerivationKey = exports2.modelsv2 = exports2.generateAccount = exports2.decodeUint64 = exports2.encodeUint64 = exports2.bigIntToBytes = exports2.bytesToBigInt = exports2.getApplicationAddress = exports2.decodeAddress = exports2.encodeAddress = exports2.isValidAddress = exports2.waitForConfirmation = exports2.Indexer = exports2.IntDecoding = exports2.Kmd = exports2.Algodv2 = exports2.ERROR_INVALID_MICROALGOS = exports2.ERROR_MULTISIG_BAD_SENDER = exports2.decodeObj = exports2.encodeObj = exports2.verifyBytes = exports2.signBytes = exports2.signBid = exports2.signTransaction = exports2.MULTISIG_BAD_SENDER_ERROR_MSG = void 0;
    var nacl = __importStar(require_naclWrappers());
    var address = __importStar(require_address());
    var encoding = __importStar(require_encoding());
    var txnBuilder = __importStar(require_transaction());
    var LogicTemplatesCommonJSExport = __importStar(require_logicTemplates());
    var bid_1 = __importDefault(require_bid());
    var convert = __importStar(require_convert());
    var utils = __importStar(require_utils());
    var SIGN_BYTES_PREFIX = Buffer.from([77, 88]);
    exports2.MULTISIG_BAD_SENDER_ERROR_MSG = "The transaction sender address and multisig preimage do not match.";
    function signTransaction(txn, sk) {
      if (typeof txn.from === "undefined") {
        const key = nacl.keyPairFromSecretKey(sk);
        txn.from = address.encodeAddress(key.publicKey);
      }
      const algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);
      return {
        txID: algoTxn.txID().toString(),
        blob: algoTxn.signTxn(sk)
      };
    }
    exports2.signTransaction = signTransaction;
    function signBid(bid, sk) {
      const signedBid = new bid_1.default(bid);
      return signedBid.signBid(sk);
    }
    exports2.signBid = signBid;
    function signBytes(bytes, sk) {
      const toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));
      const sig = nacl.sign(toBeSigned, sk);
      return sig;
    }
    exports2.signBytes = signBytes;
    function verifyBytes(bytes, signature, addr) {
      const toBeVerified = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));
      const pk = address.decodeAddress(addr).publicKey;
      return nacl.verify(toBeVerified, signature, pk);
    }
    exports2.verifyBytes = verifyBytes;
    function encodeObj(o) {
      return new Uint8Array(encoding.encode(o));
    }
    exports2.encodeObj = encodeObj;
    function decodeObj(o) {
      return encoding.decode(o);
    }
    exports2.decodeObj = decodeObj;
    exports2.ERROR_MULTISIG_BAD_SENDER = new Error(exports2.MULTISIG_BAD_SENDER_ERROR_MSG);
    exports2.ERROR_INVALID_MICROALGOS = new Error(convert.INVALID_MICROALGOS_ERROR_MSG);
    __exportStar(require_algod(), exports2);
    var algod_1 = require_algod2();
    Object.defineProperty(exports2, "Algodv2", { enumerable: true, get: function() {
      return __importDefault(algod_1).default;
    } });
    var kmd_1 = require_kmd();
    Object.defineProperty(exports2, "Kmd", { enumerable: true, get: function() {
      return __importDefault(kmd_1).default;
    } });
    var intDecoding_1 = require_intDecoding();
    Object.defineProperty(exports2, "IntDecoding", { enumerable: true, get: function() {
      return __importDefault(intDecoding_1).default;
    } });
    var indexer_1 = require_indexer();
    Object.defineProperty(exports2, "Indexer", { enumerable: true, get: function() {
      return __importDefault(indexer_1).default;
    } });
    var wait_1 = require_wait();
    Object.defineProperty(exports2, "waitForConfirmation", { enumerable: true, get: function() {
      return wait_1.waitForConfirmation;
    } });
    var address_1 = require_address();
    Object.defineProperty(exports2, "isValidAddress", { enumerable: true, get: function() {
      return address_1.isValidAddress;
    } });
    Object.defineProperty(exports2, "encodeAddress", { enumerable: true, get: function() {
      return address_1.encodeAddress;
    } });
    Object.defineProperty(exports2, "decodeAddress", { enumerable: true, get: function() {
      return address_1.decodeAddress;
    } });
    Object.defineProperty(exports2, "getApplicationAddress", { enumerable: true, get: function() {
      return address_1.getApplicationAddress;
    } });
    var bigint_1 = require_bigint();
    Object.defineProperty(exports2, "bytesToBigInt", { enumerable: true, get: function() {
      return bigint_1.bytesToBigInt;
    } });
    Object.defineProperty(exports2, "bigIntToBytes", { enumerable: true, get: function() {
      return bigint_1.bigIntToBytes;
    } });
    var uint64_1 = require_uint64();
    Object.defineProperty(exports2, "encodeUint64", { enumerable: true, get: function() {
      return uint64_1.encodeUint64;
    } });
    Object.defineProperty(exports2, "decodeUint64", { enumerable: true, get: function() {
      return uint64_1.decodeUint64;
    } });
    var account_1 = require_account();
    Object.defineProperty(exports2, "generateAccount", { enumerable: true, get: function() {
      return __importDefault(account_1).default;
    } });
    exports2.modelsv2 = __importStar(require_types());
    var mnemonic_1 = require_mnemonic();
    Object.defineProperty(exports2, "mnemonicToMasterDerivationKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToMasterDerivationKey;
    } });
    Object.defineProperty(exports2, "masterDerivationKeyToMnemonic", { enumerable: true, get: function() {
      return mnemonic_1.masterDerivationKeyToMnemonic;
    } });
    Object.defineProperty(exports2, "secretKeyToMnemonic", { enumerable: true, get: function() {
      return mnemonic_1.secretKeyToMnemonic;
    } });
    Object.defineProperty(exports2, "mnemonicToSecretKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToSecretKey;
    } });
    Object.defineProperty(exports2, "seedFromMnemonic", { enumerable: true, get: function() {
      return mnemonic_1.seedFromMnemonic;
    } });
    Object.defineProperty(exports2, "mnemonicFromSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicFromSeed;
    } });
    var convert_1 = require_convert();
    Object.defineProperty(exports2, "microalgosToAlgos", { enumerable: true, get: function() {
      return convert_1.microalgosToAlgos;
    } });
    Object.defineProperty(exports2, "algosToMicroalgos", { enumerable: true, get: function() {
      return convert_1.algosToMicroalgos;
    } });
    Object.defineProperty(exports2, "INVALID_MICROALGOS_ERROR_MSG", { enumerable: true, get: function() {
      return convert_1.INVALID_MICROALGOS_ERROR_MSG;
    } });
    var group_1 = require_group();
    Object.defineProperty(exports2, "computeGroupID", { enumerable: true, get: function() {
      return group_1.computeGroupID;
    } });
    Object.defineProperty(exports2, "assignGroupID", { enumerable: true, get: function() {
      return group_1.assignGroupID;
    } });
    var logicsig_1 = require_logicsig();
    Object.defineProperty(exports2, "LogicSigAccount", { enumerable: true, get: function() {
      return logicsig_1.LogicSigAccount;
    } });
    Object.defineProperty(exports2, "makeLogicSig", { enumerable: true, get: function() {
      return logicsig_1.makeLogicSig;
    } });
    Object.defineProperty(exports2, "signLogicSigTransaction", { enumerable: true, get: function() {
      return logicsig_1.signLogicSigTransaction;
    } });
    Object.defineProperty(exports2, "signLogicSigTransactionObject", { enumerable: true, get: function() {
      return logicsig_1.signLogicSigTransactionObject;
    } });
    Object.defineProperty(exports2, "logicSigFromByte", { enumerable: true, get: function() {
      return logicsig_1.logicSigFromByte;
    } });
    Object.defineProperty(exports2, "tealSign", { enumerable: true, get: function() {
      return logicsig_1.tealSign;
    } });
    Object.defineProperty(exports2, "tealSignFromProgram", { enumerable: true, get: function() {
      return logicsig_1.tealSignFromProgram;
    } });
    var multisig_1 = require_multisig();
    Object.defineProperty(exports2, "signMultisigTransaction", { enumerable: true, get: function() {
      return multisig_1.signMultisigTransaction;
    } });
    Object.defineProperty(exports2, "mergeMultisigTransactions", { enumerable: true, get: function() {
      return multisig_1.mergeMultisigTransactions;
    } });
    Object.defineProperty(exports2, "appendSignMultisigTransaction", { enumerable: true, get: function() {
      return multisig_1.appendSignMultisigTransaction;
    } });
    Object.defineProperty(exports2, "multisigAddress", { enumerable: true, get: function() {
      return multisig_1.multisigAddress;
    } });
    exports2.LogicTemplates = LogicTemplatesCommonJSExport.default;
    __exportStar(require_dryrun2(), exports2);
    __exportStar(require_makeTxn(), exports2);
    __exportStar(require_transaction(), exports2);
    __exportStar(require_signer(), exports2);
    __exportStar(require_composer(), exports2);
    __exportStar(require_types2(), exports2);
    __exportStar(require_abi(), exports2);
  }
});

// node_modules/algosdk/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/algosdk/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var algosdk2 = __importStar(require_main());
    __exportStar(require_main(), exports2);
    exports2.default = algosdk2;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports2, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root2, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root2, createExporter(module2.exports)));
      } else {
        factory(createExporter(root2));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root2) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v) {
          return exports3[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLocalStorage = exports2.getLocalStorageOrThrow = exports2.getCrypto = exports2.getCryptoOrThrow = exports2.getLocation = exports2.getLocationOrThrow = exports2.getNavigator = exports2.getNavigatorOrThrow = exports2.getDocument = exports2.getDocumentOrThrow = exports2.getFromWindowOrThrow = exports2.getFromWindow = void 0;
    function getFromWindow(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports2.getFromWindow = getFromWindow;
    function getFromWindowOrThrow(name) {
      const res = getFromWindow(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports2.getFromWindowOrThrow = getFromWindowOrThrow;
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    exports2.getDocumentOrThrow = getDocumentOrThrow;
    function getDocument() {
      return getFromWindow("document");
    }
    exports2.getDocument = getDocument;
    function getNavigatorOrThrow() {
      return getFromWindowOrThrow("navigator");
    }
    exports2.getNavigatorOrThrow = getNavigatorOrThrow;
    function getNavigator() {
      return getFromWindow("navigator");
    }
    exports2.getNavigator = getNavigator;
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    exports2.getLocationOrThrow = getLocationOrThrow;
    function getLocation() {
      return getFromWindow("location");
    }
    exports2.getLocation = getLocation;
    function getCryptoOrThrow() {
      return getFromWindowOrThrow("crypto");
    }
    exports2.getCryptoOrThrow = getCryptoOrThrow;
    function getCrypto() {
      return getFromWindow("crypto");
    }
    exports2.getCrypto = getCrypto;
    function getLocalStorageOrThrow() {
      return getFromWindowOrThrow("localStorage");
    }
    exports2.getLocalStorageOrThrow = getLocalStorageOrThrow;
    function getLocalStorage() {
      return getFromWindow("localStorage");
    }
    exports2.getLocalStorage = getLocalStorage;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs2();
    function getWindowMetadata() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i = 0; i < links.length; i++) {
          const link = links[i];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i = 0; i < metaTags.length; i++) {
          const tag = metaTags[i];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name
      };
      return meta;
    }
    exports2.getWindowMetadata = getWindowMetadata;
  }
});

// node_modules/detect-browser/index.js
var require_detect_browser = __commonJS({
  "node_modules/detect-browser/index.js"(exports2) {
    "use strict";
    var __spreadArrays = exports2 && exports2.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var BrowserInfo = function() {
      function BrowserInfo2(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = "browser";
      }
      return BrowserInfo2;
    }();
    exports2.BrowserInfo = BrowserInfo;
    var NodeInfo = function() {
      function NodeInfo2(version) {
        this.version = version;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    }();
    exports2.NodeInfo = NodeInfo;
    var SearchBotDeviceInfo = function() {
      function SearchBotDeviceInfo2(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    }();
    exports2.SearchBotDeviceInfo = SearchBotDeviceInfo;
    var BotInfo = function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    }();
    exports2.BotInfo = BotInfo;
    var ReactNativeInfo = function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    }();
    exports2.ReactNativeInfo = ReactNativeInfo;
    var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    var REQUIRED_VERSION_PARTS = 3;
    var userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FBAV\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    var operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
    function detect(userAgent) {
      if (!!userAgent) {
        return parseUserAgent(userAgent);
      }
      if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
        return new ReactNativeInfo();
      }
      if (typeof navigator !== "undefined") {
        return parseUserAgent(navigator.userAgent);
      }
      return getNodeVersion();
    }
    exports2.detect = detect;
    function matchUserAgent(ua) {
      return ua !== "" && userAgentRules.reduce(function(matched, _a) {
        var browser = _a[0], regex = _a[1];
        if (matched) {
          return matched;
        }
        var uaMatch = regex.exec(ua);
        return !!uaMatch && [browser, uaMatch];
      }, false);
    }
    function browserName(ua) {
      var data = matchUserAgent(ua);
      return data ? data[0] : null;
    }
    exports2.browserName = browserName;
    function parseUserAgent(ua) {
      var matchedRule = matchUserAgent(ua);
      if (!matchedRule) {
        return null;
      }
      var name = matchedRule[0], match = matchedRule[1];
      if (name === "searchbot") {
        return new BotInfo();
      }
      var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
      if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
          versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
        }
      } else {
        versionParts = [];
      }
      var version = versionParts.join(".");
      var os = detectOS(ua);
      var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
      if (searchBotMatch && searchBotMatch[1]) {
        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
      }
      return new BrowserInfo(name, version, os);
    }
    exports2.parseUserAgent = parseUserAgent;
    function detectOS(ua) {
      for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) {
          return os;
        }
      }
      return null;
    }
    exports2.detectOS = detectOS;
    function getNodeVersion() {
      var isNode = typeof process !== "undefined" && process.version;
      return isNode ? new NodeInfo(process.version.slice(1)) : null;
    }
    exports2.getNodeVersion = getNodeVersion;
    function createVersionParts(count) {
      var output = [];
      for (var ii = 0; ii < count; ii++) {
        output.push("0");
      }
      return output;
    }
  }
});

// node_modules/@walletconnect/browser-utils/dist/cjs/browser.js
var require_browser2 = __commonJS({
  "node_modules/@walletconnect/browser-utils/dist/cjs/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getClientMeta = exports2.getLocalStorage = exports2.getLocalStorageOrThrow = exports2.getCrypto = exports2.getCryptoOrThrow = exports2.getLocation = exports2.getLocationOrThrow = exports2.getNavigator = exports2.getNavigatorOrThrow = exports2.getDocument = exports2.getDocumentOrThrow = exports2.getFromWindowOrThrow = exports2.getFromWindow = exports2.isBrowser = exports2.isNode = exports2.isMobile = exports2.isIOS = exports2.isAndroid = exports2.detectOS = exports2.detectEnv = void 0;
    var tslib_1 = require_tslib();
    var windowMetadata = tslib_1.__importStar(require_cjs3());
    var windowGetters = tslib_1.__importStar(require_cjs2());
    var detect_browser_1 = require_detect_browser();
    function detectEnv(userAgent) {
      return (0, detect_browser_1.detect)(userAgent);
    }
    exports2.detectEnv = detectEnv;
    function detectOS() {
      const env = detectEnv();
      return env && env.os ? env.os : void 0;
    }
    exports2.detectOS = detectOS;
    function isAndroid() {
      const os = detectOS();
      return os ? os.toLowerCase().includes("android") : false;
    }
    exports2.isAndroid = isAndroid;
    function isIOS() {
      const os = detectOS();
      return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
    }
    exports2.isIOS = isIOS;
    function isMobile() {
      const os = detectOS();
      return os ? isAndroid() || isIOS() : false;
    }
    exports2.isMobile = isMobile;
    function isNode() {
      const env = detectEnv();
      const result = env && env.name ? env.name.toLowerCase() === "node" : false;
      return result;
    }
    exports2.isNode = isNode;
    function isBrowser() {
      const result = !isNode() && !!(0, exports2.getNavigator)();
      return result;
    }
    exports2.isBrowser = isBrowser;
    exports2.getFromWindow = windowGetters.getFromWindow;
    exports2.getFromWindowOrThrow = windowGetters.getFromWindowOrThrow;
    exports2.getDocumentOrThrow = windowGetters.getDocumentOrThrow;
    exports2.getDocument = windowGetters.getDocument;
    exports2.getNavigatorOrThrow = windowGetters.getNavigatorOrThrow;
    exports2.getNavigator = windowGetters.getNavigator;
    exports2.getLocationOrThrow = windowGetters.getLocationOrThrow;
    exports2.getLocation = windowGetters.getLocation;
    exports2.getCryptoOrThrow = windowGetters.getCryptoOrThrow;
    exports2.getCrypto = windowGetters.getCrypto;
    exports2.getLocalStorageOrThrow = windowGetters.getLocalStorageOrThrow;
    exports2.getLocalStorage = windowGetters.getLocalStorage;
    function getClientMeta() {
      return windowMetadata.getWindowMetadata();
    }
    exports2.getClientMeta = getClientMeta;
  }
});

// node_modules/@walletconnect/safe-json/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/safe-json/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.safeJsonStringify = exports2.safeJsonParse = void 0;
    function safeJsonParse(value) {
      if (typeof value !== "string") {
        throw new Error(`Cannot safe json parse value of type ${typeof value}`);
      }
      try {
        return JSON.parse(value);
      } catch (_a) {
        return value;
      }
    }
    exports2.safeJsonParse = safeJsonParse;
    function safeJsonStringify(value) {
      return typeof value === "string" ? value : JSON.stringify(value);
    }
    exports2.safeJsonStringify = safeJsonStringify;
  }
});

// node_modules/@walletconnect/browser-utils/dist/cjs/json.js
var require_json2 = __commonJS({
  "node_modules/@walletconnect/browser-utils/dist/cjs/json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.safeJsonStringify = exports2.safeJsonParse = void 0;
    var tslib_1 = require_tslib();
    var safeJson = tslib_1.__importStar(require_cjs4());
    exports2.safeJsonParse = safeJson.safeJsonParse;
    exports2.safeJsonStringify = safeJson.safeJsonStringify;
  }
});

// node_modules/@walletconnect/browser-utils/dist/cjs/local.js
var require_local = __commonJS({
  "node_modules/@walletconnect/browser-utils/dist/cjs/local.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeLocal = exports2.getLocal = exports2.setLocal = void 0;
    var json_1 = require_json2();
    var browser_1 = require_browser2();
    function setLocal(key, data) {
      const raw = (0, json_1.safeJsonStringify)(data);
      const local = (0, browser_1.getLocalStorage)();
      if (local) {
        local.setItem(key, raw);
      }
    }
    exports2.setLocal = setLocal;
    function getLocal(key) {
      let data = null;
      let raw = null;
      const local = (0, browser_1.getLocalStorage)();
      if (local) {
        raw = local.getItem(key);
      }
      data = raw ? (0, json_1.safeJsonParse)(raw) : raw;
      return data;
    }
    exports2.getLocal = getLocal;
    function removeLocal(key) {
      const local = (0, browser_1.getLocalStorage)();
      if (local) {
        local.removeItem(key);
      }
    }
    exports2.removeLocal = removeLocal;
  }
});

// node_modules/@walletconnect/browser-utils/dist/cjs/mobile.js
var require_mobile = __commonJS({
  "node_modules/@walletconnect/browser-utils/dist/cjs/mobile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMobileLinkRegistry = exports2.getMobileRegistryEntry = exports2.saveMobileLinkInfo = exports2.formatIOSMobile = exports2.mobileLinkChoiceKey = void 0;
    var local_1 = require_local();
    exports2.mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
    function formatIOSMobile(uri, entry) {
      const encodedUri = encodeURIComponent(uri);
      return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
    }
    exports2.formatIOSMobile = formatIOSMobile;
    function saveMobileLinkInfo(data) {
      const focusUri = data.href.split("?")[0];
      (0, local_1.setLocal)(exports2.mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
    }
    exports2.saveMobileLinkInfo = saveMobileLinkInfo;
    function getMobileRegistryEntry(registry, name) {
      return registry.filter((entry) => entry.name.toLowerCase().includes(name.toLowerCase()))[0];
    }
    exports2.getMobileRegistryEntry = getMobileRegistryEntry;
    function getMobileLinkRegistry(registry, whitelist) {
      let links = registry;
      if (whitelist) {
        links = whitelist.map((name) => getMobileRegistryEntry(registry, name)).filter(Boolean);
      }
      return links;
    }
    exports2.getMobileLinkRegistry = getMobileLinkRegistry;
  }
});

// node_modules/@walletconnect/browser-utils/dist/cjs/registry.js
var require_registry = __commonJS({
  "node_modules/@walletconnect/browser-utils/dist/cjs/registry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatMobileRegistry = exports2.formatMobileRegistryEntry = exports2.getDappRegistryUrl = exports2.getWalletRegistryUrl = void 0;
    var API_URL = "https://registry.walletconnect.com";
    function getWalletRegistryUrl() {
      return API_URL + "/api/v2/wallets";
    }
    exports2.getWalletRegistryUrl = getWalletRegistryUrl;
    function getDappRegistryUrl() {
      return API_URL + "/api/v2/dapps";
    }
    exports2.getDappRegistryUrl = getDappRegistryUrl;
    function formatMobileRegistryEntry(entry, platform = "mobile") {
      var _a;
      return {
        name: entry.name || "",
        shortName: entry.metadata.shortName || "",
        color: entry.metadata.colors.primary || "",
        logo: (_a = entry.image_url.sm) !== null && _a !== void 0 ? _a : "",
        universalLink: entry[platform].universal || "",
        deepLink: entry[platform].native || ""
      };
    }
    exports2.formatMobileRegistryEntry = formatMobileRegistryEntry;
    function formatMobileRegistry(registry, platform = "mobile") {
      return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
    }
    exports2.formatMobileRegistry = formatMobileRegistry;
  }
});

// node_modules/@walletconnect/browser-utils/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@walletconnect/browser-utils/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_browser2(), exports2);
    tslib_1.__exportStar(require_json2(), exports2);
    tslib_1.__exportStar(require_local(), exports2);
    tslib_1.__exportStar(require_mobile(), exports2);
    tslib_1.__exportStar(require_registry(), exports2);
  }
});

// node_modules/@walletconnect/utils/dist/cjs/constants.js
var require_constants2 = __commonJS({
  "node_modules/@walletconnect/utils/dist/cjs/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.infuraNetworks = exports2.stateMethods = exports2.signingMethods = exports2.reservedEvents = void 0;
    exports2.reservedEvents = [
      "session_request",
      "session_update",
      "exchange_key",
      "connect",
      "disconnect",
      "display_uri",
      "modal_closed",
      "transport_open",
      "transport_close",
      "transport_error"
    ];
    exports2.signingMethods = [
      "eth_sendTransaction",
      "eth_signTransaction",
      "eth_sign",
      "eth_signTypedData",
      "eth_signTypedData_v1",
      "eth_signTypedData_v2",
      "eth_signTypedData_v3",
      "eth_signTypedData_v4",
      "personal_sign",
      "wallet_addEthereumChain",
      "wallet_switchEthereumChain",
      "wallet_getPermissions",
      "wallet_requestPermissions",
      "wallet_registerOnboarding",
      "wallet_watchAsset",
      "wallet_scanQRCode"
    ];
    exports2.stateMethods = ["eth_accounts", "eth_chainId", "net_version"];
    exports2.infuraNetworks = {
      1: "mainnet",
      3: "ropsten",
      4: "rinkeby",
      5: "goerli",
      42: "kovan"
    };
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer3;
      try {
        Buffer3 = require("buffer").Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports2, module2) {
    module2.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports2, module2) {
    var isTypedArray = require_is_typedarray().strict;
    module2.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/@walletconnect/encoding/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@walletconnect/encoding/dist/cjs/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeHexLeadingZeros = exports2.sanitizeHex = exports2.addHexPrefix = exports2.removeHexPrefix = exports2.padRight = exports2.padLeft = exports2.sanitizeBytes = exports2.swapHex = exports2.swapBytes = exports2.splitBytes = exports2.calcByteLength = exports2.trimRight = exports2.trimLeft = exports2.concatArrays = exports2.concatBuffers = exports2.getEncoding = exports2.getType = exports2.isArrayBuffer = exports2.isTypedArray = exports2.isBuffer = exports2.isHexString = exports2.isBinaryString = exports2.binaryToNumber = exports2.binaryToUtf8 = exports2.binaryToHex = exports2.binaryToArray = exports2.binaryToBuffer = exports2.numberToBinary = exports2.numberToUtf8 = exports2.numberToHex = exports2.numberToArray = exports2.numberToBuffer = exports2.utf8ToBinary = exports2.utf8ToNumber = exports2.utf8ToHex = exports2.utf8ToArray = exports2.utf8ToBuffer = exports2.hexToBinary = exports2.hexToNumber = exports2.hexToUtf8 = exports2.hexToArray = exports2.hexToBuffer = exports2.arrayToBinary = exports2.arrayToNumber = exports2.arrayToUtf8 = exports2.arrayToHex = exports2.arrayToBuffer = exports2.bufferToBinary = exports2.bufferToNumber = exports2.bufferToUtf8 = exports2.bufferToHex = exports2.bufferToArray = void 0;
    var is_typedarray_1 = __importDefault(require_is_typedarray());
    var typedarray_to_buffer_1 = __importDefault(require_typedarray_to_buffer());
    var ENC_HEX = "hex";
    var ENC_UTF8 = "utf8";
    var ENC_BIN = "binary";
    var TYPE_BUFFER = "buffer";
    var TYPE_ARRAY = "array";
    var TYPE_TYPED_ARRAY = "typed-array";
    var TYPE_ARRAY_BUFFER = "array-buffer";
    var STRING_ZERO = "0";
    function bufferToArray(buf) {
      return new Uint8Array(buf);
    }
    exports2.bufferToArray = bufferToArray;
    function bufferToHex(buf, prefixed = false) {
      const hex = buf.toString(ENC_HEX);
      return prefixed ? addHexPrefix(hex) : hex;
    }
    exports2.bufferToHex = bufferToHex;
    function bufferToUtf8(buf) {
      return buf.toString(ENC_UTF8);
    }
    exports2.bufferToUtf8 = bufferToUtf8;
    function bufferToNumber(buf) {
      return buf.readUIntBE(0, buf.length);
    }
    exports2.bufferToNumber = bufferToNumber;
    function bufferToBinary(buf) {
      return arrayToBinary(bufferToArray(buf));
    }
    exports2.bufferToBinary = bufferToBinary;
    function arrayToBuffer(arr) {
      return typedarray_to_buffer_1.default(arr);
    }
    exports2.arrayToBuffer = arrayToBuffer;
    function arrayToHex(arr, prefixed = false) {
      return bufferToHex(arrayToBuffer(arr), prefixed);
    }
    exports2.arrayToHex = arrayToHex;
    function arrayToUtf8(arr) {
      return bufferToUtf8(arrayToBuffer(arr));
    }
    exports2.arrayToUtf8 = arrayToUtf8;
    function arrayToNumber(arr) {
      return bufferToNumber(arrayToBuffer(arr));
    }
    exports2.arrayToNumber = arrayToNumber;
    function arrayToBinary(arr) {
      return Array.from(arr).map(numberToBinary).join("");
    }
    exports2.arrayToBinary = arrayToBinary;
    function hexToBuffer(hex) {
      return Buffer.from(removeHexPrefix(hex), ENC_HEX);
    }
    exports2.hexToBuffer = hexToBuffer;
    function hexToArray(hex) {
      return bufferToArray(hexToBuffer(hex));
    }
    exports2.hexToArray = hexToArray;
    function hexToUtf8(hex) {
      return bufferToUtf8(hexToBuffer(hex));
    }
    exports2.hexToUtf8 = hexToUtf8;
    function hexToNumber(hex) {
      return arrayToNumber(hexToArray(hex));
    }
    exports2.hexToNumber = hexToNumber;
    function hexToBinary(hex) {
      return arrayToBinary(hexToArray(hex));
    }
    exports2.hexToBinary = hexToBinary;
    function utf8ToBuffer(utf8) {
      return Buffer.from(utf8, ENC_UTF8);
    }
    exports2.utf8ToBuffer = utf8ToBuffer;
    function utf8ToArray(utf8) {
      return bufferToArray(utf8ToBuffer(utf8));
    }
    exports2.utf8ToArray = utf8ToArray;
    function utf8ToHex(utf8, prefixed = false) {
      return bufferToHex(utf8ToBuffer(utf8), prefixed);
    }
    exports2.utf8ToHex = utf8ToHex;
    function utf8ToNumber(utf8) {
      const num = parseInt(utf8, 10);
      assert(isDefined(num), "Number can only safely store up to 53 bits");
      return num;
    }
    exports2.utf8ToNumber = utf8ToNumber;
    function utf8ToBinary(utf8) {
      return arrayToBinary(utf8ToArray(utf8));
    }
    exports2.utf8ToBinary = utf8ToBinary;
    function numberToBuffer(num) {
      return binaryToBuffer(numberToBinary(num));
    }
    exports2.numberToBuffer = numberToBuffer;
    function numberToArray(num) {
      return binaryToArray(numberToBinary(num));
    }
    exports2.numberToArray = numberToArray;
    function numberToHex(num, prefixed) {
      return binaryToHex(numberToBinary(num), prefixed);
    }
    exports2.numberToHex = numberToHex;
    function numberToUtf8(num) {
      return `${num}`;
    }
    exports2.numberToUtf8 = numberToUtf8;
    function numberToBinary(num) {
      const bin = (num >>> 0).toString(2);
      return sanitizeBytes(bin);
    }
    exports2.numberToBinary = numberToBinary;
    function binaryToBuffer(bin) {
      return arrayToBuffer(binaryToArray(bin));
    }
    exports2.binaryToBuffer = binaryToBuffer;
    function binaryToArray(bin) {
      return new Uint8Array(splitBytes(bin).map((x) => parseInt(x, 2)));
    }
    exports2.binaryToArray = binaryToArray;
    function binaryToHex(bin, prefixed) {
      return arrayToHex(binaryToArray(bin), prefixed);
    }
    exports2.binaryToHex = binaryToHex;
    function binaryToUtf8(bin) {
      return arrayToUtf8(binaryToArray(bin));
    }
    exports2.binaryToUtf8 = binaryToUtf8;
    function binaryToNumber(bin) {
      return arrayToNumber(binaryToArray(bin));
    }
    exports2.binaryToNumber = binaryToNumber;
    function isBinaryString(str) {
      if (typeof str !== "string" || !new RegExp(/^[01]+$/).test(str)) {
        return false;
      }
      if (str.length % 8 !== 0) {
        return false;
      }
      return true;
    }
    exports2.isBinaryString = isBinaryString;
    function isHexString(str, length) {
      if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length && str.length !== 2 + 2 * length) {
        return false;
      }
      return true;
    }
    exports2.isHexString = isHexString;
    function isBuffer(val) {
      return Buffer.isBuffer(val);
    }
    exports2.isBuffer = isBuffer;
    function isTypedArray(val) {
      return is_typedarray_1.default.strict(val) && !isBuffer(val);
    }
    exports2.isTypedArray = isTypedArray;
    function isArrayBuffer(val) {
      return !isTypedArray(val) && !isBuffer(val) && typeof val.byteLength !== "undefined";
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function getType(val) {
      if (isBuffer(val)) {
        return TYPE_BUFFER;
      } else if (isTypedArray(val)) {
        return TYPE_TYPED_ARRAY;
      } else if (isArrayBuffer(val)) {
        return TYPE_ARRAY_BUFFER;
      } else if (Array.isArray(val)) {
        return TYPE_ARRAY;
      } else {
        return typeof val;
      }
    }
    exports2.getType = getType;
    function getEncoding(str) {
      if (isBinaryString(str)) {
        return ENC_BIN;
      }
      if (isHexString(str)) {
        return ENC_HEX;
      }
      return ENC_UTF8;
    }
    exports2.getEncoding = getEncoding;
    function concatBuffers(...args) {
      const result = Buffer.concat(args);
      return result;
    }
    exports2.concatBuffers = concatBuffers;
    function concatArrays(...args) {
      let result = [];
      args.forEach((arg) => result = result.concat(Array.from(arg)));
      return new Uint8Array([...result]);
    }
    exports2.concatArrays = concatArrays;
    function trimLeft(data, length) {
      const diff = data.length - length;
      if (diff > 0) {
        data = data.slice(diff);
      }
      return data;
    }
    exports2.trimLeft = trimLeft;
    function trimRight(data, length) {
      return data.slice(0, length);
    }
    exports2.trimRight = trimRight;
    function calcByteLength(length, byteSize = 8) {
      const remainder = length % byteSize;
      return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
    }
    exports2.calcByteLength = calcByteLength;
    function splitBytes(str, byteSize = 8) {
      const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, "gi"));
      return Array.from(bytes || []);
    }
    exports2.splitBytes = splitBytes;
    function swapBytes(str) {
      return splitBytes(str).map(reverseString).join("");
    }
    exports2.swapBytes = swapBytes;
    function swapHex(str) {
      return binaryToHex(swapBytes(hexToBinary(str)));
    }
    exports2.swapHex = swapHex;
    function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
      return padLeft(str, calcByteLength(str.length, byteSize), padding);
    }
    exports2.sanitizeBytes = sanitizeBytes;
    function padLeft(str, length, padding = STRING_ZERO) {
      return padString(str, length, true, padding);
    }
    exports2.padLeft = padLeft;
    function padRight(str, length, padding = STRING_ZERO) {
      return padString(str, length, false, padding);
    }
    exports2.padRight = padRight;
    function removeHexPrefix(hex) {
      return hex.replace(/^0x/, "");
    }
    exports2.removeHexPrefix = removeHexPrefix;
    function addHexPrefix(hex) {
      return hex.startsWith("0x") ? hex : `0x${hex}`;
    }
    exports2.addHexPrefix = addHexPrefix;
    function sanitizeHex(hex) {
      hex = removeHexPrefix(hex);
      hex = sanitizeBytes(hex, 2);
      if (hex) {
        hex = addHexPrefix(hex);
      }
      return hex;
    }
    exports2.sanitizeHex = sanitizeHex;
    function removeHexLeadingZeros(hex) {
      const prefixed = hex.startsWith("0x");
      hex = removeHexPrefix(hex);
      hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
      return prefixed ? addHexPrefix(hex) : hex;
    }
    exports2.removeHexLeadingZeros = removeHexLeadingZeros;
    function isUndefined(value) {
      return typeof value === "undefined";
    }
    function isDefined(value) {
      return !isUndefined(value);
    }
    function assert(assertion, errorMessage) {
      if (!assertion) {
        throw new Error(errorMessage);
      }
    }
    function reverseString(str) {
      return str.split("").reverse().join("");
    }
    function padString(str, length, left, padding = STRING_ZERO) {
      const diff = length - str.length;
      let result = str;
      if (diff > 0) {
        const pad = padding.repeat(diff);
        result = left ? pad + str : str + pad;
      }
      return result;
    }
  }
});

// node_modules/@walletconnect/utils/dist/cjs/encoding.js
var require_encoding2 = __commonJS({
  "node_modules/@walletconnect/utils/dist/cjs/encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertNumberToHex = exports2.convertNumberToUtf8 = exports2.convertNumberToArrayBuffer = exports2.convertNumberToBuffer = exports2.convertHexToNumber = exports2.convertHexToUtf8 = exports2.convertHexToArrayBuffer = exports2.convertHexToBuffer = exports2.convertUtf8ToNumber = exports2.convertUtf8ToHex = exports2.convertUtf8ToBuffer = exports2.convertUtf8ToArrayBuffer = exports2.concatBuffers = exports2.convertBufferToNumber = exports2.convertBufferToHex = exports2.convertBufferToUtf8 = exports2.convertBufferToArrayBuffer = exports2.concatArrayBuffers = exports2.convertArrayBufferToNumber = exports2.convertArrayBufferToHex = exports2.convertArrayBufferToUtf8 = exports2.convertArrayBufferToBuffer = void 0;
    var tslib_1 = require_tslib();
    var bn_js_1 = tslib_1.__importDefault(require_bn());
    var encoding = tslib_1.__importStar(require_cjs6());
    function convertArrayBufferToBuffer(arrBuf) {
      return encoding.arrayToBuffer(new Uint8Array(arrBuf));
    }
    exports2.convertArrayBufferToBuffer = convertArrayBufferToBuffer;
    function convertArrayBufferToUtf8(arrBuf) {
      return encoding.arrayToUtf8(new Uint8Array(arrBuf));
    }
    exports2.convertArrayBufferToUtf8 = convertArrayBufferToUtf8;
    function convertArrayBufferToHex(arrBuf, noPrefix) {
      return encoding.arrayToHex(new Uint8Array(arrBuf), !noPrefix);
    }
    exports2.convertArrayBufferToHex = convertArrayBufferToHex;
    function convertArrayBufferToNumber(arrBuf) {
      return encoding.arrayToNumber(new Uint8Array(arrBuf));
    }
    exports2.convertArrayBufferToNumber = convertArrayBufferToNumber;
    function concatArrayBuffers(...args) {
      return encoding.hexToArray(args.map((b) => encoding.arrayToHex(new Uint8Array(b))).join("")).buffer;
    }
    exports2.concatArrayBuffers = concatArrayBuffers;
    function convertBufferToArrayBuffer(buf) {
      return encoding.bufferToArray(buf).buffer;
    }
    exports2.convertBufferToArrayBuffer = convertBufferToArrayBuffer;
    function convertBufferToUtf8(buf) {
      return encoding.bufferToUtf8(buf);
    }
    exports2.convertBufferToUtf8 = convertBufferToUtf8;
    function convertBufferToHex(buf, noPrefix) {
      return encoding.bufferToHex(buf, !noPrefix);
    }
    exports2.convertBufferToHex = convertBufferToHex;
    function convertBufferToNumber(buf) {
      return encoding.bufferToNumber(buf);
    }
    exports2.convertBufferToNumber = convertBufferToNumber;
    function concatBuffers(...args) {
      return encoding.concatBuffers(...args);
    }
    exports2.concatBuffers = concatBuffers;
    function convertUtf8ToArrayBuffer(utf8) {
      return encoding.utf8ToArray(utf8).buffer;
    }
    exports2.convertUtf8ToArrayBuffer = convertUtf8ToArrayBuffer;
    function convertUtf8ToBuffer(utf8) {
      return encoding.utf8ToBuffer(utf8);
    }
    exports2.convertUtf8ToBuffer = convertUtf8ToBuffer;
    function convertUtf8ToHex(utf8, noPrefix) {
      return encoding.utf8ToHex(utf8, !noPrefix);
    }
    exports2.convertUtf8ToHex = convertUtf8ToHex;
    function convertUtf8ToNumber(utf8) {
      return new bn_js_1.default(utf8, 10).toNumber();
    }
    exports2.convertUtf8ToNumber = convertUtf8ToNumber;
    function convertHexToBuffer(hex) {
      return encoding.hexToBuffer(hex);
    }
    exports2.convertHexToBuffer = convertHexToBuffer;
    function convertHexToArrayBuffer(hex) {
      return encoding.hexToArray(hex).buffer;
    }
    exports2.convertHexToArrayBuffer = convertHexToArrayBuffer;
    function convertHexToUtf8(hex) {
      return encoding.hexToUtf8(hex);
    }
    exports2.convertHexToUtf8 = convertHexToUtf8;
    function convertHexToNumber(hex) {
      return new bn_js_1.default(encoding.removeHexPrefix(hex), "hex").toNumber();
    }
    exports2.convertHexToNumber = convertHexToNumber;
    function convertNumberToBuffer(num) {
      return encoding.numberToBuffer(num);
    }
    exports2.convertNumberToBuffer = convertNumberToBuffer;
    function convertNumberToArrayBuffer(num) {
      return encoding.numberToArray(num).buffer;
    }
    exports2.convertNumberToArrayBuffer = convertNumberToArrayBuffer;
    function convertNumberToUtf8(num) {
      return new bn_js_1.default(num).toString();
    }
    exports2.convertNumberToUtf8 = convertNumberToUtf8;
    function convertNumberToHex(num, noPrefix) {
      const hex = encoding.removeHexPrefix(encoding.sanitizeHex(new bn_js_1.default(num).toString(16)));
      return noPrefix ? hex : encoding.addHexPrefix(hex);
    }
    exports2.convertNumberToHex = convertNumberToHex;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/cjs/constants.js
var require_constants3 = __commonJS({
  "node_modules/@walletconnect/jsonrpc-utils/dist/cjs/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.STANDARD_ERROR_MAP = exports2.SERVER_ERROR_CODE_RANGE = exports2.RESERVED_ERROR_CODES = exports2.SERVER_ERROR = exports2.INTERNAL_ERROR = exports2.INVALID_PARAMS = exports2.METHOD_NOT_FOUND = exports2.INVALID_REQUEST = exports2.PARSE_ERROR = void 0;
    exports2.PARSE_ERROR = "PARSE_ERROR";
    exports2.INVALID_REQUEST = "INVALID_REQUEST";
    exports2.METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
    exports2.INVALID_PARAMS = "INVALID_PARAMS";
    exports2.INTERNAL_ERROR = "INTERNAL_ERROR";
    exports2.SERVER_ERROR = "SERVER_ERROR";
    exports2.RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
    exports2.SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
    exports2.STANDARD_ERROR_MAP = {
      [exports2.PARSE_ERROR]: { code: -32700, message: "Parse error" },
      [exports2.INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
      [exports2.METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
      [exports2.INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
      [exports2.INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
      [exports2.SERVER_ERROR]: { code: -32e3, message: "Server error" }
    };
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/cjs/error.js
var require_error = __commonJS({
  "node_modules/@walletconnect/jsonrpc-utils/dist/cjs/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseConnectionError = exports2.validateJsonRpcError = exports2.getErrorByCode = exports2.getError = exports2.isValidErrorCode = exports2.isReservedErrorCode = exports2.isServerErrorCode = void 0;
    var constants_1 = require_constants3();
    function isServerErrorCode(code) {
      return code <= constants_1.SERVER_ERROR_CODE_RANGE[0] && code >= constants_1.SERVER_ERROR_CODE_RANGE[1];
    }
    exports2.isServerErrorCode = isServerErrorCode;
    function isReservedErrorCode(code) {
      return constants_1.RESERVED_ERROR_CODES.includes(code);
    }
    exports2.isReservedErrorCode = isReservedErrorCode;
    function isValidErrorCode(code) {
      return typeof code === "number";
    }
    exports2.isValidErrorCode = isValidErrorCode;
    function getError(type) {
      if (!Object.keys(constants_1.STANDARD_ERROR_MAP).includes(type)) {
        return constants_1.STANDARD_ERROR_MAP[constants_1.INTERNAL_ERROR];
      }
      return constants_1.STANDARD_ERROR_MAP[type];
    }
    exports2.getError = getError;
    function getErrorByCode(code) {
      const match = Object.values(constants_1.STANDARD_ERROR_MAP).find((e) => e.code === code);
      if (!match) {
        return constants_1.STANDARD_ERROR_MAP[constants_1.INTERNAL_ERROR];
      }
      return match;
    }
    exports2.getErrorByCode = getErrorByCode;
    function validateJsonRpcError(response) {
      if (typeof response.error.code === "undefined") {
        return { valid: false, error: "Missing code for JSON-RPC error" };
      }
      if (typeof response.error.message === "undefined") {
        return { valid: false, error: "Missing message for JSON-RPC error" };
      }
      if (!isValidErrorCode(response.error.code)) {
        return {
          valid: false,
          error: `Invalid error code type for JSON-RPC: ${response.error.code}`
        };
      }
      if (isReservedErrorCode(response.error.code)) {
        const error = getErrorByCode(response.error.code);
        if (error.message !== constants_1.STANDARD_ERROR_MAP[constants_1.INTERNAL_ERROR].message && response.error.message === error.message) {
          return {
            valid: false,
            error: `Invalid error code message for JSON-RPC: ${response.error.code}`
          };
        }
      }
      return { valid: true };
    }
    exports2.validateJsonRpcError = validateJsonRpcError;
    function parseConnectionError(e, url, type) {
      return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e;
    }
    exports2.parseConnectionError = parseConnectionError;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowserCryptoAvailable = exports2.getSubtleCrypto = exports2.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports2.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports2.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports2.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowser = exports2.isNode = exports2.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports2.isReactNative = isReactNative;
    function isNode() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports2.isNode = isNode;
    function isBrowser() {
      return !isReactNative() && !isNode();
    }
    exports2.isBrowser = isBrowser;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs7 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !exports3.hasOwnProperty(p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_crypto(), exports2);
    __exportStar(require_env(), exports2);
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/cjs/env.js
var require_env2 = __commonJS({
  "node_modules/@walletconnect/jsonrpc-utils/dist/cjs/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNodeJs = void 0;
    var tslib_1 = require_tslib();
    var environment_1 = require_cjs7();
    exports2.isNodeJs = environment_1.isNode;
    tslib_1.__exportStar(require_cjs7(), exports2);
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/cjs/format.js
var require_format = __commonJS({
  "node_modules/@walletconnect/jsonrpc-utils/dist/cjs/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatErrorMessage = exports2.formatJsonRpcError = exports2.formatJsonRpcResult = exports2.formatJsonRpcRequest = exports2.payloadId = void 0;
    var error_1 = require_error();
    var constants_1 = require_constants3();
    function payloadId() {
      const date = Date.now() * Math.pow(10, 3);
      const extra = Math.floor(Math.random() * Math.pow(10, 3));
      return date + extra;
    }
    exports2.payloadId = payloadId;
    function formatJsonRpcRequest2(method2, params, id) {
      return {
        id: id || payloadId(),
        jsonrpc: "2.0",
        method: method2,
        params
      };
    }
    exports2.formatJsonRpcRequest = formatJsonRpcRequest2;
    function formatJsonRpcResult(id, result) {
      return {
        id,
        jsonrpc: "2.0",
        result
      };
    }
    exports2.formatJsonRpcResult = formatJsonRpcResult;
    function formatJsonRpcError(id, error) {
      return {
        id,
        jsonrpc: "2.0",
        error: formatErrorMessage(error)
      };
    }
    exports2.formatJsonRpcError = formatJsonRpcError;
    function formatErrorMessage(error) {
      if (typeof error === "undefined") {
        return error_1.getError(constants_1.INTERNAL_ERROR);
      }
      if (typeof error === "string") {
        error = Object.assign(Object.assign({}, error_1.getError(constants_1.SERVER_ERROR)), { message: error });
      }
      if (error_1.isReservedErrorCode(error.code)) {
        error = error_1.getErrorByCode(error.code);
      }
      return error;
    }
    exports2.formatErrorMessage = formatErrorMessage;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/cjs/routing.js
var require_routing = __commonJS({
  "node_modules/@walletconnect/jsonrpc-utils/dist/cjs/routing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidTrailingWildcardRoute = exports2.isValidLeadingWildcardRoute = exports2.isValidWildcardRoute = exports2.isValidDefaultRoute = exports2.isValidRoute = void 0;
    function isValidRoute(route) {
      if (route.includes("*")) {
        return isValidWildcardRoute(route);
      }
      if (/\W/g.test(route)) {
        return false;
      }
      return true;
    }
    exports2.isValidRoute = isValidRoute;
    function isValidDefaultRoute(route) {
      return route === "*";
    }
    exports2.isValidDefaultRoute = isValidDefaultRoute;
    function isValidWildcardRoute(route) {
      if (isValidDefaultRoute(route)) {
        return true;
      }
      if (!route.includes("*")) {
        return false;
      }
      if (route.split("*").length !== 2) {
        return false;
      }
      if (route.split("*").filter((x) => x.trim() === "").length !== 1) {
        return false;
      }
      return true;
    }
    exports2.isValidWildcardRoute = isValidWildcardRoute;
    function isValidLeadingWildcardRoute(route) {
      return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
    }
    exports2.isValidLeadingWildcardRoute = isValidLeadingWildcardRoute;
    function isValidTrailingWildcardRoute(route) {
      return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
    }
    exports2.isValidTrailingWildcardRoute = isValidTrailingWildcardRoute;
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/cjs/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/@walletconnect/jsonrpc-types/dist/cjs/jsonrpc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/cjs/misc.js
var require_misc = __commonJS({
  "node_modules/@walletconnect/jsonrpc-types/dist/cjs/misc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IEvents = void 0;
    var IEvents = class {
    };
    exports2.IEvents = IEvents;
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/cjs/provider.js
var require_provider = __commonJS({
  "node_modules/@walletconnect/jsonrpc-types/dist/cjs/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IJsonRpcProvider = exports2.IBaseJsonRpcProvider = exports2.IJsonRpcConnection = void 0;
    var misc_1 = require_misc();
    var IJsonRpcConnection = class extends misc_1.IEvents {
      constructor(opts) {
        super();
      }
    };
    exports2.IJsonRpcConnection = IJsonRpcConnection;
    var IBaseJsonRpcProvider = class extends misc_1.IEvents {
      constructor() {
        super();
      }
    };
    exports2.IBaseJsonRpcProvider = IBaseJsonRpcProvider;
    var IJsonRpcProvider = class extends IBaseJsonRpcProvider {
      constructor(connection) {
        super();
      }
    };
    exports2.IJsonRpcProvider = IJsonRpcProvider;
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/cjs/validator.js
var require_validator = __commonJS({
  "node_modules/@walletconnect/jsonrpc-types/dist/cjs/validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/cjs/index.js
var require_cjs8 = __commonJS({
  "node_modules/@walletconnect/jsonrpc-types/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_jsonrpc(), exports2);
    tslib_1.__exportStar(require_misc(), exports2);
    tslib_1.__exportStar(require_provider(), exports2);
    tslib_1.__exportStar(require_validator(), exports2);
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/cjs/types.js
var require_types3 = __commonJS({
  "node_modules/@walletconnect/jsonrpc-utils/dist/cjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_cjs8(), exports2);
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/cjs/url.js
var require_url = __commonJS({
  "node_modules/@walletconnect/jsonrpc-utils/dist/cjs/url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isLocalhostUrl = exports2.isWsUrl = exports2.isHttpUrl = void 0;
    var HTTP_REGEX = "^https?:";
    var WS_REGEX = "^wss?:";
    function getUrlProtocol(url) {
      const matches = url.match(new RegExp(/^\w+:/, "gi"));
      if (!matches || !matches.length)
        return;
      return matches[0];
    }
    function matchRegexProtocol(url, regex) {
      const protocol = getUrlProtocol(url);
      if (typeof protocol === "undefined")
        return false;
      return new RegExp(regex).test(protocol);
    }
    function isHttpUrl(url) {
      return matchRegexProtocol(url, HTTP_REGEX);
    }
    exports2.isHttpUrl = isHttpUrl;
    function isWsUrl(url) {
      return matchRegexProtocol(url, WS_REGEX);
    }
    exports2.isWsUrl = isWsUrl;
    function isLocalhostUrl(url) {
      return new RegExp("wss?://localhost(:d{2,5})?").test(url);
    }
    exports2.isLocalhostUrl = isLocalhostUrl;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/cjs/validators.js
var require_validators = __commonJS({
  "node_modules/@walletconnect/jsonrpc-utils/dist/cjs/validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isJsonRpcValidationInvalid = exports2.isJsonRpcError = exports2.isJsonRpcResult = exports2.isJsonRpcResponse = exports2.isJsonRpcRequest = exports2.isJsonRpcPayload = void 0;
    function isJsonRpcPayload(payload) {
      return "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
    }
    exports2.isJsonRpcPayload = isJsonRpcPayload;
    function isJsonRpcRequest(payload) {
      return isJsonRpcPayload(payload) && "method" in payload;
    }
    exports2.isJsonRpcRequest = isJsonRpcRequest;
    function isJsonRpcResponse(payload) {
      return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
    }
    exports2.isJsonRpcResponse = isJsonRpcResponse;
    function isJsonRpcResult(payload) {
      return "result" in payload;
    }
    exports2.isJsonRpcResult = isJsonRpcResult;
    function isJsonRpcError(payload) {
      return "error" in payload;
    }
    exports2.isJsonRpcError = isJsonRpcError;
    function isJsonRpcValidationInvalid(validation) {
      return "error" in validation && validation.valid === false;
    }
    exports2.isJsonRpcValidationInvalid = isJsonRpcValidationInvalid;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/cjs/index.js
var require_cjs9 = __commonJS({
  "node_modules/@walletconnect/jsonrpc-utils/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_constants3(), exports2);
    tslib_1.__exportStar(require_error(), exports2);
    tslib_1.__exportStar(require_env2(), exports2);
    tslib_1.__exportStar(require_format(), exports2);
    tslib_1.__exportStar(require_routing(), exports2);
    tslib_1.__exportStar(require_types3(), exports2);
    tslib_1.__exportStar(require_url(), exports2);
    tslib_1.__exportStar(require_validators(), exports2);
  }
});

// node_modules/@walletconnect/utils/dist/cjs/misc.js
var require_misc2 = __commonJS({
  "node_modules/@walletconnect/utils/dist/cjs/misc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRpcUrl = exports2.getInfuraRpcUrl = exports2.logDeprecationWarning = exports2.uuid = exports2.payloadId = exports2.removeHexLeadingZeros = exports2.removeHexPrefix = exports2.addHexPrefix = exports2.sanitizeHex = void 0;
    var tslib_1 = require_tslib();
    var encoding = tslib_1.__importStar(require_cjs6());
    var jsonRpcUtils = tslib_1.__importStar(require_cjs9());
    var constants_1 = require_constants2();
    function sanitizeHex(hex) {
      return encoding.sanitizeHex(hex);
    }
    exports2.sanitizeHex = sanitizeHex;
    function addHexPrefix(hex) {
      return encoding.addHexPrefix(hex);
    }
    exports2.addHexPrefix = addHexPrefix;
    function removeHexPrefix(hex) {
      return encoding.removeHexPrefix(hex);
    }
    exports2.removeHexPrefix = removeHexPrefix;
    function removeHexLeadingZeros(hex) {
      return encoding.removeHexLeadingZeros(encoding.addHexPrefix(hex));
    }
    exports2.removeHexLeadingZeros = removeHexLeadingZeros;
    exports2.payloadId = jsonRpcUtils.payloadId;
    function uuid() {
      const result = ((a, b) => {
        for (b = a = ""; a++ < 36; b += a * 51 & 52 ? (a ^ 15 ? 8 ^ Math.random() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
        }
        return b;
      })();
      return result;
    }
    exports2.uuid = uuid;
    function logDeprecationWarning() {
      console.warn("DEPRECATION WARNING: This WalletConnect client library will be deprecated in favor of @walletconnect/client. Please check docs.walletconnect.org to learn more about this migration!");
    }
    exports2.logDeprecationWarning = logDeprecationWarning;
    function getInfuraRpcUrl(chainId, infuraId) {
      let rpcUrl;
      const network = constants_1.infuraNetworks[chainId];
      if (network) {
        rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
      }
      return rpcUrl;
    }
    exports2.getInfuraRpcUrl = getInfuraRpcUrl;
    function getRpcUrl(chainId, rpc) {
      let rpcUrl;
      const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
      if (rpc.custom && rpc.custom[chainId]) {
        rpcUrl = rpc.custom[chainId];
      } else if (infuraUrl) {
        rpcUrl = infuraUrl;
      }
      return rpcUrl;
    }
    exports2.getRpcUrl = getRpcUrl;
  }
});

// node_modules/@walletconnect/utils/dist/cjs/validators.js
var require_validators2 = __commonJS({
  "node_modules/@walletconnect/utils/dist/cjs/validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSilentPayload = exports2.isReservedEvent = exports2.isInternalEvent = exports2.isJsonRpcResponseError = exports2.isJsonRpcResponseSuccess = exports2.isJsonRpcRequest = exports2.isJsonRpcSubscription = exports2.isHexString = exports2.getEncoding = exports2.getType = exports2.isArrayBuffer = exports2.isTypedArray = exports2.isBuffer = exports2.isEmptyArray = exports2.isEmptyString = void 0;
    var tslib_1 = require_tslib();
    var encoding = tslib_1.__importStar(require_cjs6());
    var constants_1 = require_constants2();
    function isEmptyString(value) {
      return value === "" || typeof value === "string" && value.trim() === "";
    }
    exports2.isEmptyString = isEmptyString;
    function isEmptyArray(array) {
      return !(array && array.length);
    }
    exports2.isEmptyArray = isEmptyArray;
    function isBuffer(val) {
      return encoding.isBuffer(val);
    }
    exports2.isBuffer = isBuffer;
    function isTypedArray(val) {
      return encoding.isTypedArray(val);
    }
    exports2.isTypedArray = isTypedArray;
    function isArrayBuffer(val) {
      return encoding.isArrayBuffer(val);
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function getType(val) {
      return encoding.getType(val);
    }
    exports2.getType = getType;
    function getEncoding(val) {
      return encoding.getEncoding(val);
    }
    exports2.getEncoding = getEncoding;
    function isHexString(value, length) {
      return encoding.isHexString(value, length);
    }
    exports2.isHexString = isHexString;
    function isJsonRpcSubscription(object) {
      return typeof object.params === "object";
    }
    exports2.isJsonRpcSubscription = isJsonRpcSubscription;
    function isJsonRpcRequest(object) {
      return typeof object.method !== "undefined";
    }
    exports2.isJsonRpcRequest = isJsonRpcRequest;
    function isJsonRpcResponseSuccess(object) {
      return typeof object.result !== "undefined";
    }
    exports2.isJsonRpcResponseSuccess = isJsonRpcResponseSuccess;
    function isJsonRpcResponseError(object) {
      return typeof object.error !== "undefined";
    }
    exports2.isJsonRpcResponseError = isJsonRpcResponseError;
    function isInternalEvent(object) {
      return typeof object.event !== "undefined";
    }
    exports2.isInternalEvent = isInternalEvent;
    function isReservedEvent(event) {
      return constants_1.reservedEvents.includes(event) || event.startsWith("wc_");
    }
    exports2.isReservedEvent = isReservedEvent;
    function isSilentPayload(request) {
      if (request.method.startsWith("wc_")) {
        return true;
      }
      if (constants_1.signingMethods.includes(request.method)) {
        return false;
      }
      return true;
    }
    exports2.isSilentPayload = isSilentPayload;
  }
});

// node_modules/@walletconnect/utils/dist/cjs/ethereum.js
var require_ethereum = __commonJS({
  "node_modules/@walletconnect/utils/dist/cjs/ethereum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseTransactionData = exports2.parsePersonalSign = exports2.isValidAddress = exports2.toChecksumAddress = void 0;
    var js_sha3_1 = require_sha3();
    var encoding_1 = require_cjs6();
    var encoding_2 = require_encoding2();
    var misc_1 = require_misc2();
    var validators_1 = require_validators2();
    function toChecksumAddress(address) {
      address = (0, encoding_1.removeHexPrefix)(address.toLowerCase());
      const hash = (0, encoding_1.removeHexPrefix)((0, js_sha3_1.keccak_256)((0, encoding_2.convertUtf8ToBuffer)(address)));
      let checksum = "";
      for (let i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) > 7) {
          checksum += address[i].toUpperCase();
        } else {
          checksum += address[i];
        }
      }
      return (0, encoding_1.addHexPrefix)(checksum);
    }
    exports2.toChecksumAddress = toChecksumAddress;
    var isValidAddress = (address) => {
      if (!address) {
        return false;
      } else if (address.toLowerCase().substring(0, 2) !== "0x") {
        return false;
      } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
        return true;
      } else {
        return address === toChecksumAddress(address);
      }
    };
    exports2.isValidAddress = isValidAddress;
    function parsePersonalSign(params) {
      if (!(0, validators_1.isEmptyArray)(params) && !(0, validators_1.isHexString)(params[0])) {
        params[0] = (0, encoding_2.convertUtf8ToHex)(params[0]);
      }
      return params;
    }
    exports2.parsePersonalSign = parsePersonalSign;
    function parseTransactionData(txData) {
      if (typeof txData.type !== "undefined" && txData.type !== "0")
        return txData;
      if (typeof txData.from === "undefined" || !(0, exports2.isValidAddress)(txData.from)) {
        throw new Error(`Transaction object must include a valid 'from' value.`);
      }
      function parseHexValues(value) {
        let result = value;
        if (typeof value === "number" || typeof value === "string" && !(0, validators_1.isEmptyString)(value)) {
          if (!(0, validators_1.isHexString)(value)) {
            result = (0, encoding_2.convertNumberToHex)(value);
          } else if (typeof value === "string") {
            result = (0, misc_1.sanitizeHex)(value);
          }
        }
        if (typeof result === "string") {
          result = (0, misc_1.removeHexLeadingZeros)(result);
        }
        return result;
      }
      const txDataRPC = {
        from: (0, misc_1.sanitizeHex)(txData.from),
        to: typeof txData.to === "undefined" ? "" : (0, misc_1.sanitizeHex)(txData.to),
        gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
        gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
        value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
        nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
        data: typeof txData.data === "undefined" ? "" : (0, misc_1.sanitizeHex)(txData.data) || "0x"
      };
      const prunable = ["gasPrice", "gas", "value", "nonce"];
      Object.keys(txDataRPC).forEach((key) => {
        if (!txDataRPC[key].trim().length && prunable.includes(key)) {
          delete txDataRPC[key];
        }
      });
      return txDataRPC;
    }
    exports2.parseTransactionData = parseTransactionData;
  }
});

// node_modules/@walletconnect/utils/dist/cjs/payload.js
var require_payload = __commonJS({
  "node_modules/@walletconnect/utils/dist/cjs/payload.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatRpcError = exports2.promisify = void 0;
    var tslib_1 = require_tslib();
    function promisify(originalFn, thisArg) {
      const promisifiedFunction = (...callArgs) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          const callback = (err, data) => {
            if (err === null || typeof err === "undefined") {
              reject(err);
            }
            resolve(data);
          };
          originalFn.apply(thisArg, [...callArgs, callback]);
        });
      });
      return promisifiedFunction;
    }
    exports2.promisify = promisify;
    function formatRpcError(error) {
      const message = error.message || "Failed or Rejected Request";
      let code = -32e3;
      if (error && !error.code) {
        switch (message) {
          case "Parse error":
            code = -32700;
            break;
          case "Invalid request":
            code = -32600;
            break;
          case "Method not found":
            code = -32601;
            break;
          case "Invalid params":
            code = -32602;
            break;
          case "Internal error":
            code = -32603;
            break;
          default:
            code = -32e3;
            break;
        }
      }
      const result = {
        code,
        message
      };
      return result;
    }
    exports2.formatRpcError = formatRpcError;
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp(token, "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return decodeURIComponent(components.join(""));
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode2(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i = 1; i < tokens.length; i++) {
          input = decodeComponents(tokens, i).join("");
          tokens = input.match(singleMatcher);
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode2(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i = 0; i < entries.length; i++) {
        var key = entries[i];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module2.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports2) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k of Object.keys(value)) {
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports2.extract = extract;
    exports2.parse = parse;
    exports2.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x) => x.length > 0).join("&");
    };
    exports2.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash] = splitOnFirst(input, "#");
      return Object.assign({
        url: url.split("?")[0] || "",
        query: parse(extract(input), options)
      }, options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode2(hash, options) } : {});
    };
    exports2.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports2.extract(input.url);
      const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports2.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash = `#${encode2(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
  }
});

// node_modules/@walletconnect/utils/dist/cjs/url.js
var require_url2 = __commonJS({
  "node_modules/@walletconnect/utils/dist/cjs/url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatQueryString = exports2.parseQueryString = exports2.appendToQueryString = exports2.getQueryString = void 0;
    var tslib_1 = require_tslib();
    var queryStringUtils = tslib_1.__importStar(require_query_string());
    function getQueryString(url) {
      const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
      const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
      return queryString;
    }
    exports2.getQueryString = getQueryString;
    function appendToQueryString(queryString, newQueryParams) {
      let queryParams = parseQueryString(queryString);
      queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
      queryString = formatQueryString(queryParams);
      return queryString;
    }
    exports2.appendToQueryString = appendToQueryString;
    function parseQueryString(queryString) {
      return queryStringUtils.parse(queryString);
    }
    exports2.parseQueryString = parseQueryString;
    function formatQueryString(queryParams) {
      return queryStringUtils.stringify(queryParams);
    }
    exports2.formatQueryString = formatQueryString;
  }
});

// node_modules/@walletconnect/utils/dist/cjs/session.js
var require_session = __commonJS({
  "node_modules/@walletconnect/utils/dist/cjs/session.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseWalletConnectUri = exports2.isWalletConnectSession = void 0;
    var url_1 = require_url2();
    function isWalletConnectSession(object) {
      return typeof object.bridge !== "undefined";
    }
    exports2.isWalletConnectSession = isWalletConnectSession;
    function parseWalletConnectUri(str) {
      const pathStart = str.indexOf(":");
      const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
      const protocol = str.substring(0, pathStart);
      const path = str.substring(pathStart + 1, pathEnd);
      function parseRequiredParams(path2) {
        const separator = "@";
        const values = path2.split(separator);
        const requiredParams2 = {
          handshakeTopic: values[0],
          version: parseInt(values[1], 10)
        };
        return requiredParams2;
      }
      const requiredParams = parseRequiredParams(path);
      const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
      function parseQueryParams(queryString2) {
        const result2 = (0, url_1.parseQueryString)(queryString2);
        const parameters = {
          key: result2.key || "",
          bridge: result2.bridge || ""
        };
        return parameters;
      }
      const queryParams = parseQueryParams(queryString);
      const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
      return result;
    }
    exports2.parseWalletConnectUri = parseWalletConnectUri;
  }
});

// node_modules/@walletconnect/utils/dist/cjs/index.js
var require_cjs10 = __commonJS({
  "node_modules/@walletconnect/utils/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_cjs5(), exports2);
    tslib_1.__exportStar(require_constants2(), exports2);
    tslib_1.__exportStar(require_encoding2(), exports2);
    tslib_1.__exportStar(require_ethereum(), exports2);
    tslib_1.__exportStar(require_misc2(), exports2);
    tslib_1.__exportStar(require_payload(), exports2);
    tslib_1.__exportStar(require_session(), exports2);
    tslib_1.__exportStar(require_url2(), exports2);
    tslib_1.__exportStar(require_validators2(), exports2);
  }
});

// node_modules/@walletconnect/socket-transport/dist/cjs/network.js
var require_network = __commonJS({
  "node_modules/@walletconnect/socket-transport/dist/cjs/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var NetworkMonitor = class {
      constructor() {
        this._eventEmitters = [];
        if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
          window.addEventListener("online", () => this.trigger("online"));
          window.addEventListener("offline", () => this.trigger("offline"));
        }
      }
      on(event, callback) {
        this._eventEmitters.push({
          event,
          callback
        });
      }
      trigger(event) {
        let eventEmitters = [];
        if (event) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
        }
        eventEmitters.forEach((eventEmitter) => {
          eventEmitter.callback();
        });
      }
    };
    exports2.default = NetworkMonitor;
  }
});

// node_modules/ws/lib/constants.js
var require_constants4 = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants4();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode, NOOP } = require_constants4();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require("utf-8-validate");
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants4();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants4();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        const merge = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      doClose(data, mask2, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask: mask2,
          readOnly: false
        }), cb);
      }
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask: mask2,
          readOnly
        }), cb);
      }
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask: mask2,
          readOnly
        }), cb);
      }
      send(data, options, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(buf, {
            fin: options.fin,
            rsv1: false,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          }), cb);
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var Event = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      addEventListener(type, listener, options) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method2 = options && options.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method2](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method2](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method2](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method2](type, onOpen);
        } else {
          this[method2](type, listener);
        }
      },
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { URL } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants4();
    var { addEventListener, removeEventListener } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter {
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get onclose() {
        return void 0;
      }
      set onclose(listener) {
      }
      get onerror() {
        return void 0;
      }
      set onerror(listener) {
      }
      get onopen() {
        return void 0;
      }
      set onopen(listener) {
      }
      get onmessage() {
        return void 0;
      }
      set onmessage(listener) {
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method2) => {
      Object.defineProperty(WebSocket.prototype, `on${method2}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method2);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method2);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method2, listeners[i]);
          }
          this.addEventListener(method2, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        throw new Error(`Invalid URL: ${websocket.url}`);
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https.get : http.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        websocket._readyState = WebSocket.CLOSING;
        websocket.emit("error", err);
        websocket.emitClose();
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          const addr = new URL(location, address);
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket._socket.resume();
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket._socket.resume();
      websocket.close(err[kStatusCode]);
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      websocket._socket.read();
      websocket._receiver.end();
      this.removeListener("data", socketOnData);
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream2 = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let resumeOnReceiverDrain = true;
      let terminateOnDestroy = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain)
          ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain)
            ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var WebSocket = require_websocket();
    var { format, parse } = require_extension();
    var { GUID, kWebSocket } = require_constants4();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking)
          this.clients = /* @__PURE__ */ new Set();
        this.options = options;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSED) {
          process.nextTick(emitClose, this);
          return;
        }
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(emitClose.bind(void 0, this));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream2();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module2.exports = WebSocket;
  }
});

// node_modules/@walletconnect/socket-transport/dist/cjs/index.js
var require_cjs11 = __commonJS({
  "node_modules/@walletconnect/socket-transport/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_cjs10();
    var network_1 = tslib_1.__importDefault(require_network());
    var WS = typeof global.WebSocket !== "undefined" ? global.WebSocket : require_ws();
    var SocketTransport = class {
      constructor(opts) {
        this.opts = opts;
        this._queue = [];
        this._events = [];
        this._subscriptions = [];
        this._protocol = opts.protocol;
        this._version = opts.version;
        this._url = "";
        this._netMonitor = null;
        this._socket = null;
        this._nextSocket = null;
        this._subscriptions = opts.subscriptions || [];
        this._netMonitor = opts.netMonitor || new network_1.default();
        if (!opts.url || typeof opts.url !== "string") {
          throw new Error("Missing or invalid WebSocket url");
        }
        this._url = opts.url;
        this._netMonitor.on("online", () => this._socketCreate());
      }
      set readyState(value) {
      }
      get readyState() {
        return this._socket ? this._socket.readyState : -1;
      }
      set connecting(value) {
      }
      get connecting() {
        return this.readyState === 0;
      }
      set connected(value) {
      }
      get connected() {
        return this.readyState === 1;
      }
      set closing(value) {
      }
      get closing() {
        return this.readyState === 2;
      }
      set closed(value) {
      }
      get closed() {
        return this.readyState === 3;
      }
      open() {
        this._socketCreate();
      }
      close() {
        this._socketClose();
      }
      send(message, topic, silent) {
        if (!topic || typeof topic !== "string") {
          throw new Error("Missing or invalid topic field");
        }
        this._socketSend({
          topic,
          type: "pub",
          payload: message,
          silent: !!silent
        });
      }
      subscribe(topic) {
        this._socketSend({
          topic,
          type: "sub",
          payload: "",
          silent: true
        });
      }
      on(event, callback) {
        this._events.push({ event, callback });
      }
      _socketCreate() {
        if (this._nextSocket) {
          return;
        }
        const url = getWebSocketUrl(this._url, this._protocol, this._version);
        this._nextSocket = new WS(url);
        if (!this._nextSocket) {
          throw new Error("Failed to create socket");
        }
        this._nextSocket.onmessage = (event) => this._socketReceive(event);
        this._nextSocket.onopen = () => this._socketOpen();
        this._nextSocket.onerror = (event) => this._socketError(event);
        this._nextSocket.onclose = () => {
          setTimeout(() => {
            this._nextSocket = null;
            this._socketCreate();
          }, 1e3);
        };
      }
      _socketOpen() {
        this._socketClose();
        this._socket = this._nextSocket;
        this._nextSocket = null;
        this._queueSubscriptions();
        this._pushQueue();
      }
      _socketClose() {
        if (this._socket) {
          this._socket.onclose = () => {
          };
          this._socket.close();
        }
      }
      _socketSend(socketMessage) {
        const message = JSON.stringify(socketMessage);
        if (this._socket && this._socket.readyState === 1) {
          this._socket.send(message);
        } else {
          this._setToQueue(socketMessage);
          this._socketCreate();
        }
      }
      _socketReceive(event) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let socketMessage;
          try {
            socketMessage = JSON.parse(event.data);
          } catch (error) {
            return;
          }
          this._socketSend({
            topic: socketMessage.topic,
            type: "ack",
            payload: "",
            silent: true
          });
          if (this._socket && this._socket.readyState === 1) {
            const events = this._events.filter((event2) => event2.event === "message");
            if (events && events.length) {
              events.forEach((event2) => event2.callback(socketMessage));
            }
          }
        });
      }
      _socketError(e) {
        const events = this._events.filter((event) => event.event === "error");
        if (events && events.length) {
          events.forEach((event) => event.callback(e));
        }
      }
      _queueSubscriptions() {
        const subscriptions = this._subscriptions;
        subscriptions.forEach((topic) => this._queue.push({
          topic,
          type: "sub",
          payload: "",
          silent: true
        }));
        this._subscriptions = this.opts.subscriptions || [];
      }
      _setToQueue(socketMessage) {
        this._queue.push(socketMessage);
      }
      _pushQueue() {
        const queue = this._queue;
        queue.forEach((socketMessage) => this._socketSend(socketMessage));
        this._queue = [];
      }
    };
    function getWebSocketUrl(_url, protocol, version) {
      var _a, _b;
      const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
      const splitUrl = url.split("?");
      const params = (0, utils_1.isBrowser)() ? {
        protocol,
        version,
        env: "browser",
        host: ((_a = (0, utils_1.getLocation)()) === null || _a === void 0 ? void 0 : _a.host) || ""
      } : {
        protocol,
        version,
        env: ((_b = (0, utils_1.detectEnv)()) === null || _b === void 0 ? void 0 : _b.name) || ""
      };
      const queryString = (0, utils_1.appendToQueryString)((0, utils_1.getQueryString)(splitUrl[1] || ""), params);
      return splitUrl[0] + "?" + queryString;
    }
    exports2.default = SocketTransport;
  }
});

// node_modules/@walletconnect/core/dist/cjs/errors.js
var require_errors = __commonJS({
  "node_modules/@walletconnect/core/dist/cjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERROR_QRCODE_MODAL_USER_CLOSED = exports2.ERROR_QRCODE_MODAL_NOT_PROVIDED = exports2.ERROR_INVALID_URI = exports2.ERROR_INVALID_RESPONSE = exports2.ERROR_MISSING_REQUIRED = exports2.ERROR_MISSING_ID = exports2.ERROR_MISSING_METHOD = exports2.ERROR_MISSING_ERROR = exports2.ERROR_MISSING_RESULT = exports2.ERROR_MISSING_JSON_RPC = exports2.ERROR_SESSION_REJECTED = exports2.ERROR_SESSION_DISCONNECTED = exports2.ERROR_SESSION_CONNECTED = void 0;
    exports2.ERROR_SESSION_CONNECTED = "Session currently connected";
    exports2.ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
    exports2.ERROR_SESSION_REJECTED = "Session Rejected";
    exports2.ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
    exports2.ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
    exports2.ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
    exports2.ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
    exports2.ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
    exports2.ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
    exports2.ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
    exports2.ERROR_INVALID_URI = "URI format is invalid";
    exports2.ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
    exports2.ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";
  }
});

// node_modules/@walletconnect/core/dist/cjs/events.js
var require_events = __commonJS({
  "node_modules/@walletconnect/core/dist/cjs/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_cjs10();
    var EventManager = class {
      constructor() {
        this._eventEmitters = [];
      }
      subscribe(eventEmitter) {
        this._eventEmitters.push(eventEmitter);
      }
      unsubscribe(event) {
        this._eventEmitters = this._eventEmitters.filter((x) => x.event !== event);
      }
      trigger(payload) {
        let eventEmitters = [];
        let event;
        if ((0, utils_1.isJsonRpcRequest)(payload)) {
          event = payload.method;
        } else if ((0, utils_1.isJsonRpcResponseSuccess)(payload) || (0, utils_1.isJsonRpcResponseError)(payload)) {
          event = `response:${payload.id}`;
        } else if ((0, utils_1.isInternalEvent)(payload)) {
          event = payload.event;
        } else {
          event = "";
        }
        if (event) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
        }
        if ((!eventEmitters || !eventEmitters.length) && !(0, utils_1.isReservedEvent)(event) && !(0, utils_1.isInternalEvent)(event)) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
        }
        eventEmitters.forEach((eventEmitter) => {
          if ((0, utils_1.isJsonRpcResponseError)(payload)) {
            const error = new Error(payload.error.message);
            eventEmitter.callback(error, null);
          } else {
            eventEmitter.callback(null, payload);
          }
        });
      }
    };
    exports2.default = EventManager;
  }
});

// node_modules/@walletconnect/core/dist/cjs/storage.js
var require_storage = __commonJS({
  "node_modules/@walletconnect/core/dist/cjs/storage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_cjs10();
    var SessionStorage = class {
      constructor(storageId = "walletconnect") {
        this.storageId = storageId;
      }
      getSession() {
        let session = null;
        const json = (0, utils_1.getLocal)(this.storageId);
        if (json && (0, utils_1.isWalletConnectSession)(json)) {
          session = json;
        }
        return session;
      }
      setSession(session) {
        (0, utils_1.setLocal)(this.storageId, session);
        return session;
      }
      removeSession() {
        (0, utils_1.removeLocal)(this.storageId);
      }
    };
    exports2.default = SessionStorage;
  }
});

// node_modules/@walletconnect/core/dist/cjs/url.js
var require_url3 = __commonJS({
  "node_modules/@walletconnect/core/dist/cjs/url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBridgeUrl = exports2.shouldSelectRandomly = exports2.selectRandomBridgeUrl = exports2.randomBridgeIndex = exports2.extractRootDomain = exports2.extractHostname = void 0;
    var domain = "walletconnect.org";
    var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
    var bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
    function extractHostname(url) {
      let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
      hostname = hostname.split(":")[0];
      hostname = hostname.split("?")[0];
      return hostname;
    }
    exports2.extractHostname = extractHostname;
    function extractRootDomain(url) {
      return extractHostname(url).split(".").slice(-2).join(".");
    }
    exports2.extractRootDomain = extractRootDomain;
    function randomBridgeIndex() {
      return Math.floor(Math.random() * bridges.length);
    }
    exports2.randomBridgeIndex = randomBridgeIndex;
    function selectRandomBridgeUrl() {
      return bridges[randomBridgeIndex()];
    }
    exports2.selectRandomBridgeUrl = selectRandomBridgeUrl;
    function shouldSelectRandomly(url) {
      return extractRootDomain(url) === domain;
    }
    exports2.shouldSelectRandomly = shouldSelectRandomly;
    function getBridgeUrl(url) {
      if (shouldSelectRandomly(url)) {
        return selectRandomBridgeUrl();
      }
      return url;
    }
    exports2.getBridgeUrl = getBridgeUrl;
  }
});

// node_modules/@walletconnect/core/dist/cjs/index.js
var require_cjs12 = __commonJS({
  "node_modules/@walletconnect/core/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var utils_1 = require_cjs10();
    var socket_transport_1 = tslib_1.__importDefault(require_cjs11());
    var errors_1 = require_errors();
    var events_1 = tslib_1.__importDefault(require_events());
    var storage_1 = tslib_1.__importDefault(require_storage());
    var url_1 = require_url3();
    var Connector = class {
      constructor(opts) {
        this.protocol = "wc";
        this.version = 1;
        this._bridge = "";
        this._key = null;
        this._clientId = "";
        this._clientMeta = null;
        this._peerId = "";
        this._peerMeta = null;
        this._handshakeId = 0;
        this._handshakeTopic = "";
        this._connected = false;
        this._accounts = [];
        this._chainId = 0;
        this._networkId = 0;
        this._rpcUrl = "";
        this._eventManager = new events_1.default();
        this._clientMeta = (0, utils_1.getClientMeta)() || opts.connectorOpts.clientMeta || null;
        this._cryptoLib = opts.cryptoLib;
        this._sessionStorage = opts.sessionStorage || new storage_1.default(opts.connectorOpts.storageId);
        this._qrcodeModal = opts.connectorOpts.qrcodeModal;
        this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
        this._signingMethods = [...utils_1.signingMethods, ...opts.connectorOpts.signingMethods || []];
        if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
          throw new Error(errors_1.ERROR_MISSING_REQUIRED);
        }
        if (opts.connectorOpts.bridge) {
          this.bridge = (0, url_1.getBridgeUrl)(opts.connectorOpts.bridge);
        }
        if (opts.connectorOpts.uri) {
          this.uri = opts.connectorOpts.uri;
        }
        const session = opts.connectorOpts.session || this._getStorageSession();
        if (session) {
          this.session = session;
        }
        if (this.handshakeId) {
          this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
        }
        this._transport = opts.transport || new socket_transport_1.default({
          protocol: this.protocol,
          version: this.version,
          url: this.bridge,
          subscriptions: [this.clientId]
        });
        this._subscribeToInternalEvents();
        this._initTransport();
        if (opts.connectorOpts.uri) {
          this._subscribeToSessionRequest();
        }
        if (opts.pushServerOpts) {
          this._registerPushServer(opts.pushServerOpts);
        }
      }
      set bridge(value) {
        if (!value) {
          return;
        }
        this._bridge = value;
      }
      get bridge() {
        return this._bridge;
      }
      set key(value) {
        if (!value) {
          return;
        }
        const key = (0, utils_1.convertHexToArrayBuffer)(value);
        this._key = key;
      }
      get key() {
        if (this._key) {
          const key = (0, utils_1.convertArrayBufferToHex)(this._key, true);
          return key;
        }
        return "";
      }
      set clientId(value) {
        if (!value) {
          return;
        }
        this._clientId = value;
      }
      get clientId() {
        let clientId = this._clientId;
        if (!clientId) {
          clientId = this._clientId = (0, utils_1.uuid)();
        }
        return this._clientId;
      }
      set peerId(value) {
        if (!value) {
          return;
        }
        this._peerId = value;
      }
      get peerId() {
        return this._peerId;
      }
      set clientMeta(value) {
      }
      get clientMeta() {
        let clientMeta = this._clientMeta;
        if (!clientMeta) {
          clientMeta = this._clientMeta = (0, utils_1.getClientMeta)();
        }
        return clientMeta;
      }
      set peerMeta(value) {
        this._peerMeta = value;
      }
      get peerMeta() {
        const peerMeta = this._peerMeta;
        return peerMeta;
      }
      set handshakeTopic(value) {
        if (!value) {
          return;
        }
        this._handshakeTopic = value;
      }
      get handshakeTopic() {
        return this._handshakeTopic;
      }
      set handshakeId(value) {
        if (!value) {
          return;
        }
        this._handshakeId = value;
      }
      get handshakeId() {
        return this._handshakeId;
      }
      get uri() {
        const _uri = this._formatUri();
        return _uri;
      }
      set uri(value) {
        if (!value) {
          return;
        }
        const { handshakeTopic, bridge, key } = this._parseUri(value);
        this.handshakeTopic = handshakeTopic;
        this.bridge = bridge;
        this.key = key;
      }
      set chainId(value) {
        this._chainId = value;
      }
      get chainId() {
        const chainId = this._chainId;
        return chainId;
      }
      set networkId(value) {
        this._networkId = value;
      }
      get networkId() {
        const networkId = this._networkId;
        return networkId;
      }
      set accounts(value) {
        this._accounts = value;
      }
      get accounts() {
        const accounts = this._accounts;
        return accounts;
      }
      set rpcUrl(value) {
        this._rpcUrl = value;
      }
      get rpcUrl() {
        const rpcUrl = this._rpcUrl;
        return rpcUrl;
      }
      set connected(value) {
      }
      get connected() {
        return this._connected;
      }
      set pending(value) {
      }
      get pending() {
        return !!this._handshakeTopic;
      }
      get session() {
        return {
          connected: this.connected,
          accounts: this.accounts,
          chainId: this.chainId,
          bridge: this.bridge,
          key: this.key,
          clientId: this.clientId,
          clientMeta: this.clientMeta,
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          handshakeId: this.handshakeId,
          handshakeTopic: this.handshakeTopic
        };
      }
      set session(value) {
        if (!value) {
          return;
        }
        this._connected = value.connected;
        this.accounts = value.accounts;
        this.chainId = value.chainId;
        this.bridge = value.bridge;
        this.key = value.key;
        this.clientId = value.clientId;
        this.clientMeta = value.clientMeta;
        this.peerId = value.peerId;
        this.peerMeta = value.peerMeta;
        this.handshakeId = value.handshakeId;
        this.handshakeTopic = value.handshakeTopic;
      }
      on(event, callback) {
        const eventEmitter = {
          event,
          callback
        };
        this._eventManager.subscribe(eventEmitter);
      }
      off(event) {
        this._eventManager.unsubscribe(event);
      }
      createInstantRequest(instantRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this._key = yield this._generateKey();
          const request = this._formatRequest({
            method: "wc_instantRequest",
            params: [
              {
                peerId: this.clientId,
                peerMeta: this.clientMeta,
                request: this._formatRequest(instantRequest)
              }
            ]
          });
          this.handshakeId = request.id;
          this.handshakeTopic = (0, utils_1.uuid)();
          this._eventManager.trigger({
            event: "display_uri",
            params: [this.uri]
          });
          this.on("modal_closed", () => {
            throw new Error(errors_1.ERROR_QRCODE_MODAL_USER_CLOSED);
          });
          const endInstantRequest = () => {
            this.killSession();
          };
          try {
            const result = yield this._sendCallRequest(request);
            if (result) {
              endInstantRequest();
            }
            return result;
          } catch (error) {
            endInstantRequest();
            throw error;
          }
        });
      }
      connect(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this._qrcodeModal) {
            throw new Error(errors_1.ERROR_QRCODE_MODAL_NOT_PROVIDED);
          }
          if (this.connected) {
            return {
              chainId: this.chainId,
              accounts: this.accounts
            };
          }
          yield this.createSession(opts);
          return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.on("modal_closed", () => reject(new Error(errors_1.ERROR_QRCODE_MODAL_USER_CLOSED)));
            this.on("connect", (error, payload) => {
              if (error) {
                return reject(error);
              }
              resolve(payload.params[0]);
            });
          }));
        });
      }
      createSession(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (this._connected) {
            throw new Error(errors_1.ERROR_SESSION_CONNECTED);
          }
          if (this.pending) {
            return;
          }
          this._key = yield this._generateKey();
          const request = this._formatRequest({
            method: "wc_sessionRequest",
            params: [
              {
                peerId: this.clientId,
                peerMeta: this.clientMeta,
                chainId: opts && opts.chainId ? opts.chainId : null
              }
            ]
          });
          this.handshakeId = request.id;
          this.handshakeTopic = (0, utils_1.uuid)();
          this._sendSessionRequest(request, "Session update rejected", {
            topic: this.handshakeTopic
          });
          this._eventManager.trigger({
            event: "display_uri",
            params: [this.uri]
          });
        });
      }
      approveSession(sessionStatus) {
        if (this._connected) {
          throw new Error(errors_1.ERROR_SESSION_CONNECTED);
        }
        this.chainId = sessionStatus.chainId;
        this.accounts = sessionStatus.accounts;
        this.networkId = sessionStatus.networkId || 0;
        this.rpcUrl = sessionStatus.rpcUrl || "";
        const sessionParams = {
          approved: true,
          chainId: this.chainId,
          networkId: this.networkId,
          accounts: this.accounts,
          rpcUrl: this.rpcUrl,
          peerId: this.clientId,
          peerMeta: this.clientMeta
        };
        const response = {
          id: this.handshakeId,
          jsonrpc: "2.0",
          result: sessionParams
        };
        this._sendResponse(response);
        this._connected = true;
        this._setStorageSession();
        this._eventManager.trigger({
          event: "connect",
          params: [
            {
              peerId: this.peerId,
              peerMeta: this.peerMeta,
              chainId: this.chainId,
              accounts: this.accounts
            }
          ]
        });
      }
      rejectSession(sessionError) {
        if (this._connected) {
          throw new Error(errors_1.ERROR_SESSION_CONNECTED);
        }
        const message = sessionError && sessionError.message ? sessionError.message : errors_1.ERROR_SESSION_REJECTED;
        const response = this._formatResponse({
          id: this.handshakeId,
          error: { message }
        });
        this._sendResponse(response);
        this._connected = false;
        this._eventManager.trigger({
          event: "disconnect",
          params: [{ message }]
        });
        this._removeStorageSession();
      }
      updateSession(sessionStatus) {
        if (!this._connected) {
          throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);
        }
        this.chainId = sessionStatus.chainId;
        this.accounts = sessionStatus.accounts;
        this.networkId = sessionStatus.networkId || 0;
        this.rpcUrl = sessionStatus.rpcUrl || "";
        const sessionParams = {
          approved: true,
          chainId: this.chainId,
          networkId: this.networkId,
          accounts: this.accounts,
          rpcUrl: this.rpcUrl
        };
        const request = this._formatRequest({
          method: "wc_sessionUpdate",
          params: [sessionParams]
        });
        this._sendSessionRequest(request, "Session update rejected");
        this._eventManager.trigger({
          event: "session_update",
          params: [
            {
              chainId: this.chainId,
              accounts: this.accounts
            }
          ]
        });
        this._manageStorageSession();
      }
      killSession(sessionError) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const message = sessionError ? sessionError.message : "Session Disconnected";
          const sessionParams = {
            approved: false,
            chainId: null,
            networkId: null,
            accounts: null
          };
          const request = this._formatRequest({
            method: "wc_sessionUpdate",
            params: [sessionParams]
          });
          yield this._sendRequest(request);
          this._handleSessionDisconnect(message);
        });
      }
      sendTransaction(tx) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this._connected) {
            throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);
          }
          const parsedTx = (0, utils_1.parseTransactionData)(tx);
          const request = this._formatRequest({
            method: "eth_sendTransaction",
            params: [parsedTx]
          });
          const result = yield this._sendCallRequest(request);
          return result;
        });
      }
      signTransaction(tx) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this._connected) {
            throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);
          }
          const parsedTx = (0, utils_1.parseTransactionData)(tx);
          const request = this._formatRequest({
            method: "eth_signTransaction",
            params: [parsedTx]
          });
          const result = yield this._sendCallRequest(request);
          return result;
        });
      }
      signMessage(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this._connected) {
            throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);
          }
          const request = this._formatRequest({
            method: "eth_sign",
            params
          });
          const result = yield this._sendCallRequest(request);
          return result;
        });
      }
      signPersonalMessage(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this._connected) {
            throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);
          }
          params = (0, utils_1.parsePersonalSign)(params);
          const request = this._formatRequest({
            method: "personal_sign",
            params
          });
          const result = yield this._sendCallRequest(request);
          return result;
        });
      }
      signTypedData(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this._connected) {
            throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);
          }
          const request = this._formatRequest({
            method: "eth_signTypedData",
            params
          });
          const result = yield this._sendCallRequest(request);
          return result;
        });
      }
      updateChain(chainParams) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this._connected) {
            throw new Error("Session currently disconnected");
          }
          const request = this._formatRequest({
            method: "wallet_updateChain",
            params: [chainParams]
          });
          const result = yield this._sendCallRequest(request);
          return result;
        });
      }
      unsafeSend(request, options) {
        this._sendRequest(request, options);
        this._eventManager.trigger({
          event: "call_request_sent",
          params: [{ request, options }]
        });
        return new Promise((resolve, reject) => {
          this._subscribeToResponse(request.id, (error, payload) => {
            if (error) {
              reject(error);
              return;
            }
            if (!payload) {
              throw new Error(errors_1.ERROR_MISSING_JSON_RPC);
            }
            resolve(payload);
          });
        });
      }
      sendCustomRequest(request, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this._connected) {
            throw new Error(errors_1.ERROR_SESSION_DISCONNECTED);
          }
          switch (request.method) {
            case "eth_accounts":
              return this.accounts;
            case "eth_chainId":
              return (0, utils_1.convertNumberToHex)(this.chainId);
            case "eth_sendTransaction":
            case "eth_signTransaction":
              if (request.params) {
                request.params[0] = (0, utils_1.parseTransactionData)(request.params[0]);
              }
              break;
            case "personal_sign":
              if (request.params) {
                request.params = (0, utils_1.parsePersonalSign)(request.params);
              }
              break;
            default:
              break;
          }
          const formattedRequest = this._formatRequest(request);
          const result = yield this._sendCallRequest(formattedRequest, options);
          return result;
        });
      }
      approveRequest(response) {
        if ((0, utils_1.isJsonRpcResponseSuccess)(response)) {
          const formattedResponse = this._formatResponse(response);
          this._sendResponse(formattedResponse);
        } else {
          throw new Error(errors_1.ERROR_MISSING_RESULT);
        }
      }
      rejectRequest(response) {
        if ((0, utils_1.isJsonRpcResponseError)(response)) {
          const formattedResponse = this._formatResponse(response);
          this._sendResponse(formattedResponse);
        } else {
          throw new Error(errors_1.ERROR_MISSING_ERROR);
        }
      }
      transportClose() {
        this._transport.close();
      }
      _sendRequest(request, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const callRequest = this._formatRequest(request);
          const encryptionPayload = yield this._encrypt(callRequest);
          const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
          const payload = JSON.stringify(encryptionPayload);
          const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : (0, utils_1.isSilentPayload)(callRequest);
          this._transport.send(payload, topic, silent);
        });
      }
      _sendResponse(response) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const encryptionPayload = yield this._encrypt(response);
          const topic = this.peerId;
          const payload = JSON.stringify(encryptionPayload);
          const silent = true;
          this._transport.send(payload, topic, silent);
        });
      }
      _sendSessionRequest(request, errorMsg, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this._sendRequest(request, options);
          this._subscribeToSessionResponse(request.id, errorMsg);
        });
      }
      _sendCallRequest(request, options) {
        this._sendRequest(request, options);
        this._eventManager.trigger({
          event: "call_request_sent",
          params: [{ request, options }]
        });
        return this._subscribeToCallResponse(request.id);
      }
      _formatRequest(request) {
        if (typeof request.method === "undefined") {
          throw new Error(errors_1.ERROR_MISSING_METHOD);
        }
        const formattedRequest = {
          id: typeof request.id === "undefined" ? (0, utils_1.payloadId)() : request.id,
          jsonrpc: "2.0",
          method: request.method,
          params: typeof request.params === "undefined" ? [] : request.params
        };
        return formattedRequest;
      }
      _formatResponse(response) {
        if (typeof response.id === "undefined") {
          throw new Error(errors_1.ERROR_MISSING_ID);
        }
        const baseResponse = { id: response.id, jsonrpc: "2.0" };
        if ((0, utils_1.isJsonRpcResponseError)(response)) {
          const error = (0, utils_1.formatRpcError)(response.error);
          const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
          return errorResponse;
        } else if ((0, utils_1.isJsonRpcResponseSuccess)(response)) {
          const successResponse = Object.assign(Object.assign({}, baseResponse), response);
          return successResponse;
        }
        throw new Error(errors_1.ERROR_INVALID_RESPONSE);
      }
      _handleSessionDisconnect(errorMsg) {
        const message = errorMsg || "Session Disconnected";
        if (!this._connected) {
          if (this._qrcodeModal) {
            this._qrcodeModal.close();
          }
          (0, utils_1.removeLocal)(utils_1.mobileLinkChoiceKey);
        }
        if (this._connected) {
          this._connected = false;
        }
        if (this._handshakeId) {
          this._handshakeId = 0;
        }
        if (this._handshakeTopic) {
          this._handshakeTopic = "";
        }
        if (this._peerId) {
          this._peerId = "";
        }
        this._eventManager.trigger({
          event: "disconnect",
          params: [{ message }]
        });
        this._removeStorageSession();
        this.transportClose();
      }
      _handleSessionResponse(errorMsg, sessionParams) {
        if (sessionParams) {
          if (sessionParams.approved) {
            if (!this._connected) {
              this._connected = true;
              if (sessionParams.chainId) {
                this.chainId = sessionParams.chainId;
              }
              if (sessionParams.accounts) {
                this.accounts = sessionParams.accounts;
              }
              if (sessionParams.peerId && !this.peerId) {
                this.peerId = sessionParams.peerId;
              }
              if (sessionParams.peerMeta && !this.peerMeta) {
                this.peerMeta = sessionParams.peerMeta;
              }
              this._eventManager.trigger({
                event: "connect",
                params: [
                  {
                    peerId: this.peerId,
                    peerMeta: this.peerMeta,
                    chainId: this.chainId,
                    accounts: this.accounts
                  }
                ]
              });
            } else {
              if (sessionParams.chainId) {
                this.chainId = sessionParams.chainId;
              }
              if (sessionParams.accounts) {
                this.accounts = sessionParams.accounts;
              }
              this._eventManager.trigger({
                event: "session_update",
                params: [
                  {
                    chainId: this.chainId,
                    accounts: this.accounts
                  }
                ]
              });
            }
            this._manageStorageSession();
          } else {
            this._handleSessionDisconnect(errorMsg);
          }
        } else {
          this._handleSessionDisconnect(errorMsg);
        }
      }
      _handleIncomingMessages(socketMessage) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const activeTopics = [this.clientId, this.handshakeTopic];
          if (!activeTopics.includes(socketMessage.topic)) {
            return;
          }
          let encryptionPayload;
          try {
            encryptionPayload = JSON.parse(socketMessage.payload);
          } catch (error) {
            return;
          }
          const payload = yield this._decrypt(encryptionPayload);
          if (payload) {
            this._eventManager.trigger(payload);
          }
        });
      }
      _subscribeToSessionRequest() {
        this._transport.subscribe(this.handshakeTopic);
      }
      _subscribeToResponse(id, callback) {
        this.on(`response:${id}`, callback);
      }
      _subscribeToSessionResponse(id, errorMsg) {
        this._subscribeToResponse(id, (error, payload) => {
          if (error) {
            this._handleSessionResponse(error.message);
            return;
          }
          if (payload.result) {
            this._handleSessionResponse(errorMsg, payload.result);
          } else if (payload.error && payload.error.message) {
            this._handleSessionResponse(payload.error.message);
          } else {
            this._handleSessionResponse(errorMsg);
          }
        });
      }
      _subscribeToCallResponse(id) {
        return new Promise((resolve, reject) => {
          this._subscribeToResponse(id, (error, payload) => {
            if (error) {
              reject(error);
              return;
            }
            if (payload.result) {
              resolve(payload.result);
            } else if (payload.error && payload.error.message) {
              reject(new Error(payload.error.message));
            } else {
              reject(new Error(errors_1.ERROR_INVALID_RESPONSE));
            }
          });
        });
      }
      _subscribeToInternalEvents() {
        this.on("display_uri", () => {
          if (this._qrcodeModal) {
            this._qrcodeModal.open(this.uri, () => {
              this._eventManager.trigger({
                event: "modal_closed",
                params: []
              });
            }, this._qrcodeModalOptions);
          }
        });
        this.on("connect", () => {
          if (this._qrcodeModal) {
            this._qrcodeModal.close();
          }
        });
        this.on("call_request_sent", (error, payload) => {
          const { request } = payload.params[0];
          if ((0, utils_1.isMobile)() && this._signingMethods.includes(request.method)) {
            const mobileLinkUrl = (0, utils_1.getLocal)(utils_1.mobileLinkChoiceKey);
            if (mobileLinkUrl) {
              window.location.href = mobileLinkUrl.href;
            }
          }
        });
        this.on("wc_sessionRequest", (error, payload) => {
          if (error) {
            this._eventManager.trigger({
              event: "error",
              params: [
                {
                  code: "SESSION_REQUEST_ERROR",
                  message: error.toString()
                }
              ]
            });
          }
          this.handshakeId = payload.id;
          this.peerId = payload.params[0].peerId;
          this.peerMeta = payload.params[0].peerMeta;
          const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
          this._eventManager.trigger(internalPayload);
        });
        this.on("wc_sessionUpdate", (error, payload) => {
          if (error) {
            this._handleSessionResponse(error.message);
          }
          this._handleSessionResponse("Session disconnected", payload.params[0]);
        });
      }
      _initTransport() {
        this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
        this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
        this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
        this._transport.on("error", () => this._eventManager.trigger({
          event: "transport_error",
          params: ["Websocket connection failed"]
        }));
        this._transport.open();
      }
      _formatUri() {
        const protocol = this.protocol;
        const handshakeTopic = this.handshakeTopic;
        const version = this.version;
        const bridge = encodeURIComponent(this.bridge);
        const key = this.key;
        const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;
        return uri;
      }
      _parseUri(uri) {
        const result = (0, utils_1.parseWalletConnectUri)(uri);
        if (result.protocol === this.protocol) {
          if (!result.handshakeTopic) {
            throw Error("Invalid or missing handshakeTopic parameter value");
          }
          const handshakeTopic = result.handshakeTopic;
          if (!result.bridge) {
            throw Error("Invalid or missing bridge url parameter value");
          }
          const bridge = decodeURIComponent(result.bridge);
          if (!result.key) {
            throw Error("Invalid or missing key parameter value");
          }
          const key = result.key;
          return { handshakeTopic, bridge, key };
        } else {
          throw new Error(errors_1.ERROR_INVALID_URI);
        }
      }
      _generateKey() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (this._cryptoLib) {
            const result = yield this._cryptoLib.generateKey();
            return result;
          }
          return null;
        });
      }
      _encrypt(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const key = this._key;
          if (this._cryptoLib && key) {
            const result = yield this._cryptoLib.encrypt(data, key);
            return result;
          }
          return null;
        });
      }
      _decrypt(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const key = this._key;
          if (this._cryptoLib && key) {
            const result = yield this._cryptoLib.decrypt(payload, key);
            return result;
          }
          return null;
        });
      }
      _getStorageSession() {
        let result = null;
        if (this._sessionStorage) {
          result = this._sessionStorage.getSession();
        }
        return result;
      }
      _setStorageSession() {
        if (this._sessionStorage) {
          this._sessionStorage.setSession(this.session);
        }
      }
      _removeStorageSession() {
        if (this._sessionStorage) {
          this._sessionStorage.removeSession();
        }
      }
      _manageStorageSession() {
        if (this._connected) {
          this._setStorageSession();
        } else {
          this._removeStorageSession();
        }
      }
      _registerPushServer(pushServerOpts) {
        if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
          throw Error("Invalid or missing pushServerOpts.url parameter value");
        }
        if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
          throw Error("Invalid or missing pushServerOpts.type parameter value");
        }
        if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
          throw Error("Invalid or missing pushServerOpts.token parameter value");
        }
        const pushSubscription = {
          bridge: this.bridge,
          topic: this.clientId,
          type: pushServerOpts.type,
          token: pushServerOpts.token,
          peerName: "",
          language: pushServerOpts.language || ""
        };
        this.on("connect", (error, payload) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (error) {
            throw error;
          }
          if (pushServerOpts.peerMeta) {
            const peerName = payload.params[0].peerMeta.name;
            pushSubscription.peerName = peerName;
          }
          try {
            const response = yield fetch(`${pushServerOpts.url}/new`, {
              method: "POST",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json"
              },
              body: JSON.stringify(pushSubscription)
            });
            const json = yield response.json();
            if (!json.success) {
              throw Error("Failed to register in Push Server");
            }
          } catch (error2) {
            throw Error("Failed to register in Push Server");
          }
        }));
      }
    };
    exports2.default = Connector;
  }
});

// node_modules/@walletconnect/randombytes/dist/cjs/node/index.js
var require_node3 = __commonJS({
  "node_modules/@walletconnect/randombytes/dist/cjs/node/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomBytes = void 0;
    var crypto_1 = __importDefault(require("crypto"));
    var encoding_1 = require_cjs6();
    function randomBytes(length) {
      const buf = crypto_1.default.randomBytes(length);
      return encoding_1.bufferToArray(buf);
    }
    exports2.randomBytes = randomBytes;
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/constants/length.js
var require_length = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/constants/length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LENGTH_1024 = exports2.LENGTH_512 = exports2.LENGTH_256 = exports2.LENGTH_128 = exports2.LENGTH_64 = exports2.LENGTH_32 = exports2.LENGTH_16 = exports2.LENGTH_1 = exports2.LENGTH_0 = void 0;
    exports2.LENGTH_0 = 0;
    exports2.LENGTH_1 = 1;
    exports2.LENGTH_16 = 16;
    exports2.LENGTH_32 = 32;
    exports2.LENGTH_64 = 64;
    exports2.LENGTH_128 = 128;
    exports2.LENGTH_256 = 256;
    exports2.LENGTH_512 = 512;
    exports2.LENGTH_1024 = 1024;
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/constants/default.js
var require_default = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/constants/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MAC_LENGTH = exports2.IV_LENGTH = exports2.KEY_LENGTH = exports2.PREFIX_LENGTH = exports2.RIPEMD160_NODE_ALGO = exports2.SHA512_NODE_ALGO = exports2.SHA256_NODE_ALGO = exports2.HMAC_NODE_ALGO = exports2.AES_NODE_ALGO = exports2.SHA512_BROWSER_ALGO = exports2.SHA256_BROWSER_ALGO = exports2.HMAC_BROWSER = exports2.HMAC_BROWSER_ALGO = exports2.AES_BROWSER_ALGO = exports2.HMAC_LENGTH = exports2.AES_LENGTH = void 0;
    var length_1 = require_length();
    exports2.AES_LENGTH = length_1.LENGTH_256;
    exports2.HMAC_LENGTH = length_1.LENGTH_256;
    exports2.AES_BROWSER_ALGO = "AES-CBC";
    exports2.HMAC_BROWSER_ALGO = `SHA-${exports2.AES_LENGTH}`;
    exports2.HMAC_BROWSER = "HMAC";
    exports2.SHA256_BROWSER_ALGO = "SHA-256";
    exports2.SHA512_BROWSER_ALGO = "SHA-512";
    exports2.AES_NODE_ALGO = `aes-${exports2.AES_LENGTH}-cbc`;
    exports2.HMAC_NODE_ALGO = `sha${exports2.HMAC_LENGTH}`;
    exports2.SHA256_NODE_ALGO = "sha256";
    exports2.SHA512_NODE_ALGO = "sha512";
    exports2.RIPEMD160_NODE_ALGO = "ripemd160";
    exports2.PREFIX_LENGTH = length_1.LENGTH_1;
    exports2.KEY_LENGTH = length_1.LENGTH_32;
    exports2.IV_LENGTH = length_1.LENGTH_16;
    exports2.MAC_LENGTH = length_1.LENGTH_32;
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/constants/encoding.js
var require_encoding3 = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/constants/encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UTF8_ENC = exports2.HEX_ENC = void 0;
    exports2.HEX_ENC = "hex";
    exports2.UTF8_ENC = "utf8";
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/constants/error.js
var require_error2 = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/constants/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERROR_BAD_MAC = void 0;
    exports2.ERROR_BAD_MAC = "Bad MAC";
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/constants/operations.js
var require_operations = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/constants/operations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERIFY_OP = exports2.SIGN_OP = exports2.DECRYPT_OP = exports2.ENCRYPT_OP = void 0;
    exports2.ENCRYPT_OP = "encrypt";
    exports2.DECRYPT_OP = "decrypt";
    exports2.SIGN_OP = "sign";
    exports2.VERIFY_OP = "verify";
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/constants/index.js
var require_constants5 = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/constants/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !exports3.hasOwnProperty(p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_default(), exports2);
    __exportStar(require_encoding3(), exports2);
    __exportStar(require_error2(), exports2);
    __exportStar(require_length(), exports2);
    __exportStar(require_operations(), exports2);
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/lib/node.js
var require_node4 = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/lib/node.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.nodeRipemd160 = exports2.nodeSha512 = exports2.nodeSha256 = exports2.nodeHmacSha512Sign = exports2.nodeHmacSha256Sign = exports2.nodeAesDecrypt = exports2.nodeAesEncrypt = void 0;
    var crypto_1 = __importDefault(require("crypto"));
    var encoding_1 = require_cjs6();
    var constants_1 = require_constants5();
    function nodeAesEncrypt(iv, key, data) {
      const cipher = crypto_1.default.createCipheriv(constants_1.AES_NODE_ALGO, Buffer.from(key), Buffer.from(iv));
      return encoding_1.bufferToArray(encoding_1.concatBuffers(cipher.update(Buffer.from(data)), cipher.final()));
    }
    exports2.nodeAesEncrypt = nodeAesEncrypt;
    function nodeAesDecrypt(iv, key, data) {
      const decipher = crypto_1.default.createDecipheriv(constants_1.AES_NODE_ALGO, Buffer.from(key), Buffer.from(iv));
      return encoding_1.bufferToArray(encoding_1.concatBuffers(decipher.update(Buffer.from(data)), decipher.final()));
    }
    exports2.nodeAesDecrypt = nodeAesDecrypt;
    function nodeHmacSha256Sign(key, data) {
      const buf = crypto_1.default.createHmac(constants_1.HMAC_NODE_ALGO, Buffer.from(key)).update(Buffer.from(data)).digest();
      return encoding_1.bufferToArray(buf);
    }
    exports2.nodeHmacSha256Sign = nodeHmacSha256Sign;
    function nodeHmacSha512Sign(key, data) {
      const buf = crypto_1.default.createHmac(constants_1.SHA512_NODE_ALGO, Buffer.from(key)).update(Buffer.from(data)).digest();
      return encoding_1.bufferToArray(buf);
    }
    exports2.nodeHmacSha512Sign = nodeHmacSha512Sign;
    function nodeSha256(data) {
      const buf = crypto_1.default.createHash(constants_1.SHA256_NODE_ALGO).update(Buffer.from(data)).digest();
      return encoding_1.bufferToArray(buf);
    }
    exports2.nodeSha256 = nodeSha256;
    function nodeSha512(data) {
      const buf = crypto_1.default.createHash(constants_1.SHA512_NODE_ALGO).update(Buffer.from(data)).digest();
      return encoding_1.bufferToArray(buf);
    }
    exports2.nodeSha512 = nodeSha512;
    function nodeRipemd160(data) {
      const buf = crypto_1.default.createHash(constants_1.RIPEMD160_NODE_ALGO).update(Buffer.from(data)).digest();
      return encoding_1.bufferToArray(buf);
    }
    exports2.nodeRipemd160 = nodeRipemd160;
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/node/aes.js
var require_aes = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/node/aes.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.aesCbcDecrypt = exports2.aesCbcEncrypt = void 0;
    var node_1 = require_node4();
    function aesCbcEncrypt(iv, key, data) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = node_1.nodeAesEncrypt(iv, key, data);
        return result;
      });
    }
    exports2.aesCbcEncrypt = aesCbcEncrypt;
    function aesCbcDecrypt(iv, key, data) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = node_1.nodeAesDecrypt(iv, key, data);
        return result;
      });
    }
    exports2.aesCbcDecrypt = aesCbcDecrypt;
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/helpers/env.js
var require_env3 = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/helpers/env.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !exports3.hasOwnProperty(p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cjs7(), exports2);
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/helpers/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/helpers/pkcs7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pkcs7 = void 0;
    var PADDING = [
      [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
      [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
      [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
      [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
      [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
      [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
      [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
      [9, 9, 9, 9, 9, 9, 9, 9, 9],
      [8, 8, 8, 8, 8, 8, 8, 8],
      [7, 7, 7, 7, 7, 7, 7],
      [6, 6, 6, 6, 6, 6],
      [5, 5, 5, 5, 5],
      [4, 4, 4, 4],
      [3, 3, 3],
      [2, 2],
      [1]
    ];
    exports2.pkcs7 = {
      pad(plaintext) {
        const padding = PADDING[plaintext.byteLength % 16 || 0];
        const result = new Uint8Array(plaintext.byteLength + padding.length);
        result.set(plaintext);
        result.set(padding, plaintext.byteLength);
        return result;
      },
      unpad(padded) {
        return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
      }
    };
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/helpers/types.js
var require_types4 = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/helpers/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/helpers/validators.js
var require_validators3 = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/helpers/validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isConstantTime = exports2.assert = void 0;
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || "Assertion failed");
      }
    }
    exports2.assert = assert;
    function isConstantTime(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        return false;
      }
      let res = 0;
      for (let i = 0; i < arr1.length; i++) {
        res |= arr1[i] ^ arr2[i];
      }
      return res === 0;
    }
    exports2.isConstantTime = isConstantTime;
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/helpers/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !exports3.hasOwnProperty(p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_env3(), exports2);
    __exportStar(require_pkcs7(), exports2);
    __exportStar(require_types4(), exports2);
    __exportStar(require_validators3(), exports2);
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/node/hmac.js
var require_hmac = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/node/hmac.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmacSha512Verify = exports2.hmacSha512Sign = exports2.hmacSha256Verify = exports2.hmacSha256Sign = void 0;
    var helpers_1 = require_helpers();
    var node_1 = require_node4();
    function hmacSha256Sign(key, msg) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = node_1.nodeHmacSha256Sign(key, msg);
        return result;
      });
    }
    exports2.hmacSha256Sign = hmacSha256Sign;
    function hmacSha256Verify(key, msg, sig) {
      return __awaiter(this, void 0, void 0, function* () {
        const expectedSig = node_1.nodeHmacSha256Sign(key, msg);
        const result = helpers_1.isConstantTime(expectedSig, sig);
        return result;
      });
    }
    exports2.hmacSha256Verify = hmacSha256Verify;
    function hmacSha512Sign(key, msg) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = node_1.nodeHmacSha512Sign(key, msg);
        return result;
      });
    }
    exports2.hmacSha512Sign = hmacSha512Sign;
    function hmacSha512Verify(key, msg, sig) {
      return __awaiter(this, void 0, void 0, function* () {
        const expectedSig = node_1.nodeHmacSha512Sign(key, msg);
        const result = helpers_1.isConstantTime(expectedSig, sig);
        return result;
      });
    }
    exports2.hmacSha512Verify = hmacSha512Verify;
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/node/sha2.js
var require_sha2 = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/node/sha2.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ripemd160 = exports2.sha512 = exports2.sha256 = void 0;
    var node_1 = require_node4();
    function sha256(msg) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = node_1.nodeSha256(msg);
        return result;
      });
    }
    exports2.sha256 = sha256;
    function sha5122(msg) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = node_1.nodeSha512(msg);
        return result;
      });
    }
    exports2.sha512 = sha5122;
    function ripemd160(msg) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = node_1.nodeRipemd160(msg);
        return result;
      });
    }
    exports2.ripemd160 = ripemd160;
  }
});

// node_modules/@walletconnect/crypto/dist/cjs/node/index.js
var require_node5 = __commonJS({
  "node_modules/@walletconnect/crypto/dist/cjs/node/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !exports3.hasOwnProperty(p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_node3(), exports2);
    __exportStar(require_aes(), exports2);
    __exportStar(require_hmac(), exports2);
    __exportStar(require_sha2(), exports2);
    __exportStar(require_helpers(), exports2);
    __exportStar(require_constants5(), exports2);
  }
});

// node_modules/@walletconnect/iso-crypto/dist/cjs/index.js
var require_cjs13 = __commonJS({
  "node_modules/@walletconnect/iso-crypto/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decrypt = exports2.encrypt = exports2.verifyHmac = exports2.generateKey = void 0;
    var tslib_1 = require_tslib();
    var crypto2 = tslib_1.__importStar(require_node5());
    var encoding = tslib_1.__importStar(require_cjs6());
    var utils_1 = require_cjs10();
    function generateKey(length) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const _length = (length || 256) / 8;
        const bytes = crypto2.randomBytes(_length);
        const result = (0, utils_1.convertBufferToArrayBuffer)(encoding.arrayToBuffer(bytes));
        return result;
      });
    }
    exports2.generateKey = generateKey;
    function verifyHmac(payload, key) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const cipherText = encoding.hexToArray(payload.data);
        const iv = encoding.hexToArray(payload.iv);
        const hmac = encoding.hexToArray(payload.hmac);
        const hmacHex = encoding.arrayToHex(hmac, false);
        const unsigned = encoding.concatArrays(cipherText, iv);
        const chmac = yield crypto2.hmacSha256Sign(key, unsigned);
        const chmacHex = encoding.arrayToHex(chmac, false);
        if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {
          return true;
        }
        return false;
      });
    }
    exports2.verifyHmac = verifyHmac;
    function encrypt(data, key, providedIv) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const _key = encoding.bufferToArray((0, utils_1.convertArrayBufferToBuffer)(key));
        const ivArrayBuffer = providedIv || (yield generateKey(128));
        const iv = encoding.bufferToArray((0, utils_1.convertArrayBufferToBuffer)(ivArrayBuffer));
        const ivHex = encoding.arrayToHex(iv, false);
        const contentString = JSON.stringify(data);
        const content = encoding.utf8ToArray(contentString);
        const cipherText = yield crypto2.aesCbcEncrypt(iv, _key, content);
        const cipherTextHex = encoding.arrayToHex(cipherText, false);
        const unsigned = encoding.concatArrays(cipherText, iv);
        const hmac = yield crypto2.hmacSha256Sign(_key, unsigned);
        const hmacHex = encoding.arrayToHex(hmac, false);
        return {
          data: cipherTextHex,
          hmac: hmacHex,
          iv: ivHex
        };
      });
    }
    exports2.encrypt = encrypt;
    function decrypt(payload, key) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const _key = encoding.bufferToArray((0, utils_1.convertArrayBufferToBuffer)(key));
        if (!_key) {
          throw new Error("Missing key: required for decryption");
        }
        const verified = yield verifyHmac(payload, _key);
        if (!verified) {
          return null;
        }
        const cipherText = encoding.hexToArray(payload.data);
        const iv = encoding.hexToArray(payload.iv);
        const buffer = yield crypto2.aesCbcDecrypt(iv, _key, cipherText);
        const utf8 = encoding.arrayToUtf8(buffer);
        let data;
        try {
          data = JSON.parse(utf8);
        } catch (error) {
          return null;
        }
        return data;
      });
    }
    exports2.decrypt = decrypt;
  }
});

// node_modules/@walletconnect/client/dist/cjs/index.js
var require_cjs14 = __commonJS({
  "node_modules/@walletconnect/client/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var core_1 = tslib_1.__importDefault(require_cjs12());
    var cryptoLib = tslib_1.__importStar(require_cjs13());
    var WalletConnect2 = class extends core_1.default {
      constructor(connectorOpts, pushServerOpts) {
        super({
          cryptoLib,
          connectorOpts,
          pushServerOpts
        });
      }
    };
    exports2.default = WalletConnect2;
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports2, module2) {
    module2.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/buffer-fill/index.js
var require_buffer_fill = __commonJS({
  "node_modules/buffer-fill/index.js"(exports2, module2) {
    var hasFullSupport = function() {
      try {
        if (!Buffer.isEncoding("latin1")) {
          return false;
        }
        var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
        buf.fill("ab", "ucs2");
        return buf.toString("hex") === "61006200";
      } catch (_) {
        return false;
      }
    }();
    function isSingleByte(val) {
      return val.length === 1 && val.charCodeAt(0) < 256;
    }
    function fillWithNumber(buffer, val, start, end) {
      if (start < 0 || end > buffer.length) {
        throw new RangeError("Out of range index");
      }
      start = start >>> 0;
      end = end === void 0 ? buffer.length : end >>> 0;
      if (end > start) {
        buffer.fill(val, start, end);
      }
      return buffer;
    }
    function fillWithBuffer(buffer, val, start, end) {
      if (start < 0 || end > buffer.length) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return buffer;
      }
      start = start >>> 0;
      end = end === void 0 ? buffer.length : end >>> 0;
      var pos = start;
      var len = val.length;
      while (pos <= end - len) {
        val.copy(buffer, pos);
        pos += len;
      }
      if (pos !== end) {
        val.copy(buffer, pos, 0, end - pos);
      }
      return buffer;
    }
    function fill(buffer, val, start, end, encoding) {
      if (hasFullSupport) {
        return buffer.fill(val, start, end, encoding);
      }
      if (typeof val === "number") {
        return fillWithNumber(buffer, val, start, end);
      }
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = buffer.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = buffer.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (encoding === "latin1") {
          encoding = "binary";
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val === "") {
          return fillWithNumber(buffer, 0, start, end);
        }
        if (isSingleByte(val)) {
          return fillWithNumber(buffer, val.charCodeAt(0), start, end);
        }
        val = new Buffer(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        return fillWithBuffer(buffer, val, start, end);
      }
      return fillWithNumber(buffer, 0, start, end);
    }
    module2.exports = fill;
  }
});

// node_modules/buffer-alloc-unsafe/index.js
var require_buffer_alloc_unsafe = __commonJS({
  "node_modules/buffer-alloc-unsafe/index.js"(exports2, module2) {
    function allocUnsafe(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
      }
      if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
      if (Buffer.allocUnsafe) {
        return Buffer.allocUnsafe(size);
      } else {
        return new Buffer(size);
      }
    }
    module2.exports = allocUnsafe;
  }
});

// node_modules/buffer-alloc/index.js
var require_buffer_alloc = __commonJS({
  "node_modules/buffer-alloc/index.js"(exports2, module2) {
    var bufferFill = require_buffer_fill();
    var allocUnsafe = require_buffer_alloc_unsafe();
    module2.exports = function alloc(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
      }
      if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
      if (Buffer.alloc) {
        return Buffer.alloc(size, fill, encoding);
      }
      var buffer = allocUnsafe(size);
      if (size === 0) {
        return buffer;
      }
      if (fill === void 0) {
        return bufferFill(buffer, 0);
      }
      if (typeof encoding !== "string") {
        encoding = void 0;
      }
      return bufferFill(buffer, fill, encoding);
    };
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports2, module2) {
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length >>>= 0;
        if (length > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      return isModern ? Buffer.from(value) : new Buffer(value);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/qrcode/lib/utils/buffer.js
var require_buffer = __commonJS({
  "node_modules/qrcode/lib/utils/buffer.js"(exports2, module2) {
    module2.exports.alloc = require_buffer_alloc();
    module2.exports.from = require_buffer_from();
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils4 = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports2) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports2.getSymbolSize = function getSymbolSize(version) {
      if (!version)
        throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    exports2.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    exports2.getBCHDigit = function(data) {
      var digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports2.setToSJISFunction = function setToSJISFunction(f) {
      if (typeof f !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f;
    };
    exports2.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports2.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports2) {
    exports2.L = { bit: 1 };
    exports2.M = { bit: 0 };
    exports2.Q = { bit: 3 };
    exports2.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports2.L;
        case "m":
        case "medium":
          return exports2.M;
        case "q":
        case "quartile":
          return exports2.Q;
        case "h":
        case "high":
          return exports2.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports2.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports2.from = function from(value, defaultValue) {
      if (exports2.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports2, module2) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        var bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (var i = 0; i < length; i++) {
          this.putBit((num >>> length - i - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module2.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports2, module2) {
    var BufferUtil = require_buffer();
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = BufferUtil.alloc(size * size);
      this.reservedBit = BufferUtil.alloc(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      var index = row * this.size + col;
      this.data[index] = value;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module2.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports2) {
    var getSymbolSize = require_utils4().getSymbolSize;
    exports2.getRowColCoords = function getRowColCoords(version) {
      if (version === 1)
        return [];
      var posCount = Math.floor(version / 7) + 2;
      var size = getSymbolSize(version);
      var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      var positions = [size - 7];
      for (var i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports2.getPositions = function getPositions(version) {
      var coords = [];
      var pos = exports2.getRowColCoords(version);
      var posLength = pos.length;
      for (var i = 0; i < posLength; i++) {
        for (var j = 0; j < posLength; j++) {
          if (i === 0 && j === 0 || i === 0 && j === posLength - 1 || i === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i], pos[j]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports2) {
    var getSymbolSize = require_utils4().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports2.getPositions = function getPositions(version) {
      var size = getSymbolSize(version);
      return [
        [0, 0],
        [size - FINDER_PATTERN_SIZE, 0],
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports2) {
    exports2.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports2.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports2.from = function from(value) {
      return exports2.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports2.getPenaltyN1 = function getPenaltyN1(data) {
      var size = data.size;
      var points = 0;
      var sameCountCol = 0;
      var sameCountRow = 0;
      var lastCol = null;
      var lastRow = null;
      for (var row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (var col = 0; col < size; col++) {
          var module3 = data.get(row, col);
          if (module3 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module3;
            sameCountCol = 1;
          }
          module3 = data.get(col, row);
          if (module3 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module3;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports2.getPenaltyN2 = function getPenaltyN2(data) {
      var size = data.size;
      var points = 0;
      for (var row = 0; row < size - 1; row++) {
        for (var col = 0; col < size - 1; col++) {
          var last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports2.getPenaltyN3 = function getPenaltyN3(data) {
      var size = data.size;
      var points = 0;
      var bitsCol = 0;
      var bitsRow = 0;
      for (var row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (var col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports2.getPenaltyN4 = function getPenaltyN4(data) {
      var darkCount = 0;
      var modulesCount = data.data.length;
      for (var i = 0; i < modulesCount; i++)
        darkCount += data.data[i];
      var k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i, j) {
      switch (maskPattern) {
        case exports2.Patterns.PATTERN000:
          return (i + j) % 2 === 0;
        case exports2.Patterns.PATTERN001:
          return i % 2 === 0;
        case exports2.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports2.Patterns.PATTERN011:
          return (i + j) % 3 === 0;
        case exports2.Patterns.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports2.Patterns.PATTERN101:
          return i * j % 2 + i * j % 3 === 0;
        case exports2.Patterns.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 === 0;
        case exports2.Patterns.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports2.applyMask = function applyMask(pattern, data) {
      var size = data.size;
      for (var col = 0; col < size; col++) {
        for (var row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports2.getBestMask = function getBestMask(data, setupFormatFunc) {
      var numPatterns = Object.keys(exports2.Patterns).length;
      var bestPattern = 0;
      var lowerPenalty = Infinity;
      for (var p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports2.applyMask(p, data);
        var penalty = exports2.getPenaltyN1(data) + exports2.getPenaltyN2(data) + exports2.getPenaltyN3(data) + exports2.getPenaltyN4(data);
        exports2.applyMask(p, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports2) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports2.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports2.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports2) {
    var BufferUtil = require_buffer();
    var EXP_TABLE = BufferUtil.alloc(512);
    var LOG_TABLE = BufferUtil.alloc(256);
    (function initTables() {
      var x = 1;
      for (var i = 0; i < 255; i++) {
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;
        x <<= 1;
        if (x & 256) {
          x ^= 285;
        }
      }
      for (i = 255; i < 512; i++) {
        EXP_TABLE[i] = EXP_TABLE[i - 255];
      }
    })();
    exports2.log = function log(n) {
      if (n < 1)
        throw new Error("log(" + n + ")");
      return LOG_TABLE[n];
    };
    exports2.exp = function exp(n) {
      return EXP_TABLE[n];
    };
    exports2.mul = function mul(x, y) {
      if (x === 0 || y === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports2) {
    var BufferUtil = require_buffer();
    var GF = require_galois_field();
    exports2.mul = function mul(p1, p2) {
      var coeff = BufferUtil.alloc(p1.length + p2.length - 1);
      for (var i = 0; i < p1.length; i++) {
        for (var j = 0; j < p2.length; j++) {
          coeff[i + j] ^= GF.mul(p1[i], p2[j]);
        }
      }
      return coeff;
    };
    exports2.mod = function mod(divident, divisor) {
      var result = BufferUtil.from(divident);
      while (result.length - divisor.length >= 0) {
        var coeff = result[0];
        for (var i = 0; i < divisor.length; i++) {
          result[i] ^= GF.mul(divisor[i], coeff);
        }
        var offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports2.generateECPolynomial = function generateECPolynomial(degree) {
      var poly = BufferUtil.from([1]);
      for (var i = 0; i < degree; i++) {
        poly = exports2.mul(poly, [1, GF.exp(i)]);
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports2, module2) {
    var BufferUtil = require_buffer();
    var Polynomial = require_polynomial();
    var Buffer3 = require("buffer").Buffer;
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode2(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      var pad = BufferUtil.alloc(this.degree);
      var paddedData = Buffer3.concat([data, pad], data.length + this.degree);
      var remainder = Polynomial.mod(paddedData, this.genPoly);
      var start = this.degree - remainder.length;
      if (start > 0) {
        var buff = BufferUtil.alloc(this.degree);
        remainder.copy(buff, start);
        return buff;
      }
      return remainder;
    };
    module2.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports2) {
    exports2.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports2) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports2.KANJI = new RegExp(kanji, "g");
    exports2.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports2.BYTE = new RegExp(byte, "g");
    exports2.NUMERIC = new RegExp(numeric, "g");
    exports2.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports2.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports2.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports2.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports2) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports2.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports2.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports2.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports2.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports2.MIXED = {
      bit: -1
    };
    exports2.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid version: " + version);
      }
      if (version >= 1 && version < 10)
        return mode.ccBits[0];
      else if (version < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports2.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports2.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports2.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports2.KANJI;
      else
        return exports2.BYTE;
    };
    exports2.toString = function toString(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports2.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      var lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports2.NUMERIC;
        case "alphanumeric":
          return exports2.ALPHANUMERIC;
        case "kanji":
          return exports2.KANJI;
        case "byte":
          return exports2.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports2.from = function from(value, defaultValue) {
      if (exports2.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports2) {
    var Utils = require_utils4();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var isArray = require_isarray();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version) {
      return Mode.getCharCountIndicator(mode, version) + 4;
    }
    function getTotalBitsFromDataArray(segments, version) {
      var totalBits = 0;
      segments.forEach(function(data) {
        var reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        var length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports2.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports2.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      var totalCodewords = Utils.getSymbolTotalCodewords(version);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports2.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      var seg;
      var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports2.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error("Invalid QR Code version");
      }
      var d = version << 12;
      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }
      return version << 12 | d;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports2) {
    var Utils = require_utils4();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports2.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      var data = errorCorrectionLevel.bit << 3 | mask;
      var d = data << 10;
      while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
      }
      return (data << 10 | d) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports2, module2) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      var i, group, value;
      for (i = 0; i + 3 <= this.data.length; i += 3) {
        group = this.data.substr(i, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      var remainingNum = this.data.length - i;
      if (remainingNum > 0) {
        group = this.data.substr(i);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module2.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports2, module2) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      var i;
      for (i = 0; i + 2 <= this.data.length; i += 2) {
        var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
      }
    };
    module2.exports = AlphanumericData;
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports2, module2) {
    var BufferUtil = require_buffer();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      this.data = BufferUtil.from(data);
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (var i = 0, l = this.data.length; i < l; i++) {
        bitBuffer.put(this.data[i], 8);
      }
    };
    module2.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports2, module2) {
    var Mode = require_mode();
    var Utils = require_utils4();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      var i;
      for (i = 0; i < this.data.length; i++) {
        var value = Utils.toSJIS(this.data[i]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error("Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8");
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module2.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports2, module2) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s, d) {
        var predecessors = {};
        var costs = {};
        costs[s] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s, 0);
        var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u] || {};
          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              cost_of_e = adjacent_nodes[v];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v];
              first_visit = typeof costs[v] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u;
              }
            }
          }
        }
        if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
          var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d) {
        var nodes = [];
        var u = d;
        var predecessor;
        while (u) {
          nodes.push(u);
          predecessor = predecessors[u];
          u = predecessors[u];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);
      },
      PriorityQueue: {
        make: function(opts) {
          var T = dijkstra.PriorityQueue, t = {}, key;
          opts = opts || {};
          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t[key] = T[key];
            }
          }
          t.queue = [];
          t.sorter = opts.sorter || T.default_sorter;
          return t;
        },
        default_sorter: function(a, b) {
          return a.cost - b.cost;
        },
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module2 !== "undefined") {
      module2.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports2) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils4();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      var segments = [];
      var result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      var byteSegs;
      var kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      var nodes = [];
      for (var i = 0; i < segs.length; i++) {
        var seg = segs[i];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version) {
      var table = {};
      var graph = { "start": {} };
      var prevNodeIds = ["start"];
      for (var i = 0; i < nodes.length; i++) {
        var nodeGroup = nodes[i];
        var currentNodeIds = [];
        for (var j = 0; j < nodeGroup.length; j++) {
          var node = nodeGroup[j];
          var key = "" + i + j;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (var n = 0; n < prevNodeIds.length; n++) {
            var prevNodeId = prevNodeIds[n];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]]["end"] = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      var mode;
      var bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports2.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports2.fromString = function fromString(data, version) {
      var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      var nodes = buildNodes(segs);
      var graph = buildGraph(nodes, version);
      var path = dijkstra.find_path(graph.map, "start", "end");
      var optimizedSegs = [];
      for (var i = 1; i < path.length - 1; i++) {
        optimizedSegs.push(graph.table[path[i]].node);
      }
      return exports2.fromArray(mergeSegments(optimizedSegs));
    };
    exports2.rawSplit = function rawSplit(data) {
      return exports2.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports2) {
    var BufferUtil = require_buffer();
    var Utils = require_utils4();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    var isArray = require_isarray();
    function setupFinderPattern(matrix, version) {
      var size = matrix.size;
      var pos = FinderPattern.getPositions(version);
      for (var i = 0; i < pos.length; i++) {
        var row = pos[i][0];
        var col = pos[i][1];
        for (var r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r)
            continue;
          for (var c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c)
              continue;
            if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      var size = matrix.size;
      for (var r = 8; r < size - 8; r++) {
        var value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version) {
      var pos = AlignmentPattern.getPositions(version);
      for (var i = 0; i < pos.length; i++) {
        var row = pos[i][0];
        var col = pos[i][1];
        for (var r = -2; r <= 2; r++) {
          for (var c = -2; c <= 2; c++) {
            if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version) {
      var size = matrix.size;
      var bits = Version.getEncodedBits(version);
      var row, col, mod;
      for (var i = 0; i < 18; i++) {
        row = Math.floor(i / 3);
        col = i % 3 + size - 8 - 3;
        mod = (bits >> i & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      var size = matrix.size;
      var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      var i, mod;
      for (i = 0; i < 15; i++) {
        mod = (bits >> i & 1) === 1;
        if (i < 6) {
          matrix.set(i, 8, mod, true);
        } else if (i < 8) {
          matrix.set(i + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i, 8, mod, true);
        }
        if (i < 8) {
          matrix.set(8, size - i - 1, mod, true);
        } else if (i < 9) {
          matrix.set(8, 15 - i - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      var size = matrix.size;
      var inc = -1;
      var row = size - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (var c = 0; c < 2; c++) {
            if (!matrix.isReserved(row, col - c)) {
              var dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version, errorCorrectionLevel, segments) {
      var buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        data.write(buffer);
      });
      var totalCodewords = Utils.getSymbolTotalCodewords(version);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (var i = 0; i < remainingByte; i++) {
        buffer.put(i % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      var totalCodewords = Utils.getSymbolTotalCodewords(version);
      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      var dataTotalCodewords = totalCodewords - ecTotalCodewords;
      var ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
      var blocksInGroup2 = totalCodewords % ecTotalBlocks;
      var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      var rs = new ReedSolomonEncoder(ecCount);
      var offset = 0;
      var dcData = new Array(ecTotalBlocks);
      var ecData = new Array(ecTotalBlocks);
      var maxDataSize = 0;
      var buffer = BufferUtil.from(bitBuffer.buffer);
      for (var b = 0; b < ecTotalBlocks; b++) {
        var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b] = buffer.slice(offset, offset + dataSize);
        ecData[b] = rs.encode(dcData[b]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      var data = BufferUtil.alloc(totalCodewords);
      var index = 0;
      var i, r;
      for (i = 0; i < maxDataSize; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i < dcData[r].length) {
            data[index++] = dcData[r][i];
          }
        }
      }
      for (i = 0; i < ecCount; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i];
        }
      }
      return data;
    }
    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      var segments;
      if (isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        var estimatedVersion = version;
        if (!estimatedVersion) {
          var rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      var bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version) {
        version = bestVersion;
      } else if (version < bestVersion) {
        throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
      }
      var dataBits = createData(version, errorCorrectionLevel, segments);
      var moduleCount = Utils.getSymbolSize(version);
      var modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version >= 7) {
        setupVersionInfo(modules, version);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports2.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      var errorCorrectionLevel = ECLevel.M;
      var version;
      var mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/pngjs/lib/chunkstream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var ChunkStream = module2.exports = function() {
      Stream.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      var dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = new Buffer(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read) {
      this._reads.shift();
      var smallerBuf = this._buffers[0];
      if (smallerBuf.length > read.length) {
        this._buffered -= read.length;
        this._buffers[0] = smallerBuf.slice(read.length);
        read.func.call(this, smallerBuf.slice(0, read.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read) {
      this._reads.shift();
      var pos = 0;
      var count = 0;
      var data = new Buffer(read.length);
      while (pos < read.length) {
        var buf = this._buffers[count++];
        var len = Math.min(buf.length, read.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read.length;
      read.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          var read = this._reads[0];
          if (read.allowLess) {
            this._processReadAllowingLess(read);
          } else if (this._buffered >= read.length) {
            this._processRead(read);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/pngjs/lib/interlace.js"(exports2) {
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports2.getImagePasses = function(width, height) {
      var images = [];
      var xLeftOver = width % 8;
      var yLeftOver = height % 8;
      var xRepeats = (width - xLeftOver) / 8;
      var yRepeats = (height - yLeftOver) / 8;
      for (var i = 0; i < imagePasses.length; i++) {
        var pass = imagePasses[i];
        var passWidth = xRepeats * pass.x.length;
        var passHeight = yRepeats * pass.y.length;
        for (var j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i });
        }
      }
      return images;
    };
    exports2.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        var outerXLeftOver = x % imagePasses[pass].x.length;
        var outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        var outerYLeftOver = y % imagePasses[pass].y.length;
        var outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/pngjs/lib/paeth-predictor.js"(exports2, module2) {
    "use strict";
    module2.exports = function paethPredictor(left, above, upLeft) {
      var paeth = left + above - upLeft;
      var pLeft = Math.abs(paeth - left);
      var pAbove = Math.abs(paeth - above);
      var pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/pngjs/lib/filter-parse.js"(exports2, module2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      var byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module2.exports = function(bitmapInfo, dependencies) {
      var width = bitmapInfo.width;
      var height = bitmapInfo.height;
      var interlace = bitmapInfo.interlace;
      var bpp = bitmapInfo.bpp;
      var depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        var passes = interlaceUtils.getImagePasses(width, height);
        for (var i = 0; i < passes.length; i++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i].width, bpp, depth),
            height: passes[i].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f3Up = lastLine ? lastLine[x] : 0;
        var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        var f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      var xComparison = this._xComparison;
      var xBiggerThan = xComparison - 1;
      var lastLine = this._lastLine;
      for (var x = 0; x < byteWidth; x++) {
        var rawByte = rawData[1 + x];
        var f4Up = lastLine ? lastLine[x] : 0;
        var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      var filter = rawData[0];
      var unfilteredLine;
      var currentImage = this._images[this._imageIndex];
      var byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = new Buffer(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/pngjs/lib/filter-parse-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module2.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      var buffers = [];
      var that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/pngjs/lib/constants.js
var require_constants6 = __commonJS({
  "node_modules/pngjs/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/pngjs/lib/crc.js"(exports2, module2) {
    "use strict";
    var crcTable = [];
    (function() {
      for (var i = 0; i < 256; i++) {
        var currentCrc = i;
        for (var j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i] = currentCrc;
      }
    })();
    var CrcCalculator = module2.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (var i = 0; i < data.length; i++) {
        this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      var crc = -1;
      for (var i = 0; i < buf.length; i++) {
        crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/pngjs/lib/parser.js
var require_parser = __commonJS({
  "node_modules/pngjs/lib/parser.js"(exports2, module2) {
    "use strict";
    var constants = require_constants6();
    var CrcCalculator = require_crc();
    var Parser = module2.exports = function(options, dependencies) {
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      var signature = constants.PNG_SIGNATURE;
      for (var i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      var length = data.readUInt32BE(0);
      var type = data.readUInt32BE(4);
      var name = "";
      for (var i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }
      var ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(new Buffer(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      var fileCrc = data.readInt32BE(0);
      var calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      var width = data.readUInt32BE(0);
      var height = data.readUInt32BE(4);
      var depth = data[8];
      var colorType = data[9];
      var compr = data[10];
      var filter = data[11];
      var interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      var entries = Math.floor(data.length / 3);
      for (var i = 0; i < entries; i++) {
        this._palette.push([
          data[i * 3],
          data[i * 3 + 1],
          data[i * 3 + 2],
          255
        ]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (var i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      var leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/pngjs/lib/bitmapper.js"(exports2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      function() {
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        var pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        var pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      function() {
      },
      function(pxData, pixelData, pxPos, maxBit) {
        var pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        var pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      var leftOver = [];
      var i = 0;
      function split() {
        if (i === data.length) {
          throw new Error("Ran out of data");
        }
        var byte = data[i];
        i++;
        var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i];
            i++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          var returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
      var imageWidth = image.width;
      var imageHeight = image.height;
      var imagePass = image.index;
      for (var y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
          var pxPos = getPxPos(x, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
      var imageWidth = image.width;
      var imageHeight = image.height;
      var imagePass = image.index;
      for (var y = 0; y < imageHeight; y++) {
        for (var x = 0; x < imageWidth; x++) {
          var pixelData = bits.get(bpp);
          var pxPos = getPxPos(x, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports2.dataToBitMap = function(data, bitmapInfo) {
      var width = bitmapInfo.width;
      var height = bitmapInfo.height;
      var depth = bitmapInfo.depth;
      var bpp = bitmapInfo.bpp;
      var interlace = bitmapInfo.interlace;
      if (depth !== 8) {
        var bits = bitRetriever(data, depth);
      }
      var pxData;
      if (depth <= 8) {
        pxData = new Buffer(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      var maxBit = Math.pow(2, depth) - 1;
      var rawPos = 0;
      var images;
      var getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        var nonInterlacedPxPos = 0;
        getPxPos = function() {
          var returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/pngjs/lib/format-normaliser.js"(exports2, module2) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = color[i];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (var i = 0; i < 4; i++) {
              outdata[pxPos + i] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      var maxOutSample = 255;
      var maxInSample = Math.pow(2, depth) - 1;
      var pxPos = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          for (var i = 0; i < 4; i++) {
            outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module2.exports = function(indata, imageData) {
      var depth = imageData.depth;
      var width = imageData.width;
      var height = imageData.height;
      var colorType = imageData.colorType;
      var transColor = imageData.transColor;
      var palette = imageData.palette;
      var outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = new Buffer(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/pngjs/lib/parser-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var zlib = require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module2.exports = function(options) {
      ChunkStream.call(this);
      this._parser = new Parser(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          var rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          var imageSize = rowSize * this._bitmapInfo.height;
          var chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
          this._inflate = zlib.createInflate({ chunkSize });
          var leftToInflate = imageSize;
          var emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          var filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
      this.destroySoon();
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      try {
        var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/pngjs/lib/bitpacker.js"(exports2, module2) {
    "use strict";
    var constants = require_constants6();
    module2.exports = function(dataIn, width, height, options) {
      var outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
      if (options.colorType === options.inputColorType) {
        var bigEndian = function() {
          var buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      var data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      var maxValue = 255;
      var inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
      if (inBpp === 4 && !options.inputHasAlpha) {
        inBpp = 3;
      }
      var outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
      if (options.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      var outData = new Buffer(width * height * outBpp);
      var inIndex = 0;
      var outIndex = 0;
      var bgColor = options.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        var red;
        var green;
        var blue;
        var alpha = maxValue;
        switch (options.inputColorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error("input color type:" + options.inputColorType + " is not supported at present");
        }
        if (options.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
          }
        }
        return { red, green, blue, alpha };
      }
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var rgba = getRGBA(data, inIndex);
          switch (options.colorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
            case constants.COLORTYPE_COLOR:
              if (options.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants.COLORTYPE_ALPHA:
            case constants.COLORTYPE_GRAYSCALE:
              var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            default:
              throw new Error("unrecognised color Type " + options.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/pngjs/lib/filter-pack.js"(exports2, module2) {
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (var x = 0; x < byteWidth; x++) {
        rawData[rawPos + x] = pxData[pxPos + x];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      var sum = 0;
      var length = pxPos + byteWidth;
      for (var i = pxPos; i < length; i++) {
        sum += Math.abs(pxData[i]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var val = pxData[pxPos + x] - left;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var val = pxData[pxPos + x] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (var x = 0; x < byteWidth; x++) {
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - up;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      var sum = 0;
      var length = pxPos + byteWidth;
      for (var x = pxPos; x < length; x++) {
        var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        var val = pxData[x] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - (left + up >> 1);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var val = pxData[pxPos + x] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      var sum = 0;
      for (var x = 0; x < byteWidth; x++) {
        var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module2.exports = function(pxData, width, height, options, bpp) {
      var filterTypes;
      if (!("filterType" in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options.filterType === "number") {
        filterTypes = [options.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options.bitDepth === 16) {
        bpp *= 2;
      }
      var byteWidth = width * bpp;
      var rawPos = 0;
      var pxPos = 0;
      var rawData = new Buffer((byteWidth + 1) * height);
      var sel = filterTypes[0];
      for (var y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          var min = Infinity;
          for (var i = 0; i < filterTypes.length; i++) {
            var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/pngjs/lib/packer.js"(exports2, module2) {
    "use strict";
    var constants = require_constants6();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib = require("zlib");
    var Packer = module2.exports = function(options) {
      this._options = options;
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
      options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.colorType) === -1) {
        throw new Error("option color type:" + options.colorType + " is not supported at present");
      }
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.inputColorType) === -1) {
        throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.bitDepth !== 8 && options.bitDepth !== 16) {
        throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      var packedData = bitPacker(data, width, height, this._options);
      var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      var filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      var len = data ? data.length : 0;
      var buf = new Buffer(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      var buf = new Buffer(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      var buf = new Buffer(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/pngjs/lib/packer-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var constants = require_constants6();
    var Packer = require_packer();
    var PackerAsync = module2.exports = function(opt) {
      Stream.call(this);
      var options = opt || {};
      this._packer = new Packer(options);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", new Buffer(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      var filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/pngjs/lib/sync-inflate.js"(exports2, module2) {
    "use strict";
    var assert = require("assert").ok;
    var zlib = require("zlib");
    var util = require("util");
    var kMaxLength = require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
        opts.chunkSize = zlib.Z_MIN_CHUNK;
      }
      zlib.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      var self2 = this;
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var leftToInflate = this._maxLength;
      var inOff = 0;
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(err) {
        error = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        var have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      var buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate, zlib.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      var flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module2.exports = exports2 = inflateSync;
    exports2.Inflate = Inflate;
    exports2.createInflate = createInflate;
    exports2.inflateSync = inflateSync;
  }
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/pngjs/lib/sync-reader.js"(exports2, module2) {
    "use strict";
    var SyncReader = module2.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        var read = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
          this._reads.shift();
          var buf = this._buffer;
          this._buffer = buf.slice(read.length);
          read.func.call(this, buf.slice(0, read.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/pngjs/lib/filter-parse-sync.js"(exports2) {
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports2.process = function(inBuffer, bitmapInfo) {
      var outBuffers = [];
      var reader = new SyncReader(inBuffer);
      var filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/pngjs/lib/parser-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib = require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module2.exports = function(buffer, options) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      var err;
      function handleError(_err_) {
        err = _err_;
      }
      var metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      var gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      var inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      var reader = new SyncReader(buffer);
      var parser = new Parser(options, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      var inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      var inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib.inflateSync(inflateData);
      } else {
        var rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        var imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, { chunkSize: imageSize, maxLength: imageSize });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      var unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      var normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/pngjs/lib/packer-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib = require("zlib");
    if (!zlib.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants6();
    var Packer = require_packer();
    module2.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      var options = opt || {};
      var packer = new Packer(options);
      var chunks = [];
      chunks.push(new Buffer(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      var compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/pngjs/lib/png-sync.js"(exports2) {
    "use strict";
    var parse = require_parser_sync();
    var pack = require_packer_sync();
    exports2.read = function(buffer, options) {
      return parse(buffer, options || {});
    };
    exports2.write = function(png, options) {
      return pack(png, options);
    };
  }
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/pngjs/lib/png.js"(exports2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports2.PNG = function(options) {
      Stream.call(this);
      options = options || {};
      this.width = options.width | 0;
      this.height = options.height | 0;
      this.data = this.width > 0 && this.height > 0 ? new Buffer(4 * this.width * this.height) : null;
      if (options.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG, Stream);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        var onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (var y = 0; y < height; y++) {
        src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src) {
      if (src.gamma) {
        for (var y = 0; y < src.height; y++) {
          for (var x = 0; x < src.width; x++) {
            var idx = src.width * y + x << 2;
            for (var i = 0; i < 3; i++) {
              var sample = src.data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils5 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports2) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      var hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
          return [c, c];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      var hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports2.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      var width = options.width && options.width >= 21 ? options.width : void 0;
      var scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports2.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports2.getImageWidth = function getImageWidth(qrSize, opts) {
      var scale = exports2.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
      var size = qr.modules.size;
      var data = qr.modules.data;
      var scale = exports2.getScale(size, opts);
      var symbolSize = Math.floor((size + opts.margin * 2) * scale);
      var scaledMargin = opts.margin * scale;
      var palette = [opts.color.light, opts.color.dark];
      for (var i = 0; i < symbolSize; i++) {
        for (var j = 0; j < symbolSize; j++) {
          var posDst = (i * symbolSize + j) * 4;
          var pxColor = opts.color.light;
          if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            var iSrc = Math.floor((i - scaledMargin) / scale);
            var jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/png.js
var require_png2 = __commonJS({
  "node_modules/qrcode/lib/renderer/png.js"(exports2) {
    var fs = require("fs");
    var PNG = require_png().PNG;
    var Utils = require_utils5();
    exports2.render = function render(qrData, options) {
      var opts = Utils.getOptions(options);
      var pngOpts = opts.rendererOpts;
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      pngOpts.width = size;
      pngOpts.height = size;
      var pngImage = new PNG(pngOpts);
      Utils.qrToImageData(pngImage.data, qrData, opts);
      return pngImage;
    };
    exports2.renderToDataURL = function renderToDataURL(qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      exports2.renderToBuffer(qrData, options, function(err, output) {
        if (err)
          cb(err);
        var url = "data:image/png;base64,";
        url += output.toString("base64");
        cb(null, url);
      });
    };
    exports2.renderToBuffer = function renderToBuffer(qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      var png = exports2.render(qrData, options);
      var buffer = [];
      png.on("error", cb);
      png.on("data", function(data) {
        buffer.push(data);
      });
      png.on("end", function() {
        cb(null, Buffer.concat(buffer));
      });
      png.pack();
    };
    exports2.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      var stream = fs.createWriteStream(path);
      stream.on("error", cb);
      stream.on("close", cb);
      exports2.renderToFileStream(stream, qrData, options);
    };
    exports2.renderToFileStream = function renderToFileStream(stream, qrData, options) {
      var png = exports2.render(qrData, options);
      png.pack().pipe(stream);
    };
  }
});

// node_modules/qrcode/lib/renderer/utf8.js
var require_utf82 = __commonJS({
  "node_modules/qrcode/lib/renderer/utf8.js"(exports2) {
    var Utils = require_utils5();
    var BLOCK_CHAR = {
      WW: " ",
      WB: "\u2584",
      BB: "\u2588",
      BW: "\u2580"
    };
    var INVERTED_BLOCK_CHAR = {
      BB: " ",
      BW: "\u2584",
      WW: "\u2588",
      WB: "\u2580"
    };
    function getBlockChar(top, bottom, blocks2) {
      if (top && bottom)
        return blocks2.BB;
      if (top && !bottom)
        return blocks2.BW;
      if (!top && bottom)
        return blocks2.WB;
      return blocks2.WW;
    }
    exports2.render = function(qrData, options, cb) {
      var opts = Utils.getOptions(options);
      var blocks2 = BLOCK_CHAR;
      if (opts.color.dark.hex === "#ffffff" || opts.color.light.hex === "#000000") {
        blocks2 = INVERTED_BLOCK_CHAR;
      }
      var size = qrData.modules.size;
      var data = qrData.modules.data;
      var output = "";
      var hMargin = Array(size + opts.margin * 2 + 1).join(blocks2.WW);
      hMargin = Array(opts.margin / 2 + 1).join(hMargin + "\n");
      var vMargin = Array(opts.margin + 1).join(blocks2.WW);
      output += hMargin;
      for (var i = 0; i < size; i += 2) {
        output += vMargin;
        for (var j = 0; j < size; j++) {
          var topModule = data[i * size + j];
          var bottomModule = data[(i + 1) * size + j];
          output += getBlockChar(topModule, bottomModule, blocks2);
        }
        output += vMargin + "\n";
      }
      output += hMargin.slice(0, -1);
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
    exports2.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      var fs = require("fs");
      var utf8 = exports2.render(qrData, options);
      fs.writeFile(path, utf8, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/terminal.js
var require_terminal = __commonJS({
  "node_modules/qrcode/lib/renderer/terminal.js"(exports2) {
    exports2.render = function(qrData, options, cb) {
      var size = qrData.modules.size;
      var data = qrData.modules.data;
      var black = "\x1B[40m  \x1B[0m";
      var white = "\x1B[47m  \x1B[0m";
      var output = "";
      var hMargin = Array(size + 3).join(white);
      var vMargin = Array(2).join(white);
      output += hMargin + "\n";
      for (var i = 0; i < size; ++i) {
        output += white;
        for (var j = 0; j < size; j++) {
          output += data[i * size + j] ? black : white;
        }
        output += vMargin + "\n";
      }
      output += hMargin + "\n";
      if (typeof cb === "function") {
        cb(null, output);
      }
      return output;
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports2) {
    var Utils = require_utils5();
    function getColorAttrib(color, attrib) {
      var alpha = color.a / 255;
      var str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x, y) {
      var str = cmd + x;
      if (typeof y !== "undefined")
        str += " " + y;
      return str;
    }
    function qrToPath(data, size, margin) {
      var path = "";
      var moveBy = 0;
      var newRow = false;
      var lineLength = 0;
      for (var i = 0; i < data.length; i++) {
        var col = Math.floor(i % size);
        var row = Math.floor(i / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i]) {
          lineLength++;
          if (!(i > 0 && col > 0 && data[i - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports2.render = function render(qrData, options, cb) {
      var opts = Utils.getOptions(options);
      var size = qrData.modules.size;
      var data = qrData.modules.data;
      var qrcodesize = size + opts.margin * 2;
      var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      var path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/renderer/svg.js
var require_svg = __commonJS({
  "node_modules/qrcode/lib/renderer/svg.js"(exports2) {
    var svgTagRenderer = require_svg_tag();
    exports2.render = svgTagRenderer.render;
    exports2.renderToFile = function renderToFile(path, qrData, options, cb) {
      if (typeof cb === "undefined") {
        cb = options;
        options = void 0;
      }
      var fs = require("fs");
      var svgTag = exports2.render(qrData, options);
      var xmlStr = '<?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">' + svgTag;
      fs.writeFile(path, xmlStr, cb);
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports2) {
    var Utils = require_utils5();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports2.render = function render(qrData, canvas, options) {
      var opts = options;
      var canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      var ctx = canvasEl.getContext("2d");
      var image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports2.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      var opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      var canvasEl = exports2.render(qrData, canvas, opts);
      var type = opts.type || "image/png";
      var rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser3 = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports2) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      var args = [].slice.call(arguments, 1);
      var argsNum = args.length;
      var isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            var data2 = QRCode.create(text, opts);
            resolve(renderFunc(data2, canvas, opts));
          } catch (e) {
            reject(e);
          }
        });
      }
      try {
        var data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e) {
        cb(e);
      }
    }
    exports2.create = QRCode.create;
    exports2.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports2.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports2.toString = renderCanvas.bind(null, function(data, _, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/qrcode/lib/server.js
var require_server = __commonJS({
  "node_modules/qrcode/lib/server.js"(exports2) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var PngRenderer = require_png2();
    var Utf8Renderer = require_utf82();
    var TerminalRenderer = require_terminal();
    var SvgRenderer = require_svg();
    function checkParams(text, opts, cb) {
      if (typeof text === "undefined") {
        throw new Error("String required as first argument");
      }
      if (typeof cb === "undefined") {
        cb = opts;
        opts = {};
      }
      if (typeof cb !== "function") {
        if (!canPromise()) {
          throw new Error("Callback required as last argument");
        } else {
          opts = cb || {};
          cb = null;
        }
      }
      return {
        opts,
        cb
      };
    }
    function getTypeFromFilename(path) {
      return path.slice((path.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
    }
    function getRendererFromType(type) {
      switch (type) {
        case "svg":
          return SvgRenderer;
        case "txt":
        case "utf8":
          return Utf8Renderer;
        case "png":
        case "image/png":
        default:
          return PngRenderer;
      }
    }
    function getStringRendererFromType(type) {
      switch (type) {
        case "svg":
          return SvgRenderer;
        case "terminal":
          return TerminalRenderer;
        case "utf8":
        default:
          return Utf8Renderer;
      }
    }
    function render(renderFunc, text, params) {
      if (!params.cb) {
        return new Promise(function(resolve, reject) {
          try {
            var data2 = QRCode.create(text, params.opts);
            return renderFunc(data2, params.opts, function(err, data3) {
              return err ? reject(err) : resolve(data3);
            });
          } catch (e) {
            reject(e);
          }
        });
      }
      try {
        var data = QRCode.create(text, params.opts);
        return renderFunc(data, params.opts, params.cb);
      } catch (e) {
        params.cb(e);
      }
    }
    exports2.create = QRCode.create;
    exports2.toCanvas = require_browser3().toCanvas;
    exports2.toString = function toString(text, opts, cb) {
      var params = checkParams(text, opts, cb);
      var renderer = getStringRendererFromType(params.opts.type);
      return render(renderer.render, text, params);
    };
    exports2.toDataURL = function toDataURL(text, opts, cb) {
      var params = checkParams(text, opts, cb);
      var renderer = getRendererFromType(params.opts.type);
      return render(renderer.renderToDataURL, text, params);
    };
    exports2.toBuffer = function toBuffer(text, opts, cb) {
      var params = checkParams(text, opts, cb);
      var renderer = getRendererFromType(params.opts.type);
      return render(renderer.renderToBuffer, text, params);
    };
    exports2.toFile = function toFile(path, text, opts, cb) {
      if (typeof path !== "string" || !(typeof text === "string" || typeof text === "object")) {
        throw new Error("Invalid argument");
      }
      if (arguments.length < 3 && !canPromise()) {
        throw new Error("Too few arguments provided");
      }
      var params = checkParams(text, opts, cb);
      var type = params.opts.type || getTypeFromFilename(path);
      var renderer = getRendererFromType(type);
      var renderToFile = renderer.renderToFile.bind(null, path);
      return render(renderToFile, text, params);
    };
    exports2.toFileStream = function toFileStream(stream, text, opts) {
      if (arguments.length < 2) {
        throw new Error("Too few arguments provided");
      }
      var params = checkParams(text, opts, stream.emit.bind(stream, "error"));
      var renderer = getRendererFromType("png");
      var renderToFileStream = renderer.renderToFileStream.bind(null, stream);
      render(renderToFileStream, text, params);
    };
  }
});

// node_modules/qrcode/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/qrcode/lib/index.js"(exports2, module2) {
    module2.exports = require_server();
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports2, module2) {
    module2.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports2, module2) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e) {
          e.stopPropagation();
          if (options.format) {
            e.preventDefault();
            if (typeof e.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e.clipboardData.clearData();
              e.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e.preventDefault();
            options.onCopy(e.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module2.exports = copy;
  }
});

// node_modules/preact/dist/preact.js
var require_preact = __commonJS({
  "node_modules/preact/dist/preact.js"(exports2) {
    var n, l, u, t, i, r, o, f, e = {}, c = [], s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    function a(n2, l2) {
      for (var u2 in l2)
        n2[u2] = l2[u2];
      return n2;
    }
    function p(n2) {
      var l2 = n2.parentNode;
      l2 && l2.removeChild(n2);
    }
    function v(n2, l2, u2) {
      var t2, i2 = arguments, r2 = {};
      for (t2 in l2)
        t2 !== "key" && t2 !== "ref" && (r2[t2] = l2[t2]);
      if (arguments.length > 3)
        for (u2 = [u2], t2 = 3; t2 < arguments.length; t2++)
          u2.push(i2[t2]);
      if (u2 != null && (r2.children = u2), typeof n2 == "function" && n2.defaultProps != null)
        for (t2 in n2.defaultProps)
          r2[t2] === void 0 && (r2[t2] = n2.defaultProps[t2]);
      return h(n2, r2, l2 && l2.key, l2 && l2.ref, null);
    }
    function h(l2, u2, t2, i2, r2) {
      var o2 = { type: l2, props: u2, key: t2, ref: i2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r2 };
      return r2 == null && (o2.__v = o2), n.vnode && n.vnode(o2), o2;
    }
    function y(n2) {
      return n2.children;
    }
    function d(n2, l2) {
      this.props = n2, this.context = l2;
    }
    function x(n2, l2) {
      if (l2 == null)
        return n2.__ ? x(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
      for (var u2; l2 < n2.__k.length; l2++)
        if ((u2 = n2.__k[l2]) != null && u2.__e != null)
          return u2.__e;
      return typeof n2.type == "function" ? x(n2) : null;
    }
    function m(n2) {
      var l2, u2;
      if ((n2 = n2.__) != null && n2.__c != null) {
        for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
          if ((u2 = n2.__k[l2]) != null && u2.__e != null) {
            n2.__e = n2.__c.base = u2.__e;
            break;
          }
        return m(n2);
      }
    }
    function w(l2) {
      (!l2.__d && (l2.__d = true) && u.push(l2) && !t++ || r !== n.debounceRendering) && ((r = n.debounceRendering) || i)(k);
    }
    function k() {
      for (var n2; t = u.length; )
        n2 = u.sort(function(n3, l2) {
          return n3.__v.__b - l2.__v.__b;
        }), u = [], n2.some(function(n3) {
          var l2, u2, t2, i2, r2, o2, f2;
          n3.__d && (o2 = (r2 = (l2 = n3).__v).__e, (f2 = l2.__P) && (u2 = [], (t2 = a({}, r2)).__v = t2, i2 = z(f2, r2, t2, l2.__n, f2.ownerSVGElement !== void 0, null, u2, o2 == null ? x(r2) : o2), A(u2, r2), i2 != o2 && m(r2)));
        });
    }
    function g(n2, l2, u2, t2, i2, r2, o2, f2, s2) {
      var a2, v2, h2, y2, d2, m2, w2, k2 = u2 && u2.__k || c, g2 = k2.length;
      if (f2 == e && (f2 = r2 != null ? r2[0] : g2 ? x(u2, 0) : null), a2 = 0, l2.__k = _(l2.__k, function(u3) {
        if (u3 != null) {
          if (u3.__ = l2, u3.__b = l2.__b + 1, (h2 = k2[a2]) === null || h2 && u3.key == h2.key && u3.type === h2.type)
            k2[a2] = void 0;
          else
            for (v2 = 0; v2 < g2; v2++) {
              if ((h2 = k2[v2]) && u3.key == h2.key && u3.type === h2.type) {
                k2[v2] = void 0;
                break;
              }
              h2 = null;
            }
          if (y2 = z(n2, u3, h2 = h2 || e, t2, i2, r2, o2, f2, s2), (v2 = u3.ref) && h2.ref != v2 && (w2 || (w2 = []), h2.ref && w2.push(h2.ref, null, u3), w2.push(v2, u3.__c || y2, u3)), y2 != null) {
            var c2;
            if (m2 == null && (m2 = y2), u3.__d !== void 0)
              c2 = u3.__d, u3.__d = void 0;
            else if (r2 == h2 || y2 != f2 || y2.parentNode == null) {
              n:
                if (f2 == null || f2.parentNode !== n2)
                  n2.appendChild(y2), c2 = null;
                else {
                  for (d2 = f2, v2 = 0; (d2 = d2.nextSibling) && v2 < g2; v2 += 2)
                    if (d2 == y2)
                      break n;
                  n2.insertBefore(y2, f2), c2 = f2;
                }
              l2.type == "option" && (n2.value = "");
            }
            f2 = c2 !== void 0 ? c2 : y2.nextSibling, typeof l2.type == "function" && (l2.__d = f2);
          } else
            f2 && h2.__e == f2 && f2.parentNode != n2 && (f2 = x(h2));
        }
        return a2++, u3;
      }), l2.__e = m2, r2 != null && typeof l2.type != "function")
        for (a2 = r2.length; a2--; )
          r2[a2] != null && p(r2[a2]);
      for (a2 = g2; a2--; )
        k2[a2] != null && j(k2[a2], k2[a2]);
      if (w2)
        for (a2 = 0; a2 < w2.length; a2++)
          $(w2[a2], w2[++a2], w2[++a2]);
    }
    function _(n2, l2, u2) {
      if (u2 == null && (u2 = []), n2 == null || typeof n2 == "boolean")
        l2 && u2.push(l2(null));
      else if (Array.isArray(n2))
        for (var t2 = 0; t2 < n2.length; t2++)
          _(n2[t2], l2, u2);
      else
        u2.push(l2 ? l2(typeof n2 == "string" || typeof n2 == "number" ? h(null, n2, null, null, n2) : n2.__e != null || n2.__c != null ? h(n2.type, n2.props, n2.key, null, n2.__v) : n2) : n2);
      return u2;
    }
    function b(n2, l2, u2, t2, i2) {
      var r2;
      for (r2 in u2)
        r2 === "children" || r2 === "key" || r2 in l2 || C(n2, r2, null, u2[r2], t2);
      for (r2 in l2)
        i2 && typeof l2[r2] != "function" || r2 === "children" || r2 === "key" || r2 === "value" || r2 === "checked" || u2[r2] === l2[r2] || C(n2, r2, l2[r2], u2[r2], t2);
    }
    function P(n2, l2, u2) {
      l2[0] === "-" ? n2.setProperty(l2, u2) : n2[l2] = typeof u2 == "number" && s.test(l2) === false ? u2 + "px" : u2 == null ? "" : u2;
    }
    function C(n2, l2, u2, t2, i2) {
      var r2, o2, f2, e2, c2;
      if (i2 ? l2 === "className" && (l2 = "class") : l2 === "class" && (l2 = "className"), l2 === "style")
        if (r2 = n2.style, typeof u2 == "string")
          r2.cssText = u2;
        else {
          if (typeof t2 == "string" && (r2.cssText = "", t2 = null), t2)
            for (e2 in t2)
              u2 && e2 in u2 || P(r2, e2, "");
          if (u2)
            for (c2 in u2)
              t2 && u2[c2] === t2[c2] || P(r2, c2, u2[c2]);
        }
      else
        l2[0] === "o" && l2[1] === "n" ? (o2 = l2 !== (l2 = l2.replace(/Capture$/, "")), f2 = l2.toLowerCase(), l2 = (f2 in n2 ? f2 : l2).slice(2), u2 ? (t2 || n2.addEventListener(l2, N, o2), (n2.l || (n2.l = {}))[l2] = u2) : n2.removeEventListener(l2, N, o2)) : l2 !== "list" && l2 !== "tagName" && l2 !== "form" && l2 !== "type" && l2 !== "size" && !i2 && l2 in n2 ? n2[l2] = u2 == null ? "" : u2 : typeof u2 != "function" && l2 !== "dangerouslySetInnerHTML" && (l2 !== (l2 = l2.replace(/^xlink:?/, "")) ? u2 == null || u2 === false ? n2.removeAttributeNS("http://www.w3.org/1999/xlink", l2.toLowerCase()) : n2.setAttributeNS("http://www.w3.org/1999/xlink", l2.toLowerCase(), u2) : u2 == null || u2 === false && !/^ar/.test(l2) ? n2.removeAttribute(l2) : n2.setAttribute(l2, u2));
    }
    function N(l2) {
      this.l[l2.type](n.event ? n.event(l2) : l2);
    }
    function z(l2, u2, t2, i2, r2, o2, f2, e2, c2) {
      var s2, p2, v2, h2, x2, m2, w2, k2, _2, b2, P2 = u2.type;
      if (u2.constructor !== void 0)
        return null;
      (s2 = n.__b) && s2(u2);
      try {
        n:
          if (typeof P2 == "function") {
            if (k2 = u2.props, _2 = (s2 = P2.contextType) && i2[s2.__c], b2 = s2 ? _2 ? _2.props.value : s2.__ : i2, t2.__c ? w2 = (p2 = u2.__c = t2.__c).__ = p2.__E : ("prototype" in P2 && P2.prototype.render ? u2.__c = p2 = new P2(k2, b2) : (u2.__c = p2 = new d(k2, b2), p2.constructor = P2, p2.render = D), _2 && _2.sub(p2), p2.props = k2, p2.state || (p2.state = {}), p2.context = b2, p2.__n = i2, v2 = p2.__d = true, p2.__h = []), p2.__s == null && (p2.__s = p2.state), P2.getDerivedStateFromProps != null && (p2.__s == p2.state && (p2.__s = a({}, p2.__s)), a(p2.__s, P2.getDerivedStateFromProps(k2, p2.__s))), h2 = p2.props, x2 = p2.state, v2)
              P2.getDerivedStateFromProps == null && p2.componentWillMount != null && p2.componentWillMount(), p2.componentDidMount != null && p2.__h.push(p2.componentDidMount);
            else {
              if (P2.getDerivedStateFromProps == null && k2 !== h2 && p2.componentWillReceiveProps != null && p2.componentWillReceiveProps(k2, b2), !p2.__e && p2.shouldComponentUpdate != null && p2.shouldComponentUpdate(k2, p2.__s, b2) === false || u2.__v === t2.__v && !p2.__) {
                for (p2.props = k2, p2.state = p2.__s, u2.__v !== t2.__v && (p2.__d = false), p2.__v = u2, u2.__e = t2.__e, u2.__k = t2.__k, p2.__h.length && f2.push(p2), s2 = 0; s2 < u2.__k.length; s2++)
                  u2.__k[s2] && (u2.__k[s2].__ = u2);
                break n;
              }
              p2.componentWillUpdate != null && p2.componentWillUpdate(k2, p2.__s, b2), p2.componentDidUpdate != null && p2.__h.push(function() {
                p2.componentDidUpdate(h2, x2, m2);
              });
            }
            p2.context = b2, p2.props = k2, p2.state = p2.__s, (s2 = n.__r) && s2(u2), p2.__d = false, p2.__v = u2, p2.__P = l2, s2 = p2.render(p2.props, p2.state, p2.context), u2.__k = s2 != null && s2.type == y && s2.key == null ? s2.props.children : Array.isArray(s2) ? s2 : [s2], p2.getChildContext != null && (i2 = a(a({}, i2), p2.getChildContext())), v2 || p2.getSnapshotBeforeUpdate == null || (m2 = p2.getSnapshotBeforeUpdate(h2, x2)), g(l2, u2, t2, i2, r2, o2, f2, e2, c2), p2.base = u2.__e, p2.__h.length && f2.push(p2), w2 && (p2.__E = p2.__ = null), p2.__e = false;
          } else
            o2 == null && u2.__v === t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : u2.__e = T(t2.__e, u2, t2, i2, r2, o2, f2, c2);
        (s2 = n.diffed) && s2(u2);
      } catch (l3) {
        u2.__v = null, n.__e(l3, u2, t2);
      }
      return u2.__e;
    }
    function A(l2, u2) {
      n.__c && n.__c(u2, l2), l2.some(function(u3) {
        try {
          l2 = u3.__h, u3.__h = [], l2.some(function(n2) {
            n2.call(u3);
          });
        } catch (l3) {
          n.__e(l3, u3.__v);
        }
      });
    }
    function T(n2, l2, u2, t2, i2, r2, o2, f2) {
      var s2, a2, p2, v2, h2, y2 = u2.props, d2 = l2.props;
      if (i2 = l2.type === "svg" || i2, r2 != null) {
        for (s2 = 0; s2 < r2.length; s2++)
          if ((a2 = r2[s2]) != null && ((l2.type === null ? a2.nodeType === 3 : a2.localName === l2.type) || n2 == a2)) {
            n2 = a2, r2[s2] = null;
            break;
          }
      }
      if (n2 == null) {
        if (l2.type === null)
          return document.createTextNode(d2);
        n2 = i2 ? document.createElementNS("http://www.w3.org/2000/svg", l2.type) : document.createElement(l2.type, d2.is && { is: d2.is }), r2 = null, f2 = false;
      }
      if (l2.type === null)
        y2 !== d2 && n2.data != d2 && (n2.data = d2);
      else {
        if (r2 != null && (r2 = c.slice.call(n2.childNodes)), p2 = (y2 = u2.props || e).dangerouslySetInnerHTML, v2 = d2.dangerouslySetInnerHTML, !f2) {
          if (y2 === e)
            for (y2 = {}, h2 = 0; h2 < n2.attributes.length; h2++)
              y2[n2.attributes[h2].name] = n2.attributes[h2].value;
          (v2 || p2) && (v2 && p2 && v2.__html == p2.__html || (n2.innerHTML = v2 && v2.__html || ""));
        }
        b(n2, d2, y2, i2, f2), v2 ? l2.__k = [] : (l2.__k = l2.props.children, g(n2, l2, u2, t2, l2.type !== "foreignObject" && i2, r2, o2, e, f2)), f2 || ("value" in d2 && (s2 = d2.value) !== void 0 && s2 !== n2.value && C(n2, "value", s2, y2.value, false), "checked" in d2 && (s2 = d2.checked) !== void 0 && s2 !== n2.checked && C(n2, "checked", s2, y2.checked, false));
      }
      return n2;
    }
    function $(l2, u2, t2) {
      try {
        typeof l2 == "function" ? l2(u2) : l2.current = u2;
      } catch (l3) {
        n.__e(l3, t2);
      }
    }
    function j(l2, u2, t2) {
      var i2, r2, o2;
      if (n.unmount && n.unmount(l2), (i2 = l2.ref) && (i2.current && i2.current !== l2.__e || $(i2, null, u2)), t2 || typeof l2.type == "function" || (t2 = (r2 = l2.__e) != null), l2.__e = l2.__d = void 0, (i2 = l2.__c) != null) {
        if (i2.componentWillUnmount)
          try {
            i2.componentWillUnmount();
          } catch (l3) {
            n.__e(l3, u2);
          }
        i2.base = i2.__P = null;
      }
      if (i2 = l2.__k)
        for (o2 = 0; o2 < i2.length; o2++)
          i2[o2] && j(i2[o2], u2, t2);
      r2 != null && p(r2);
    }
    function D(n2, l2, u2) {
      return this.constructor(n2, u2);
    }
    function E(l2, u2, t2) {
      var i2, r2, f2;
      n.__ && n.__(l2, u2), r2 = (i2 = t2 === o) ? null : t2 && t2.__k || u2.__k, l2 = v(y, null, [l2]), f2 = [], z(u2, (i2 ? u2 : t2 || u2).__k = l2, r2 || e, e, u2.ownerSVGElement !== void 0, t2 && !i2 ? [t2] : r2 ? null : c.slice.call(u2.childNodes), f2, t2 || e, i2), A(f2, l2);
    }
    n = { __e: function(n2, l2) {
      for (var u2, t2; l2 = l2.__; )
        if ((u2 = l2.__c) && !u2.__)
          try {
            if (u2.constructor && u2.constructor.getDerivedStateFromError != null && (t2 = true, u2.setState(u2.constructor.getDerivedStateFromError(n2))), u2.componentDidCatch != null && (t2 = true, u2.componentDidCatch(n2)), t2)
              return w(u2.__E = u2);
          } catch (l3) {
            n2 = l3;
          }
      throw n2;
    } }, l = function(n2) {
      return n2 != null && n2.constructor === void 0;
    }, d.prototype.setState = function(n2, l2) {
      var u2;
      u2 = this.__s !== this.state ? this.__s : this.__s = a({}, this.state), typeof n2 == "function" && (n2 = n2(u2, this.props)), n2 && a(u2, n2), n2 != null && this.__v && (l2 && this.__h.push(l2), w(this));
    }, d.prototype.forceUpdate = function(n2) {
      this.__v && (this.__e = true, n2 && this.__h.push(n2), w(this));
    }, d.prototype.render = y, u = [], t = 0, i = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o = e, f = 0, exports2.render = E, exports2.hydrate = function(n2, l2) {
      E(n2, l2, o);
    }, exports2.createElement = v, exports2.h = v, exports2.Fragment = y, exports2.createRef = function() {
      return {};
    }, exports2.isValidElement = l, exports2.Component = d, exports2.cloneElement = function(n2, l2) {
      var u2, t2;
      for (t2 in l2 = a(a({}, n2.props), l2), arguments.length > 2 && (l2.children = c.slice.call(arguments, 2)), u2 = {}, l2)
        t2 !== "key" && t2 !== "ref" && (u2[t2] = l2[t2]);
      return h(n2.type, u2, l2.key || n2.key, l2.ref || n2.ref, null);
    }, exports2.createContext = function(n2) {
      var l2 = {}, u2 = { __c: "__cC" + f++, __: n2, Consumer: function(n3, l3) {
        return n3.children(l3);
      }, Provider: function(n3) {
        var t2, i2 = this;
        return this.getChildContext || (t2 = [], this.getChildContext = function() {
          return l2[u2.__c] = i2, l2;
        }, this.shouldComponentUpdate = function(n4) {
          i2.props.value !== n4.value && t2.some(function(l3) {
            l3.context = n4.value, w(l3);
          });
        }, this.sub = function(n4) {
          t2.push(n4);
          var l3 = n4.componentWillUnmount;
          n4.componentWillUnmount = function() {
            t2.splice(t2.indexOf(n4), 1), l3 && l3.call(n4);
          };
        }), n3.children;
      } };
      return u2.Consumer.contextType = u2, u2.Provider.__ = u2, u2;
    }, exports2.toChildArray = _, exports2._e = j, exports2.options = n;
  }
});

// node_modules/preact/hooks/dist/hooks.js
var require_hooks = __commonJS({
  "node_modules/preact/hooks/dist/hooks.js"(exports2) {
    var n, t, r, u = require_preact(), o = 0, i = [], c = u.options.__r, e = u.options.diffed, f = u.options.__c, a = u.options.unmount;
    function p(n2, r2) {
      u.options.__h && u.options.__h(t, n2, o || r2), o = 0;
      var i2 = t.__H || (t.__H = { __: [], __h: [] });
      return n2 >= i2.__.length && i2.__.push({}), i2.__[n2];
    }
    function v(n2) {
      return o = 1, s(T, n2);
    }
    function s(r2, u2, o2) {
      var i2 = p(n++, 2);
      return i2.__c || (i2.__c = t, i2.__ = [o2 ? o2(u2) : T(void 0, u2), function(n2) {
        var t2 = r2(i2.__[0], n2);
        i2.__[0] !== t2 && (i2.__[0] = t2, i2.__c.setState({}));
      }]), i2.__;
    }
    function x(r2, o2) {
      var i2 = p(n++, 4);
      !u.options.__s && h(i2.__H, o2) && (i2.__ = r2, i2.__H = o2, t.__h.push(i2));
    }
    function l(t2, r2) {
      var u2 = p(n++, 7);
      return h(u2.__H, r2) ? (u2.__H = r2, u2.__h = t2, u2.__ = t2()) : u2.__;
    }
    function m() {
      i.some(function(n2) {
        if (n2.__P)
          try {
            n2.__H.__h.forEach(y), n2.__H.__h.forEach(d), n2.__H.__h = [];
          } catch (t2) {
            return n2.__H.__h = [], u.options.__e(t2, n2.__v), true;
          }
      }), i = [];
    }
    function y(n2) {
      n2.t && n2.t();
    }
    function d(n2) {
      var t2 = n2.__();
      typeof t2 == "function" && (n2.t = t2);
    }
    function h(n2, t2) {
      return !n2 || t2.some(function(t3, r2) {
        return t3 !== n2[r2];
      });
    }
    function T(n2, t2) {
      return typeof t2 == "function" ? t2(n2) : t2;
    }
    u.options.__r = function(r2) {
      c && c(r2), n = 0, (t = r2.__c).__H && (t.__H.__h.forEach(y), t.__H.__h.forEach(d), t.__H.__h = []);
    }, u.options.diffed = function(n2) {
      e && e(n2);
      var t2 = n2.__c;
      if (t2) {
        var o2 = t2.__H;
        o2 && o2.__h.length && (i.push(t2) !== 1 && r === u.options.requestAnimationFrame || ((r = u.options.requestAnimationFrame) || function(n3) {
          var t3, r2 = function() {
            clearTimeout(u2), cancelAnimationFrame(t3), setTimeout(n3);
          }, u2 = setTimeout(r2, 100);
          typeof window != "undefined" && (t3 = requestAnimationFrame(r2));
        })(m));
      }
    }, u.options.__c = function(n2, t2) {
      t2.some(function(n3) {
        try {
          n3.__h.forEach(y), n3.__h = n3.__h.filter(function(n4) {
            return !n4.__ || d(n4);
          });
        } catch (r2) {
          t2.some(function(n4) {
            n4.__h && (n4.__h = []);
          }), t2 = [], u.options.__e(r2, n3.__v);
        }
      }), f && f(n2, t2);
    }, u.options.unmount = function(n2) {
      a && a(n2);
      var t2 = n2.__c;
      if (t2) {
        var r2 = t2.__H;
        if (r2)
          try {
            r2.__.forEach(function(n3) {
              return n3.t && n3.t();
            });
          } catch (n3) {
            u.options.__e(n3, t2.__v);
          }
      }
    }, exports2.useState = v, exports2.useReducer = s, exports2.useEffect = function(r2, o2) {
      var i2 = p(n++, 3);
      !u.options.__s && h(i2.__H, o2) && (i2.__ = r2, i2.__H = o2, t.__H.__h.push(i2));
    }, exports2.useLayoutEffect = x, exports2.useRef = function(n2) {
      return o = 5, l(function() {
        return { current: n2 };
      }, []);
    }, exports2.useImperativeHandle = function(n2, t2, r2) {
      o = 6, x(function() {
        typeof n2 == "function" ? n2(t2()) : n2 && (n2.current = t2());
      }, r2 == null ? r2 : r2.concat(n2));
    }, exports2.useMemo = l, exports2.useCallback = function(n2, t2) {
      return o = 8, l(function() {
        return n2;
      }, t2);
    }, exports2.useContext = function(r2) {
      var u2 = t.context[r2.__c], o2 = p(n++, 9);
      return o2.__c = r2, u2 ? (o2.__ == null && (o2.__ = true, u2.sub(t)), u2.props.value) : r2.__;
    }, exports2.useDebugValue = function(n2, t2) {
      u.options.useDebugValue && u.options.useDebugValue(t2 ? t2(n2) : n2);
    }, exports2.useErrorBoundary = function(r2) {
      var u2 = p(n++, 10), o2 = v();
      return u2.__ = r2, t.componentDidCatch || (t.componentDidCatch = function(n2) {
        u2.__ && u2.__(n2), o2[1](n2);
      }), [o2[0], function() {
        o2[1](void 0);
      }];
    };
  }
});

// node_modules/preact/compat/dist/compat.js
var require_compat = __commonJS({
  "node_modules/preact/compat/dist/compat.js"(exports2) {
    var n = require_hooks(), t = require_preact();
    function e(n2, t2) {
      for (var e2 in t2)
        n2[e2] = t2[e2];
      return n2;
    }
    function r(n2, t2) {
      for (var e2 in n2)
        if (e2 !== "__source" && !(e2 in t2))
          return true;
      for (var r2 in t2)
        if (r2 !== "__source" && n2[r2] !== t2[r2])
          return true;
      return false;
    }
    var o = function(n2) {
      var t2, e2;
      function o2(t3) {
        var e3;
        return (e3 = n2.call(this, t3) || this).isPureReactComponent = true, e3;
      }
      return e2 = n2, (t2 = o2).prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, t2.__proto__ = e2, o2.prototype.shouldComponentUpdate = function(n3, t3) {
        return r(this.props, n3) || r(this.state, t3);
      }, o2;
    }(t.Component);
    function u(n2, o2) {
      function u2(n3) {
        var t2 = this.props.ref, e2 = t2 == n3.ref;
        return !e2 && t2 && (t2.call ? t2(null) : t2.current = null), o2 ? !o2(this.props, n3) || !e2 : r(this.props, n3);
      }
      function i2(r2) {
        return this.shouldComponentUpdate = u2, t.createElement(n2, e({}, r2));
      }
      return i2.prototype.isReactComponent = true, i2.displayName = "Memo(" + (n2.displayName || n2.name) + ")", i2.t = true, i2;
    }
    var i = t.options.__b;
    function f(n2) {
      function t2(t3) {
        var r2 = e({}, t3);
        return delete r2.ref, n2(r2, t3.ref);
      }
      return t2.prototype.isReactComponent = t2.t = true, t2.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t2;
    }
    t.options.__b = function(n2) {
      n2.type && n2.type.t && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), i && i(n2);
    };
    var c = function(n2, e2) {
      return n2 ? t.toChildArray(n2).reduce(function(n3, t2, r2) {
        return n3.concat(e2(t2, r2));
      }, []) : null;
    }, l = { map: c, forEach: c, count: function(n2) {
      return n2 ? t.toChildArray(n2).length : 0;
    }, only: function(n2) {
      if ((n2 = t.toChildArray(n2)).length !== 1)
        throw new Error("Children.only() expects only one child.");
      return n2[0];
    }, toArray: t.toChildArray }, a = t.options.__e;
    function s(n2) {
      return n2 && ((n2 = e({}, n2)).__c = null, n2.__k = n2.__k && n2.__k.map(s)), n2;
    }
    function p() {
      this.__u = 0, this.o = null, this.__b = null;
    }
    function v(n2) {
      var t2 = n2.__.__c;
      return t2 && t2.u && t2.u(n2);
    }
    function h(n2) {
      var e2, r2, o2;
      function u2(u3) {
        if (e2 || (e2 = n2()).then(function(n3) {
          r2 = n3.default || n3;
        }, function(n3) {
          o2 = n3;
        }), o2)
          throw o2;
        if (!r2)
          throw e2;
        return t.createElement(r2, u3);
      }
      return u2.displayName = "Lazy", u2.t = true, u2;
    }
    function d() {
      this.i = null, this.l = null;
    }
    t.options.__e = function(n2, t2, e2) {
      if (n2.then) {
        for (var r2, o2 = t2; o2 = o2.__; )
          if ((r2 = o2.__c) && r2.__c)
            return r2.__c(n2, t2.__c);
      }
      a(n2, t2, e2);
    }, (p.prototype = new t.Component()).__c = function(n2, t2) {
      var e2 = this;
      e2.o == null && (e2.o = []), e2.o.push(t2);
      var r2 = v(e2.__v), o2 = false, u2 = function() {
        o2 || (o2 = true, r2 ? r2(i2) : i2());
      };
      t2.__c = t2.componentWillUnmount, t2.componentWillUnmount = function() {
        u2(), t2.__c && t2.__c();
      };
      var i2 = function() {
        var n3;
        if (!--e2.__u)
          for (e2.__v.__k[0] = e2.state.u, e2.setState({ u: e2.__b = null }); n3 = e2.o.pop(); )
            n3.forceUpdate();
      };
      e2.__u++ || e2.setState({ u: e2.__b = e2.__v.__k[0] }), n2.then(u2, u2);
    }, p.prototype.render = function(n2, e2) {
      return this.__b && (this.__v.__k[0] = s(this.__b), this.__b = null), [t.createElement(t.Component, null, e2.u ? null : n2.children), e2.u && n2.fallback];
    };
    var x = function(n2, t2, e2) {
      if (++e2[1] === e2[0] && n2.l.delete(t2), n2.props.revealOrder && (n2.props.revealOrder[0] !== "t" || !n2.l.size))
        for (e2 = n2.i; e2; ) {
          for (; e2.length > 3; )
            e2.pop()();
          if (e2[1] < e2[0])
            break;
          n2.i = e2 = e2[2];
        }
    };
    (d.prototype = new t.Component()).u = function(n2) {
      var t2 = this, e2 = v(t2.__v), r2 = t2.l.get(n2);
      return r2[0]++, function(o2) {
        var u2 = function() {
          t2.props.revealOrder ? (r2.push(o2), x(t2, n2, r2)) : o2();
        };
        e2 ? e2(u2) : u2();
      };
    }, d.prototype.render = function(n2) {
      this.i = null, this.l = /* @__PURE__ */ new Map();
      var e2 = t.toChildArray(n2.children);
      n2.revealOrder && n2.revealOrder[0] === "b" && e2.reverse();
      for (var r2 = e2.length; r2--; )
        this.l.set(e2[r2], this.i = [1, 0, this.i]);
      return n2.children;
    }, d.prototype.componentDidUpdate = d.prototype.componentDidMount = function() {
      var n2 = this;
      n2.l.forEach(function(t2, e2) {
        x(n2, e2, t2);
      });
    };
    var m = function() {
      function n2() {
      }
      var t2 = n2.prototype;
      return t2.getChildContext = function() {
        return this.props.context;
      }, t2.render = function(n3) {
        return n3.children;
      }, n2;
    }();
    function y(n2) {
      var e2 = this, r2 = n2.container, o2 = t.createElement(m, { context: e2.context }, n2.vnode);
      return e2.s && e2.s !== r2 && (e2.p.parentNode && e2.s.removeChild(e2.p), t._e(e2.v), e2.h = false), n2.vnode ? e2.h ? (r2.__k = e2.__k, t.render(o2, r2), e2.__k = r2.__k) : (e2.p = document.createTextNode(""), t.hydrate("", r2), r2.appendChild(e2.p), e2.h = true, e2.s = r2, t.render(o2, r2, e2.p), e2.__k = e2.p.__k) : e2.h && (e2.p.parentNode && e2.s.removeChild(e2.p), t._e(e2.v)), e2.v = o2, e2.componentWillUnmount = function() {
        e2.p.parentNode && e2.s.removeChild(e2.p), t._e(e2.v);
      }, null;
    }
    function b(n2, e2) {
      return t.createElement(y, { vnode: n2, container: e2 });
    }
    var g = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    t.Component.prototype.isReactComponent = {};
    var w = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.element") || 60103;
    function E(n2, e2, r2) {
      if (e2.__k == null)
        for (; e2.firstChild; )
          e2.removeChild(e2.firstChild);
      return t.render(n2, e2), typeof r2 == "function" && r2(), n2 ? n2.__c : null;
    }
    var _ = t.options.event;
    function A(n2, t2) {
      n2["UNSAFE_" + t2] && !n2[t2] && Object.defineProperty(n2, t2, { configurable: false, get: function() {
        return this["UNSAFE_" + t2];
      }, set: function(n3) {
        this["UNSAFE_" + t2] = n3;
      } });
    }
    t.options.event = function(n2) {
      _ && (n2 = _(n2)), n2.persist = function() {
      };
      var t2 = false, e2 = false, r2 = n2.stopPropagation;
      n2.stopPropagation = function() {
        r2.call(n2), t2 = true;
      };
      var o2 = n2.preventDefault;
      return n2.preventDefault = function() {
        o2.call(n2), e2 = true;
      }, n2.isPropagationStopped = function() {
        return t2;
      }, n2.isDefaultPrevented = function() {
        return e2;
      }, n2.nativeEvent = n2;
    };
    var C = { configurable: true, get: function() {
      return this.class;
    } }, S = t.options.vnode;
    function k(n2) {
      return t.createElement.bind(null, n2);
    }
    function N(n2) {
      return !!n2 && n2.$$typeof === w;
    }
    function R(n2) {
      return N(n2) ? t.cloneElement.apply(null, arguments) : n2;
    }
    function U(n2) {
      return !!n2.__k && (t.render(null, n2), true);
    }
    function F(n2) {
      return n2 && (n2.base || n2.nodeType === 1 && n2) || null;
    }
    t.options.vnode = function(n2) {
      n2.$$typeof = w;
      var e2 = n2.type, r2 = n2.props;
      if (e2) {
        if (r2.class != r2.className && (C.enumerable = "className" in r2, r2.className != null && (r2.class = r2.className), Object.defineProperty(r2, "className", C)), typeof e2 != "function") {
          var o2, u2, i2;
          for (i2 in r2.defaultValue && r2.value !== void 0 && (r2.value || r2.value === 0 || (r2.value = r2.defaultValue), delete r2.defaultValue), Array.isArray(r2.value) && r2.multiple && e2 === "select" && (t.toChildArray(r2.children).forEach(function(n3) {
            r2.value.indexOf(n3.props.value) != -1 && (n3.props.selected = true);
          }), delete r2.value), r2)
            if (o2 = g.test(i2))
              break;
          if (o2)
            for (i2 in u2 = n2.props = {}, r2)
              u2[g.test(i2) ? i2.replace(/[A-Z0-9]/, "-$&").toLowerCase() : i2] = r2[i2];
        }
        !function(t2) {
          var e3 = n2.type, r3 = n2.props;
          if (r3 && typeof e3 == "string") {
            var o3 = {};
            for (var u3 in r3)
              /^on(Ani|Tra|Tou)/.test(u3) && (r3[u3.toLowerCase()] = r3[u3], delete r3[u3]), o3[u3.toLowerCase()] = u3;
            if (o3.ondoubleclick && (r3.ondblclick = r3[o3.ondoubleclick], delete r3[o3.ondoubleclick]), o3.onbeforeinput && (r3.onbeforeinput = r3[o3.onbeforeinput], delete r3[o3.onbeforeinput]), o3.onchange && (e3 === "textarea" || e3.toLowerCase() === "input" && !/^fil|che|ra/i.test(r3.type))) {
              var i3 = o3.oninput || "oninput";
              r3[i3] || (r3[i3] = r3[o3.onchange], delete r3[o3.onchange]);
            }
          }
        }(), typeof e2 == "function" && !e2.m && e2.prototype && (A(e2.prototype, "componentWillMount"), A(e2.prototype, "componentWillReceiveProps"), A(e2.prototype, "componentWillUpdate"), e2.m = true);
      }
      S && S(n2);
    };
    var M = function(n2, t2) {
      return n2(t2);
    }, O = { useState: n.useState, useReducer: n.useReducer, useEffect: n.useEffect, useLayoutEffect: n.useLayoutEffect, useRef: n.useRef, useImperativeHandle: n.useImperativeHandle, useMemo: n.useMemo, useCallback: n.useCallback, useContext: n.useContext, useDebugValue: n.useDebugValue, version: "16.8.0", Children: l, render: E, hydrate: E, unmountComponentAtNode: U, createPortal: b, createElement: t.createElement, createContext: t.createContext, createFactory: k, cloneElement: R, createRef: t.createRef, Fragment: t.Fragment, isValidElement: N, findDOMNode: F, Component: t.Component, PureComponent: o, memo: u, forwardRef: f, unstable_batchedUpdates: M, Suspense: p, SuspenseList: d, lazy: h };
    Object.keys(n).forEach(function(t2) {
      exports2[t2] = n[t2];
    }), exports2.createElement = t.createElement, exports2.createContext = t.createContext, exports2.createRef = t.createRef, exports2.Fragment = t.Fragment, exports2.Component = t.Component, exports2.version = "16.8.0", exports2.Children = l, exports2.render = E, exports2.hydrate = function(n2, e2, r2) {
      return t.hydrate(n2, e2), typeof r2 == "function" && r2(), n2 ? n2.__c : null;
    }, exports2.unmountComponentAtNode = U, exports2.createPortal = b, exports2.createFactory = k, exports2.cloneElement = R, exports2.isValidElement = N, exports2.findDOMNode = F, exports2.PureComponent = o, exports2.memo = u, exports2.forwardRef = f, exports2.unstable_batchedUpdates = M, exports2.Suspense = p, exports2.SuspenseList = d, exports2.lazy = h, exports2.default = O;
  }
});

// node_modules/algorand-walletconnect-qrcode-modal/dist/cjs/index.js
var require_cjs15 = __commonJS({
  "node_modules/algorand-walletconnect-qrcode-modal/dist/cjs/index.js"(exports2, module2) {
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var browserUtils = require_cjs5();
    var QRCode = _interopDefault(require_lib3());
    var copy = _interopDefault(require_copy_to_clipboard());
    var React = require_compat();
    function open(uri) {
      QRCode.toString(uri, {
        type: "terminal"
      }).then(console.log);
    }
    var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
    var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E";
    var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
    var ANIMATION_DURATION = 300;
    var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
    var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
    var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
    var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
    var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
    var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
    var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
    function Header(props) {
      return React.createElement("div", {
        className: "walletconnect-modal__header"
      }, React.createElement("img", {
        src: WALLETCONNECT_LOGO_SVG_URL,
        className: "walletconnect-modal__headerLogo"
      }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
        className: "walletconnect-modal__close__wrapper",
        onClick: props.onClose
      }, React.createElement("div", {
        id: WALLETCONNECT_CLOSE_BUTTON_ID,
        className: "walletconnect-modal__close__icon"
      }, React.createElement("div", {
        className: "walletconnect-modal__close__line1"
      }), React.createElement("div", {
        className: "walletconnect-modal__close__line2"
      }))));
    }
    function ConnectButton(props) {
      return React.createElement("a", {
        className: "walletconnect-connect__button",
        href: props.href,
        id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
        onClick: props.onClick,
        rel: "noopener noreferrer",
        style: {
          backgroundColor: props.color
        },
        target: "_blank"
      }, props.name);
    }
    var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
    function WalletButton(props) {
      var color = props.color;
      var href = props.href;
      var name = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      return React.createElement("a", {
        className: "walletconnect-modal__base__row",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("h3", {
        className: "walletconnect-modal__base__row__h3"
      }, name), React.createElement("div", {
        className: "walletconnect-modal__base__row__right"
      }, React.createElement("div", {
        className: "walletconnect-modal__base__row__right__app-icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("img", {
        src: CARET_SVG_URL,
        className: "walletconnect-modal__base__row__right__caret"
      })));
    }
    function WalletIcon(props) {
      var color = props.color;
      var href = props.href;
      var name = props.name;
      var logo = props.logo;
      var onClick = props.onClick;
      var fontSize = window.innerWidth < 768 ? (name.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
      return React.createElement("a", {
        className: "walletconnect-connect__button__icon_anchor",
        href,
        onClick,
        rel: "noopener noreferrer",
        target: "_blank"
      }, React.createElement("div", {
        className: "walletconnect-connect__button__icon",
        style: {
          background: "url('" + logo + "') " + color,
          backgroundSize: "100%"
        }
      }), React.createElement("div", {
        style: {
          fontSize
        },
        className: "walletconnect-connect__button__text"
      }, name));
    }
    var GRID_MIN_COUNT = 5;
    var LINKS_PER_PAGE = 12;
    function LinkDisplay(props) {
      var android = browserUtils.isAndroid();
      var ref = React.useState("");
      var input = ref[0];
      var setInput = ref[1];
      var ref$1 = React.useState("");
      var filter = ref$1[0];
      var setFilter = ref$1[1];
      var ref$2 = React.useState(1);
      var page = ref$2[0];
      var setPage = ref$2[1];
      var links = filter ? props.links.filter(function(link) {
        return link.name.toLowerCase().includes(filter.toLowerCase());
      }) : props.links;
      var errorMessage = props.errorMessage;
      var grid = filter || links.length > GRID_MIN_COUNT;
      var pages = Math.ceil(links.length / LINKS_PER_PAGE);
      var range = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
      var pageLinks = links.length ? links.filter(function(_, index2) {
        return index2 + 1 >= range[0] && index2 + 1 <= range[1];
      }) : [];
      var hasPaging = !!(!android && pages > 1);
      var filterTimeout = void 0;
      function handleInput(e) {
        setInput(e.target.value);
        clearTimeout(filterTimeout);
        if (e.target.value) {
          filterTimeout = setTimeout(function() {
            setFilter(e.target.value);
            setPage(1);
          }, 1e3);
        } else {
          setInput("");
          setFilter("");
          setPage(1);
        }
      }
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
        className: "walletconnect-search__input",
        placeholder: "Search",
        value: input,
        onChange: handleInput
      }), React.createElement("div", {
        className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
      }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
        var color = entry.color;
        var name = entry.name;
        var shortName = entry.shortName;
        var logo = entry.logo;
        var href = browserUtils.formatIOSMobile(props.uri, entry);
        var handleClickIOS = React.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name,
            href
          });
        }, [pageLinks]);
        return !grid ? React.createElement(WalletButton, {
          color,
          href,
          name,
          logo,
          onClick: handleClickIOS
        }) : React.createElement(WalletIcon, {
          color,
          href,
          name: shortName || name,
          logo,
          onClick: handleClickIOS
        });
      }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
        name: props.text.connect,
        color: DEFAULT_BUTTON_COLOR,
        href: props.uri,
        onClick: React.useCallback(function() {
          browserUtils.saveMobileLinkInfo({
            name: "Unknown",
            href: props.uri
          });
        }, [])
      })), hasPaging && React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, Array(pages).fill(0).map(function(_, index2) {
        var pageNumber = index2 + 1;
        var selected = page === pageNumber;
        return React.createElement("a", {
          style: {
            margin: "auto 10px",
            fontWeight: selected ? "bold" : "normal"
          },
          onClick: function() {
            return setPage(pageNumber);
          }
        }, pageNumber);
      })));
    }
    function Notification(props) {
      var show = !!props.message.trim();
      return React.createElement("div", {
        className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
      }, props.message);
    }
    var formatQRCodeImage = function(data) {
      try {
        var result = "";
        return Promise.resolve(QRCode.toString(data, {
          margin: 0,
          type: "svg"
        })).then(function(dataString) {
          if (typeof dataString === "string") {
            result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
          }
          return result;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };
    function QRCodeDisplay(props) {
      var ref = React.useState("");
      var notification = ref[0];
      var setNotification = ref[1];
      var ref$1 = React.useState("");
      var svg = ref$1[0];
      var setSvg = ref$1[1];
      React.useEffect(function() {
        try {
          return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
            setSvg(_formatQRCodeImage);
          });
        } catch (e) {
          Promise.reject(e);
        }
      }, []);
      var copyToClipboard = function() {
        var success = copy(props.uri);
        if (success) {
          setNotification(props.text.copied_to_clipboard);
          setInterval(function() {
            return setNotification("");
          }, 1200);
        } else {
          setNotification("Error");
          setInterval(function() {
            return setNotification("");
          }, 1200);
        }
      };
      return React.createElement("div", null, React.createElement("p", {
        id: WALLETCONNECT_CTA_TEXT_ID,
        className: "walletconnect-qrcode__text"
      }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: svg
        }
      }), React.createElement("div", {
        className: "walletconnect-modal__footer"
      }, React.createElement("a", {
        onClick: copyToClipboard
      }, props.text.copy_to_clipboard)), React.createElement(Notification, {
        message: notification
      }));
    }
    var officialAlgorandWallet = {
      id: "23138217b046ae8d9d07e62b3337fb288c4445f92f64be067809cd0a8f9454b9",
      name: "Pera Wallet",
      homepage: "https://perawallet.app",
      chains: ["algorand"],
      image_id: "1765f9aa-f99e-414e-826b-6b570d480999",
      image_url: {
        sm: "https://algorand-app.s3.amazonaws.com/app-icons/Pera-walletconnect-128.png",
        md: "https://algorand-app.s3.amazonaws.com/app-icons/Pera-walletconnect-128.png",
        lg: "https://algorand-app.s3.amazonaws.com/app-icons/Pera-walletconnect-128.png"
      },
      app: {
        browser: "",
        ios: "https://apps.apple.com/us/app/algorand-wallet/id1459898525",
        android: "https://play.google.com/store/apps/details?id=com.algorand.android",
        mac: "",
        windows: "",
        linux: ""
      },
      mobile: {
        native: "algorand-wc:",
        universal: ""
      },
      desktop: {
        native: "",
        universal: ""
      },
      metadata: {
        shortName: "Pera Wallet",
        colors: {
          primary: "rgb(255, 238, 85)",
          secondary: ""
        }
      }
    };
    var registry = {};
    registry[officialAlgorandWallet.id] = officialAlgorandWallet;
    function Modal(props) {
      var android = browserUtils.isAndroid();
      var mobile = browserUtils.isMobile();
      var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
      var ref = React.useState(false);
      var loading = ref[0];
      var setLoading = ref[1];
      var ref$1 = React.useState(false);
      var fetched = ref$1[0];
      var setFetched = ref$1[1];
      var ref$2 = React.useState(!mobile);
      var displayQRCode = ref$2[0];
      var setDisplayQRCode = ref$2[1];
      var displayProps = {
        mobile,
        text: props.text,
        uri: props.uri,
        qrcodeModalOptions: props.qrcodeModalOptions
      };
      var ref$3 = React.useState("");
      var singleLinkHref = ref$3[0];
      var setSingleLinkHref = ref$3[1];
      var ref$4 = React.useState(false);
      var hasSingleLink = ref$4[0];
      var setHasSingleLink = ref$4[1];
      var ref$5 = React.useState([]);
      var links = ref$5[0];
      var setLinks = ref$5[1];
      var ref$6 = React.useState("");
      var errorMessage = ref$6[0];
      var setErrorMessage = ref$6[1];
      var getLinksIfNeeded = function() {
        if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
          return;
        }
        React.useEffect(function() {
          var initLinks = function() {
            try {
              if (android) {
                return Promise.resolve();
              }
              setLoading(true);
              try {
                var platform = mobile ? "mobile" : "desktop";
                var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform), whitelist);
                setLoading(false);
                setFetched(true);
                setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                setLinks(_links);
                var hasSingleLink2 = _links.length === 1;
                if (hasSingleLink2) {
                  setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                  setDisplayQRCode(true);
                }
                setHasSingleLink(hasSingleLink2);
              } catch (e) {
                setLoading(false);
                setFetched(true);
                setErrorMessage(props.text.something_went_wrong);
                console.error(e);
              }
              return Promise.resolve();
            } catch (e) {
              return Promise.reject(e);
            }
          };
          initLinks();
        });
      };
      getLinksIfNeeded();
      var rightSelected = mobile ? displayQRCode : !displayQRCode;
      return React.createElement("div", {
        id: WALLETCONNECT_MODAL_ID,
        className: "walletconnect-qrcode__base animated fadeIn"
      }, React.createElement("div", {
        className: "walletconnect-modal__base"
      }, React.createElement(Header, {
        onClose: props.onClose
      }), hasSingleLink && displayQRCode ? React.createElement("div", {
        className: "walletconnect-modal__single_wallet"
      }, React.createElement("a", {
        onClick: function() {
          return browserUtils.saveMobileLinkInfo({
            name: links[0].name,
            href: singleLinkHref
          });
        },
        href: singleLinkHref,
        rel: "noopener noreferrer",
        target: "_blank"
      }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
      }, React.createElement("div", {
        className: "walletconnect-modal__mobile__toggle_selector"
      }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.mobile), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(true);
        }
      }, props.text.qrcode), React.createElement("a", {
        onClick: function() {
          return setDisplayQRCode(false), getLinksIfNeeded();
        }
      }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign({}, displayProps, {
        links,
        errorMessage
      })))));
    }
    var de = {
      choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
      connect_mobile_wallet: "Verbinde mit Mobile Wallet",
      scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
      connect: "Verbinden",
      qrcode: "QR-Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "In die Zwischenablage kopieren",
      copied_to_clipboard: "In die Zwischenablage kopiert!",
      connect_with: "Verbinden mit Hilfe von",
      loading: "Laden...",
      something_went_wrong: "Etwas ist schief gelaufen",
      no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
      no_wallets_found: "keine Wallet gefunden"
    };
    var en = {
      choose_preferred_wallet: "Choose your preferred wallet",
      connect_mobile_wallet: "Connect to Mobile Wallet",
      scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
      connect: "Connect",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copy to clipboard",
      copied_to_clipboard: "Copied to clipboard!",
      connect_with: "Connect with",
      loading: "Loading...",
      something_went_wrong: "Something went wrong",
      no_supported_wallets: "There are no supported wallets yet",
      no_wallets_found: "No wallets found"
    };
    var es = {
      choose_preferred_wallet: "Elige tu billetera preferida",
      connect_mobile_wallet: "Conectar a billetera m\xF3vil",
      scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vil",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Conectar mediante",
      loading: "Cargando...",
      something_went_wrong: "Algo sali\xF3 mal",
      no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
      no_wallets_found: "No se encontraron billeteras"
    };
    var fr = {
      choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
      connect_mobile_wallet: "Se connecter au portefeuille mobile",
      scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
      connect: "Se connecter",
      qrcode: "QR Code",
      mobile: "Mobile",
      desktop: "Desktop",
      copy_to_clipboard: "Copier",
      copied_to_clipboard: "Copi\xE9!",
      connect_with: "Connectez-vous \xE0 l'aide de",
      loading: "Chargement...",
      something_went_wrong: "Quelque chose a mal tourn\xE9",
      no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
      no_wallets_found: "Aucun portefeuille trouv\xE9"
    };
    var ko = {
      choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
      connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
      scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
      connect: "\uC5F0\uACB0",
      qrcode: "QR \uCF54\uB4DC",
      mobile: "\uBAA8\uBC14\uC77C",
      desktop: "\uB370\uC2A4\uD06C\uD0D1",
      copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
      copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
      connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
      loading: "\uB85C\uB4DC \uC911...",
      something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
      no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
      no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
    };
    var pt = {
      choose_preferred_wallet: "Escolha sua carteira preferida",
      connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
      scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
      connect: "Conectar",
      qrcode: "C\xF3digo QR",
      mobile: "M\xF3vel",
      desktop: "Desktop",
      copy_to_clipboard: "Copiar",
      copied_to_clipboard: "Copiado!",
      connect_with: "Ligar por meio de",
      loading: "Carregamento...",
      something_went_wrong: "Algo correu mal",
      no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
      no_wallets_found: "Nenhuma carteira encontrada"
    };
    var zh = {
      choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
      connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
      scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
      connect: "\u8FDE\u63A5",
      qrcode: "\u4E8C\u7EF4\u7801",
      mobile: "\u79FB\u52A8",
      desktop: "\u684C\u9762",
      copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
      copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
      connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
      loading: "\u6B63\u5728\u52A0\u8F7D...",
      something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
      no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
      no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
    };
    var fa = {
      choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
      connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
      scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
      connect: "\u0627\u062A\u0635\u0627\u0644",
      qrcode: "\u06A9\u062F QR",
      mobile: "\u0633\u06CC\u0627\u0631",
      desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
      copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
      copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
      connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
      loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
      something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
      no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
      no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
    };
    var languages = {
      de,
      en,
      es,
      fr,
      ko,
      pt,
      zh,
      fa
    };
    function injectStyleSheet() {
      var doc = browserUtils.getDocumentOrThrow();
      var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);
      if (prev) {
        doc.head.removeChild(prev);
      }
      var style = doc.createElement("style");
      style.setAttribute("id", WALLETCONNECT_STYLE_ID);
      style.innerText = WALLETCONNECT_STYLE_SHEET;
      doc.head.appendChild(style);
    }
    function renderWrapper() {
      var doc = browserUtils.getDocumentOrThrow();
      var wrapper = doc.createElement("div");
      wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
      doc.body.appendChild(wrapper);
      return wrapper;
    }
    function triggerCloseAnimation() {
      var doc = browserUtils.getDocumentOrThrow();
      var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);
      if (modal) {
        modal.className = modal.className.replace("fadeIn", "fadeOut");
        setTimeout(function() {
          var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);
          if (wrapper) {
            doc.body.removeChild(wrapper);
          }
        }, ANIMATION_DURATION);
      }
    }
    function getWrappedCallback(cb) {
      return function() {
        triggerCloseAnimation();
        if (cb) {
          cb();
        }
      };
    }
    function getText() {
      var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
      return languages[lang] || languages["en"];
    }
    function open$1(uri, cb, qrcodeModalOptions) {
      injectStyleSheet();
      var wrapper = renderWrapper();
      React.render(React.createElement(Modal, {
        text: getText(),
        uri,
        onClose: getWrappedCallback(cb),
        qrcodeModalOptions
      }), wrapper);
    }
    function close$1() {
      triggerCloseAnimation();
    }
    var isNode = function() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    };
    function open$2(uri, cb, qrcodeModalOptions) {
      console.log(uri);
      if (isNode()) {
        open(uri);
      } else {
        open$1(uri, cb, qrcodeModalOptions);
      }
    }
    function close$2() {
      if (isNode())
        ;
      else {
        close$1();
      }
    }
    var index = {
      open: open$2,
      close: close$2
    };
    module2.exports = index;
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/constants.js
var require_constants7 = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.STANDARD_ERROR_MAP = exports2.SERVER_ERROR_CODE_RANGE = exports2.RESERVED_ERROR_CODES = exports2.SERVER_ERROR = exports2.INTERNAL_ERROR = exports2.INVALID_PARAMS = exports2.METHOD_NOT_FOUND = exports2.INVALID_REQUEST = exports2.PARSE_ERROR = void 0;
    exports2.PARSE_ERROR = "PARSE_ERROR";
    exports2.INVALID_REQUEST = "INVALID_REQUEST";
    exports2.METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
    exports2.INVALID_PARAMS = "INVALID_PARAMS";
    exports2.INTERNAL_ERROR = "INTERNAL_ERROR";
    exports2.SERVER_ERROR = "SERVER_ERROR";
    exports2.RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
    exports2.SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
    exports2.STANDARD_ERROR_MAP = {
      [exports2.PARSE_ERROR]: { code: -32700, message: "Parse error" },
      [exports2.INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
      [exports2.METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
      [exports2.INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
      [exports2.INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
      [exports2.SERVER_ERROR]: { code: -32e3, message: "Server error" }
    };
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/error.js
var require_error3 = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateJsonRpcError = exports2.getErrorByCode = exports2.getError = exports2.isValidErrorCode = exports2.isReservedErrorCode = exports2.isServerErrorCode = void 0;
    var constants_1 = require_constants7();
    function isServerErrorCode(code) {
      return code <= constants_1.SERVER_ERROR_CODE_RANGE[0] && code >= constants_1.SERVER_ERROR_CODE_RANGE[1];
    }
    exports2.isServerErrorCode = isServerErrorCode;
    function isReservedErrorCode(code) {
      return constants_1.RESERVED_ERROR_CODES.includes(code);
    }
    exports2.isReservedErrorCode = isReservedErrorCode;
    function isValidErrorCode(code) {
      return typeof code === "number";
    }
    exports2.isValidErrorCode = isValidErrorCode;
    function getError(type) {
      if (!Object.keys(constants_1.STANDARD_ERROR_MAP).includes(type)) {
        return constants_1.STANDARD_ERROR_MAP[constants_1.INTERNAL_ERROR];
      }
      return constants_1.STANDARD_ERROR_MAP[type];
    }
    exports2.getError = getError;
    function getErrorByCode(code) {
      const match = Object.values(constants_1.STANDARD_ERROR_MAP).find((e) => e.code === code);
      if (!match) {
        return constants_1.STANDARD_ERROR_MAP[constants_1.INTERNAL_ERROR];
      }
      return match;
    }
    exports2.getErrorByCode = getErrorByCode;
    function validateJsonRpcError(response) {
      if (typeof response.error.code === "undefined") {
        return { valid: false, error: "Missing code for JSON-RPC error" };
      }
      if (typeof response.error.message === "undefined") {
        return { valid: false, error: "Missing message for JSON-RPC error" };
      }
      if (!isValidErrorCode(response.error.code)) {
        return {
          valid: false,
          error: `Invalid error code type for JSON-RPC: ${response.error.code}`
        };
      }
      if (isReservedErrorCode(response.error.code)) {
        const error = getErrorByCode(response.error.code);
        if (error.message !== constants_1.STANDARD_ERROR_MAP[constants_1.INTERNAL_ERROR].message && response.error.message === error.message) {
          return {
            valid: false,
            error: `Invalid error code message for JSON-RPC: ${response.error.code}`
          };
        }
      }
      return { valid: true };
    }
    exports2.validateJsonRpcError = validateJsonRpcError;
  }
});

// node_modules/@pedrouid/environment/dist/cjs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@pedrouid/environment/dist/cjs/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowserCryptoAvailable = exports2.getSubtleCrypto = exports2.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports2.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports2.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports2.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@pedrouid/environment/dist/cjs/env.js
var require_env4 = __commonJS({
  "node_modules/@pedrouid/environment/dist/cjs/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBrowser = exports2.isNode = exports2.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports2.isReactNative = isReactNative;
    function isNode() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports2.isNode = isNode;
    function isBrowser() {
      return !isReactNative() && !isNode();
    }
    exports2.isBrowser = isBrowser;
  }
});

// node_modules/@pedrouid/environment/dist/cjs/index.js
var require_cjs16 = __commonJS({
  "node_modules/@pedrouid/environment/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !exports3.hasOwnProperty(p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_crypto2(), exports2);
    __exportStar(require_env4(), exports2);
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/env.js
var require_env5 = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNodeJs = void 0;
    var tslib_1 = require_tslib();
    var environment_1 = require_cjs16();
    exports2.isNodeJs = environment_1.isNode;
    tslib_1.__exportStar(require_cjs16(), exports2);
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/format.js
var require_format2 = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatErrorMessage = exports2.formatJsonRpcError = exports2.formatJsonRpcResult = exports2.formatJsonRpcRequest = exports2.payloadId = void 0;
    var error_1 = require_error3();
    var constants_1 = require_constants7();
    function payloadId() {
      const date = Date.now() * Math.pow(10, 3);
      const extra = Math.floor(Math.random() * Math.pow(10, 3));
      return date + extra;
    }
    exports2.payloadId = payloadId;
    function formatJsonRpcRequest2(method2, params, id) {
      return {
        id: id || payloadId(),
        jsonrpc: "2.0",
        method: method2,
        params
      };
    }
    exports2.formatJsonRpcRequest = formatJsonRpcRequest2;
    function formatJsonRpcResult(id, result) {
      return {
        id,
        jsonrpc: "2.0",
        result
      };
    }
    exports2.formatJsonRpcResult = formatJsonRpcResult;
    function formatJsonRpcError(id, error) {
      return {
        id,
        jsonrpc: "2.0",
        error: formatErrorMessage(error)
      };
    }
    exports2.formatJsonRpcError = formatJsonRpcError;
    function formatErrorMessage(error) {
      if (typeof error === "undefined") {
        return error_1.getError(constants_1.INTERNAL_ERROR);
      }
      if (typeof error === "string") {
        error = Object.assign(Object.assign({}, error_1.getError(constants_1.SERVER_ERROR)), { message: error });
      }
      if (error_1.isReservedErrorCode(error.code)) {
        error = error_1.getErrorByCode(error.code);
      }
      if (!error_1.isServerErrorCode(error.code)) {
        throw new Error("Error code is not in server code range");
      }
      return error;
    }
    exports2.formatErrorMessage = formatErrorMessage;
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/routing.js
var require_routing2 = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/routing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidTrailingWildcardRoute = exports2.isValidLeadingWildcardRoute = exports2.isValidWildcardRoute = exports2.isValidDefaultRoute = exports2.isValidRoute = void 0;
    function isValidRoute(route) {
      if (route.includes("*")) {
        return isValidWildcardRoute(route);
      }
      if (/\W/g.test(route)) {
        return false;
      }
      return true;
    }
    exports2.isValidRoute = isValidRoute;
    function isValidDefaultRoute(route) {
      return route === "*";
    }
    exports2.isValidDefaultRoute = isValidDefaultRoute;
    function isValidWildcardRoute(route) {
      if (isValidDefaultRoute(route)) {
        return true;
      }
      if (!route.includes("*")) {
        return false;
      }
      if (route.split("*").length !== 2) {
        return false;
      }
      if (route.split("*").filter((x) => x.trim() === "").length !== 1) {
        return false;
      }
      return true;
    }
    exports2.isValidWildcardRoute = isValidWildcardRoute;
    function isValidLeadingWildcardRoute(route) {
      return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
    }
    exports2.isValidLeadingWildcardRoute = isValidLeadingWildcardRoute;
    function isValidTrailingWildcardRoute(route) {
      return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
    }
    exports2.isValidTrailingWildcardRoute = isValidTrailingWildcardRoute;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/misc.js
var require_misc3 = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/misc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IEvents = void 0;
    var IEvents = class {
    };
    exports2.IEvents = IEvents;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/provider.js
var require_provider2 = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IJsonRpcProvider = exports2.IBaseJsonRpcProvider = exports2.IJsonRpcConnection = void 0;
    var misc_1 = require_misc3();
    var IJsonRpcConnection = class extends misc_1.IEvents {
      constructor(opts) {
        super();
      }
    };
    exports2.IJsonRpcConnection = IJsonRpcConnection;
    var IBaseJsonRpcProvider = class extends misc_1.IEvents {
      constructor() {
        super();
      }
    };
    exports2.IBaseJsonRpcProvider = IBaseJsonRpcProvider;
    var IJsonRpcProvider = class extends IBaseJsonRpcProvider {
      constructor(connection) {
        super();
      }
    };
    exports2.IJsonRpcProvider = IJsonRpcProvider;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/blockchain.js
var require_blockchain = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/blockchain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IBlockchainProvider = exports2.IBlockchainAuthenticator = exports2.IPendingRequests = void 0;
    var misc_1 = require_misc3();
    var provider_1 = require_provider2();
    var IPendingRequests = class {
      constructor(storage) {
        this.storage = storage;
      }
    };
    exports2.IPendingRequests = IPendingRequests;
    var IBlockchainAuthenticator = class extends misc_1.IEvents {
      constructor(config) {
        super();
        this.config = config;
      }
    };
    exports2.IBlockchainAuthenticator = IBlockchainAuthenticator;
    var IBlockchainProvider = class extends provider_1.IJsonRpcProvider {
      constructor(connection, config) {
        super(connection);
      }
    };
    exports2.IBlockchainProvider = IBlockchainProvider;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/jsonrpc.js
var require_jsonrpc2 = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/jsonrpc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/multi.js
var require_multi = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/multi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IMultiServiceProvider = void 0;
    var provider_1 = require_provider2();
    var IMultiServiceProvider = class extends provider_1.IBaseJsonRpcProvider {
      constructor(config) {
        super();
        this.config = config;
      }
    };
    exports2.IMultiServiceProvider = IMultiServiceProvider;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/router.js
var require_router = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/router.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IJsonRpcRouter = void 0;
    var IJsonRpcRouter = class {
      constructor(routes) {
        this.routes = routes;
      }
    };
    exports2.IJsonRpcRouter = IJsonRpcRouter;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/schema.js
var require_schema = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/validator.js
var require_validator2 = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IJsonRpcValidator = void 0;
    var IJsonRpcValidator = class {
      constructor(schemas) {
        this.schemas = schemas;
      }
    };
    exports2.IJsonRpcValidator = IJsonRpcValidator;
  }
});

// node_modules/@json-rpc-tools/types/dist/cjs/index.js
var require_cjs17 = __commonJS({
  "node_modules/@json-rpc-tools/types/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_blockchain(), exports2);
    tslib_1.__exportStar(require_jsonrpc2(), exports2);
    tslib_1.__exportStar(require_misc3(), exports2);
    tslib_1.__exportStar(require_multi(), exports2);
    tslib_1.__exportStar(require_provider2(), exports2);
    tslib_1.__exportStar(require_router(), exports2);
    tslib_1.__exportStar(require_schema(), exports2);
    tslib_1.__exportStar(require_validator2(), exports2);
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/types.js
var require_types5 = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_cjs17(), exports2);
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/validators.js
var require_validators4 = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isJsonRpcValidationInvalid = exports2.isJsonRpcError = exports2.isJsonRpcResult = exports2.isJsonRpcResponse = exports2.isJsonRpcRequest = exports2.isJsonRpcPayload = void 0;
    function isJsonRpcPayload(payload) {
      return "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
    }
    exports2.isJsonRpcPayload = isJsonRpcPayload;
    function isJsonRpcRequest(payload) {
      return isJsonRpcPayload(payload) && "method" in payload;
    }
    exports2.isJsonRpcRequest = isJsonRpcRequest;
    function isJsonRpcResponse(payload) {
      return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
    }
    exports2.isJsonRpcResponse = isJsonRpcResponse;
    function isJsonRpcResult(payload) {
      return "result" in payload;
    }
    exports2.isJsonRpcResult = isJsonRpcResult;
    function isJsonRpcError(payload) {
      return "error" in payload;
    }
    exports2.isJsonRpcError = isJsonRpcError;
    function isJsonRpcValidationInvalid(validation) {
      return "error" in validation && validation.valid === false;
    }
    exports2.isJsonRpcValidationInvalid = isJsonRpcValidationInvalid;
  }
});

// node_modules/@json-rpc-tools/utils/dist/cjs/index.js
var require_cjs18 = __commonJS({
  "node_modules/@json-rpc-tools/utils/dist/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_constants7(), exports2);
    tslib_1.__exportStar(require_error3(), exports2);
    tslib_1.__exportStar(require_env5(), exports2);
    tslib_1.__exportStar(require_format2(), exports2);
    tslib_1.__exportStar(require_routing2(), exports2);
    tslib_1.__exportStar(require_types5(), exports2);
    tslib_1.__exportStar(require_validators4(), exports2);
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => Algonaut
});
module.exports = __toCommonJS(src_exports);
var import_buffer = require("buffer");
var import_algosdk = __toESM(require_cjs());
var import_client = __toESM(require_cjs14());
var import_algorand_walletconnect_qrcode_modal = __toESM(require_cjs15());
var import_utils = __toESM(require_cjs18());
var Algonaut = class {
  algodClient;
  indexerClient = void 0;
  account = void 0;
  address = void 0;
  sKey = void 0;
  mnemonic = void 0;
  config = void 0;
  sdk = void 0;
  uiLoading = false;
  walletConnect = {
    connected: false,
    connector: void 0,
    accounts: [],
    address: "",
    assets: [],
    chain: void 0
  };
  constructor(config) {
    this.config = config;
    this.algodClient = new import_algosdk.default.Algodv2(config.API_TOKEN, config.BASE_SERVER, config.PORT);
    if (config.INDEX_SERVER) {
      this.indexerClient = new import_algosdk.default.Indexer(config.API_TOKEN, config.INDEX_SERVER, config.PORT);
    } else {
      console.warn("No indexer configured because INDEX_SERVER was not provided.");
    }
    this.sdk = import_algosdk.default;
  }
  getConfig() {
    if (this.config)
      return this.config;
    return false;
  }
  async checkStatus() {
    const status = await this.algodClient.status().do();
    console.log("Algorand network status: %o", status);
    return status;
  }
  setAccount(account) {
    this.account = account;
    this.address = account.addr;
    if (this.config)
      this.config.SIGNING_MODE = "local";
    this.mnemonic = import_algosdk.default.secretKeyToMnemonic(account.sk);
  }
  setWalletConnectAccount(address) {
    this.account = {
      addr: address,
      sk: new Uint8Array([])
    };
    if (this.config)
      this.config.SIGNING_MODE = "walletconnect";
  }
  createWallet() {
    this.account = import_algosdk.default.generateAccount();
    if (this.account) {
      this.address = this.account.addr;
      this.mnemonic = import_algosdk.default.secretKeyToMnemonic(this.account.sk);
      return {
        address: this.account.addr,
        mnemonic: this.mnemonic || ""
      };
    } else {
      throw new Error("There was no account: could not create algonaut wallet!");
    }
  }
  recoverAccount(mnemonic) {
    try {
      this.account = import_algosdk.default.mnemonicToSecretKey(mnemonic);
      if (import_algosdk.default.isValidAddress(this.account?.addr)) {
        return this.account || false;
      }
      if (this.config)
        this.config.SIGNING_MODE = "local";
    } catch (error) {
      console.log(error);
      return false;
    }
    return false;
  }
  async waitForConfirmation(txId, limitDelta, log = false) {
    let lastround = (await this.algodClient.status().do())["last-round"];
    const limit = lastround + (limitDelta ? limitDelta : 50);
    const returnValue = {
      status: "fail",
      message: ""
    };
    while (lastround < limit) {
      let pendingInfo = "";
      try {
        pendingInfo = await this.algodClient.pendingTransactionInformation(txId).do();
        if (log) {
          console.log("waiting for confirmation");
        }
      } catch (er) {
        console.error(er.response?.text);
      }
      if (pendingInfo["confirmed-round"] !== null && pendingInfo["confirmed-round"] > 0) {
        console.log("Transaction confirmed in round " + pendingInfo["confirmed-round"]);
        returnValue.txId = txId;
        returnValue.status = "success";
        returnValue.message = "Transaction confirmed in round " + pendingInfo["confirmed-round"];
        break;
      }
      lastround++;
    }
    return returnValue;
  }
  generateLogicSig(base64ProgramString) {
    const program = new Uint8Array(import_buffer.Buffer.from(base64ProgramString, "base64"));
    return new import_algosdk.default.LogicSigAccount(program);
  }
  async atomicOptInAsset(assetIndex) {
    if (this.account && assetIndex) {
      const params = await this.algodClient.getTransactionParams().do();
      const optInTransaction = import_algosdk.default.makeAssetTransferTxnWithSuggestedParamsFromObject({
        from: this.account.addr,
        to: this.account.addr,
        suggestedParams: params,
        assetIndex,
        amount: 0
      });
      return {
        transaction: optInTransaction,
        transactionSigner: this.account,
        isLogigSig: false
      };
    } else {
      throw new Error("there was no account!");
    }
  }
  async optInAsset(assetIndex, callbacks) {
    if (!this.account)
      throw new Error("There was no account!");
    const { transaction } = await this.atomicOptInAsset(assetIndex);
    return await this.sendTransaction(transaction, callbacks);
  }
  async isOptedIntoAsset(args) {
    let optInState = false;
    const accountInfo = await this.getAccountInfo(args.account);
    accountInfo.assets.forEach((asset) => {
      if (asset["asset-id"] == args.assetId) {
        optInState = true;
      }
    });
    return optInState;
  }
  encodeArguments(args) {
    const encodedArgs = [];
    args.forEach((arg) => {
      if (typeof arg == "number") {
        encodedArgs.push(import_algosdk.default.encodeUint64(arg));
      } else if (typeof arg == "bigint") {
        encodedArgs.push(import_algosdk.default.encodeUint64(arg));
      } else if (typeof arg == "string") {
        encodedArgs.push(new Uint8Array(import_buffer.Buffer.from(arg)));
      }
    });
    return encodedArgs;
  }
  async atomicCreateAsset(args) {
    if (!args.metaBlock) {
      args.metaBlock = "wot? wot wot?";
    }
    if (!args.defaultFrozen)
      args.defaultFrozen = false;
    if (!args.assetURL)
      args.assetURL = void 0;
    const metaBlockLength = args.metaBlock.length;
    if (metaBlockLength > 511) {
      console.error("meta block is " + metaBlockLength);
      throw new Error("drat! this meta block is too long!");
    }
    const enc = new TextEncoder();
    if (!this.account)
      throw new Error("There was no account");
    const note = enc.encode(args.metaBlock);
    const addr = this.account.addr;
    const totalIssuance = args.amount;
    const manager = this.account.addr;
    const reserve = this.account.addr;
    const freeze = this.account.addr;
    const clawback = this.account.addr;
    const params = await this.algodClient.getTransactionParams().do();
    const txn = import_algosdk.default.makeAssetCreateTxnWithSuggestedParams(addr, note, totalIssuance, args.decimals, args.defaultFrozen, manager, reserve, freeze, clawback, args.symbol, args.assetName, args.assetURL, args.assetMetadataHash, params);
    return {
      transaction: txn,
      transactionSigner: this.account,
      isLogigSig: false
    };
  }
  async createAsset(args, callbacks) {
    const atomicTxn = await this.atomicCreateAsset(args);
    const txn = atomicTxn.transaction;
    try {
      const assetID = null;
      const txStatus = await this.sendTransaction(txn, callbacks);
      const ptx = await this.algodClient.pendingTransactionInformation(txn.txID().toString()).do();
      txStatus.createdIndex = ptx["asset-index"];
      return txStatus;
    } catch (er) {
      console.log("transaction error");
      console.log(er);
      throw new Error(er);
    }
  }
  async atomicDeleteAsset(assetId) {
    if (!this.account)
      throw new Error("there was no account!");
    const enc = new TextEncoder();
    const transaction = import_algosdk.default.makeAssetDestroyTxnWithSuggestedParams(this.account.addr, enc.encode("doh!"), assetId, await this.algodClient.getTransactionParams().do());
    return {
      transaction,
      transactionSigner: this.account,
      isLogigSig: false
    };
  }
  async deleteAsset(assetId, callbacks) {
    const { transaction } = await this.atomicDeleteAsset(assetId);
    return await this.sendTransaction(transaction, callbacks);
  }
  async atomicSendAsset(args) {
    if (!this.account)
      throw new Error("there is no account!");
    const transaction = import_algosdk.default.makeAssetTransferTxnWithSuggestedParamsFromObject({
      from: this.account.addr,
      to: args.to,
      amount: args.amount,
      assetIndex: args.assetIndex,
      suggestedParams: await this.algodClient.getTransactionParams().do()
    });
    return {
      transaction,
      transactionSigner: this.account,
      isLogigSig: false
    };
  }
  async sendAsset(args, callbacks) {
    if (!this.account)
      throw new Error("There was no account!");
    const { transaction } = await this.atomicSendAsset(args);
    return await this.sendTransaction(transaction, callbacks);
  }
  async getAssetInfo(assetIndex) {
    const info = await this.algodClient.getAssetByID(assetIndex).do();
    return info;
  }
  async atomicOptInApp(args) {
    if (this.account && args.appIndex) {
      const sender = this.account.addr;
      const params = await this.algodClient.getTransactionParams().do();
      const optInTransaction = import_algosdk.default.makeApplicationOptInTxnFromObject({
        from: sender,
        appIndex: args.appIndex,
        suggestedParams: params,
        appArgs: args.appArgs ? this.encodeArguments(args.appArgs) : void 0,
        accounts: args.optionalFields?.accounts ? args.optionalFields?.accounts : void 0,
        foreignApps: args.optionalFields?.applications ? args.optionalFields?.applications : void 0,
        foreignAssets: args.optionalFields?.assets ? args.optionalFields?.assets : void 0
      });
      return {
        transaction: optInTransaction,
        transactionSigner: this.account,
        isLogigSig: false
      };
    } else {
      throw new Error("algonautjs has no account loaded!");
    }
  }
  async optInApp(args, callbacks) {
    if (this.account && args.appIndex) {
      const { transaction } = await this.atomicOptInApp(args);
      return await this.sendTransaction(transaction, callbacks);
    } else {
      if (!this.account)
        throw new Error("No account set.");
      throw new Error("Must provide appIndex");
    }
  }
  async atomicDeleteApplication(appIndex) {
    if (this.account && appIndex) {
      try {
        const sender = this.account.addr;
        const params = await this.algodClient.getTransactionParams().do();
        const txn = import_algosdk.default.makeApplicationDeleteTxn(sender, params, appIndex);
        return {
          transaction: txn,
          transactionSigner: this.account,
          isLogigSig: false
        };
      } catch (e) {
        throw new Error(e);
      }
    } else {
      throw new Error("No account loaded");
    }
  }
  async deleteApplication(appIndex, callbacks) {
    if (!this.account)
      throw new Error("There was no account");
    try {
      const { transaction } = await this.atomicDeleteApplication(appIndex);
      const txId = transaction.txID().toString();
      const status = await this.sendTransaction(transaction, callbacks);
      const transactionResponse = await this.algodClient.pendingTransactionInformation(txId).do();
      const appId = transactionResponse["txn"]["txn"].apid;
      console.log("Deleted app-id: ", appId);
      return {
        status: "success",
        message: "deleted app index " + appId,
        txId
      };
    } catch (e) {
      console.log(e);
      throw new Error(e.response?.text);
    }
  }
  async atomicCallApp(args) {
    if (this.account && args.appIndex && args.appArgs.length) {
      const processedArgs = this.encodeArguments(args.appArgs);
      const params = await this.algodClient.getTransactionParams().do();
      const callAppTransaction = import_algosdk.default.makeApplicationNoOpTxnFromObject({
        from: this.account.addr,
        suggestedParams: params,
        appIndex: args.appIndex,
        appArgs: processedArgs,
        accounts: args.optionalFields?.accounts || void 0,
        foreignApps: args.optionalFields?.applications || void 0,
        foreignAssets: args.optionalFields?.assets || void 0
      });
      return {
        transaction: callAppTransaction,
        transactionSigner: this.account,
        isLogigSig: false
      };
    } else {
      throw new Error("there was no account!");
    }
  }
  async callApp(args, callbacks) {
    if (!this.account)
      throw new Error("There was no account!");
    if (!args.appIndex)
      throw new Error("Must provide appIndex");
    if (!args.appArgs.length)
      throw new Error("Must provide at least one appArgs");
    const { transaction } = await this.atomicCallApp(args);
    return await this.sendTransaction(transaction, callbacks);
  }
  async atomicCallAppWithLSig(args) {
    if (this.account && args.appIndex && args.appArgs.length) {
      const processedArgs = this.encodeArguments(args.appArgs);
      const params = await this.algodClient.getTransactionParams().do();
      const callAppTransaction = import_algosdk.default.makeApplicationNoOpTxnFromObject({
        from: args.lsig.address(),
        suggestedParams: params,
        appIndex: args.appIndex,
        appArgs: processedArgs,
        accounts: args.optionalFields?.accounts || void 0,
        foreignApps: args.optionalFields?.applications || void 0,
        foreignAssets: args.optionalFields?.assets || void 0
      });
      return {
        transaction: callAppTransaction,
        transactionSigner: args.lsig,
        isLogigSig: true
      };
    } else {
      throw new Error("there was no account!");
    }
  }
  async atomicCloseOutApp(args) {
    if (this.account && args.appIndex && args.appArgs.length) {
      try {
        const params = await this.algodClient.getTransactionParams().do();
        const processedArgs = this.encodeArguments(args.appArgs);
        const closeOutTxn = import_algosdk.default.makeApplicationCloseOutTxnFromObject({
          from: this.account.addr,
          suggestedParams: params,
          appIndex: args.appIndex,
          appArgs: processedArgs,
          accounts: args.optionalFields?.accounts || void 0,
          foreignApps: args.optionalFields?.applications || void 0,
          foreignAssets: args.optionalFields?.assets || void 0
        });
        return {
          transaction: closeOutTxn,
          transactionSigner: this.account,
          isLogigSig: false
        };
      } catch (e) {
        throw new Error(e);
      }
    } else {
      throw new Error("requires app index");
    }
  }
  async closeOutApp(args, callbacks) {
    if (!this.account)
      throw new Error("There was no account!");
    if (!args.appIndex)
      throw new Error("Must provide appIndex");
    if (!args.appArgs.length)
      throw new Error("Must provide at least one appArgs");
    const { transaction } = await this.atomicCloseOutApp(args);
    return await this.sendTransaction(transaction, callbacks);
  }
  getAppEscrowAccount(appId) {
    return import_algosdk.default.getApplicationAddress(appId);
  }
  async getAppInfo(appId) {
    const info = await this.algodClient.getApplicationByID(appId).do();
    const state = {
      hasState: true,
      globals: [],
      locals: [],
      creatorAddress: info.params.creator,
      index: appId
    };
    if (info.params["global-state"]) {
      state.globals = this.decodeStateArray(info.params["global-state"]);
    }
    return state;
  }
  async createApp(args, callbacks) {
    if (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {
      console.warn("drat! your note is too long!");
      throw new Error("Your note is too long");
    }
    if (!this.account)
      throw new Error("There was no account!");
    try {
      const sender = this.account.addr;
      const onComplete = import_algosdk.default.OnApplicationComplete.NoOpOC;
      const params = await this.algodClient.getTransactionParams().do();
      let approvalProgram = new Uint8Array();
      let clearProgram = new Uint8Array();
      approvalProgram = await this.compileProgram(args.tealApprovalCode);
      clearProgram = await this.compileProgram(args.tealClearCode);
      if (approvalProgram && clearProgram) {
        const txn = import_algosdk.default.makeApplicationCreateTxn(sender, params, onComplete, approvalProgram, clearProgram, args.schema.localInts, args.schema.localBytes, args.schema.globalInts, args.schema.globalBytes, this.encodeArguments(args.appArgs), args.optionalFields?.accounts ? args.optionalFields.accounts : void 0, args.optionalFields?.applications ? args.optionalFields.applications : void 0, args.optionalFields?.assets ? args.optionalFields.assets : void 0, args.optionalFields?.note ? new Uint8Array(import_buffer.Buffer.from(args.optionalFields.note, "utf8")) : void 0);
        const txId = txn.txID().toString();
        const result = await this.sendTransaction(txn, callbacks);
        const transactionResponse = await this.algodClient.pendingTransactionInformation(txId).do();
        result.message = "Created App ID: " + transactionResponse["application-index"];
        result.createdIndex = transactionResponse["application-index"];
        result.meta = transactionResponse;
        result.txId = txId;
        return result;
      } else {
        throw new Error("could not compile teal code");
      }
    } catch (er) {
      throw new Error(er.message);
    }
  }
  async atomicCreateApp(args) {
    if (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {
      throw new Error("Your NOTE is too long, it must be less thatn 1024 Bytes");
    } else if (this.account) {
      try {
        const sender = this.account.addr;
        const onComplete = import_algosdk.default.OnApplicationComplete.NoOpOC;
        const params = await this.algodClient.getTransactionParams().do();
        let approvalProgram = new Uint8Array();
        let clearProgram = new Uint8Array();
        approvalProgram = await this.compileProgram(args.tealApprovalCode);
        clearProgram = await this.compileProgram(args.tealClearCode);
        if (!approvalProgram || !clearProgram) {
          throw new Error("Error: you must provide an approval program and a clear state program.");
        }
        const applicationCreateTransaction = import_algosdk.default.makeApplicationCreateTxn(sender, params, onComplete, approvalProgram, clearProgram, args.schema.localInts, args.schema.localBytes, args.schema.globalInts, args.schema.globalBytes, this.encodeArguments(args.appArgs), args.optionalFields?.accounts ? args.optionalFields.accounts : void 0, args.optionalFields?.applications ? args.optionalFields.applications : void 0, args.optionalFields?.assets ? args.optionalFields.assets : void 0, args.optionalFields?.note ? new Uint8Array(import_buffer.Buffer.from(args.optionalFields.note, "utf8")) : void 0);
        return {
          transaction: applicationCreateTransaction,
          transactionSigner: this.account,
          isLogigSig: false
        };
      } catch (er) {
        throw new Error("There was an error creating the transaction");
      }
    } else {
      throw new Error("Algonaut.js has no account loaded!");
    }
  }
  async deployTealWithLSig(args) {
    if (args.noteText && args.noteText.length > 511) {
      throw new Error("Your note is too long");
    }
    if (!this.account)
      throw new Error("there was no account");
    let encodedArgs = [];
    if (args.appArgs && args.appArgs.length) {
      encodedArgs = this.encodeArguments(args.appArgs);
    }
    const sender = args.lsig.address();
    const onComplete = import_algosdk.default.OnApplicationComplete.NoOpOC;
    const params = await this.algodClient.getTransactionParams().do();
    let approvalProgram = new Uint8Array();
    let clearProgram = new Uint8Array();
    try {
      approvalProgram = await this.compileProgram(args.tealApprovalCode);
      clearProgram = await this.compileProgram(args.tealClearCode);
      if (approvalProgram && clearProgram) {
        const txn = import_algosdk.default.makeApplicationCreateTxn(sender, params, onComplete, approvalProgram, clearProgram, args.schema.localInts, args.schema.localBytes, args.schema.globalInts, args.schema.globalBytes, encodedArgs, args.optionalFields?.accounts || void 0);
        const txId = txn.txID().toString();
        const signedTxn = import_algosdk.default.signLogicSigTransactionObject(txn, args.lsig);
        await this.algodClient.sendRawTransaction(signedTxn.blob).do();
        const txStatus = await this.waitForConfirmation(txId);
        const transactionResponse = await this.algodClient.pendingTransactionInformation(txId).do();
        const appId = transactionResponse["application-index"];
        return {
          status: "success",
          message: "created new app with id: " + appId,
          txId
        };
      } else {
        throw new Error("Error compiling programs.");
      }
    } catch (er) {
      console.error("Error deploying contract:");
      throw new Error(er);
    }
  }
  async atomicUpdateApp(args) {
    if (!this.account)
      throw new Error("Algonaut.js has no account loaded!");
    if (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {
      throw new Error("Your NOTE is too long, it must be less thatn 1024 Bytes");
    }
    try {
      const sender = this.account.addr;
      const onComplete = import_algosdk.default.OnApplicationComplete.NoOpOC;
      const params = await this.algodClient.getTransactionParams().do();
      let approvalProgram = new Uint8Array();
      let clearProgram = new Uint8Array();
      approvalProgram = await this.compileProgram(args.tealApprovalCode);
      clearProgram = await this.compileProgram(args.tealClearCode);
      if (!approvalProgram || !clearProgram) {
        throw new Error("Error: you must provide an approval program and a clear state program.");
      }
      const applicationCreateTransaction = import_algosdk.default.makeApplicationUpdateTxn(sender, params, args.appIndex, approvalProgram, clearProgram, this.encodeArguments(args.appArgs), args.optionalFields?.accounts ? args.optionalFields.accounts : void 0, args.optionalFields?.applications ? args.optionalFields.applications : void 0, args.optionalFields?.assets ? args.optionalFields.assets : void 0, args.optionalFields?.note ? new Uint8Array(import_buffer.Buffer.from(args.optionalFields.note, "utf8")) : void 0);
      return {
        transaction: applicationCreateTransaction,
        transactionSigner: this.account,
        isLogigSig: false
      };
    } catch (er) {
      throw new Error("There was an error creating the transaction");
    }
  }
  async updateApp(args, callbacks) {
    const { transaction } = await this.atomicUpdateApp(args);
    return await this.sendTransaction(transaction, callbacks);
  }
  async compileProgram(programSource) {
    const encoder = new TextEncoder();
    const programBytes = encoder.encode(programSource);
    const compileResponse = await this.algodClient.compile(programBytes).do();
    const compiledBytes = new Uint8Array(import_buffer.Buffer.from(compileResponse.result, "base64"));
    return compiledBytes;
  }
  async atomicPayment(args) {
    if (this.account) {
      const encodedNote = args.note ? new Uint8Array(import_buffer.Buffer.from(args.note, "utf8")) : new Uint8Array();
      const transaction = import_algosdk.default.makePaymentTxnWithSuggestedParamsFromObject({
        from: this.account.addr,
        to: args.to,
        amount: args.amount,
        note: encodedNote,
        suggestedParams: await this.algodClient.getTransactionParams().do()
      });
      return {
        transaction,
        transactionSigner: this.account,
        isLogigSig: false
      };
    } else {
      throw new Error("there is no account!");
    }
  }
  async sendAlgo(args, callbacks) {
    if (!this.account)
      throw new Error("there was no account!");
    const { transaction } = await this.atomicPayment(args);
    return await this.sendTransaction(transaction);
  }
  async getAccountInfo(address) {
    const accountInfo = await this.algodClient.accountInformation(address).do();
    return accountInfo;
  }
  async getAlgoBalance(address) {
    const accountInfo = await this.algodClient.accountInformation(address).do();
    return accountInfo.amount;
  }
  async getTokenBalance(address, assetIndex) {
    const accountInfo = await this.algodClient.accountInformation(address).do();
    let stkBalance = 0;
    accountInfo.assets.forEach((asset) => {
      if (asset["asset-id"] == assetIndex) {
        stkBalance = asset.amount;
      }
    });
    return stkBalance;
  }
  async accountHasTokens(address, assetIndex) {
    return "this is not done yet";
  }
  async getAppGlobalState(applicationIndex) {
    const info = await this.getAppInfo(applicationIndex);
    if (info.hasState) {
      return this.stateArrayToObject(info.globals);
    } else {
      return {};
    }
  }
  async getAppLocalState(applicationIndex) {
    if (this.account) {
      const state = {
        hasState: false,
        globals: [],
        locals: [],
        creatorAddress: "",
        index: applicationIndex
      };
      const accountInfoResponse = await this.algodClient.accountInformation(this.account?.addr).do();
      for (let i = 0; i < accountInfoResponse["apps-local-state"].length; i++) {
        if (accountInfoResponse["apps-local-state"][i].id == applicationIndex) {
          state.hasState = true;
          for (let n = 0; n < accountInfoResponse["apps-local-state"][i]["key-value"].length; n++) {
            const stateItem = accountInfoResponse["apps-local-state"][i]["key-value"][n];
            const key = import_buffer.Buffer.from(stateItem.key, "base64").toString();
            const type = stateItem.value.type;
            let value = void 0;
            let valueAsAddr = "";
            if (type == 1) {
              value = import_buffer.Buffer.from(stateItem.value.bytes, "base64").toString();
              valueAsAddr = import_algosdk.default.encodeAddress(import_buffer.Buffer.from(stateItem.value.bytes, "base64"));
            } else if (stateItem.value.type == 2) {
              value = stateItem.value.uint;
            }
            state.locals.push({
              key,
              value: value || "",
              address: valueAsAddr
            });
          }
        }
      }
      return state;
    } else {
      throw new Error("there is no account");
    }
  }
  async atomicAssetTransferWithLSig(args) {
    if (args.lsig) {
      const transaction = import_algosdk.default.makeAssetTransferTxnWithSuggestedParamsFromObject({
        from: args.lsig.address(),
        to: args.to,
        amount: args.amount,
        assetIndex: args.assetIndex,
        suggestedParams: await this.algodClient.getTransactionParams().do()
      });
      return {
        transaction,
        transactionSigner: args.lsig,
        isLogigSig: true
      };
    } else {
      throw new Error("there is no logic sig object!");
    }
  }
  async atomicPaymentWithLSig(args) {
    if (args.lsig) {
      const transaction = import_algosdk.default.makePaymentTxnWithSuggestedParamsFromObject({
        from: args.lsig.address(),
        to: args.to,
        amount: args.amount,
        suggestedParams: await this.algodClient.getTransactionParams().do()
      });
      return {
        transaction,
        transactionSigner: args.lsig,
        isLogigSig: true
      };
    } else {
      throw new Error("there is no account!");
    }
  }
  async sendTransaction(txnOrTxns, callbacks) {
    if (!this.account)
      throw new Error("There is no account");
    if (this.config && this.config.SIGNING_MODE && this.config.SIGNING_MODE === "walletconnect") {
      if (Array.isArray(txnOrTxns)) {
        return await this.sendWalletConnectTxns(txnOrTxns, callbacks);
      } else {
        if (txnOrTxns.transaction) {
          return await this.sendWalletConnectTxns([txnOrTxns], callbacks);
        } else {
          return await this.sendWalletConnectTxns([{
            transaction: txnOrTxns,
            transactionSigner: this.account,
            isLogigSig: false
          }], callbacks);
        }
      }
    } else {
      if (Array.isArray(txnOrTxns)) {
        return await this.sendAtomicTransaction(txnOrTxns, callbacks);
      } else {
        let txn;
        if (txnOrTxns && txnOrTxns.transaction) {
          txn = txnOrTxns.transaction;
        } else {
          txn = txnOrTxns;
        }
        if (!this.account || !this.account.sk)
          throw new Error("");
        const signedTxn = txn.signTxn(this.account.sk);
        if (callbacks?.onSign)
          callbacks.onSign(signedTxn);
        const tx = await this.algodClient.sendRawTransaction(signedTxn).do();
        if (callbacks?.onSend)
          callbacks.onSend(signedTxn);
        const txId = tx.txId || tx.id || tx.txId().toString();
        console.log("Transaction ID: " + txId);
        const txStatus = await this.waitForConfirmation(txId);
        if (callbacks?.onConfirm)
          callbacks.onConfirm(signedTxn);
        return txStatus;
      }
    }
  }
  async sendAtomicTransaction(transactions, callbacks) {
    try {
      const txns = [];
      const signed = [];
      transactions.forEach((txn) => {
        txns.push(txn.transaction);
      });
      const txnGroup = import_algosdk.default.assignGroupID(txns);
      transactions.forEach((txn, i) => {
        let signedTx;
        if (txn.isLogigSig) {
          signedTx = import_algosdk.default.signLogicSigTransaction(txnGroup[i], txn.transactionSigner);
        } else {
          signedTx = import_algosdk.default.signTransaction(txnGroup[i], txn.transactionSigner.sk);
        }
        signed.push(signedTx.blob);
      });
      if (callbacks?.onSign)
        callbacks.onSign(signed);
      const tx = await this.algodClient.sendRawTransaction(signed).do();
      if (callbacks?.onSend)
        callbacks.onSend(tx);
      const txStatus = await this.waitForConfirmation(tx.txId);
      const transactionResponse = await this.algodClient.pendingTransactionInformation(tx.txId).do();
      txStatus.meta = transactionResponse;
      if (callbacks?.onConfirm)
        callbacks.onConfirm(txStatus);
      return txStatus;
    } catch (e) {
      console.error("Error sending atomic transaction:");
      throw new Error(e);
    }
  }
  async sendWalletConnectTxns(walletTxns, callbacks) {
    if (this.walletConnect.connected) {
      let txns = walletTxns.map((txn) => txn.transaction);
      if (walletTxns.length > 1) {
        txns = import_algosdk.default.assignGroupID(txns);
      }
      const txnsToSign = txns.map((txn) => {
        const encodedTxn = import_buffer.Buffer.from(import_algosdk.default.encodeUnsignedTransaction(txn)).toString("base64");
        return {
          txn: encodedTxn,
          message: "txn description"
        };
      });
      const requestParams = [txnsToSign];
      const request = (0, import_utils.formatJsonRpcRequest)("algo_signTxn", requestParams);
      let result;
      try {
        result = await this.walletConnect.connector.sendCustomRequest(request);
      } catch (er) {
        throw new Error("You canceled the transaction");
      }
      const signedPartialTxns = result.map((r, i) => {
        if (r == null) {
          throw new Error(`Transaction at index ${i}: was not signed when it should have been`);
        }
        const rawSignedTxn = import_buffer.Buffer.from(r, "base64");
        return new Uint8Array(rawSignedTxn);
      });
      if (callbacks?.onSign)
        callbacks.onSign(signedPartialTxns);
      if (signedPartialTxns) {
        let tx;
        try {
          tx = await this.algodClient.sendRawTransaction(signedPartialTxns).do();
        } catch (er) {
          tx = er;
          console.error("Error sending raw transaction");
          throw new Error(er);
        }
        if (callbacks?.onSend)
          callbacks.onSend(tx);
        const txStatus = await this.waitForConfirmation(tx.txId);
        const transactionResponse = await this.algodClient.pendingTransactionInformation(tx.txId).do();
        txStatus.meta = transactionResponse;
        if (callbacks?.onConfirm)
          callbacks.onConfirm(txStatus);
        return txStatus;
      } else {
        throw new Error("there were no signed transactions returned");
      }
    } else {
      throw new Error("There is no wallet connect session");
    }
  }
  usingWalletConnect() {
    if (this.config && this.config.SIGNING_MODE && this.config.SIGNING_MODE === "walletconnect") {
      return true;
    }
    return false;
  }
  async createWalletConnectTransactions(transactions) {
    const txns = [];
    transactions.forEach((txn) => {
      txns.push(txn.transaction);
    });
    return txns;
  }
  async sendTxWithAlgoSigner(params) {
    try {
      await this.connectToAlgoSigner();
      const txParams = await window.AlgoSigner.algod({
        ledger: params.LEDGER,
        path: "/v2/transactions/params"
      });
      const signedTx = await window.AlgoSigner.sign({
        assetIndex: params.assetIndex || null,
        from: params.from,
        to: params.to,
        amount: +params.amount,
        note: params.note || "",
        type: params.type,
        fee: txParams["min-fee"],
        firstRound: txParams["last-round"],
        lastRound: txParams["last-round"] + 1e3,
        genesisID: txParams["genesis-id"],
        genesisHash: txParams["genesis-hash"],
        flatFee: true
      });
      const tx = window.AlgoSigner.send({
        ledger: params.LEDGER,
        tx: signedTx.blob
      });
      return this.waitForAlgoSignerConfirmation(tx);
    } catch (error) {
      console.log(error);
      throw new Error("Error sending transaction: " + JSON.stringify(error));
    }
  }
  async waitForAlgoSignerConfirmation(tx) {
    console.log(`Transaction ${tx.txId} waiting for confirmation...`);
    let status = await window.AlgoSigner.algod({
      ledger: "TestNet",
      path: "/v2/transactions/pending/" + tx.txId
    });
    while (true) {
      if (status["confirmed-round"] !== null && status["confirmed-round"] > 0) {
        console.log(`Transaction confirmed in round ${status["confirmed-round"]}.`);
        break;
      }
      status = await window.AlgoSigner.algod({
        ledger: "TestNet",
        path: "/v2/transactions/pending/" + tx.txId
      });
    }
    return tx;
  }
  async disconnectAlgoWallet() {
    if (this.walletConnect.connected) {
      this.walletConnect.connector?.killSession();
    }
  }
  async connectAlgoWallet(clientListener) {
    console.log("connecting wallet: ");
    if (!clientListener)
      clientListener = void 0;
    const bridge = "https://bridge.walletconnect.org";
    this.walletConnect.connector = new import_client.default({
      bridge,
      qrcodeModal: import_algorand_walletconnect_qrcode_modal.default
    });
    if (!this.walletConnect.connector.connected) {
      this.walletConnect.connector.createSession();
    }
    this.subscribeToEvents(clientListener);
  }
  subscribeToEvents(clientListener) {
    if (!this.walletConnect.connector) {
      return;
    }
    this.walletConnect.connector.on("session_update", async (error, payload) => {
      if (error) {
        throw error;
      }
      const { accounts } = payload.params[0];
      if (clientListener)
        clientListener.onSessionUpdate(payload);
      this.onSessionUpdate(accounts);
    });
    this.walletConnect.connector.on("connect", (error, payload) => {
      if (error) {
        throw error;
      }
      if (clientListener)
        clientListener.onConnect(payload);
      this.onConnect(payload);
    });
    this.walletConnect.connector.on("disconnect", (error, payload) => {
      if (error) {
        throw error;
      }
      if (clientListener)
        clientListener.onDisconnect(payload);
      this.onDisconnect();
    });
    if (this.walletConnect.connector.connected) {
      const { accounts } = this.walletConnect.connector;
      const address = accounts[0];
      this.walletConnect.connected = true;
      this.walletConnect.accounts = accounts;
      this.walletConnect.address = address;
      this.onSessionUpdate(accounts);
    }
  }
  async killSession() {
    if (this.walletConnect.connector) {
      this.walletConnect.connector.killSession();
    }
    this.resetApp();
  }
  async chainUpdate(newChain) {
    this.walletConnect.chain = newChain;
  }
  async resetApp() {
    console.log("reset app called");
    console.log("TBD!");
  }
  async onConnect(payload) {
    const { accounts } = payload.params[0];
    const address = accounts[0];
    this.setWalletConnectAccount(address);
    this.walletConnect.connected = true;
    this.walletConnect.accounts = accounts;
    this.walletConnect.address = address;
  }
  onDisconnect() {
    this.walletConnect.connected = false;
    this.walletConnect.accounts = [];
    this.walletConnect.address = "";
    this.account = void 0;
  }
  async onSessionUpdate(accounts) {
    this.walletConnect.address = accounts[0];
    this.walletConnect.accounts = accounts;
    this.setWalletConnectAccount(accounts[0]);
  }
  stateArrayToObject(stateArray) {
    const stateObj = {};
    stateArray.forEach((value) => {
      if (value.key)
        stateObj[value.key] = value.value || null;
    });
    return stateObj;
  }
  fromBase64(encoded) {
    return import_buffer.Buffer.from(encoded, "base64").toString();
  }
  valueAsAddr(encoded) {
    return import_algosdk.default.encodeAddress(import_buffer.Buffer.from(encoded, "base64"));
  }
  decodeStateArray(stateArray) {
    const result = [];
    for (let n = 0; n < stateArray.length; n++) {
      const stateItem = stateArray[n];
      const key = this.fromBase64(stateItem.key);
      const type = stateItem.value.type;
      let value = void 0;
      let valueAsAddr = "";
      if (type == 1) {
        value = this.fromBase64(stateItem.value.bytes);
        valueAsAddr = this.valueAsAddr(stateItem.value.bytes);
      } else if (stateItem.value.type == 2) {
        value = stateItem.value.uint;
      }
      result.push({
        key,
        value: value || "",
        address: valueAsAddr
      });
    }
    return result;
  }
  isAlgoSignerInstalled() {
    return typeof window.AlgoSigner !== "undefined";
  }
  async connectToAlgoSigner() {
    return await window.AlgoSigner.connect();
  }
  async getAccounts(ledger) {
    await this.connectToAlgoSigner();
    const accounts = await window.AlgoSigner.accounts({ ledger });
    return accounts;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*
 * [hi-base32]{@link https://github.com/emn178/hi-base32}
 *
 * @version 0.5.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
//# sourceMappingURL=index.js.map
