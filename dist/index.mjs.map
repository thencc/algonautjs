{"version":3,"sources":["../src/index.ts","../src/algo-config.ts","../src/constants.ts","../src/utils.ts"],"names":["import_buffer","testnetConfig","mainnetConfig","defaultNodeConfig","defaultLibConfig","logger","args","unsAcctSync","Algonaut","config","esm_default","awConfig","H","libConfig","rn","nodeConfig","isValid","AlgodClient","IndexerClient","status","acct","walletInitParams","wip","mnemonic","d","route","inkeyW","inkeyClientSdk","txId","limitDelta","log","_a","lastround","limit","returnValue","pendingInfo","er","base64ProgramString","program","LogicSigAccount","assetIndex","optionalTxnArgs","suggestedParams","makeAssetTransferTxnWithSuggestedParamsFromObject","callbacks","transaction","optInState","asset","encodedArgs","arg","encodeUint64","fromAddr","metaBlockLength","note","totalIssuance","manager","reserve","freeze","clawback","makeAssetCreateTxnWithSuggestedParams","txn","txStatus","ptx","assetId","enc","makeAssetDestroyTxnWithSuggestedParams","isValidAddress","_b","_c","_d","_e","_f","_g","makeApplicationOptInTxnFromObject","appIndex","makeApplicationDeleteTxn","e","processedArgs","makeApplicationNoOpTxnFromObject","makeApplicationCloseOutTxnFromObject","appId","getApplicationAddress","proms","promsRes","info","localState","state","approvalProgram","clearProgram","makeApplicationCreateTxnFromObject","OnApplicationComplete","result","transactionResponse","onComplete","makeApplicationCreateTxn","sender","signedTxn","signLogicSigTransactionObject","makeApplicationUpdateTxn","programSource","programBytes","compileResponse","encodedNote","makePaymentTxnWithSuggestedParamsFromObject","address","accountInfo","bal","applicationIndex","accountInfoResponse","i","n","stateItem","key","type","value","valueAsAddr","encodeAddress","txnOrTxns","txnArr","algoTxnArr","t","nativeT","gId","txnBuffArr","awTxnsToSign","awTxnsSigned","tx","str","stateArray","stateObj","encoded","decodeUnsignedTransaction","to","from","microalgosToAlgos","account","generateAccount","secretKeyToMnemonic","mnemonicToSecretKey","error","buff","src_default","buffer"],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer';\n\nimport algosdk, {\n\tsecretKeyToMnemonic,\n\tgenerateAccount,\n\tAccount as AlgosdkAccount,\n\tAlgodv2,\n\tIndexer,\n\tLogicSigAccount,\n\tmakeAssetTransferTxnWithSuggestedParamsFromObject,\n\tmakeApplicationOptInTxnFromObject,\n\tmakeAssetCreateTxnWithSuggestedParams,\n\tmakeAssetDestroyTxnWithSuggestedParams,\n\tmakeApplicationDeleteTxn,\n\tmakeApplicationNoOpTxnFromObject,\n\tmakeApplicationCloseOutTxnFromObject,\n\tmakeApplicationCreateTxnFromObject,\n\tOnApplicationComplete,\n\tmakeApplicationCreateTxn,\n\tsignLogicSigTransactionObject,\n\tmakeApplicationUpdateTxn,\n\tencodeAddress,\n\tmakePaymentTxnWithSuggestedParamsFromObject,\n\tTransaction,\n\tmnemonicToSecretKey,\n\tisValidAddress,\n\tencodeUint64,\n\tgetApplicationAddress,\n\tmicroalgosToAlgos,\n\tdecodeUnsignedTransaction\n} from 'algosdk';\n\nimport type {\n\tAlgonautConfig,\n\tAlgonautWallet,\n\tAlgonautTransactionStatus,\n\tAlgonautAtomicTransaction,\n\tAlgonautTransactionFields,\n\tAlgonautAppState,\n\tAlgonautStateData,\n\tAlgonautError,\n\tAlgonautTxnCallbacks,\n\tAlgonautCreateAssetArguments,\n\tAlgonautSendAssetArguments,\n\tAlgonautCallAppArguments,\n\tAlgonautDeployArguments,\n\tAlgonautLsigDeployArguments,\n\tAlgonautLsigCallAppArguments,\n\tAlgonautLsigSendAssetArguments,\n\tAlgonautPaymentArguments,\n\tAlgonautLsigPaymentArguments,\n\tAlgonautUpdateAppArguments,\n\tAlgonautGetApplicationResponse,\n\tAlgonautAppStateEncoded\n} from './AlgonautTypes';\nexport * from './AlgonautTypes';\nexport type AlgoTxn = Transaction;\n\nimport {\n\tAnyWalletState,\n\tsetLogsEnabled as AWSetLogsEnabled,\n\tWALLET_ID\n} from '@thencc/any-wallet';\nimport type {\n\tAccount,\n\tAnyWalletStateConfig,\n\tW_ID,\n\tWalletInitParamsObj\n} from '@thencc/any-wallet';\nexport * from '@thencc/any-wallet';\n\nimport type { InkeySdk } from '@thencc/inkey-client-js';\n\nimport { defaultNodeConfig, mainnetConfig, testnetConfig } from './algo-config';\nimport { defaultLibConfig } from './constants';\nimport { logger } from './utils';\n\nlet unsAcctSync = null as null | (() => void);\n\nexport class Algonaut {\n\talgodClient!: Algodv2; // it will be set or it throws an Error\n\tindexerClient = undefined as undefined | Indexer;\n\tnodeConfig = defaultNodeConfig;\n\tlibConfig = defaultLibConfig;\n\n\t// expose entire algosdk in case the dapp needs more\n\tsdk = algosdk;\n\n\t// handles all algo wallets (inkey, pera, etc) + remembers last used in localstorage\n\twalletState!: AnyWalletState;\n\tinkeyClientSdk = null as null | InkeySdk;\n\tinkeyLoading = false;\n\tinkeyLoaded = false;\n\n\taccount = null as null | typeof this.walletState.activeAccount;\n\tget connectedAccounts() {\n\t\treturn this.walletState.connectedAccounts;\n\t}\n\n\t// TODO come back to private class fields during the security pass. + figure out how to make account immutable\n\t// \"#account\" set on aw acct listener (but private fields compile weird..? making a #private field in the type dec)\n\t// #account = null as null | typeof AnyWalletState.activeAccount;\n\t// get account() {\n\t// \treturn this.#account;\n\t// }\n\n\t// func re-mappings (definitely set in init call in class constructor)\n\t/**\n\t * connects the given wallet + optional init params\n\t * @argument walletId of which wallet type to connect \n\t * @returns an array of connected accounts\n\t */\n\tconnect!: typeof this.walletState.connectWallet;\n\tdisconnect!: typeof this.walletState.disconnectWallet;\n\tdisconnectAll!: typeof this.walletState.disconnectAllWallets;\n\tsetActiveAccount!: typeof this.walletState.setAsActiveAccount;\n\tsubscribeToAccountChanges!: typeof this.walletState.subscribeToAccountChanges;\n\n\n\t/**\n\t * Instantiates Algonaut.js.\n\t *\n\t * @example\n\t * Usage:\n\t *\n\t * ```js\n\t * import { Algonaut } from '@thencc/algonautjs';\n\t * const algonaut = new Algonaut({\n\t * \t\tnodeConfig: {\n\t *\t \t\tBASE_SERVER: 'https://testnet-algorand.api.purestake.io/ps2',\n\t *\t \t\tINDEX_SERVER: 'https://testnet-algorand.api.purestake.io/idx2'\n\t *\t \t\tLEDGER: 'TestNet',\n\t *\t \t\tPORT: '',\n\t *\t \t\tAPI_TOKEN: { 'X-API-Key': 'YOUR_API_TOKEN' }\n\t * \t\t}\n\t * });\n\t * ```\n\t *\n\t * @param config config object\n\t */\n\tconstructor(config?: AlgonautConfig) {\n\t\tthis.setNodeConfig(config?.nodeConfig); // makes algod client too\n\t\tthis.setLibConfig(config);\n\t\tthis.initAwState(config);\n\t}\n\n\t// initAwState(awConfig?: AnyWalletStateConfig) {\n\tinitAwState(config?: AlgonautConfig) {\n\t\tlogger.log('initAwState', config);\n\n\t\tconst awConfig: AnyWalletStateConfig | undefined = config ?\n\t\t\t{\n\t\t\t\tstorageKey: config.storageKey,\n\t\t\t\tstorageController: config.storageController,\n\t\t\t} : undefined;\n\t\tthis.walletState = new AnyWalletState(awConfig);\n\n\t\tthis.initWallets(config?.initWallets); // sets init params for future .connect wallet calls\n\t\tthis.initAcctSync();\n\n\t\t// func remappings\n\t\tthis.subscribeToAccountChanges = this.walletState.subscribeToAccountChanges;\n\t\tthis.setActiveAccount = this.walletState.setAsActiveAccount;\n\t\tthis.connect = this.walletState.connectWallet;\n\t\tthis.disconnect = this.walletState.disconnectWallet;\n\t\tthis.disconnectAll = this.walletState.disconnectAllWallets;\n\t}\n\n\tsetLibConfig(config?: AlgonautConfig) {\n\t\t// logger.log('setLibConfig', config);\n\t\tlet libConfig: typeof defaultLibConfig;\n\t\tif (config == undefined) {\n\t\t\tlibConfig = defaultLibConfig;\n\t\t} else {\n\t\t\tif ('disableLogs' in config && typeof config.disableLogs == 'boolean') {\n\t\t\t\tlogger.enabled = !config.disableLogs;\n\t\t\t\tAWSetLogsEnabled(!config.disableLogs);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * checks if config obj is valid for use\n\t * @param config algonaut config for network + signing mode\n\t * @returns boolean. true is good.\n\t */\n\tisValidNodeConfig(nodeConfig?: AlgonautConfig['nodeConfig']): boolean {\n\t\t// logger.log('isValidNodeConfig?', config);\n\t\tlet isValid = true;\n\n\t\t// do all checks\n\t\tif (nodeConfig == undefined || !nodeConfig.BASE_SERVER) {\n\t\t\tisValid = false;\n\t\t}\n\t\t// FYI some configs dont need an api token\n\n\t\t// TODO add more checks...\n\n\t\treturn isValid;\n\t}\n\n\t/**\n\t * sets config for use (new algod, indexerClient, etc)\n\t * @param config algonaut config for network + signing mode\n\t * \t\t- will throw Error if config is lousy\n\t */\n\tsetNodeConfig(nodeConfig?: AlgonautConfig['nodeConfig'] | 'mainnet' | 'testnet') {\n\t\tlogger.log('setNodeConfig', nodeConfig);\n\n\t\tif (nodeConfig == undefined) {\n\t\t\tnodeConfig = defaultNodeConfig;\n\t\t}\n\n\t\tif (typeof nodeConfig == 'string') {\n\t\t\tif (nodeConfig == 'mainnet') {\n\t\t\t\tnodeConfig = mainnetConfig;\n\t\t\t} else if (nodeConfig == 'testnet') {\n\t\t\t\tnodeConfig = testnetConfig;\n\t\t\t} else {\n\t\t\t\tthrow new Error('bad node config string.');\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isValidNodeConfig(nodeConfig)) {\n\t\t\tthrow new Error('bad node config!');\n\t\t}\n\t\tif (typeof nodeConfig == 'undefined') {\n\t\t\tthrow new Error('node config undefined'); // shouldnt ever happen... but needed to TS to be happy\n\t\t}\n\n\t\tthis.nodeConfig = nodeConfig;\n\t\tthis.algodClient = new Algodv2(nodeConfig.API_TOKEN, nodeConfig.BASE_SERVER, nodeConfig.PORT);\n\n\t\tif (nodeConfig.INDEX_SERVER) {\n\t\t\tthis.indexerClient = new Indexer(nodeConfig.API_TOKEN, nodeConfig.INDEX_SERVER, nodeConfig.PORT);\n\t\t} else {\n\t\t\tconsole.warn('No indexer configured because INDEX_SERVER was not provided.');\n\t\t}\n\t}\n\n\t/**\n\t * @returns nodeConfig object or `false` if no nodeConfig is set\n\t */\n\tgetNodeConfig(): AlgonautConfig['nodeConfig'] | boolean {\n\t\tif (this.nodeConfig) return this.nodeConfig;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks status of Algorand network\n\t * @returns Promise resolving to status of Algorand network\n\t */\n\tasync checkStatus(): Promise<any | AlgonautError> {\n\t\tif (!this.getNodeConfig()) {\n\t\t\tthrow new Error('No node configuration set.');\n\t\t}\n\n\t\tconst status = await this.algodClient.status().do();\n\t\tlogger.log('Algorand network status: %o', status);\n\t\treturn status;\n\t}\n\n\tinitAcctSync() {\n\t\tunsAcctSync = this.walletState.subscribeToAccountChanges(\n\t\t\t(acct) => {\n\t\t\t\tlogger.log('acct changed', acct);\n\t\t\t\tthis.account = acct;\n\t\t\t\t// this.#account = acct; // revisit this for security pass + consider field setting not just entire obj\n\t\t\t}\n\t\t);\n\t}\n\tstopAcctSync() {\n\t\tif (unsAcctSync) unsAcctSync();\n\t}\n\n\tinitWallets(walletInitParams?: AlgonautConfig['initWallets']) {\n\t\tif (walletInitParams == undefined) {\n\t\t\tlogger.debug('.enableWallets called without any init params.');\n\t\t}\n\t\t// default to NONE\n\t\tconst defaultWip: WalletInitParamsObj = {\n\t\t\t// inkey: true, // not even inkey\n\t\t};\n\t\tconst wip = walletInitParams || defaultWip;\n\t\tthis.walletState.initWallets(wip); // defaults to all except mnemonic client\n\t}\n\n\t/**\n\t * @deprecated use .connect() with mnemonic arg\n\t * Recovers account from mnemonic\n\t *  (helpful for rapid development but overall very insecure unless on server-side)\n\t * @param mnemonic Mnemonic associated with Algonaut account\n\t * @returns If mnemonic is valid, it returns the account (address, chain). Otherwise, throws an error.\n\t */\n\tasync mnemonicConnect(mnemonic: string): Promise<Account[]> {\n\t\tif (!mnemonic) throw new Error('algonaut.mnemonicConnect: No mnemonic provided.');\n\t\treturn await this.connect('mnemonic', mnemonic);\n\t}\n\n\t/**\n\t * @deprecated use .connect or loop through enabled wallets' methods\n\t */\n\tasync inkeyConnect(): Promise<Account[]> {\n\t\tconsole.warn('.inkeyConnect is deprecated. please use .connect');\n\t\treturn await this.connect('inkey');\n\t}\n\n\t/**\n\t * @deprecated use .disconnect or loop through enabled wallets' methods\n\t */\n\tasync inkeyDisconnect() {\n\t\tconsole.warn('.inkeyDisconnect is deprecated. please use .disconnect');\n\t\treturn await this.disconnect(WALLET_ID.INKEY);\n\t}\n\n\t/**\n\t * Shows the inkey-wallet modal\n\t * @returns\n\t */\n\tasync inkeyShow(route?: string) {\n\t\tconst ic = await this.getInkeyClientSdk();\n\t\tic.show(route);\n\t}\n\n\t/**\n\t * Hides the inkey-wallet modal\n\t * @returns\n\t */\n\tasync inkeyHide() {\n\t\tconst ic = await this.getInkeyClientSdk();\n\t\tic.hide();\n\t}\n\n\t/**\n\t * Loads and/or returns the inkey-wallet client sdk for whatever use. see inkey-client-js docs for more.\n\t * @returns\n\t */\n\tasync getInkeyClientSdk(): Promise<InkeySdk> {\n\t\tlogger.log('getInkeyClientSdk');\n\t\tif (this.inkeyClientSdk !== null) {\n\t\t\tthis.inkeyLoaded = true;\n\t\t\treturn this.inkeyClientSdk;\n\t\t} else {\n\t\t\t// load it\n\t\t\tconst inkeyW = this.walletState.allWallets.inkey;\n\t\t\tif (!inkeyW) {\n\t\t\t\tconsole.warn('Inkey wallet not enabled by dev');\n\t\t\t\tthrow new Error('Inkey wallet not enabled by dev');\n\t\t\t}\n\n\t\t\tthis.inkeyLoading = true;\n\t\t\tawait inkeyW.loadClient();\n\t\t\tthis.inkeyLoading = false;\n\n\t\t\tconst inkeyClientSdk: InkeySdk = inkeyW.client!.sdk;\n\n\t\t\tif (inkeyClientSdk.frameBus.ready == false) {\n\t\t\t\tlogger.debug('inkeySdk FrameBus not yet ready...');\n\t\t\t\tawait inkeyClientSdk.frameBus.isReady();\n\t\t\t\tlogger.debug('inkeySdk FrameBus IS ready.');\n\t\t\t}\n\n\t\t\tthis.inkeyLoaded = true;\n\t\t\tthis.inkeyClientSdk = inkeyClientSdk;\n\t\t\treturn this.inkeyClientSdk;\n\t\t}\n\t}\n\n\t/**\n\t * General purpose method to await transaction confirmation\n\t * @param txId a string id of the transacion you want to watch\n\t * @param limitDelta how many rounds to wait, defaults to 50\n\t * @param log set to true if you'd like to see \"waiting for confirmation\" log messages\n\t */\n\tasync waitForConfirmation(txId: string, limitDelta?: number, log = false): Promise<AlgonautTransactionStatus> {\n\t\tif (!txId) throw new Error('waitForConfirmation: No transaction ID provided.');\n\n\t\tlet lastround = (await this.algodClient.status().do())['last-round'];\n\t\tconst limit = lastround + (limitDelta ? limitDelta : 50);\n\n\t\tconst returnValue = {\n\t\t\tstatus: 'fail',\n\t\t\tmessage: ''\n\t\t} as AlgonautTransactionStatus;\n\n\t\twhile (lastround < limit) {\n\t\t\tlet pendingInfo = '' as any;\n\t\t\ttry {\n\t\t\t\tpendingInfo = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\t\t\t\tif (log) {\n\t\t\t\t\tlogger.log('waiting for confirmation');\n\t\t\t\t}\n\t\t\t} catch (er: any) {\n\t\t\t\tconsole.error(er.response?.text);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tpendingInfo['confirmed-round'] !== null &&\n\t\t\t\tpendingInfo['confirmed-round'] > 0\n\t\t\t) {\n\n\t\t\t\tif (log) {\n\t\t\t\t\tlogger.log('Transaction confirmed in round ' + pendingInfo['confirmed-round']);\n\t\t\t\t}\n\n\t\t\t\treturnValue.txId = txId;\n\t\t\t\treturnValue.status = 'success';\n\t\t\t\treturnValue.message = 'Transaction confirmed in round ' + pendingInfo['confirmed-round'];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlastround = (await this.algodClient.status().do())['last-round'];\n\t\t}\n\n\t\treturn returnValue;\n\n\t}\n\n\t/**\n\t * Creates a LogicSig from a base64 program string.  Note that this method does not COMPILE\n\t * the program, just builds an LSig from an already compiled base64 result!\n\t * @param base64ProgramString\n\t * @returns an algosdk LogicSigAccount\n\t */\n\tgenerateLogicSig(base64ProgramString: string): LogicSigAccount {\n\t\tif (!base64ProgramString) throw new Error('No program string provided.');\n\n\t\tconst program = new Uint8Array(\n\t\t\tBuffer.from(base64ProgramString, 'base64')\n\t\t);\n\n\t\treturn new LogicSigAccount(program);\n\t}\n\n\tasync atomicOptInAsset(assetIndex: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!this.walletState.activeAddress) throw new Error('No account set in Algonaut.');\n\t\tif (!assetIndex) throw new Error('No asset index provided.');\n\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst optInTransaction = makeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\tfrom: this.walletState.activeAddress,\n\t\t\tto: this.walletState.activeAddress,\n\t\t\tassetIndex: assetIndex,\n\t\t\tamount: 0,\n\t\t\tsuggestedParams,\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: optInTransaction,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Opt-in the current account for the a token or NFT Asset.\n\t * @param assetIndex number of asset to opt-in to\n\t * @param callbacks `AlgonautTxnCallbacks`, passed to {@link sendTransaction}\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync optInAsset(assetIndex: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\tif (!this.walletState.activeAddress) throw new Error('There was no account!');\n\t\tif (!assetIndex) throw new Error('No asset index provided.');\n\t\tconst { transaction } = await this.atomicOptInAsset(assetIndex, optionalTxnArgs);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\n\t// this is a bit harder with the algosdk api\n\t// what we may want to do be more opinionated and have a standard local\n\t// field we always set on apps when opted in\n\n\t// OR maybe we check for HAS STATE which might check for local state\n\t// of any kind on that app id?\n\n\t// async isOptedIntoApp(account: string, appId: number): boolean {\n\t// \tlet optInState = false;\n\n\t// \tconst accountInfo = await this.getAccountInfo(account);\n\t// \taccountInfo.assets.forEach((asset: any) => {\n\t// \t\tif (asset['asset-id'] == assetId) {\n\t// \t\t\toptInState = true;\n\t// \t\t}\n\n\t// \t});\n\n\t// \treturn optInState;\n\t// }\n\n\n\t/**\n\t * You can be opted into an asset but still have a zero balance. Use this call\n\t * for cases where you just need to know the address's opt-in state\n\t * @param args object containing `account` and `assetId` properties\n\t * @returns boolean true if account holds asset\n\t */\n\tasync isOptedIntoAsset(args: { account: string, assetId: number }): Promise<boolean> {\n\t\tif (!args.account) throw new Error('No account provided.');\n\t\tif (!args.assetId) throw new Error('No asset ID provided.');\n\n\t\tlet optInState = false;\n\t\tconst accountInfo = await this.getAccountInfo(args.account);\n\t\taccountInfo.assets.forEach((asset: any) => {\n\t\t\tif (asset['asset-id'] == args.assetId) {\n\t\t\t\toptInState = true;\n\t\t\t}\n\n\t\t});\n\n\t\treturn optInState;\n\t}\n\n\t/**\n\t * Sync function that returns a correctly-encoded argument array for\n\t * an algo transaction\n\t * @param args must be an any[] array, as it will often need to be\n\t * a mix of strings and numbers. Valid types are: string, number, and bigint\n\t * @returns a Uint8Array of encoded arguments\n\t */\n\tencodeArguments(args: any[]): Uint8Array[] {\n\t\tconst encodedArgs = [] as Uint8Array[];\n\n\t\t// loop through args and encode them based on type\n\t\targs.forEach((arg: any) => {\n\t\t\tif (typeof arg == 'number') {\n\t\t\t\tencodedArgs.push(encodeUint64(arg));\n\t\t\t} else if (typeof arg == 'bigint') {\n\t\t\t\tencodedArgs.push(encodeUint64(arg));\n\t\t\t} else if (typeof arg == 'string') {\n\t\t\t\tencodedArgs.push(new Uint8Array(Buffer.from(arg)));\n\t\t\t}\n\t\t});\n\n\t\treturn encodedArgs;\n\t}\n\n\t/**\n\t * Create asset transaction\n\t * @param args : AlgonautCreateAssetArguments obj must contain: `assetName`, `symbol`, `decimals`, `amount`.\n\t * @returns atomic txn to create asset\n\t*/\n\tasync atomicCreateAsset(args: AlgonautCreateAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.assetName) throw new Error('args.assetName not provided.');\n\t\tif (!args.symbol) throw new Error('args.symbol not provided');\n\t\tif (typeof args.decimals == 'undefined') throw new Error('args.decimals not provided.');\n\t\tif (!args.amount) throw new Error('args.amount not provided.');\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tif (!args.metaBlock) {\n\t\t\targs.metaBlock = ' ';\n\t\t}\n\n\t\tif (!args.defaultFrozen) args.defaultFrozen = false;\n\t\tif (!args.assetURL) args.assetURL = undefined;\n\n\t\tconst metaBlockLength = args.metaBlock.length;\n\n\t\tif (metaBlockLength > 1023) {\n\t\t\tconsole.error('meta block is ' + metaBlockLength);\n\t\t\tthrow new Error('drat! this meta block is too long!');\n\t\t}\n\n\t\tconst enc = new TextEncoder();\n\n\t\t// arbitrary data: 1024 bytes, or about 1023 characters\n\t\tconst note = enc.encode(args.metaBlock);\n\t\tconst totalIssuance = args.amount;\n\n\t\t// set accounts\n\t\tconst manager = (args.manager && args.manager.length > 0) ? args.manager : fromAddr;\n\t\tconst reserve = (args.reserve && args.reserve.length > 0) ? args.reserve : fromAddr;\n\t\tconst freeze = (args.freeze && args.freeze.length > 0) ? args.freeze : fromAddr;\n\t\tconst clawback = (args.clawback && args.clawback.length > 0) ? args.clawback : fromAddr;\n\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t// signing and sending \"txn\" allows \"addr\" to create an asset\n\t\tconst txn = makeAssetCreateTxnWithSuggestedParams(\n\t\t\tfromAddr,\n\t\t\tnote,\n\t\t\ttotalIssuance,\n\t\t\targs.decimals,\n\t\t\targs.defaultFrozen,\n\t\t\tmanager,\n\t\t\treserve,\n\t\t\tfreeze,\n\t\t\tclawback,\n\t\t\targs.symbol,\n\t\t\targs.assetName,\n\t\t\targs.assetURL,\n\t\t\targs.assetMetadataHash,\n\t\t\tsuggestedParams\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: txn,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\n\t/**\n\t * Create asset\n\t * @param args AlgonautCreateAssetArguments. Must pass `assetName`, `symbol`, `decimals`, `amount`.\n\t * @param callbacks AlgonautTxnCallbacks\n\t * @returns asset index\n\t*/\n\tasync createAsset(\n\t\targs: AlgonautCreateAssetArguments,\n\t\tcallbacks?: AlgonautTxnCallbacks\n\t): Promise<AlgonautTransactionStatus> {\n\t\tconst atomicTxn = await this.atomicCreateAsset(args);\n\t\tconst txn = atomicTxn.transaction;\n\n\t\ttry {\n\t\t\t// const assetID = null;\n\t\t\tconst txStatus = await this.sendTransaction(txn, callbacks);\n\n\t\t\tconst ptx = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(txn.txID().toString())\n\t\t\t\t.do();\n\t\t\ttxStatus.createdIndex = ptx['asset-index'];\n\n\t\t\treturn txStatus;\n\n\t\t} catch (er) {\n\t\t\tlogger.log('transaction error');\n\t\t\tlogger.log(er);\n\t\t\tthrow new Error(er as any);\n\t\t}\n\t}\n\n\tasync atomicDeleteAsset(assetId: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!this.walletState.activeAddress) throw new Error('there was no account!');\n\t\tif (!assetId) throw new Error('No assetId provided!');\n\n\t\tconst enc = new TextEncoder();\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst transaction = makeAssetDestroyTxnWithSuggestedParams(\n\t\t\tthis.walletState.activeAddress,\n\t\t\tenc.encode('doh!'), // what is this?\n\t\t\tassetId,\n\t\t\tsuggestedParams,\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: transaction,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Deletes asset\n\t * @param assetId Index of the ASA to delete\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync deleteAsset(assetId: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\tif (!assetId) throw new Error('No asset ID provided!');\n\t\tconst { transaction } = await this.atomicDeleteAsset(assetId, optionalTxnArgs);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Creates send asset transaction.\n\t *\n\t * IMPORTANT: Before you can call this, the target account has to \"opt-in\"\n\t * to the ASA index.  You can't just send ASAs to people blind!\n\t *\n\t * @param args - object containing `to`, `assetIndex`, and `amount` properties\n\t * @returns Promise resolving to `AlgonautAtomicTransaction`\n\t */\n\tasync atomicSendAsset(args: AlgonautSendAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.to) throw new Error('No to address provided');\n\t\tif (!isValidAddress(args.to)) throw new Error('Invalid to address');\n\t\tif (!args.assetIndex) throw new Error('No asset index provided');\n\t\tif (!(typeof args.amount == 'bigint' || typeof args.amount == 'number')) {\n\t\t\tthrow new Error('Amount has to be a number.');\n\t\t}\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst transaction =\n\t\t\tmakeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\tfrom: fromAddr,\n\t\t\t\tto: args.to,\n\t\t\t\tamount: args.amount,\n\t\t\t\tassetIndex: args.assetIndex,\n\t\t\t\tsuggestedParams\n\t\t\t});\n\n\t\treturn {\n\t\t\ttransaction: transaction,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Sends asset to an address.\n\t *\n\t * IMPORTANT: Before you can call this, the target account has to \"opt-in\"\n\t * to the ASA index.  You can't just send ASAs to people blind!\n\t *\n\t * @param args - object containing `to`, `assetIndex`, and `amount` properties\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync sendAsset(args: AlgonautSendAssetArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tconst { transaction } = await this.atomicSendAsset(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Get info about an asset\n\t * @param assetIndex\n\t * @returns\n\t */\n\tasync getAssetInfo(assetIndex: number): Promise<any> {\n\t\tif (!assetIndex) throw new Error('No asset ID provided');\n\n\t\tconst info = await this.algodClient.getAssetByID(assetIndex).do();\n\t\treturn info;\n\t}\n\n\t/**\n\t * Creates transaction to opt into an app\n\t * @param args AlgonautCallAppArgs\n\t * @returns AlgonautAtomicTransaction\n\t */\n\tasync atomicOptInApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.appIndex) throw new Error('No app ID provided');\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst optInTransaction = makeApplicationOptInTxnFromObject({\n\t\t\tfrom: fromAddr,\n\t\t\tappIndex: args.appIndex,\n\t\t\tsuggestedParams,\n\t\t\tappArgs: args.appArgs ? this.encodeArguments(args.appArgs) : undefined,\n\t\t\taccounts: args.optionalFields?.accounts ? args.optionalFields?.accounts : undefined,\n\t\t\tforeignApps: args.optionalFields?.applications ? args.optionalFields?.applications : undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets ? args.optionalFields?.assets : undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: optInTransaction,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Opt-in the current account for an app.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields`\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync optInApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicOptInApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Returns atomic transaction that deletes application\n\t * @param appIndex - ID of application\n\t * @returns Promise resolving to atomic transaction that deletes application\n\t */\n\tasync atomicDeleteApp(appIndex: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!appIndex) throw new Error('No app ID provided');\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst txn = makeApplicationDeleteTxn(fromAddr, suggestedParams, appIndex);\n\n\t\treturn {\n\t\t\ttransaction: txn,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Deletes an application from the blockchain\n\t * @param appIndex - ID of application\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync deleteApp(appIndex: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\ttry {\n\t\t\tconst { transaction } = await this.atomicDeleteApp(appIndex, optionalTxnArgs);\n\t\t\tconst txId = transaction.txID().toString();\n\n\t\t\t// display results\n\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t.do();\n\t\t\tconst appId = transactionResponse['txn']['txn'].apid;\n\n\t\t\treturn {\n\t\t\t\tstatus: 'success',\n\t\t\t\tmessage: 'deleted app index ' + appId,\n\t\t\t\ttxId\n\t\t\t};\n\n\t\t} catch (e: any) {\n\t\t\tlogger.log(e);\n\t\t\tthrow new Error(e.response?.text);\n\t\t}\n\t}\n\n\tasync atomicCallApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = args?.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\t\tif (!args.appArgs.length) throw new Error('Must provide at least one appArgs');\n\n\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst callAppTransaction = makeApplicationNoOpTxnFromObject({\n\t\t\tfrom: fromAddr,\n\t\t\tsuggestedParams,\n\t\t\tappIndex: args.appIndex,\n\t\t\tappArgs: processedArgs,\n\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets || undefined,\n\t\t\tnote: args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: callAppTransaction,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Call a \"method\" on a stateful contract.  In TEAL, you're really giving\n\t * an argument which branches to a specific place and reads the other args\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t */\n\tasync callApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicCallApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\tasync atomicCallAppWithLSig(args: AlgonautLsigCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\t\tif (!args.appArgs.length) throw new Error('Must provide at least one appArgs');\n\n\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst callAppTransaction = makeApplicationNoOpTxnFromObject({\n\t\t\tfrom: args.lsig.address(),\n\t\t\tsuggestedParams,\n\t\t\tappIndex: args.appIndex,\n\t\t\tappArgs: processedArgs,\n\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: callAppTransaction,\n\t\t\tisLogigSig: true,\n\t\t\tlSig: args.lsig,\n\t\t};\n\t}\n\n\t/**\n\t * Returns an atomic transaction that closes out the user's local state in an application.\n\t * The opposite of {@link atomicOptInApp}.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t * @returns Promise resolving to atomic transaction\n\t */\n\tasync atomicCloseOutApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = args?.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\n\t\ttry {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\t\tconst closeOutTxn = makeApplicationCloseOutTxnFromObject({\n\t\t\t\tfrom: fromAddr,\n\t\t\t\tsuggestedParams,\n\t\t\t\tappIndex: args.appIndex,\n\t\t\t\tappArgs: processedArgs,\n\t\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: closeOutTxn,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\t\t} catch (e: any) {\n\t\t\tthrow new Error(e);\n\t\t}\n\t}\n\n\t/**\n\t * Closes out the user's local state in an application.\n\t * The opposite of {@link optInApp}.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to atomic transaction\n\t */\n\tasync closeOutApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks) {\n\t\tconst { transaction } = await this.atomicCloseOutApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Get an application's escrow account\n\t * @param appId - ID of application\n\t * @returns Escrow account address as string\n\t */\n\tgetAppEscrowAccount(appId: number | bigint): string {\n\t\tif (!appId) throw new Error('No appId provided');\n\t\treturn getApplicationAddress(appId);\n\t}\n\n\t/**\n\t * Get info about an application (globals, locals, creator address, index)\n\t *\n\t * @param appId - ID of application\n\t * @returns Promise resolving to application state\n\t */\n\tasync getAppInfo(appId: number): Promise<AlgonautAppState> {\n\t\tif (!appId) throw new Error('No appId provided');\n\n\t\tconst proms = [\n\t\t\tthis.algodClient.getApplicationByID(appId).do(),\n\t\t] as Promise<any>[];\n\n\t\tconst addr = this.walletState.activeAddress;\n\t\t// get locals if we have an account\n\t\tif (addr) {\n\t\t\tproms.push(this.getAppLocalState(appId)); // TODO get rid of this call / only return locals (not incorrect duplicate state obj)\n\t\t}\n\n\t\tconst promsRes = await Promise.all(proms);\n\t\tconst info = promsRes[0] as AlgonautGetApplicationResponse;\n\t\tconst localState = promsRes[1] as AlgonautAppState | void;\n\n\t\t// decode state\n\t\tconst state = {\n\t\t\thasState: true,\n\t\t\tglobals: [],\n\t\t\tlocals: localState?.locals || [],\n\t\t\tcreatorAddress: info.params.creator,\n\t\t\tindex: appId\n\t\t} as AlgonautAppState;\n\n\t\tif (info.params['global-state']) {\n\t\t\tstate.globals = this.decodeStateArray(info.params['global-state']);\n\t\t}\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Create and deploy a new Smart Contract from TEAL code\n\t *\n\t * @param args AlgonautDeployArguments\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns AlgonautTransactionStatus\n\t */\n\tasync createApp(\n\t\targs: AlgonautDeployArguments,\n\t\tcallbacks?: AlgonautTxnCallbacks\n\t): Promise<AlgonautTransactionStatus> {\n\t\tif (args.optionalFields &&\n\t\t\targs.optionalFields.note &&\n\t\t\targs.optionalFields.note.length > 1023) {\n\t\t\tconsole.warn('drat! your note is too long!');\n\t\t\tthrow new Error('Your note is too long');\n\t\t}\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (!args.schema) throw new Error('No schema provided');\n\n\t\ttry {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\t\t\t// logger.log('approval', approvalProgram);\n\t\t\t// logger.log('clear', clearProgram);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (approvalProgram && clearProgram) {\n\n\t\t\t\tconst txn = makeApplicationCreateTxnFromObject({\n\t\t\t\t\tfrom: fromAddr,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete: OnApplicationComplete.NoOpOC,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\tnumLocalInts: args.schema.localInts,\n\t\t\t\t\tnumLocalByteSlices: args.schema.localBytes,\n\t\t\t\t\tnumGlobalInts: args.schema.globalInts,\n\t\t\t\t\tnumGlobalByteSlices: args.schema.globalBytes,\n\t\t\t\t\tappArgs: this.encodeArguments(args.appArgs),\n\t\t\t\t\taccounts: args.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\t\tforeignApps: args.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\t\tforeignAssets: args.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\t\tnote: args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t\t});\n\t\t\t\tconst txId = txn.txID().toString();\n\n\t\t\t\t// Wait for confirmation\n\t\t\t\tconst result = await this.sendTransaction(txn, callbacks);\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\n\t\t\t\tresult.message = 'Created App ID: ' + transactionResponse['application-index'];\n\t\t\t\tresult.createdIndex = transactionResponse['application-index'];\n\t\t\t\tresult.meta = transactionResponse;\n\t\t\t\tresult.txId = txId;\n\t\t\t\treturn result;\n\n\t\t\t} else {\n\t\t\t\tthrow new Error('could not compile teal code');\n\t\t\t}\n\n\t\t} catch (er: any) {\n\t\t\tthrow new Error(er.message);\n\t\t}\n\t}\n\n\t/**\n\t * Create an atomic transaction to deploy a\n\t * new Smart Contract from TEAL code\n\t *\n\t * @param args AlgonautDeployArguments\n\t * @returns AlgonautAtomicTransaction\n\t */\n\tasync atomicCreateApp(args: AlgonautDeployArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (!args.schema) throw new Error('No schema provided');\n\n\t\tif (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {\n\t\t\tthrow new Error('Your NOTE is too long, it must be less thatn 1024 Bytes');\n\t\t} else if (fromAddr) {\n\t\t\ttry {\n\t\t\t\tconst onComplete = OnApplicationComplete.NoOpOC;\n\t\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t\t// create unsigned transaction\n\t\t\t\tif (!approvalProgram || !clearProgram) {\n\t\t\t\t\tthrow new Error('Error: you must provide an approval program and a clear state program.');\n\t\t\t\t}\n\n\t\t\t\tconst applicationCreateTransaction = makeApplicationCreateTxn(\n\t\t\t\t\tfromAddr,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\t\targs.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t\t);\n\n\t\t\t\treturn {\n\t\t\t\t\ttransaction: applicationCreateTransaction,\n\t\t\t\t\tisLogigSig: false\n\t\t\t\t};\n\n\t\t\t} catch (er: any) {\n\t\t\t\tthrow new Error('There was an error creating the transaction');\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Algonaut.js has no account loaded!');\n\t\t}\n\t}\n\n\n\t/**\n\t * deploys a contract from an lsig account\n\t * keep in mind that the local and global byte and int values have caps,\n\t * 16 for local and 32 for global and that the cost of deploying the\n\t * app goes up based on how many of these slots you want to allocate\n\t *\n\t * @param args AlgonautLsigDeployArguments\n\t * @returns\n\t */\n\tasync deployTealWithLSig(\n\t\targs: AlgonautLsigDeployArguments\n\t): Promise<AlgonautTransactionStatus> {\n\t\tif (args.noteText && args.noteText.length > 511) {\n\t\t\tthrow new Error('Your note is too long');\n\t\t}\n\n\t\tlet encodedArgs = [] as Uint8Array[];\n\t\tif (args.appArgs && args.appArgs.length) {\n\t\t\tencodedArgs = this.encodeArguments(args.appArgs);\n\t\t}\n\n\t\tconst sender = args.lsig.address();\n\t\tconst onComplete = OnApplicationComplete.NoOpOC;\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tlet approvalProgram = new Uint8Array();\n\t\tlet clearProgram = new Uint8Array();\n\n\t\ttry {\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (approvalProgram && clearProgram) {\n\t\t\t\tconst txn = makeApplicationCreateTxn(\n\t\t\t\t\tsender,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tencodedArgs,\n\t\t\t\t\targs.optionalFields?.accounts || undefined\n\t\t\t\t);\n\n\t\t\t\tconst txId = txn.txID().toString();\n\t\t\t\tconst signedTxn = signLogicSigTransactionObject(txn, args.lsig);\n\n\t\t\t\tawait this.algodClient.sendRawTransaction(signedTxn.blob).do();\n\n\t\t\t\t// TBD check txStatus\n\t\t\t\t// const txStatus = await this.waitForConfirmation(txId);\n\n\t\t\t\t// display results\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\t\t\t\tconst appId = transactionResponse['application-index'];\n\n\t\t\t\treturn {\n\t\t\t\t\tstatus: 'success',\n\t\t\t\t\tmessage: 'created new app with id: ' + appId,\n\t\t\t\t\ttxId\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthrow new Error('Error compiling programs.');\n\t\t\t}\n\t\t} catch (er: any) {\n\t\t\tconsole.error('Error deploying contract:');\n\t\t\tthrow new Error(er);\n\t\t}\n\t}\n\n\t/**\n\t * Updates an application with `makeApplicationUpdateTxn`\n\t * @param args AlgonautUpdateAppArguments\n\t * @returns atomic transaction that updates the app\n\t */\n\tasync atomicUpdateApp(args: AlgonautUpdateAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {\n\t\t\tthrow new Error('Your NOTE is too long, it must be less thatn 1024 Bytes');\n\t\t}\n\n\t\ttry {\n\t\t\t// const onComplete = OnApplicationComplete.NoOpOC;\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (!approvalProgram || !clearProgram) {\n\t\t\t\tthrow new Error('Error: you must provide an approval program and a clear state program.');\n\t\t\t}\n\n\t\t\tconst applicationCreateTransaction = makeApplicationUpdateTxn(\n\t\t\t\tfromAddr,\n\t\t\t\tsuggestedParams,\n\t\t\t\targs.appIndex,\n\t\t\t\tapprovalProgram,\n\t\t\t\tclearProgram,\n\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\targs.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\ttransaction: applicationCreateTransaction,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\n\t\t} catch (er: any) {\n\t\t\tthrow new Error('There was an error creating the transaction');\n\t\t}\n\t}\n\n\t/**\n\t * Sends an update app transaction\n\t * @param args AlgonautUpdateAppArguments\n\t * @param callbacks optional callbacks: `onSign`, `onSend`, `onConfirm`\n\t * @returns transaction status\n\t */\n\tasync updateApp(args: AlgonautUpdateAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicUpdateApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Compiles TEAL source via [algodClient.compile](https://py-algorand-sdk.readthedocs.io/en/latest/algosdk/v2client/algod.html#v2client.algod.AlgodClient.compile)\n\t * @param programSource source to compile\n\t * @returns Promise resolving to Buffer of compiled bytes\n\t */\n\tasync compileProgram(programSource: string): Promise<Uint8Array> {\n\t\tconst encoder = new TextEncoder();\n\t\tconst programBytes = encoder.encode(programSource);\n\t\tconst compileResponse = await this.algodClient.compile(programBytes).do();\n\t\tconst compiledBytes = new Uint8Array(\n\t\t\tBuffer.from(compileResponse.result, 'base64')\n\t\t);\n\t\treturn compiledBytes;\n\t}\n\n\tasync atomicSendAlgo(args: AlgonautPaymentArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!(typeof args.amount == 'bigint' || typeof args.amount == 'number')) {\n\t\t\tthrow new Error('Amount has to be a number.');\n\t\t}\n\t\tif (!args.to) throw new Error('You did not specify a to address');\n\t\tif (!isValidAddress(args.to)) throw new Error('Invalid to address');\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tif (fromAddr) {\n\t\t\tconst encodedNote = args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : new Uint8Array();\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tconst transaction =\n\t\t\t\tmakePaymentTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: fromAddr,\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tnote: encodedNote,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no fromAddr');\n\t\t}\n\t}\n\n\t/**\n\t * Sends ALGO from own account to `args.to`\n\t *\n\t * @param args `AlgonautPaymentArgs` object containing `to`, `amount`, and optional `note`\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to transaction status\n\t */\n\tasync sendAlgo(args: AlgonautPaymentArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicSendAlgo(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Fetch full account info for an account\n\t * @param address the accress to read info for\n\t * @returns Promise of type AccountInfo\n\t */\n\tasync getAccountInfo(address: string): Promise<any> {\n\t\tif (!address) throw new Error('No address provided');\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\treturn accountInfo;\n\t}\n\n\n\t/**\n\t * Checks Algo balance of account\n\t * @param address - Wallet of balance to check\n\t * @returns Promise resolving to Algo balance\n\t */\n\tasync getAlgoBalance(address: string): Promise<any> {\n\t\tif (!address) throw new Error('No address provided');\n\t\t//logger.log('checking algo balance');\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\treturn accountInfo.amount;\n\t}\n\n\t/**\n\t * Checks token balance of account\n\t * @param address - Wallet of balance to check\n\t * @param assetIndex - the ASA index\n\t * @returns Promise resolving to token balance\n\t */\n\tasync getTokenBalance(address: string, assetIndex: number): Promise<number> {\n\t\tif (!address) throw new Error('No address provided');\n\t\tif (!assetIndex) throw new Error('No asset index provided');\n\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\t//logger.log('accountInfo', accountInfo);\n\n\t\tlet bal = 0;\n\t\taccountInfo.assets.forEach((asset: any) => {\n\t\t\tif (asset['asset-id'] == assetIndex) {\n\t\t\t\tbal = asset.amount;\n\t\t\t}\n\t\t});\n\n\t\treturn bal;\n\t}\n\n\t/**\n\t * Checks if account has at least one token (before playback)\n\t * Keeping this here in case this is a faster/less expensive operation than checking actual balance\n\t * @param address - Address to check\n\t * @param assetIndex - the index of the ASA\n\t */\n\tasync accountHasTokens(address: string, assetIndex: number): Promise<boolean> {\n\t\tconst bal = await this.getTokenBalance(address, assetIndex);\n\t\tif (bal > 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Gets global state for an application.\n\t * @param applicationIndex - the applications index\n\t * @returns {object} object representing global state\n\t */\n\tasync getAppGlobalState(applicationIndex: number): Promise<any> {\n\t\tif (!applicationIndex) throw new Error('No application ID provided');\n\n\t\tconst info = await this.getAppInfo(applicationIndex);\n\t\tif (info.hasState) {\n\t\t\treturn this.stateArrayToObject(info.globals);\n\t\t} else {\n\t\t\treturn {} as any;\n\t\t}\n\t}\n\n\t/**\n\t * Gets account local state for an app. Defaults to AnyWallets.activeAddress unless\n\t * an address is provided.\n\t * @param applicationIndex the applications index\n\t */\n\tasync getAppLocalState(applicationIndex: number, address?: string): Promise<AlgonautAppState | void> {\n\t\tif (!applicationIndex) throw new Error('No application ID provided');\n\n\t\tconst state = {\n\t\t\thasState: false,\n\t\t\tglobals: [],\n\t\t\tlocals: [],\n\t\t\tcreatorAddress: '',\n\t\t\tindex: applicationIndex\n\t\t} as AlgonautAppState;\n\n\t\t// read state\n\n\t\t// can we detect addresses values and auto-convert them?\n\t\t// maybe a 32-byte field gets an address field added?\n\n\t\tif (this.walletState.activeAddress && !address) {\n\t\t\taddress = this.walletState.activeAddress;\n\t\t}\n\n\t\tif (address) {\n\t\t\tconst accountInfoResponse = await this.algodClient\n\t\t\t\t.accountInformation(address)\n\t\t\t\t.do();\n\n\t\t\t//logger.log(accountInfoResponse);\n\n\t\t\tfor (let i = 0; i < accountInfoResponse['apps-local-state'].length; i++) {\n\t\t\t\tif (accountInfoResponse['apps-local-state'][i].id == applicationIndex) {\n\t\t\t\t\t//logger.log('Found Application');\n\n\t\t\t\t\tstate.hasState = true;\n\n\t\t\t\t\tfor (let n = 0; n < accountInfoResponse['apps-local-state'][i]['key-value'].length; n++) {\n\n\t\t\t\t\t\tconst stateItem = accountInfoResponse['apps-local-state'][i]['key-value'][n];\n\t\t\t\t\t\tconst key = Buffer.from(stateItem.key, 'base64').toString();\n\t\t\t\t\t\tconst type = stateItem.value.type;\n\t\t\t\t\t\tlet value = undefined as undefined | string | number;\n\t\t\t\t\t\tlet valueAsAddr = '';\n\n\t\t\t\t\t\tif (type == 1) {\n\t\t\t\t\t\t\tvalue = Buffer.from(stateItem.value.bytes, 'base64').toString();\n\t\t\t\t\t\t\tvalueAsAddr = encodeAddress(Buffer.from(stateItem.value.bytes, 'base64'));\n\n\t\t\t\t\t\t} else if (stateItem.value.type == 2) {\n\t\t\t\t\t\t\tvalue = stateItem.value.uint;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.locals.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tvalue: value || '',\n\t\t\t\t\t\t\taddress: valueAsAddr\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn state;\n\t\t} else {\n\t\t\t// throw new Error('No address provided, and no account set.');\n\t\t\tconsole.warn('Algonaut used in non-authd state, not getting local vars');\n\t\t}\n\t}\n\n\tasync atomicAssetTransferWithLSig(args: AlgonautLsigSendAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (args.lsig) {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tconst transaction =\n\t\t\t\tmakeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tassetIndex: args.assetIndex,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\tisLogigSig: true,\n\t\t\t\tlSig: args.lsig,\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no logic sig object!');\n\t\t}\n\t}\n\n\tasync atomicPaymentWithLSig(args: AlgonautLsigPaymentArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (args.lsig) {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\t\tconst transaction =\n\t\t\t\tmakePaymentTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\tisLogigSig: true,\n\t\t\t\tlSig: args.lsig,\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no account!');\n\t\t}\n\t}\n\n\tnormalizeTxns(txnOrTxns: Transaction | AlgonautAtomicTransaction | AlgonautAtomicTransaction[]) {\n\t\tlogger.log('normalizeTxns', txnOrTxns);\n\n\t\tlet txnArr: (AlgonautAtomicTransaction | Transaction)[] = [];\n\n\t\tif (!Array.isArray(txnOrTxns)) {\n\t\t\ttxnArr = [txnOrTxns];\n\t\t} else {\n\t\t\ttxnArr = txnOrTxns;\n\t\t}\n\t\t// logger.log('txnArr', txnArr);\n\n\t\tlet algoTxnArr: Transaction[] = [];\n\t\talgoTxnArr = txnArr.map((t) => {\n\t\t\tlet nativeT = (t as AlgonautAtomicTransaction).transaction as Transaction | undefined;\n\t\t\tif (nativeT == undefined) {\n\t\t\t\tnativeT = t as Transaction;\n\t\t\t}\n\t\t\treturn nativeT;\n\t\t});\n\t\tlogger.log('algoTxnArr', [...algoTxnArr]);\n\n\t\t// assign txn(s) a group id\n\t\tif (algoTxnArr.length > 1) {\n\t\t\talgoTxnArr = algosdk.assignGroupID(algoTxnArr);\n\t\t\tlogger.log('added group id to txn array');\n\t\t\tif (algoTxnArr[0].group) {\n\t\t\t\tconst gId = this.txnBuffToB64(algoTxnArr[0].group);\n\t\t\t\tlogger.log('gId', gId);\n\t\t\t}\n\t\t}\n\n\t\tconst txnBuffArr = algoTxnArr.map(t => t.toByte());\n\t\tlogger.log('txnBuffArr', txnBuffArr);\n\n\t\treturn txnBuffArr;\n\t}\n\n\t/**\n\t * Signs a transaction or multiple w the correct wallet according to AW (does not send / submit txn(s) to network)\n\t * @param txnOrTxns Either an array of atomic transactions or a single transaction to sign\n\t * @param signedTxns array of\n\t * @returns Promise resolving to AlgonautTransactionStatus\n\t */\n\tasync signTransaction(txnOrTxns: AlgonautAtomicTransaction[] | Transaction | AlgonautAtomicTransaction): Promise<Uint8Array[]> {\n\t\tconst awTxnsToSign = this.normalizeTxns(txnOrTxns);\n\t\tlogger.log('awTxnsToSign', awTxnsToSign);\n\t\tlet awTxnsSigned: Uint8Array[];\n\t\ttry {\n\t\t\tawTxnsSigned = await this.walletState.signTransactions(awTxnsToSign);\n\t\t\tlogger.log('awTxnsSigned', awTxnsSigned);\n\t\t} catch (e) {\n\t\t\tconsole.warn('err signing txns...');\n\t\t\tlogger.log(e);\n\t\t\tthrow new Error('Error signing transactions');\n\t\t}\n\t\treturn awTxnsSigned;\n\t}\n\n\t/**\n\t * Sends a transaction or multiple w the correct wallet according to AW\n\t * @param txnOrTxns Either an array of atomic transactions or a single transaction to sign\n\t * @param callbacks Optional object with callbacks - `onSign`, `onSend`, and `onConfirm`\n\t * @returns Promise resolving to AlgonautTransactionStatus\n\t */\n\tasync sendTransaction(txnOrTxns: AlgonautAtomicTransaction[] | Transaction | AlgonautAtomicTransaction, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\t/**\n\t\t * 1. normalize incoming txn(s) to array of Uint8Arrs\n\t\t * 2. sign w AW\n\t\t * 3. send Raw txn arr\n\t\t * 4. return result + txid\n\t\t */\n\n\t\tconst awTxnsSigned = await this.signTransaction(txnOrTxns);\n\n\t\tif (callbacks?.onSign) callbacks.onSign(awTxnsSigned);\n\n\t\tconst tx = await this.algodClient.sendRawTransaction(awTxnsSigned).do();\n\n\t\tif (callbacks?.onSend) callbacks.onSend(tx);\n\n\t\t// Wait for transaction to be confirmed\n\t\tconst txStatus = await this.waitForConfirmation(tx.txId);\n\n\t\tconst transactionResponse = await this.algodClient\n\t\t\t.pendingTransactionInformation(tx.txId)\n\t\t\t.do();\n\t\ttxStatus.meta = transactionResponse;\n\n\t\tif (callbacks?.onConfirm) callbacks.onConfirm(txStatus);\n\t\treturn txStatus;\n\t}\n\n\t/**\n\t *\n\t * @param str string\n\t * @param enc the encoding type of the string (defaults to utf8)\n\t * @returns string encoded as Uint8Array\n\t */\n\ttoUint8Array(str: string, enc: BufferEncoding = 'utf8'): Uint8Array {\n\t\treturn new Uint8Array(Buffer.from(str, enc));\n\t}\n\n\t/**\n\t * @deprecated use toUint8Array instead.\n\t * @param str string\n\t * @param enc the encoding type of the string (defaults to utf8)\n\t * @returns string encoded as Uint8Array\n\t */\n\tto8Arr(str: string, enc: BufferEncoding = 'utf8'): Uint8Array {\n\t\treturn this.toUint8Array(str, enc);\n\t}\n\n\t/**\n\t * Helper function to turn `globals` and `locals` array into more useful objects\n\t *\n\t * @param stateArray State array returned from functions like {@link getAppInfo}\n\t * @returns A more useful object: `{ array[0].key: array[0].value, array[1].key: array[1].value, ... }`\n\t * TODO add correct typing for this method\n\t */\n\tstateArrayToObject(stateArray: object[]): any {\n\t\tconst stateObj = {} as any;\n\t\tstateArray.forEach((value: any) => {\n\t\t\tif (value.key) stateObj[value.key] = value.value || null;\n\t\t});\n\t\treturn stateObj;\n\t}\n\n\t/**\n\t * Used for decoding state\n\t * @param encoded Base64 string\n\t * @returns Human-readable string\n\t */\n\tb64StrToHumanStr(encoded: string): string {\n\t\treturn Buffer.from(encoded, 'base64').toString();\n\t}\n\n\t/**\n\t * @deprecated Use b64StrToHumanStr instead\n\t * @param encoded Base64 string\n\t * @returns Human-readable string\n\t */\n\tfromBase64(encoded: string): string {\n\t\treturn this.b64StrToHumanStr(encoded);\n\t}\n\n\t/**\n\t * Decodes a Base64-encoded Uint8 Algorand address and returns a string\n\t * @param encoded An encoded Algorand address\n\t * @returns Decoded address\n\t */\n\tvalueAsAddr(encoded: string): string {\n\t\treturn encodeAddress(Buffer.from(encoded, 'base64'));\n\t}\n\n\t/**\n\t * Decodes app state into a human-readable format\n\t * @param stateArray Encoded app state\n\t * @returns Array of objects with key, value, and address properties\n\t */\n\tdecodeStateArray(stateArray: AlgonautAppStateEncoded[]) {\n\t\tconst result: AlgonautStateData[] = [];\n\n\t\tfor (let n = 0;\n\t\t\tn < stateArray.length;\n\t\t\tn++) {\n\n\t\t\tconst stateItem = stateArray[n];\n\n\t\t\tconst key = this.b64StrToHumanStr(stateItem.key);\n\t\t\tconst type = stateItem.value.type;\n\t\t\tlet value = undefined as undefined | string | number;\n\t\t\tlet valueAsAddr = '';\n\n\t\t\tif (type == 1) {\n\t\t\t\tvalue = this.b64StrToHumanStr(stateItem.value.bytes);\n\t\t\t\tvalueAsAddr = this.valueAsAddr(stateItem.value.bytes);\n\n\t\t\t} else if (stateItem.value.type == 2) {\n\t\t\t\tvalue = stateItem.value.uint;\n\t\t\t}\n\n\t\t\tresult.push({\n\t\t\t\tkey: key,\n\t\t\t\tvalue: value || '',\n\t\t\t\taddress: valueAsAddr\n\t\t\t});\n\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Does what it says on the tin.\n\t * @param txn base64-encoded unsigned transaction\n\t * @returns transaction object\n\t */\n\tdecodeBase64UnsignedTransaction(txn: string): Transaction {\n\t\treturn decodeUnsignedTransaction(Buffer.from(txn, 'base64'));\n\t}\n\n\t/**\n\t * Describes an Algorand transaction, for display in Inkey\n\t * @param txn Transaction to describe\n\t */\n\ttxnSummary(txn: Transaction) {\n\t\t// for reference: https://developer.algorand.org/docs/get-details/transactions/transactions/\n\n\t\tif (txn.type) {\n\t\t\tconst to = txn.to ? encodeAddress(txn.to.publicKey) : '';\n\t\t\tconst from = txn.from ? encodeAddress(txn.from.publicKey) : '';\n\n\t\t\t// sending algo\n\t\t\tif (txn.type === 'pay') {\n\t\t\t\tif (txn.amount) {\n\t\t\t\t\treturn `Send ${microalgosToAlgos(txn.amount as number)} ALGO to ${to}`;\n\t\t\t\t} else {\n\t\t\t\t\treturn `Send 0 ALGO to ${to}`;\n\t\t\t\t}\n\n\t\t\t\t// sending assets\n\t\t\t} else if (txn.type === 'axfer') {\n\t\t\t\tif (!txn.amount && to === from) {\n\t\t\t\t\treturn `Opt-in to asset ID ${txn.assetIndex}`;\n\t\t\t\t} else {\n\t\t\t\t\tconst amount = txn.amount ? txn.amount : 0;\n\t\t\t\t\treturn `Transfer ${amount} of asset ID ${txn.assetIndex} to ${to}`;\n\t\t\t\t}\n\n\t\t\t\t// asset config\n\t\t\t\t// this could be creating, destroying, or configuring an asset,\n\t\t\t\t// depending on which fields are set\n\t\t\t} else if (txn.type === 'acfg') {\n\n\t\t\t\t// if unit name is supplied, we are creating\n\t\t\t\tif (txn.assetUnitName) {\n\t\t\t\t\treturn `Create asset ${txn.assetName}, symbol ${txn.assetUnitName}`;\n\t\t\t\t}\n\n\t\t\t\treturn `Configure asset ${txn.assetIndex}`;\n\n\t\t\t\t// asset freeze\n\t\t\t} else if (txn.type === 'afrz') {\n\t\t\t\treturn `Freeze asset ${txn.assetIndex}`;\n\n\t\t\t\t// application call\n\t\t\t} else if (txn.type === 'appl') {\n\t\t\t\t// let's find out what kind of application call this is\n\t\t\t\t// reference: https://developer.algorand.org/docs/get-details/dapps/avm/teal/specification/#oncomplete\n\t\t\t\tswitch (txn.appOnComplete) {\n\t\t\t\t\t// NoOp\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturn `Call to application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// OptIn\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn `Opt-in to application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// CloseOut\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn `Close out application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// ClearState\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturn `Execute clear state program of application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// Update\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\treturn `Update application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// Delete\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\treturn `Delete application ID ${txn.appIndex}`;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (txn.appIndex == undefined) {\n\t\t\t\t\t\t\t// Create\n\t\t\t\t\t\t\treturn 'Create an application';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn `Call to application ID ${txn.appIndex}`;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// default case\n\t\t\t} else {\n\t\t\t\treturn `Transaction of type ${txn.type} to ${to}`;\n\t\t\t}\n\t\t} else {\n\t\t\t// no better option\n\t\t\treturn txn.toString();\n\t\t}\n\t}\n\n\t/**\n\t * Creates a wallet address + mnemonic from account's secret key.\n\t * Changed in 0.3: this does NOT set algonaut.account.\n\t * @returns AlgonautWallet Object containing `address` and `mnemonic`\n\t */\n\tcreateWallet(): AlgonautWallet {\n\t\tconst account = generateAccount();\n\n\t\tif (account) {\n\t\t\tconst mnemonic = secretKeyToMnemonic(account.sk);\n\t\t\treturn {\n\t\t\t\taddress: account.addr,\n\t\t\t\tmnemonic: mnemonic,\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('There was no account: could not create algonaut wallet!');\n\t\t}\n\t}\n\n\t/**\n\t * Recovers account from mnemonic\n\t * Changed in 0.3: this does NOT set algonaut.account.\n\t * @param mnemonic Mnemonic associated with Algonaut account\n\t * @returns If mnemonic is valid, returns algosdk account (.addr, .sk). Otherwise, throws an error.\n\t */\n\trecoverAccount(mnemonic: string): AlgosdkAccount {\n\t\tif (!mnemonic) throw new Error('No mnemonic provided.');\n\n\t\ttry {\n\t\t\tconst account = mnemonicToSecretKey(mnemonic);\n\t\t\tif (isValidAddress(account?.addr)) {\n\t\t\t\treturn account;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Not a valid mnemonic.');\n\t\t\t}\n\t\t} catch (error: any) {\n\t\t\t// should we throw an error here instead of returning false?\n\t\t\tconsole.error(error);\n\t\t\tthrow new Error('Could not recover account from mnemonic.');\n\t\t}\n\t}\n\n\t/**\n\t * txn(b64) -> txnBuff (buffer)\n\t * @param txn base64-encoded unsigned transaction\n\t * @returns trransaction as buffer object\n\t */\n\ttxnB64ToTxnBuff(txn: string): Buffer {\n\t\treturn Buffer.from(txn, 'base64');\n\t}\n\n\t/**\n\t * Converts between buff -> b64 (txns)\n\t * @param buff likely a algorand txn as a Uint8Array buffer\n\t * @returns string (like for inkey / base64 transmit use)\n\t */\n\ttxnBuffToB64(buff: Uint8Array): string {\n\t\treturn Buffer.from(buff).toString('base64');\n\t}\n\n\t/**\n\t * Does what it says on the tin.\n\t * @param txn algorand txn object\n\t * @returns string (like for inkey / base64 transmit use)\n\t */\n\ttxnToStr(txn: algosdk.Transaction): string {\n\t\tconst buff = txn.toByte();\n\t\treturn this.txnBuffToB64(buff);\n\t}\n\n}\nexport default Algonaut;\n\nexport const buffer = Buffer; // sometimes this is helpful on the frontend\n","import type { AlgonautConfig } from './AlgonautTypes';\n\nexport const testnetConfig: AlgonautConfig['nodeConfig'] = {\n\tLEDGER: 'testnet',\n\tBASE_SERVER: 'https://testnet-api.algonode.cloud',\n\tINDEX_SERVER: 'https://testnet-idx.algonode.cloud',\n\tAPI_TOKEN: '',\n\tPORT: '', // 443\n};\nexport const mainnetConfig: AlgonautConfig['nodeConfig'] = {\n\tLEDGER: 'mainnet',\n\tBASE_SERVER: 'https://mainnet-api.algonode.cloud',\n\tINDEX_SERVER: 'https://mainnet-idx.algonode.cloud',\n\tAPI_TOKEN: '',\n\tPORT: '',\n};\nexport const defaultNodeConfig = testnetConfig;\n","import type { AlgonautConfig } from './AlgonautTypes';\n\nexport const defaultLibConfig = {\n\tdisableLogs: true,\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// log helper - for disabling logs w a query string but not the dapp's logs\nexport const logger = {\n\tenabled: false,\n\tlog(...args: any) {\n\t\tif (!this.enabled) return;\n\t\tconsole.log(...args);\n\t},\n\tdebug(...args: any) {\n\t\tif (!this.enabled) return;\n\t\tconsole.debug(...args);\n\t},\n};\n"]}