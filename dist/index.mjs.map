{
  "version": 3,
  "sources": ["../src/index.ts", "../src/AlgonautTypes.ts", "../node_modules/.pnpm/@vue-reactivity+watch@0.2.0_@vue+reactivity@3.3.4_@vue+shared@3.3.4/node_modules/@vue-reactivity/watch/dist/index.mjs", "../src/algo-config.ts", "../src/constants.ts", "../src/utils.ts"],
  "sourcesContent": ["import { Buffer } from 'buffer';\n\nimport algosdk, {\n\tsecretKeyToMnemonic,\n\tgenerateAccount,\n\tAccount as AlgosdkAccount,\n\tAlgodv2,\n\tIndexer,\n\tLogicSigAccount,\n\tmakeAssetTransferTxnWithSuggestedParamsFromObject,\n\tmakeApplicationOptInTxnFromObject,\n\tmakeAssetCreateTxnWithSuggestedParams,\n\tmakeAssetDestroyTxnWithSuggestedParams,\n\tmakeApplicationDeleteTxn,\n\tmakeApplicationNoOpTxnFromObject,\n\tmakeApplicationCloseOutTxnFromObject,\n\tmakeApplicationCreateTxnFromObject,\n\tOnApplicationComplete,\n\tmakeApplicationCreateTxn,\n\tsignLogicSigTransactionObject,\n\tmakeApplicationUpdateTxn,\n\tencodeAddress,\n\tmakePaymentTxnWithSuggestedParamsFromObject,\n\tTransaction,\n\tmnemonicToSecretKey,\n\tisValidAddress,\n\tencodeUint64,\n\tgetApplicationAddress,\n\tmicroalgosToAlgos,\n\tdecodeUnsignedTransaction,\n\tsignMultisigTransaction\n} from 'algosdk';\n\nimport type {\n\tAlgonautConfig,\n\tAlgonautWallet,\n\tAlgonautTransactionStatus,\n\tAlgonautAtomicTransaction,\n\tAlgonautTransactionFields,\n\tAlgonautAppState,\n\tAlgonautStateData,\n\tAlgonautError,\n\tAlgonautTxnCallbacks,\n\tAlgonautContractSchema,\n\tAlgonautCreateAssetArguments,\n\tAlgonautSendAssetArguments,\n\tAlgonautCallAppArguments,\n\tAlgonautDeployArguments,\n\tAlgonautLsigDeployArguments,\n\tAlgonautLsigCallAppArguments,\n\tAlgonautLsigSendAssetArguments,\n\tAlgonautPaymentArguments,\n\tAlgonautLsigPaymentArguments,\n\tAlgonautUpdateAppArguments,\n\tAlgonautGetApplicationResponse,\n\tAlgonautAppStateEncoded,\n\tTxnForSigning\n} from './AlgonautTypes';\nexport * from './AlgonautTypes';\nexport type AlgoTxn = Transaction;\n\nimport { \n\tAnyWalletState, \n\tenableWallets, \n\tremoveAllAccounts, \n\tsetLogsEnabled as AWSetLogsEnabled, \n\tsignTransactions, \n\tsubscribeToAccountChanges,\n\tWALLET_ID,\n\trecallState\n} from '@thencc/any-wallet';\nimport type {\n\tAccount,\n\tClientInitParams,\n\tWalletInitParamsObj\n} from '@thencc/any-wallet';\nexport * from '@thencc/any-wallet';\n\nimport type { createClient } from '@thencc/inkey-client-js';\ntype InkeySdk = Awaited<ReturnType<typeof createClient>>;\n\nimport { defaultNodeConfig, mainnetConfig, testnetConfig } from './algo-config';\nimport { defaultLibConfig } from './constants';\nimport { logger } from './utils';\n\n/*\n\nfor stateful contracts i think we want to read it in and hold all the\nNV pairs as fields\n\nand maybe read the TEAL and make wrapper methods for things we see in\na config file?\n\nTBD:\n\n- standard typed return values\n- standard error values, pre-parse the algo error goop\n\n\nthere are a couple ways to go for atomic txs, i THINK the more pleasant API is\n\nawait runAtomicTransaction([\n\tawait atomicSendASA(),\n\tawait atomicSendAlgo(),\n\tawait atomicCallApp()\n])\n\n*/\n\nlet unsAcctSync = null as null | (() => void);\n\nexport class Algonaut {\n\talgodClient!: Algodv2; // it will be set or it throws an Error\n\tindexerClient = undefined as undefined | Indexer;\n\tnodeConfig = defaultNodeConfig;\n\tlibConfig = defaultLibConfig;\n\t\n\t// expose entire algosdk in case the dapp needs more\n\tsdk = algosdk;\n\t\n\t// handles all algo wallets (inkey, pera, etc) + remembers last used in localstorage\n\twalletState = AnyWalletState;\n\tinkeyClientSdk = null as null | InkeySdk;\n\tinkeyLoading = false;\n\tinkeyLoaded = false;\n\n\taccount = null as null | typeof AnyWalletState.activeAccount;\n\tget connectedAccounts() {\n\t\treturn AnyWalletState.connectedAccounts;\n\t}\n\n\t// TODO come back to private class fields during the security pass. + figure out how to make account immutable\n\t// \"#account\" set on aw acct listener (but private fields compile weird..? making a #private field in the type dec)\n\t// #account = null as null | typeof AnyWalletState.activeAccount;\n\t// get account() {\n\t// \treturn this.#account;\n\t// }\n\n\t/**\n\t * Instantiates Algonaut.js.\n\t *\n\t * @example\n\t * Usage:\n\t *\n\t * ```js\n\t * import { Algonaut } from '@thencc/algonautjs';\n\t * const algonaut = new Algonaut({\n\t * \t\tnodeConfig: {\n\t *\t \t\tBASE_SERVER: 'https://testnet-algorand.api.purestake.io/ps2',\n\t *\t \t\tINDEX_SERVER: 'https://testnet-algorand.api.purestake.io/idx2'\n\t *\t \t\tLEDGER: 'TestNet',\n\t *\t \t\tPORT: '',\n\t *\t \t\tAPI_TOKEN: { 'X-API-Key': 'YOUR_API_TOKEN' }\n\t * \t\t}\n\t * });\n\t * ```\n\t *\n\t * @param config config object\n\t */\n\tconstructor(config?: AlgonautConfig) {\n\t\tthis.setNodeConfig(config?.nodeConfig); // makes algod client too\n\t\tthis.enableWallets(config?.initWallets);\n\t\tthis.setLibConfig(config?.libConfig);\n\t\tthis.initAcctSync();\n\t}\n\n\tsetLibConfig(libConfig?: AlgonautConfig['libConfig']) {\n\t\t// logger.log('setLibConfig', libConfig);\n\t\tif (libConfig == undefined)  {\n\t\t\tlibConfig = defaultLibConfig;\n\t\t}\n\t\tif (libConfig !== undefined) {\n\t\t\tif ('disableLogs' in libConfig && typeof libConfig.disableLogs == 'boolean') {\n\t\t\t\tlogger.enabled = !libConfig.disableLogs;\n\t\t\t\tAWSetLogsEnabled(!libConfig.disableLogs);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * checks if config obj is valid for use\n\t * @param config algonaut config for network + signing mode\n\t * @returns boolean. true is good.\n\t */\n\tisValidNodeConfig(nodeConfig?: AlgonautConfig['nodeConfig']): boolean {\n\t\t// logger.log('isValidNodeConfig?', config);\n\t\tlet isValid = true;\n\n\t\t// do all checks\n\t\tif (nodeConfig == undefined || !nodeConfig.BASE_SERVER) {\n\t\t\tisValid = false;\n\t\t}\n\t\t// FYI some configs dont need an api token\n\n\t\t// TODO add more checks...\n\n\t\treturn isValid;\n\t}\n\n\t/**\n\t * sets config for use (new algod, indexerClient, etc)\n\t * @param config algonaut config for network + signing mode\n\t * \t\t- will throw Error if config is lousy\n\t */\n\tsetNodeConfig(nodeConfig?: AlgonautConfig['nodeConfig'] | 'mainnet' | 'testnet') {\n\t\tlogger.log('setNodeConfig', nodeConfig);\n\t\t\n\t\tif (nodeConfig == undefined) {\n\t\t\tnodeConfig = defaultNodeConfig;\n\t\t}\n\n\t\tif (typeof nodeConfig == 'string') {\n\t\t\tif (nodeConfig == 'mainnet') {\n\t\t\t\tnodeConfig = mainnetConfig;\n\t\t\t} else if (nodeConfig == 'testnet') {\n\t\t\t\tnodeConfig = testnetConfig;\n\t\t\t} else {\n\t\t\t\tthrow new Error('bad node config string.');\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isValidNodeConfig(nodeConfig)) {\n\t\t\tthrow new Error('bad node config!');\n\t\t}\n\t\tif (typeof nodeConfig == 'undefined') {\n\t\t\tthrow new Error('node config undefined'); // shouldnt ever happen... but needed to TS to be happy\n\t\t}\n\n\t\tthis.nodeConfig = nodeConfig;\n\t\tthis.algodClient = new Algodv2(nodeConfig.API_TOKEN, nodeConfig.BASE_SERVER, nodeConfig.PORT);\n\n\t\tif (nodeConfig.INDEX_SERVER) {\n\t\t\tthis.indexerClient = new Indexer(nodeConfig.API_TOKEN, nodeConfig.INDEX_SERVER, nodeConfig.PORT);\n\t\t} else {\n\t\t\tconsole.warn('No indexer configured because INDEX_SERVER was not provided.');\n\t\t}\n\t}\n\n\t/**\n\t * @returns nodeConfig object or `false` if no nodeConfig is set\n\t */\n\tgetNodeConfig(): AlgonautConfig['nodeConfig'] | boolean {\n\t\tif (this.nodeConfig) return this.nodeConfig;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks status of Algorand network\n\t * @returns Promise resolving to status of Algorand network\n\t */\n\tasync checkStatus(): Promise<any | AlgonautError> {\n\t\tif (!this.getNodeConfig()) {\n\t\t\tthrow new Error('No node configuration set.');\n\t\t}\n\n\t\tconst status = await this.algodClient.status().do();\n\t\tlogger.log('Algorand network status: %o', status);\n\t\treturn status;\n\t}\n\n\tinitAcctSync() {\n\t\tunsAcctSync = subscribeToAccountChanges(\n\t\t\t(acct) => {\n\t\t\t\tlogger.log('acct changed', acct);\n\t\t\t\tthis.account = acct;\n\t\t\t\t// this.#account = acct; // revisit this for security pass + consider field setting not just entire obj\n\t\t\t}\n\t\t);\n\t}\n\tstopAcctSync() {\n\t\tif (unsAcctSync) unsAcctSync();\n\t}\n\n\tenableWallets(walletInitParams?: AlgonautConfig['initWallets']) {\n\t\tif (walletInitParams == undefined) {\n\t\t\tlogger.debug('.enableWallets called without any init params.');\n\t\t}\n\t\t// default to NONE\n\t\tconst defaultWip: WalletInitParamsObj = {\n\t\t\t// inkey: true, // not even inkey\n\t\t};\n\t\tconst wip = walletInitParams || defaultWip;\n\t\tenableWallets(wip); // defaults to all except mnemonic client\n\t}\n\n\t/**\n\t * @deprecated use .connect() with mnemonic arg\n\t * Recovers account from mnemonic\n\t *  (helpful for rapid development but overall very insecure unless on server-side)\n\t * @param mnemonic Mnemonic associated with Algonaut account\n\t * @returns If mnemonic is valid, it returns the account (address, chain). Otherwise, throws an error.\n\t */\n\tasync mnemonicConnect(mnemonic: string): Promise<Account[]> {\n\t\tif (!mnemonic) throw new Error('algonaut.mnemonicConnect: No mnemonic provided.');\n\t\treturn await this.connect({\n\t\t\tmnemonic\n\t\t});\n\t}\n\n\t/**\n\t * @deprecated use .connect or loop through enabled wallets' methods\n\t */\n\tasync inkeyConnect(): Promise<Account[]> {\n\t\tconsole.warn('.inkeyConnect is deprecated. please use .connect');\n\t\treturn await this.connect({\n\t\t\tinkey: true // \"true\" means use the defaults\n\t\t});\n\t}\n\n\t/**\n\t * @deprecated use .disconnect or loop through enabled wallets' methods\n\t */\n\tasync inkeyDisconnect() {\n\t\tconsole.warn('.inkeyDisconnect is deprecated. please use .disconnect');\n\t\treturn await this.disconnect([WALLET_ID.INKEY]);\n\t}\n\n\t/**\n\t * Shows the inkey-wallet modal \n\t * @returns \n\t */\n\tasync inkeyShow(route?: string) {\n\t\tconst ic = await this.getInkeyClientSdk();\n\t\tic.show(route);\n\t}\n\n\t/**\n\t * Hides the inkey-wallet modal\n\t * @returns \n\t */\n\tasync inkeyHide() {\n\t\tconst ic = await this.getInkeyClientSdk();\n\t\tic.hide();\n\t}\n\n\t/**\n\t * Loads and/or returns the inkey-wallet client sdk for whatever use. see inkey-client-js docs for more.\n\t * @returns \n\t */\n\tasync getInkeyClientSdk() {\n\t\tlogger.log('getInkeyClientSdk');\n\t\tif (this.inkeyClientSdk !== null) {\n\t\t\tthis.inkeyLoaded = true;\n\t\t\treturn this.inkeyClientSdk;\n\t\t} else {\n\t\t\t// load it\n\t\t\tlet inkeyW = this.walletState.enabledWallets?.inkey;\n\t\t\tif (!inkeyW) {\n\t\t\t\tconsole.warn('Inkey wallet not enabled by dev');\n\t\t\t\tthrow new Error('Inkey wallet not enabled by dev');\n\t\t\t}\n\n\t\t\tthis.inkeyLoading = true;\n\t\t\tawait inkeyW.loadClient();\n\t\t\tthis.inkeyLoading = false;\n\n\t\t\tconst inkeyClientSdk:InkeySdk = inkeyW.client!.sdk;\n\n\t\t\tif (inkeyClientSdk.frameBus.ready == false) {\n\t\t\t\tlogger.debug('inkeySdk FrameBus not yet ready...');\n\t\t\t\tawait inkeyClientSdk.frameBus.isReady();\n\t\t\t\tlogger.debug('inkeySdk FrameBus IS ready.');\n\t\t\t}\n\n\t\t\tthis.inkeyLoaded = true;\n\t\t\tthis.inkeyClientSdk = inkeyClientSdk;\n\t\t\treturn this.inkeyClientSdk;\n\t\t}\n\t}\n\n\t/**\n\t * Connects a wallet to be used as algonaut.account. uses:\n\t * \t- the SINGLE passed in init params for the specified wallet\n\t *  - or, the SINGLE enabled wallet IF 1 wallet is enabled (as is the default. just inkey)\n\t * FAILs and throws when multiple init params are passed in or multiple wallets are enabled when nothing is passed in (since it doesnt know which to connect up)\n\t */\n\tasync connect(initWallets?: WalletInitParamsObj) {\n\t\t// logger.log('connect initWallets', initWallets);\n\t\tif (initWallets !== undefined) {\n\t\t\tconst initWs = Object.entries(initWallets);\n\t\t\tif (initWs.length == 1) {\n\t\t\t\tconst wId = initWs[0][0] as WALLET_ID;\t\t\t\t\n\t\t\t\tconst wInitParams = initWs[0][1] as ClientInitParams; // grab the only enabled wallet\n\t\t\t\tconst w = AnyWalletState.allWallets[wId];\n\t\t\t\tlogger.debug('connect: ', wId, wInitParams)\n\n\t\t\t\tif (w !== undefined) {\n\t\t\t\t\t// possibly enable this wallet \n\t\t\t\t\tif (AnyWalletState.enabledWallets == null || \n\t\t\t\t\t\t!(AnyWalletState.enabledWallets[wId])\n\t\t\t\t\t) {\n\t\t\t\t\t\t// AnyWalletState.enabledWallets[wId] = w; // same same as below\n\t\t\t\t\t\tenableWallets(initWallets);\n\t\t\t\t\t}\n\n\t\t\t\t\t// FYI ignore the .isConnected check (as in below init using singular enabledWallet) \n\t\t\t\t\t// to allow for authing into multiple accounts of 1 wallet type\n\n\t\t\t\t\tw.initParams = wInitParams;\n\t\t\t\t\treturn await w.connect();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Could not find wallet to enable');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Cannot init multiple wallets at once using .connect(). To enable multiple wallets at once define initWallets params in Algonaut class instantiation.');\n\t\t\t}\n\t\t} else {\n\t\t\t// then assume to use the only enabled wallet (must be only 1)\n\t\t\tif (AnyWalletState.enabledWallets) {\n\t\t\t\tconst enabledWs = Object.entries(AnyWalletState.enabledWallets);\n\t\t\t\tif (enabledWs.length == 1) {\n\t\t\t\t\tconst w = enabledWs[0][1]; // grab the only enabled wallet\n\t\t\t\t\tif (w) {\n\t\t\t\t\t\t// FYI DONT check isConnected or isActive to allow for inited multiple accts from the same wallet provider\n\t\t\t\t\t\treturn await w.connect();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Wallet wasnt initialized correctly.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Too many wallets enabled to know which to connect.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('No enabled wallets to connect.');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * disconnects\n\t * \t- the active wallet IF no arg passed in\n\t * \t- all the wallets IF \"true\" is passed in as an arg\n\t * \t- or, specific wallets if an array of wallet ids is passed in. (ex: [\"inkey\", \"algosigner\", \"mnemonic\"] )\n\t */\n\tasync disconnect(wIds?: WALLET_ID[] | true) {\n\t\tif (typeof wIds == undefined) {\n\t\t\t// (try) disconnect active wallet only\n\t\t\tif (AnyWalletState.enabledWallets) {\n\t\t\t\tconst enabledWs = Object.entries(AnyWalletState.enabledWallets);\n\t\t\t\tif (enabledWs.length == 1) {\n\t\t\t\t\tconst w = enabledWs[0][1]; // grab the only enabled wallet\n\t\t\t\t\tif (w) {\n\t\t\t\t\t\tif (w.isConnected) {\n\t\t\t\t\t\t\tlogger.log('disconnecting active wallet:', w.id);\n\t\t\t\t\t\t\treturn await w.disconnect();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('Wallet already disconnected.');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Wallet wasnt initialized correctly.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Too many wallets enabled to know which to connect.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('No enabled wallets to disconnect.');\n\t\t\t}\n\t\t} else if (typeof wIds == 'boolean') {\n\t\t\tif (wIds == true) {\n\t\t\t\t// disconnect ALL wallets\n\t\t\t\tlogger.log('disconnecting all wallets from dapp');\n\t\t\t\tfor (let wId of Object.keys(AnyWalletState.allWallets)) {\n\t\t\t\t\tconst w = AnyWalletState.allWallets[wId as WALLET_ID];\n\t\t\t\t\tif (w) {\n\t\t\t\t\t\tif (w.isConnected) {\n\t\t\t\t\t\t\tlogger.log('disconnecting wallet:', wId);\n\t\t\t\t\t\t\treturn await w.disconnect();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error('Wallet already disconnected.');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Could not find wallet by id to disconnect... (shouldnt happen)');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// nothing\n\t\t\t\t// for wIds == false\n\t\t\t}\n\t\t} else if (Array.isArray(wIds)) {\n\t\t\t// disconnect this/these wallets by wallet id\n\t\t\tlogger.log('disconnecting these wallets:', wIds);\n\t\t\tfor (let wId of wIds) {\n\t\t\t\tconst w = AnyWalletState.allWallets[wId];\n\t\t\t\tif (w) {\n\t\t\t\t\tif (w.isConnected) {\n\t\t\t\t\t\tlogger.log('disconnecting wallet:', wId);\n\t\t\t\t\t\treturn await w.disconnect();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Wallet already disconnected.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Could not find wallet by id to disconnect... (shouldnt happen)');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.debug('this shouldnt happen... passed in a bad arg to .disconnect() ');\n\t\t}\n\t}\n\n\tdisconnectAll() {\n\t\tremoveAllAccounts();\n\t}\n\n\treconnect() {\n\t\trecallState();\n\t}\n\n\t/**\n\t * General purpose method to await transaction confirmation\n\t * @param txId a string id of the transacion you want to watch\n\t * @param limitDelta how many rounds to wait, defaults to 50\n\t * @param log set to true if you'd like to see \"waiting for confirmation\" log messages\n\t */\n\tasync waitForConfirmation(txId: string, limitDelta?: number, log = false): Promise<AlgonautTransactionStatus> {\n\t\tif (!txId) throw new Error('waitForConfirmation: No transaction ID provided.');\n\n\t\tlet lastround = (await this.algodClient.status().do())['last-round'];\n\t\tconst limit = lastround + (limitDelta ? limitDelta : 50);\n\n\t\tconst returnValue = {\n\t\t\tstatus: 'fail',\n\t\t\tmessage: ''\n\t\t} as AlgonautTransactionStatus;\n\n\t\twhile (lastround < limit) {\n\t\t\tlet pendingInfo = '' as any;\n\t\t\ttry {\n\t\t\t\tpendingInfo = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\t\t\t\tif (log) {\n\t\t\t\t\tlogger.log('waiting for confirmation');\n\t\t\t\t}\n\t\t\t} catch (er: any) {\n\t\t\t\tconsole.error(er.response?.text);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tpendingInfo['confirmed-round'] !== null &&\n\t\t\t\tpendingInfo['confirmed-round'] > 0\n\t\t\t) {\n\n\t\t\t\tif (log) {\n\t\t\t\t\tlogger.log('Transaction confirmed in round ' + pendingInfo['confirmed-round']);\n\t\t\t\t}\n\n\t\t\t\treturnValue.txId = txId;\n\t\t\t\treturnValue.status = 'success';\n\t\t\t\treturnValue.message = 'Transaction confirmed in round ' + pendingInfo['confirmed-round'];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlastround = (await this.algodClient.status().do())['last-round'];\n\t\t}\n\n\t\treturn returnValue;\n\n\t}\n\n\t/**\n\t * Creates a LogicSig from a base64 program string.  Note that this method does not COMPILE\n\t * the program, just builds an LSig from an already compiled base64 result!\n\t * @param base64ProgramString\n\t * @returns an algosdk LogicSigAccount\n\t */\n\tgenerateLogicSig(base64ProgramString: string): LogicSigAccount {\n\t\tif (!base64ProgramString) throw new Error('No program string provided.');\n\n\t\tconst program = new Uint8Array(\n\t\t\tBuffer.from(base64ProgramString, 'base64')\n\t\t);\n\n\t\treturn new LogicSigAccount(program);\n\t}\n\n\tasync atomicOptInAsset(assetIndex: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!this.walletState.activeAddress) throw new Error('No account set in Algonaut.');\n\t\tif (!assetIndex) throw new Error('No asset index provided.');\n\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst optInTransaction = makeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\tfrom: this.walletState.activeAddress,\n\t\t\tto: this.walletState.activeAddress,\n\t\t\tassetIndex: assetIndex,\n\t\t\tamount: 0,\n\t\t\tsuggestedParams,\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: optInTransaction,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Opt-in the current account for the a token or NFT Asset.\n\t * @param assetIndex number of asset to opt-in to\n\t * @param callbacks `AlgonautTxnCallbacks`, passed to {@link sendTransaction}\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync optInAsset(assetIndex: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\tif (!this.walletState.activeAddress) throw new Error('There was no account!');\n\t\tif (!assetIndex) throw new Error('No asset index provided.');\n\t\tconst { transaction } = await this.atomicOptInAsset(assetIndex, optionalTxnArgs);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\n\t// this is a bit harder with the algosdk api\n\t// what we may want to do be more opinionated and have a standard local\n\t// field we always set on apps when opted in\n\n\t// OR maybe we check for HAS STATE which might check for local state\n\t// of any kind on that app id?\n\n\t// async isOptedIntoApp(account: string, appId: number): boolean {\n\t// \tlet optInState = false;\n\n\t// \tconst accountInfo = await this.getAccountInfo(account);\n\t// \taccountInfo.assets.forEach((asset: any) => {\n\t// \t\tif (asset['asset-id'] == assetId) {\n\t// \t\t\toptInState = true;\n\t// \t\t}\n\n\t// \t});\n\n\t// \treturn optInState;\n\t// }\n\n\n\t/**\n\t * You can be opted into an asset but still have a zero balance. Use this call\n\t * for cases where you just need to know the address's opt-in state\n\t * @param args object containing `account` and `assetId` properties\n\t * @returns boolean true if account holds asset\n\t */\n\tasync isOptedIntoAsset(args: { account: string, assetId: number }): Promise<boolean> {\n\t\tif (!args.account) throw new Error('No account provided.');\n\t\tif (!args.assetId) throw new Error('No asset ID provided.');\n\n\t\tlet optInState = false;\n\t\tconst accountInfo = await this.getAccountInfo(args.account);\n\t\taccountInfo.assets.forEach((asset: any) => {\n\t\t\tif (asset['asset-id'] == args.assetId) {\n\t\t\t\toptInState = true;\n\t\t\t}\n\n\t\t});\n\n\t\treturn optInState;\n\t}\n\n\t/**\n\t * Sync function that returns a correctly-encoded argument array for\n\t * an algo transaction\n\t * @param args must be an any[] array, as it will often need to be\n\t * a mix of strings and numbers. Valid types are: string, number, and bigint\n\t * @returns a Uint8Array of encoded arguments\n\t */\n\tencodeArguments(args: any[]): Uint8Array[] {\n\t\tconst encodedArgs = [] as Uint8Array[];\n\n\t\t// loop through args and encode them based on type\n\t\targs.forEach((arg: any) => {\n\t\t\tif (typeof arg == 'number') {\n\t\t\t\tencodedArgs.push(encodeUint64(arg));\n\t\t\t} else if (typeof arg == 'bigint') {\n\t\t\t\tencodedArgs.push(encodeUint64(arg));\n\t\t\t} else if (typeof arg == 'string') {\n\t\t\t\tencodedArgs.push(new Uint8Array(Buffer.from(arg)));\n\t\t\t}\n\t\t});\n\n\t\treturn encodedArgs;\n\t}\n\n\t/**\n\t * Create asset transaction\n\t * @param args : AlgonautCreateAssetArguments obj must contain: `assetName`, `symbol`, `decimals`, `amount`.\n\t * @returns atomic txn to create asset\n\t*/\n\tasync atomicCreateAsset(args: AlgonautCreateAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.assetName) throw new Error('args.assetName not provided.');\n\t\tif (!args.symbol) throw new Error('args.symbol not provided');\n\t\tif (typeof args.decimals == 'undefined') throw new Error('args.decimals not provided.');\n\t\tif (!args.amount) throw new Error('args.amount not provided.');\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tif (!args.metaBlock) {\n\t\t\targs.metaBlock = ' ';\n\t\t}\n\n\t\tif (!args.defaultFrozen) args.defaultFrozen = false;\n\t\tif (!args.assetURL) args.assetURL = undefined;\n\n\t\tconst metaBlockLength = args.metaBlock.length;\n\n\t\tif (metaBlockLength > 1023) {\n\t\t\tconsole.error('meta block is ' + metaBlockLength);\n\t\t\tthrow new Error('drat! this meta block is too long!');\n\t\t}\n\n\t\tconst enc = new TextEncoder();\n\n\t\t// arbitrary data: 1024 bytes, or about 1023 characters\n\t\tconst note = enc.encode(args.metaBlock);\n\t\tconst totalIssuance = args.amount;\n\n\t\t// set accounts\n\t\tconst manager = (args.manager && args.manager.length > 0) ? args.manager : fromAddr;\n\t\tconst reserve = (args.reserve && args.reserve.length > 0) ? args.reserve : fromAddr;\n\t\tconst freeze = (args.freeze && args.freeze.length > 0) ? args.freeze : fromAddr;\n\t\tconst clawback = (args.clawback && args.clawback.length > 0) ? args.clawback : fromAddr;\n\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t// signing and sending \"txn\" allows \"addr\" to create an asset\n\t\tconst txn = makeAssetCreateTxnWithSuggestedParams(\n\t\t\tfromAddr,\n\t\t\tnote,\n\t\t\ttotalIssuance,\n\t\t\targs.decimals,\n\t\t\targs.defaultFrozen,\n\t\t\tmanager,\n\t\t\treserve,\n\t\t\tfreeze,\n\t\t\tclawback,\n\t\t\targs.symbol,\n\t\t\targs.assetName,\n\t\t\targs.assetURL,\n\t\t\targs.assetMetadataHash,\n\t\t\tsuggestedParams\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: txn,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\n\t/**\n\t * Create asset\n\t * @param args AlgonautCreateAssetArguments. Must pass `assetName`, `symbol`, `decimals`, `amount`.\n\t * @param callbacks AlgonautTxnCallbacks\n\t * @returns asset index\n\t*/\n\tasync createAsset(\n\t\targs: AlgonautCreateAssetArguments,\n\t\tcallbacks?: AlgonautTxnCallbacks\n\t): Promise<AlgonautTransactionStatus> {\n\t\tconst atomicTxn = await this.atomicCreateAsset(args);\n\t\tconst txn = atomicTxn.transaction;\n\n\t\ttry {\n\t\t\tconst assetID = null;\n\t\t\tconst txStatus = await this.sendTransaction(txn, callbacks);\n\n\t\t\tconst ptx = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(txn.txID().toString())\n\t\t\t\t.do();\n\t\t\ttxStatus.createdIndex = ptx['asset-index'];\n\n\t\t\treturn txStatus;\n\n\t\t} catch (er) {\n\t\t\tlogger.log('transaction error');\n\t\t\tlogger.log(er);\n\t\t\tthrow new Error(er as any);\n\t\t}\n\t}\n\n\tasync atomicDeleteAsset(assetId: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!this.walletState.activeAddress) throw new Error('there was no account!');\n\t\tif (!assetId) throw new Error('No assetId provided!');\n\n\t\tconst enc = new TextEncoder();\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst transaction = makeAssetDestroyTxnWithSuggestedParams(\n\t\t\tthis.walletState.activeAddress,\n\t\t\tenc.encode('doh!'), // what is this?\n\t\t\tassetId,\n\t\t\tsuggestedParams,\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: transaction,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Deletes asset\n\t * @param assetId Index of the ASA to delete\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync deleteAsset(assetId: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\tif (!assetId) throw new Error('No asset ID provided!');\n\t\tconst { transaction } = await this.atomicDeleteAsset(assetId, optionalTxnArgs);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Creates send asset transaction.\n\t *\n\t * IMPORTANT: Before you can call this, the target account has to \"opt-in\"\n\t * to the ASA index.  You can't just send ASAs to people blind!\n\t *\n\t * @param args - object containing `to`, `assetIndex`, and `amount` properties\n\t * @returns Promise resolving to `AlgonautAtomicTransaction`\n\t */\n\tasync atomicSendAsset(args: AlgonautSendAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.to) throw new Error('No to address provided');\n\t\tif (!isValidAddress(args.to)) throw new Error('Invalid to address');\n\t\tif (!args.assetIndex) throw new Error('No asset index provided');\n\t\tif (!(typeof args.amount == 'bigint' || typeof args.amount == 'number')) {\n\t\t\tthrow new Error('Amount has to be a number.');\n\t\t}\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst transaction =\n\t\t\tmakeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\tfrom: fromAddr,\n\t\t\t\tto: args.to,\n\t\t\t\tamount: args.amount,\n\t\t\t\tassetIndex: args.assetIndex,\n\t\t\t\tsuggestedParams\n\t\t\t});\n\n\t\treturn {\n\t\t\ttransaction: transaction,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Sends asset to an address.\n\t *\n\t * IMPORTANT: Before you can call this, the target account has to \"opt-in\"\n\t * to the ASA index.  You can't just send ASAs to people blind!\n\t *\n\t * @param args - object containing `to`, `assetIndex`, and `amount` properties\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync sendAsset(args: AlgonautSendAssetArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tconst { transaction } = await this.atomicSendAsset(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Get info about an asset\n\t * @param assetIndex\n\t * @returns\n\t */\n\tasync getAssetInfo(assetIndex: number): Promise<any> {\n\t\tif (!assetIndex) throw new Error('No asset ID provided');\n\n\t\tconst info = await this.algodClient.getAssetByID(assetIndex).do();\n\t\treturn info;\n\t}\n\n\t/**\n\t * Creates transaction to opt into an app\n\t * @param args AlgonautCallAppArgs\n\t * @returns AlgonautAtomicTransaction\n\t */\n\tasync atomicOptInApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.appIndex) throw new Error('No app ID provided');\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tconst optInTransaction = makeApplicationOptInTxnFromObject({\n\t\t\tfrom: fromAddr,\n\t\t\tappIndex: args.appIndex,\n\t\t\tsuggestedParams,\n\t\t\tappArgs: args.appArgs ? this.encodeArguments(args.appArgs) : undefined,\n\t\t\taccounts: args.optionalFields?.accounts ? args.optionalFields?.accounts : undefined,\n\t\t\tforeignApps: args.optionalFields?.applications ? args.optionalFields?.applications : undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets ? args.optionalFields?.assets : undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: optInTransaction,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Opt-in the current account for an app.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields`\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync optInApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicOptInApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Returns atomic transaction that deletes application\n\t * @param appIndex - ID of application\n\t * @returns Promise resolving to atomic transaction that deletes application\n\t */\n\tasync atomicDeleteApp(appIndex: number, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautAtomicTransaction> {\n\t\tif (!appIndex) throw new Error('No app ID provided');\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tconst suggestedParams = optionalTxnArgs?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst txn = makeApplicationDeleteTxn(fromAddr, suggestedParams, appIndex);\n\n\t\treturn {\n\t\t\ttransaction: txn,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Deletes an application from the blockchain\n\t * @param appIndex - ID of application\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync deleteApp(appIndex: number, callbacks?: AlgonautTxnCallbacks, optionalTxnArgs?: AlgonautTransactionFields): Promise<AlgonautTransactionStatus> {\n\t\ttry {\n\t\t\tconst { transaction } = await this.atomicDeleteApp(appIndex, optionalTxnArgs);\n\t\t\tconst txId = transaction.txID().toString();\n\n\t\t\tconst status = await this.sendTransaction(transaction, callbacks);\n\n\t\t\t// display results\n\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t.do();\n\t\t\tconst appId = transactionResponse['txn']['txn'].apid;\n\n\t\t\treturn {\n\t\t\t\tstatus: 'success',\n\t\t\t\tmessage: 'deleted app index ' + appId,\n\t\t\t\ttxId\n\t\t\t};\n\n\t\t} catch (e: any) {\n\t\t\tlogger.log(e);\n\t\t\tthrow new Error(e.response?.text);\n\t\t}\n\t}\n\n\tasync atomicCallApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = args?.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\t\tif (!args.appArgs.length) throw new Error('Must provide at least one appArgs');\n\n\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst callAppTransaction = makeApplicationNoOpTxnFromObject({\n\t\t\tfrom: fromAddr,\n\t\t\tsuggestedParams,\n\t\t\tappIndex: args.appIndex,\n\t\t\tappArgs: processedArgs,\n\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets || undefined,\n\t\t\tnote: args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: callAppTransaction,\n\t\t\ttransactionSigner: undefined,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Call a \"method\" on a stateful contract.  In TEAL, you're really giving\n\t * an argument which branches to a specific place and reads the other args\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t */\n\tasync callApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicCallApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\tasync atomicCallAppWithLSig(args: AlgonautLsigCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\t\tif (!args.appArgs.length) throw new Error('Must provide at least one appArgs');\n\n\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\tconst callAppTransaction = makeApplicationNoOpTxnFromObject({\n\t\t\tfrom: args.lsig.address(),\n\t\t\tsuggestedParams,\n\t\t\tappIndex: args.appIndex,\n\t\t\tappArgs: processedArgs,\n\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t});\n\n\t\treturn {\n\t\t\ttransaction: callAppTransaction,\n\t\t\ttransactionSigner: args.lsig,\n\t\t\tisLogigSig: true\n\t\t};\n\t}\n\n\t/**\n\t * Returns an atomic transaction that closes out the user's local state in an application.\n\t * The opposite of {@link atomicOptInApp}.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t * @returns Promise resolving to atomic transaction\n\t */\n\tasync atomicCloseOutApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = args?.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\n\t\ttry {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\t\tconst closeOutTxn = makeApplicationCloseOutTxnFromObject({\n\t\t\t\tfrom: fromAddr,\n\t\t\t\tsuggestedParams,\n\t\t\t\tappIndex: args.appIndex,\n\t\t\t\tappArgs: processedArgs,\n\t\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: closeOutTxn,\n\t\t\t\ttransactionSigner: undefined,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\t\t} catch (e: any) {\n\t\t\tthrow new Error(e);\n\t\t}\n\t}\n\n\t/**\n\t * Closes out the user's local state in an application.\n\t * The opposite of {@link optInApp}.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to atomic transaction\n\t */\n\tasync closeOutApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks) {\n\t\tconst { transaction } = await this.atomicCloseOutApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Get an application's escrow account\n\t * @param appId - ID of application\n\t * @returns Escrow account address as string\n\t */\n\tgetAppEscrowAccount(appId: number | bigint): string {\n\t\tif (!appId) throw new Error('No appId provided');\n\t\treturn getApplicationAddress(appId);\n\t}\n\n\t/**\n\t * Get info about an application (globals, locals, creator address, index)\n\t *\n\t * @param appId - ID of application\n\t * @returns Promise resolving to application state\n\t */\n\tasync getAppInfo(appId: number): Promise<AlgonautAppState> {\n\t\tif (!appId) throw new Error('No appId provided');\n\n\t\tconst proms = [\n\t\t\tthis.algodClient.getApplicationByID(appId).do(),\n\t\t] as Promise<any>[];\n\n\t\tconst addr = this.walletState.activeAddress;\n\t\t// get locals if we have an account\n\t\tif (addr) {\n\t\t\tproms.push(this.getAppLocalState(appId)); // TODO get rid of this call / only return locals (not incorrect duplicate state obj)\n\t\t}\n\n\t\tconst promsRes = await Promise.all(proms);\n\t\tconst info = promsRes[0] as AlgonautGetApplicationResponse;\n\t\tconst localState = promsRes[1] as AlgonautAppState | void;\n\n\t\t// decode state\n\t\tconst state = {\n\t\t\thasState: true,\n\t\t\tglobals: [],\n\t\t\tlocals: localState?.locals || [],\n\t\t\tcreatorAddress: info.params.creator,\n\t\t\tindex: appId\n\t\t} as AlgonautAppState;\n\n\t\tif (info.params['global-state']) {\n\t\t\tstate.globals = this.decodeStateArray(info.params['global-state']);\n\t\t}\n\n\t\treturn state;\n\t}\n\n\t/**\n\t * Create and deploy a new Smart Contract from TEAL code\n\t *\n\t * @param args AlgonautDeployArguments\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns AlgonautTransactionStatus\n\t */\n\tasync createApp(\n\t\targs: AlgonautDeployArguments,\n\t\tcallbacks?: AlgonautTxnCallbacks\n\t): Promise<AlgonautTransactionStatus> {\n\t\tif (args.optionalFields &&\n\t\t\targs.optionalFields.note &&\n\t\t\targs.optionalFields.note.length > 1023) {\n\t\t\tconsole.warn('drat! your note is too long!');\n\t\t\tthrow new Error('Your note is too long');\n\t\t}\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (!args.schema) throw new Error('No schema provided');\n\n\t\ttry {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\t\t\t// logger.log('approval', approvalProgram);\n\t\t\t// logger.log('clear', clearProgram);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (approvalProgram && clearProgram) {\n\n\t\t\t\tconst txn = makeApplicationCreateTxnFromObject({\n\t\t\t\t\tfrom: fromAddr,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete: OnApplicationComplete.NoOpOC,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\tnumLocalInts: args.schema.localInts,\n\t\t\t\t\tnumLocalByteSlices: args.schema.localBytes,\n\t\t\t\t\tnumGlobalInts: args.schema.globalInts,\n\t\t\t\t\tnumGlobalByteSlices: args.schema.globalBytes,\n\t\t\t\t\tappArgs: this.encodeArguments(args.appArgs),\n\t\t\t\t\taccounts: args.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\t\tforeignApps: args.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\t\tforeignAssets: args.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\t\tnote: args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t\t});\n\t\t\t\tconst txId = txn.txID().toString();\n\n\t\t\t\t// Wait for confirmation\n\t\t\t\tconst result = await this.sendTransaction(txn, callbacks);\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\n\t\t\t\tresult.message = 'Created App ID: ' + transactionResponse['application-index'];\n\t\t\t\tresult.createdIndex = transactionResponse['application-index'];\n\t\t\t\tresult.meta = transactionResponse;\n\t\t\t\tresult.txId = txId;\n\t\t\t\treturn result;\n\n\t\t\t} else {\n\t\t\t\tthrow new Error('could not compile teal code');\n\t\t\t}\n\n\t\t} catch (er: any) {\n\t\t\tthrow new Error(er.message);\n\t\t}\n\t}\n\n\t/**\n\t * Create an atomic transaction to deploy a\n\t * new Smart Contract from TEAL code\n\t *\n\t * @param args AlgonautDeployArguments\n\t * @returns AlgonautAtomicTransaction\n\t */\n\tasync atomicCreateApp(args: AlgonautDeployArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (!args.schema) throw new Error('No schema provided');\n\n\t\tif (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {\n\t\t\tthrow new Error('Your NOTE is too long, it must be less thatn 1024 Bytes');\n\t\t} else if (fromAddr) {\n\t\t\ttry {\n\t\t\t\tconst onComplete = OnApplicationComplete.NoOpOC;\n\t\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t\t// create unsigned transaction\n\t\t\t\tif (!approvalProgram || !clearProgram) {\n\t\t\t\t\tthrow new Error('Error: you must provide an approval program and a clear state program.');\n\t\t\t\t}\n\n\t\t\t\tconst applicationCreateTransaction = makeApplicationCreateTxn(\n\t\t\t\t\tfromAddr,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\t\targs.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t\t);\n\n\t\t\t\treturn {\n\t\t\t\t\ttransaction: applicationCreateTransaction,\n\t\t\t\t\ttransactionSigner: undefined,\n\t\t\t\t\tisLogigSig: false\n\t\t\t\t};\n\n\t\t\t} catch (er: any) {\n\t\t\t\tthrow new Error('There was an error creating the transaction');\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Algonaut.js has no account loaded!');\n\t\t}\n\t}\n\n\n\t/**\n\t * deploys a contract from an lsig account\n\t * keep in mind that the local and global byte and int values have caps,\n\t * 16 for local and 32 for global and that the cost of deploying the\n\t * app goes up based on how many of these slots you want to allocate\n\t *\n\t * @param args AlgonautLsigDeployArguments\n\t * @returns\n\t */\n\tasync deployTealWithLSig(\n\t\targs: AlgonautLsigDeployArguments\n\t): Promise<AlgonautTransactionStatus> {\n\t\tif (args.noteText && args.noteText.length > 511) {\n\t\t\tthrow new Error('Your note is too long');\n\t\t}\n\n\t\tlet encodedArgs = [] as Uint8Array[];\n\t\tif (args.appArgs && args.appArgs.length) {\n\t\t\tencodedArgs = this.encodeArguments(args.appArgs);\n\t\t}\n\n\t\tconst sender = args.lsig.address();\n\t\tconst onComplete = OnApplicationComplete.NoOpOC;\n\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\tlet approvalProgram = new Uint8Array();\n\t\tlet clearProgram = new Uint8Array();\n\n\t\ttry {\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (approvalProgram && clearProgram) {\n\t\t\t\tconst txn = makeApplicationCreateTxn(\n\t\t\t\t\tsender,\n\t\t\t\t\tsuggestedParams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tencodedArgs,\n\t\t\t\t\targs.optionalFields?.accounts || undefined\n\t\t\t\t);\n\n\t\t\t\tconst txId = txn.txID().toString();\n\t\t\t\tconst signedTxn = signLogicSigTransactionObject(txn, args.lsig);\n\n\t\t\t\tawait this.algodClient.sendRawTransaction(signedTxn.blob).do();\n\t\t\t\tconst txStatus = await this.waitForConfirmation(txId);\n\n\t\t\t\t// TBD check txStatus\n\n\t\t\t\t// display results\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\t\t\t\tconst appId = transactionResponse['application-index'];\n\n\t\t\t\treturn {\n\t\t\t\t\tstatus: 'success',\n\t\t\t\t\tmessage: 'created new app with id: ' + appId,\n\t\t\t\t\ttxId\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthrow new Error('Error compiling programs.');\n\t\t\t}\n\t\t} catch (er: any) {\n\t\t\tconsole.error('Error deploying contract:');\n\t\t\tthrow new Error(er);\n\t\t}\n\t}\n\n\t/**\n\t * Updates an application with `makeApplicationUpdateTxn`\n\t * @param args AlgonautUpdateAppArguments\n\t * @returns atomic transaction that updates the app\n\t */\n\tasync atomicUpdateApp(args: AlgonautUpdateAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tconst fromAddr = this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\t\tif (!args.tealApprovalCode) throw new Error('No approval program provided');\n\t\tif (!args.tealClearCode) throw new Error('No clear program provided');\n\t\tif (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {\n\t\t\tthrow new Error('Your NOTE is too long, it must be less thatn 1024 Bytes');\n\t\t}\n\n\t\ttry {\n\t\t\tconst onComplete = OnApplicationComplete.NoOpOC;\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (!approvalProgram || !clearProgram) {\n\t\t\t\tthrow new Error('Error: you must provide an approval program and a clear state program.');\n\t\t\t}\n\n\t\t\tconst applicationCreateTransaction = makeApplicationUpdateTxn(\n\t\t\t\tfromAddr,\n\t\t\t\tsuggestedParams,\n\t\t\t\targs.appIndex,\n\t\t\t\tapprovalProgram,\n\t\t\t\tclearProgram,\n\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\targs.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : undefined\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\ttransaction: applicationCreateTransaction,\n\t\t\t\ttransactionSigner: undefined,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\n\t\t} catch (er: any) {\n\t\t\tthrow new Error('There was an error creating the transaction');\n\t\t}\n\t}\n\n\t/**\n\t * Sends an update app transaction\n\t * @param args AlgonautUpdateAppArguments\n\t * @param callbacks optional callbacks: `onSign`, `onSend`, `onConfirm`\n\t * @returns transaction status\n\t */\n\tasync updateApp(args: AlgonautUpdateAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicUpdateApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Compiles TEAL source via [algodClient.compile](https://py-algorand-sdk.readthedocs.io/en/latest/algosdk/v2client/algod.html#v2client.algod.AlgodClient.compile)\n\t * @param programSource source to compile\n\t * @returns Promise resolving to Buffer of compiled bytes\n\t */\n\tasync compileProgram(programSource: string): Promise<Uint8Array> {\n\t\tconst encoder = new TextEncoder();\n\t\tconst programBytes = encoder.encode(programSource);\n\t\tconst compileResponse = await this.algodClient.compile(programBytes).do();\n\t\tconst compiledBytes = new Uint8Array(\n\t\t\tBuffer.from(compileResponse.result, 'base64')\n\t\t);\n\t\treturn compiledBytes;\n\t}\n\n\tasync atomicSendAlgo(args: AlgonautPaymentArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!(typeof args.amount == 'bigint' || typeof args.amount == 'number')) {\n\t\t\tthrow new Error('Amount has to be a number.');\n\t\t}\n\t\tif (!args.to) throw new Error('You did not specify a to address');\n\t\tif (!isValidAddress(args.to)) throw new Error('Invalid to address');\n\t\tconst fromAddr = args.from || this.walletState.activeAddress;\n\t\tif (!fromAddr) throw new Error('there is no fromAddr');\n\n\t\tif (fromAddr) {\n\t\t\tconst encodedNote = args.optionalFields?.note ? this.toUint8Array(args.optionalFields.note) : new Uint8Array();\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tconst transaction =\n\t\t\t\tmakePaymentTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: fromAddr,\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tnote: encodedNote,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\ttransactionSigner: undefined,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no fromAddr');\n\t\t}\n\t}\n\n\t/**\n\t * Sends ALGO from own account to `args.to`\n\t *\n\t * @param args `AlgonautPaymentArgs` object containing `to`, `amount`, and optional `note`\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to transaction status\n\t */\n\tasync sendAlgo(args: AlgonautPaymentArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicSendAlgo(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Fetch full account info for an account\n\t * @param address the accress to read info for\n\t * @returns Promise of type AccountInfo\n\t */\n\tasync getAccountInfo(address: string): Promise<any> {\n\t\tif (!address) throw new Error('No address provided');\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\treturn accountInfo;\n\t}\n\n\n\t/**\n\t * Checks Algo balance of account\n\t * @param address - Wallet of balance to check\n\t * @returns Promise resolving to Algo balance\n\t */\n\tasync getAlgoBalance(address: string): Promise<any> {\n\t\tif (!address) throw new Error('No address provided');\n\t\t//logger.log('checking algo balance');\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\treturn accountInfo.amount;\n\t}\n\n\t/**\n\t * Checks token balance of account\n\t * @param address - Wallet of balance to check\n\t * @param assetIndex - the ASA index\n\t * @returns Promise resolving to token balance\n\t */\n\tasync getTokenBalance(address: string, assetIndex: number): Promise<number> {\n\t\tif (!address) throw new Error('No address provided');\n\t\tif (!assetIndex) throw new Error('No asset index provided');\n\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\t//logger.log('accountInfo', accountInfo);\n\n\t\tlet bal = 0;\n\t\taccountInfo.assets.forEach((asset: any) => {\n\t\t\tif (asset['asset-id'] == assetIndex) {\n\t\t\t\tbal = asset.amount;\n\t\t\t}\n\t\t});\n\n\t\treturn bal;\n\t}\n\n\t/**\n\t * Checks if account has at least one token (before playback)\n\t * Keeping this here in case this is a faster/less expensive operation than checking actual balance\n\t * @param address - Address to check\n\t * @param assetIndex - the index of the ASA\n\t */\n\tasync accountHasTokens(address: string, assetIndex: number): Promise<boolean> {\n\t\tlet bal = await this.getTokenBalance(address, assetIndex);\n\t\tif (bal > 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Gets global state for an application.\n\t * @param applicationIndex - the applications index\n\t * @returns {object} object representing global state\n\t */\n\tasync getAppGlobalState(applicationIndex: number): Promise<any> {\n\t\tif (!applicationIndex) throw new Error('No application ID provided');\n\n\t\tconst info = await this.getAppInfo(applicationIndex);\n\t\tif (info.hasState) {\n\t\t\treturn this.stateArrayToObject(info.globals);\n\t\t} else {\n\t\t\treturn {} as any;\n\t\t}\n\t}\n\n\t/**\n\t * Gets account local state for an app. Defaults to AnyWallets.activeAddress unless\n\t * an address is provided.\n\t * @param applicationIndex the applications index\n\t */\n\tasync getAppLocalState(applicationIndex: number, address?: string): Promise<AlgonautAppState | void> {\n\t\tif (!applicationIndex) throw new Error('No application ID provided');\n\n\t\tconst state = {\n\t\t\thasState: false,\n\t\t\tglobals: [],\n\t\t\tlocals: [],\n\t\t\tcreatorAddress: '',\n\t\t\tindex: applicationIndex\n\t\t} as AlgonautAppState;\n\n\t\t// read state\n\n\t\t// can we detect addresses values and auto-convert them?\n\t\t// maybe a 32-byte field gets an address field added?\n\n\t\tif (this.walletState.activeAddress && !address) {\n\t\t\taddress = this.walletState.activeAddress;\n\t\t}\n\n\t\tif (address) {\n\t\t\tconst accountInfoResponse = await this.algodClient\n\t\t\t\t.accountInformation(address)\n\t\t\t\t.do();\n\n\t\t\t//logger.log(accountInfoResponse);\n\n\t\t\tfor (let i = 0; i < accountInfoResponse['apps-local-state'].length; i++) {\n\t\t\t\tif (accountInfoResponse['apps-local-state'][i].id == applicationIndex) {\n\t\t\t\t\t//logger.log('Found Application');\n\n\t\t\t\t\tstate.hasState = true;\n\n\t\t\t\t\tfor (let n = 0; n < accountInfoResponse['apps-local-state'][i]['key-value'].length; n++) {\n\n\t\t\t\t\t\tconst stateItem = accountInfoResponse['apps-local-state'][i]['key-value'][n];\n\t\t\t\t\t\tconst key = Buffer.from(stateItem.key, 'base64').toString();\n\t\t\t\t\t\tconst type = stateItem.value.type;\n\t\t\t\t\t\tlet value = undefined as undefined | string | number;\n\t\t\t\t\t\tlet valueAsAddr = '';\n\n\t\t\t\t\t\tif (type == 1) {\n\t\t\t\t\t\t\tvalue = Buffer.from(stateItem.value.bytes, 'base64').toString();\n\t\t\t\t\t\t\tvalueAsAddr = encodeAddress(Buffer.from(stateItem.value.bytes, 'base64'));\n\n\t\t\t\t\t\t} else if (stateItem.value.type == 2) {\n\t\t\t\t\t\t\tvalue = stateItem.value.uint;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.locals.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tvalue: value || '',\n\t\t\t\t\t\t\taddress: valueAsAddr\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn state;\n\t\t} else {\n\t\t\t// throw new Error('No address provided, and no account set.');\n\t\t\tconsole.warn('Algonaut used in non-authd state, not getting local vars');\n\t\t}\n\t}\n\n\tasync atomicAssetTransferWithLSig(args: AlgonautLsigSendAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (args.lsig) {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\n\t\t\tconst transaction =\n\t\t\t\tmakeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tassetIndex: args.assetIndex,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\ttransactionSigner: args.lsig,\n\t\t\t\tisLogigSig: true\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no logic sig object!');\n\t\t}\n\t}\n\n\tasync atomicPaymentWithLSig(args: AlgonautLsigPaymentArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (args.lsig) {\n\t\t\tconst suggestedParams = args.optionalFields?.suggestedParams || (await this.algodClient.getTransactionParams().do());\n\t\t\tconst transaction =\n\t\t\t\tmakePaymentTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tsuggestedParams\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\ttransactionSigner: args.lsig,\n\t\t\t\tisLogigSig: true\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no account!');\n\t\t}\n\t}\n\n\tnormalizeTxns(txnOrTxns: Transaction | AlgonautAtomicTransaction | AlgonautAtomicTransaction[]) {\n\t\tlogger.log('normalizeTxns', txnOrTxns);\n\n\t\tlet txnArr: (AlgonautAtomicTransaction | Transaction)[] = [];\n\n\t\tif (!Array.isArray(txnOrTxns)) {\n\t\t\ttxnArr = [txnOrTxns];\n\t\t} else {\n\t\t\ttxnArr = txnOrTxns;\n\t\t}\n\t\t// logger.log('txnArr', txnArr);\n\n\t\tlet algoTxnArr: Transaction[] = [];\n\t\talgoTxnArr = txnArr.map((t) => {\n\t\t\tlet nativeT = (t as AlgonautAtomicTransaction).transaction as Transaction | undefined;\n\t\t\tif (nativeT == undefined) {\n\t\t\t\tnativeT = t as Transaction;\n\t\t\t}\n\t\t\treturn nativeT;\n\t\t});\n\t\tlogger.log('algoTxnArr', [...algoTxnArr]);\n\n\t\t// assign txn(s) a group id\n\t\tif (algoTxnArr.length > 1) {\n\t\t\talgoTxnArr = algosdk.assignGroupID(algoTxnArr);\n\t\t\tlogger.log('added group id to txn array');\n\t\t\tif (algoTxnArr[0].group) {\n\t\t\t\tlet gId = this.txnBuffToB64(algoTxnArr[0].group);\n\t\t\t\tlogger.log('gId', gId);\n\t\t\t}\n\t\t}\n\n\t\tconst txnBuffArr = algoTxnArr.map(t => t.toByte());\n\t\tlogger.log('txnBuffArr', txnBuffArr);\n\n\t\treturn txnBuffArr;\n\t}\n\n\t/**\n\t * Signs a transaction or multiple w the correct wallet according to AW (does not send / submit txn(s) to network)\n\t * @param txnOrTxns Either an array of atomic transactions or a single transaction to sign\n\t * @param signedTxns array of \n\t * @returns Promise resolving to AlgonautTransactionStatus\n\t */\n\tasync signTransaction(txnOrTxns: AlgonautAtomicTransaction[] | Transaction | AlgonautAtomicTransaction): Promise<Uint8Array[]> {\n\t\tconst awTxnsToSign = this.normalizeTxns(txnOrTxns);\n\t\tlogger.log('awTxnsToSign', awTxnsToSign);\n\t\tlet awTxnsSigned: Uint8Array[];\n\t\ttry {\n\t\t\tawTxnsSigned = await signTransactions(awTxnsToSign);\n\t\t\tlogger.log('awTxnsSigned', awTxnsSigned);\n\t\t} catch(e) {\n\t\t\tconsole.warn('err signing txns...');\n\t\t\tlogger.log(e);\n\t\t\tthrow new Error('Error signing transactions');\n\t\t}\n\t\treturn awTxnsSigned;\n\t}\n\n\t/**\n\t * Sends a transaction or multiple w the correct wallet according to AW\n\t * @param txnOrTxns Either an array of atomic transactions or a single transaction to sign\n\t * @param callbacks Optional object with callbacks - `onSign`, `onSend`, and `onConfirm`\n\t * @returns Promise resolving to AlgonautTransactionStatus\n\t */\n\tasync sendTransaction(txnOrTxns: AlgonautAtomicTransaction[] | Transaction | AlgonautAtomicTransaction, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\t/**\n\t\t * 1. normalize incoming txn(s) to array of Uint8Arrs\n\t\t * 2. sign w AW\n\t\t * 3. send Raw txn arr\n\t\t * 4. return result + txid\n\t\t */\n\n\t\tconst awTxnsSigned = await this.signTransaction(txnOrTxns);\n\n\t\tif (callbacks?.onSign) callbacks.onSign(awTxnsSigned);\n\n\t\tconst tx = await this.algodClient.sendRawTransaction(awTxnsSigned).do();\n\n\t\tif (callbacks?.onSend) callbacks.onSend(tx);\n\n\t\t// Wait for transaction to be confirmed\n\t\tconst txStatus = await this.waitForConfirmation(tx.txId);\n\n\t\tconst transactionResponse = await this.algodClient\n\t\t\t.pendingTransactionInformation(tx.txId)\n\t\t\t.do();\n\t\ttxStatus.meta = transactionResponse;\n\n\t\tif (callbacks?.onConfirm) callbacks.onConfirm(txStatus);\n\t\treturn txStatus;\n\t}\n\n\t/**\n\t * \n\t * @param str string\n\t * @param enc the encoding type of the string (defaults to utf8)\n\t * @returns string encoded as Uint8Array\n\t */\n\ttoUint8Array(str: string, enc: BufferEncoding = 'utf8'): Uint8Array {\n\t\treturn new Uint8Array(Buffer.from(str, enc));\n\t}\n\n\t/**\n\t * @deprecated use toUint8Array instead.\n\t * @param str string\n\t * @param enc the encoding type of the string (defaults to utf8)\n\t * @returns string encoded as Uint8Array\n\t */\n\tto8Arr(str: string, enc: BufferEncoding = 'utf8'): Uint8Array {\n\t\treturn this.toUint8Array(str, enc);\n\t}\n\n\t/**\n\t * Helper function to turn `globals` and `locals` array into more useful objects\n\t *\n\t * @param stateArray State array returned from functions like {@link getAppInfo}\n\t * @returns A more useful object: `{ array[0].key: array[0].value, array[1].key: array[1].value, ... }`\n\t * TODO add correct typing for this method\n\t */\n\tstateArrayToObject(stateArray: object[]): any {\n\t\tconst stateObj = {} as any;\n\t\tstateArray.forEach((value: any) => {\n\t\t\tif (value.key) stateObj[value.key] = value.value || null;\n\t\t});\n\t\treturn stateObj;\n\t}\n\n\t/**\n\t * Used for decoding state\n\t * @param encoded Base64 string\n\t * @returns Human-readable string\n\t */\n\tb64StrToHumanStr(encoded: string): string {\n\t\treturn Buffer.from(encoded, 'base64').toString();\n\t}\n\n\t/**\n\t * @deprecated Use b64StrToHumanStr instead\n\t * @param encoded Base64 string\n\t * @returns Human-readable string\n\t */\n\tfromBase64(encoded: string): string {\n\t\treturn this.b64StrToHumanStr(encoded);\n\t}\n\n\t/**\n\t * Decodes a Base64-encoded Uint8 Algorand address and returns a string\n\t * @param encoded An encoded Algorand address\n\t * @returns Decoded address\n\t */\n\tvalueAsAddr(encoded: string): string {\n\t\treturn encodeAddress(Buffer.from(encoded, 'base64'));\n\t}\n\n\t/**\n\t * Decodes app state into a human-readable format\n\t * @param stateArray Encoded app state\n\t * @returns Array of objects with key, value, and address properties\n\t */\n\tdecodeStateArray(stateArray: AlgonautAppStateEncoded[]) {\n\t\tconst result: AlgonautStateData[] = [];\n\n\t\tfor (let n = 0;\n\t\t\tn < stateArray.length;\n\t\t\tn++) {\n\n\t\t\tconst stateItem = stateArray[n];\n\n\t\t\tconst key = this.b64StrToHumanStr(stateItem.key);\n\t\t\tconst type = stateItem.value.type;\n\t\t\tlet value = undefined as undefined | string | number;\n\t\t\tlet valueAsAddr = '';\n\n\t\t\tif (type == 1) {\n\t\t\t\tvalue = this.b64StrToHumanStr(stateItem.value.bytes);\n\t\t\t\tvalueAsAddr = this.valueAsAddr(stateItem.value.bytes);\n\n\t\t\t} else if (stateItem.value.type == 2) {\n\t\t\t\tvalue = stateItem.value.uint;\n\t\t\t}\n\n\t\t\tresult.push({\n\t\t\t\tkey: key,\n\t\t\t\tvalue: value || '',\n\t\t\t\taddress: valueAsAddr\n\t\t\t});\n\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Does what it says on the tin.\n\t * @param txn base64-encoded unsigned transaction\n\t * @returns transaction object\n\t */\n\tdecodeBase64UnsignedTransaction(txn: string): Transaction {\n\t\treturn decodeUnsignedTransaction(Buffer.from(txn, 'base64'));\n\t}\n\n\t/**\n\t * Describes an Algorand transaction, for display in Inkey\n\t * @param txn Transaction to describe\n\t */\n\ttxnSummary(txn: Transaction) {\n\t\t// for reference: https://developer.algorand.org/docs/get-details/transactions/transactions/\n\n\t\tif (txn.type) {\n\t\t\tconst to = txn.to ? encodeAddress(txn.to.publicKey) : '';\n\t\t\tconst from = txn.from ? encodeAddress(txn.from.publicKey) : '';\n\n\t\t\t// sending algo\n\t\t\tif (txn.type === 'pay') {\n\t\t\t\tif (txn.amount) {\n\t\t\t\t\treturn `Send ${microalgosToAlgos(txn.amount as number)} ALGO to ${to}`;\n\t\t\t\t} else {\n\t\t\t\t\treturn `Send 0 ALGO to ${to}`;\n\t\t\t\t}\n\n\t\t\t\t// sending assets\n\t\t\t} else if (txn.type === 'axfer') {\n\t\t\t\tif (!txn.amount && to === from) {\n\t\t\t\t\treturn `Opt-in to asset ID ${txn.assetIndex}`;\n\t\t\t\t} else {\n\t\t\t\t\tconst amount = txn.amount ? txn.amount : 0;\n\t\t\t\t\treturn `Transfer ${amount} of asset ID ${txn.assetIndex} to ${to}`;\n\t\t\t\t}\n\n\t\t\t\t// asset config\n\t\t\t\t// this could be creating, destroying, or configuring an asset,\n\t\t\t\t// depending on which fields are set\n\t\t\t} else if (txn.type === 'acfg') {\n\n\t\t\t\t// if unit name is supplied, we are creating\n\t\t\t\tif (txn.assetUnitName) {\n\t\t\t\t\treturn `Create asset ${txn.assetName}, symbol ${txn.assetUnitName}`;\n\t\t\t\t}\n\n\t\t\t\treturn `Configure asset ${txn.assetIndex}`;\n\n\t\t\t\t// asset freeze\n\t\t\t} else if (txn.type === 'afrz') {\n\t\t\t\treturn `Freeze asset ${txn.assetIndex}`;\n\n\t\t\t\t// application call\n\t\t\t} else if (txn.type === 'appl') {\n\t\t\t\t// let's find out what kind of application call this is\n\t\t\t\t// reference: https://developer.algorand.org/docs/get-details/dapps/avm/teal/specification/#oncomplete\n\t\t\t\tswitch (txn.appOnComplete) {\n\t\t\t\t\t// NoOp\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturn `Call to application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// OptIn\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn `Opt-in to application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// CloseOut\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn `Close out application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// ClearState\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturn `Execute clear state program of application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// Update\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\treturn `Update application ID ${txn.appIndex}`;\n\n\t\t\t\t\t// Delete\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\treturn `Delete application ID ${txn.appIndex}`;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn `Call to application ID ${txn.appIndex}`;\n\t\t\t\t}\n\n\t\t\t\t// default case\n\t\t\t} else {\n\t\t\t\treturn `Transaction of type ${txn.type} to ${to}`;\n\t\t\t}\n\t\t} else {\n\t\t\t// no better option\n\t\t\treturn txn.toString();\n\t\t}\n\t}\n\n\t/**\n\t * Creates a wallet address + mnemonic from account's secret key.\n\t * Changed in 0.3: this does NOT set algonaut.account.\n\t * @returns AlgonautWallet Object containing `address` and `mnemonic`\n\t */\n\tcreateWallet(): AlgonautWallet {\n\t\tconst account = generateAccount();\n\n\t\tif (account) {\n\t\t\tconst mnemonic = secretKeyToMnemonic(account.sk);\n\t\t\treturn {\n\t\t\t\taddress: account.addr,\n\t\t\t\tmnemonic: mnemonic,\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('There was no account: could not create algonaut wallet!');\n\t\t}\n\t}\n\n\t/**\n\t * Recovers account from mnemonic\n\t * Changed in 0.3: this does NOT set algonaut.account.\n\t * @param mnemonic Mnemonic associated with Algonaut account\n\t * @returns If mnemonic is valid, returns algosdk account (.addr, .sk). Otherwise, throws an error.\n\t */\n\trecoverAccount(mnemonic: string): AlgosdkAccount {\n\t\tif (!mnemonic) throw new Error('No mnemonic provided.');\n\n\t\ttry {\n\t\t\tconst account = mnemonicToSecretKey(mnemonic);\n\t\t\tif (isValidAddress(account?.addr)) {\n\t\t\t\treturn account;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Not a valid mnemonic.');\n\t\t\t}\n\t\t} catch (error: any) {\n\t\t\t// should we throw an error here instead of returning false?\n\t\t\tconsole.error(error);\n\t\t\tthrow new Error('Could not recover account from mnemonic.');\n\t\t}\n\t}\n\n\t/**\n\t * txn(b64) -> txnBuff (buffer)\n\t * @param txn base64-encoded unsigned transaction\n\t * @returns trransaction as buffer object\n\t */\n\ttxnB64ToTxnBuff(txn: string): Buffer {\n\t\treturn Buffer.from(txn, 'base64');\n\t}\n\n\t/**\n\t * Converts between buff -> b64 (txns)\n\t * @param buff likely a algorand txn as a Uint8Array buffer\n\t * @returns string (like for inkey / base64 transmit use)\n\t */\n\ttxnBuffToB64(buff: Uint8Array): string {\n\t\treturn Buffer.from(buff).toString('base64');\n\t}\n\n\t/**\n\t * Does what it says on the tin.\n\t * @param txn algorand txn object\n\t * @returns string (like for inkey / base64 transmit use)\n\t */\n\ttxnToStr(txn: algosdk.Transaction): string {\n\t\tconst buff = txn.toByte();\n\t\treturn this.txnBuffToB64(buff);\n\t}\n\n}\nexport default Algonaut;\n\nexport const buffer = Buffer; // sometimes this is helpful on the frontend\n", "import type {\n\tLogicSigAccount,\n\tTransaction,\n\tAccount,\n\tSuggestedParams,\n\tMultisigMetadata,\n} from 'algosdk';\n\n// FYI the line below breaks in some deno envs\nimport type { ApplicationStateSchema } from 'algosdk/dist/types/client/v2/algod/models/types';\n\nimport type { WalletInitParamsObj } from '@thencc/any-wallet';\n\nexport type AlgonautConfig = {\n\tlibConfig?: {\n\t\tdisableLogs?: boolean; // should default to true\n\t};\n\n\tnodeConfig?: {\n\t\tBASE_SERVER: string;\n\t\tINDEX_SERVER?: string; // optional, but helpful\n\t\tLEDGER: string;\n\t\tPORT: string;\n\t\tAPI_TOKEN: any;\n\t};\n\n\t// if we wanted to support multiple init params of any-wallet, but too verbose... \n\t// anyWalletConfig?: {\n\t// \twalletInitParams?: WalletInitParamsObj;\n\t// };\n\tinitWallets?: WalletInitParamsObj;\n}\n\nexport interface AlgonautStateData {\n\tkey: string;\n\tvalue: string | number | bigint;\n\taddress: string; // if we can detect an address, we put it here\n}\n\nexport interface AlgonautContractSchema {\n\tlocalInts: number,\n\tlocalBytes: number,\n\tglobalInts: number,\n\tglobalBytes: number,\n}\n\nexport interface AlgonautDeployArguments {\n\ttealApprovalCode: string;\n\ttealClearCode: string;\n\tappArgs: any[];\n\tschema: AlgonautContractSchema;\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautUpdateAppArguments {\n\tappIndex: number;\n\ttealApprovalCode: string;\n\ttealClearCode: string;\n\tappArgs: any[];\n\t//schema: AlgonautContractSchema;\n\toptionalFields?: AlgonautTransactionFields;\n\t//lease: Uint8Array;\n\t//rekeyTo: string;\n}\n\nexport interface AlgonautDeleteAppArguments {\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautLsigDeployArguments extends AlgonautDeployArguments {\n\tlsig: LogicSigAccount;\n\tnoteText?: string;\n}\n\nexport interface AlgonautAppStateEncoded {\n\tkey: string;\n\tvalue: {\n\t\tbytes: string;\n\t\ttype: number;\n\t\tuint: number\n\t}\n}\n\nexport interface AlgonautGetApplicationResponse {\n\tid: number;\n\tparams: {\n\t\t'approval-program': string;\n\t\t'clear-state-program': string;\n\t\tcreator: string;\n\t\textraProgramPages?: number;\n\t\t'global-state'?: AlgonautAppStateEncoded[];\n\t\t'global-state-schema'?: ApplicationStateSchema;\n\t\t'local-state-schema'?: ApplicationStateSchema;\n\t}\n}\n\nexport interface AlgonautAppState {\n\tindex: number;\n\thasState: boolean;\n\tcreatorAddress: string;\n\tglobals: AlgonautStateData[];\n\tlocals: AlgonautStateData[];\n}\n\nexport interface AlgonautCallAppArguments {\n\tfrom?: string;\n\tappIndex: number;\n\tappArgs: any[];\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautLsigCallAppArguments extends AlgonautCallAppArguments {\n\tlsig: LogicSigAccount;\n}\n\nexport interface AlgonautCreateAssetArguments {\n\tfrom?: string;\n\tassetName: string;\n\tsymbol: string;\n\tmetaBlock: string;\n\tdecimals: number;\n\tamount: number;\n\tassetURL?: string;\n\tdefaultFrozen?: boolean;\n\tassetMetadataHash?: string;\n\tclawback?: string;\n\tmanager?: string;\n\treserve?: string;\n\tfreeze?: string;\n\trekeyTo?: string;\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautDestroyAssetArguments {\n\trekeyTo?: string;\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautSendAssetArguments {\n\tto: string;\n\tfrom?: string;\n\tassetIndex: number;\n\tamount: number | bigint;\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautLsigSendAssetArguments extends AlgonautSendAssetArguments {\n\tlsig: LogicSigAccount;\n}\n\nexport interface AlgonautPaymentArguments {\n\tamount: number | bigint;\n\tto: string;\n\tfrom?: string;\n\toptionalFields?: AlgonautTransactionFields;\n}\n\nexport interface AlgonautLsigPaymentArguments extends AlgonautPaymentArguments {\n\tlsig: LogicSigAccount;\n}\n\nexport interface AlgonautTxnCallbacks {\n\tonSign(payload: any): void;\n\tonSend(payload: any): void;\n\tonConfirm(payload: any): void;\n}\n\nexport type AlgonautError = {\n\tmessage: string;\n\trawError?: any;\n}\n\nexport type AlgonautTransactionStatus = {\n\tstatus: 'success' | 'fail' | 'rejected';\n\tmessage: string;\n\tindex?: number;\n\ttxId: string;\n\terror?: Error;\n\tmeta?: any;\n\tcreatedIndex?: number; // implement this for created apps and assets\n}\n\nexport type AlgonautWallet = {\n\taddress: string;\n\tmnemonic: string;\n}\n\nexport type AlgonautTransactionFields = {\n\taccounts?: string[],\n\tapplications?: number[],\n\tassets?: number[],\n\treKeyTo?: string,\n\tnote?: string,\n\tcloseRemainderTo?: string,\n\tmanager?: string,\n\tfreeze?: string,\n\tclawback?: string,\n\treserve?: string;\n\tsuggestedParams?: SuggestedParams;\n}\n\nexport type AlgonautAtomicTransaction = {\n\ttransaction: Transaction;\n\t// TODO remove this, yeah?\n\ttransactionSigner: undefined | Account | LogicSigAccount; // undefined means theres not enough info to tell, like when a .from field is in params\n\tisLogigSig: boolean;\n}\n\nexport type InkeySignTxnResponse = {\n\tsuccess: boolean;\n\treject?: boolean;\n\terror?: any;\n\tsignedTxns?: Uint8Array[] | Uint8Array;\n}\n\nexport type TxnForSigning = {\n\ttxn: string; // base64 encoded transaction\n\ttxnDecoded?: Transaction;\n\tisLogicSig?: boolean;\n\tisMultisig?: boolean;\n\tmultisigMeta?: MultisigMetadata;\n}", "// src/index.ts\nimport { ReactiveEffect, isReactive, isRef, isShallow } from \"@vue/reactivity\";\nimport { NOOP, hasChanged, isArray, isFunction as isFunction2, isObject } from \"@vue/shared\";\n\n// src/errorHandling.ts\nimport { isFunction, isPromise } from \"@vue/shared\";\nfunction callWithErrorHandling(fn, type, args) {\n  let res;\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, type);\n  }\n  return res;\n}\nfunction callWithAsyncErrorHandling(fn, type, args) {\n  if (isFunction(fn)) {\n    const res = callWithErrorHandling(fn, type, args);\n    if (res && isPromise(res)) {\n      res.catch((err) => {\n        handleError(err, type);\n      });\n    }\n    return res;\n  }\n  const values = [];\n  for (let i = 0; i < fn.length; i++)\n    values.push(callWithAsyncErrorHandling(fn[i], type, args));\n  return values;\n}\nfunction handleError(err, type) {\n  console.error(new Error(`[@vue-reactivity/watch]: ${type}`));\n  console.error(err);\n}\nfunction warn(message) {\n  console.warn(createError(message));\n}\nfunction createError(message) {\n  return new Error(`[reactivue]: ${message}`);\n}\n\n// src/index.ts\nvar INITIAL_WATCHER_VALUE = {};\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\nfunction watch(source, cb, options) {\n  return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, { immediate, deep, flush } = {}) {\n  let getter;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => source;\n    deep = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(isReactive);\n    getter = () => source.map((s) => {\n      if (isRef(s))\n        return s.value;\n      else if (isReactive(s))\n        return traverse(s);\n      else if (isFunction2(s))\n        return callWithErrorHandling(s, \"watch getter\");\n      else\n        return warn(\"invalid source\");\n    });\n  } else if (isFunction2(source)) {\n    if (cb) {\n      getter = () => callWithErrorHandling(source, \"watch getter\");\n    } else {\n      getter = () => {\n        if (cleanup)\n          cleanup();\n        return callWithAsyncErrorHandling(source, \"watch callback\", [onCleanup]);\n      };\n    }\n  } else {\n    getter = NOOP;\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    getter = () => traverse(baseGetter());\n  }\n  let cleanup;\n  let onCleanup = (fn) => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, \"watch cleanup\");\n    };\n  };\n  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\n  const job = () => {\n    if (!effect.active)\n      return;\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup)\n          cleanup();\n        callWithAsyncErrorHandling(cb, \"watch value\", [\n          newValue,\n          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,\n          onCleanup\n        ]);\n        oldValue = newValue;\n      }\n    } else {\n      effect.run();\n    }\n  };\n  job.allowRecurse = !!cb;\n  let scheduler;\n  if (flush === \"sync\") {\n    scheduler = job;\n  } else {\n    scheduler = () => {\n      job();\n    };\n  }\n  const effect = new ReactiveEffect(getter, scheduler);\n  if (cb) {\n    if (immediate)\n      job();\n    else\n      oldValue = effect.run();\n  } else {\n    effect.run();\n  }\n  return () => effect.stop();\n}\nfunction traverse(value, seen = /* @__PURE__ */ new Set()) {\n  if (!isObject(value) || seen.has(value))\n    return value;\n  seen.add(value);\n  if (isArray(value)) {\n    for (let i = 0; i < value.length; i++)\n      traverse(value[i], seen);\n  } else if (value instanceof Map) {\n    value.forEach((_, key) => {\n      traverse(value.get(key), seen);\n    });\n  } else if (value instanceof Set) {\n    value.forEach((v) => {\n      traverse(v, seen);\n    });\n  } else {\n    for (const key of Object.keys(value))\n      traverse(value[key], seen);\n  }\n  return value;\n}\nexport {\n  watch,\n  watchEffect\n};\n", "import type { AlgonautConfig } from './AlgonautTypes';\n\nexport const testnetConfig: AlgonautConfig['nodeConfig'] = {\n\tLEDGER: 'testnet',\n\tBASE_SERVER: 'https://testnet-api.algonode.cloud',\n\tINDEX_SERVER: 'https://testnet-idx.algonode.cloud',\n\tAPI_TOKEN: '',\n\tPORT: '', // 443\n};\nexport const mainnetConfig: AlgonautConfig['nodeConfig'] = {\n\tLEDGER: 'mainnet',\n\tBASE_SERVER: 'https://mainnet-api.algonode.cloud',\n\tINDEX_SERVER: 'https://mainnet-idx.algonode.cloud',\n\tAPI_TOKEN: '',\n\tPORT: '',\n};\nexport const defaultNodeConfig = testnetConfig;\n", "import type { AlgonautConfig } from './AlgonautTypes';\n\nexport const defaultLibConfig: AlgonautConfig['libConfig'] = {\n\tdisableLogs: true,\n};\n", "\n// log helper - for disabling logs w a query string but not the dapp's logs\nexport const logger = {\n\tenabled: false,\n\tlog(...args: any) {\n\t\tif (!this.enabled) return;\n\t\tconsole.log(...args);\n\t},\n\tdebug(...args: any) {\n\t\tif (!this.enabled) return;\n\t\tconsole.debug(...args);\n\t},\n};\n"],
  "mappings": "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",
  "names": ["init_shim", "import_buffer", "init_shim", "init_shim", "callWithErrorHandling", "fn", "type", "args", "res", "err", "handleError", "callWithAsyncErrorHandling", "isFunction", "isPromise", "values", "i", "warn", "message", "createError", "INITIAL_WATCHER_VALUE", "watch", "source", "cb", "options", "doWatch", "immediate", "deep", "flush", "getter", "forceTrigger", "isMultiSource", "isRef", "isShallow", "isReactive", "isArray", "s", "traverse", "isFunction", "callWithErrorHandling", "warn", "cleanup", "callWithAsyncErrorHandling", "onCleanup", "NOOP", "baseGetter", "fn", "effect", "oldValue", "INITIAL_WATCHER_VALUE", "job", "newValue", "v", "i", "hasChanged", "scheduler", "ReactiveEffect", "value", "seen", "isObject", "_", "key", "init_shim", "testnetConfig", "mainnetConfig", "defaultNodeConfig", "init_shim", "defaultLibConfig", "init_shim", "logger", "args", "unsAcctSync", "Algonaut", "defaultNodeConfig", "defaultLibConfig", "esm_default", "i", "config", "libConfig", "logger", "Qn", "nodeConfig", "isValid", "mainnetConfig", "testnetConfig", "AlgodClient", "IndexerClient", "status", "ot", "acct", "walletInitParams", "Gn", "mnemonic", "N", "route", "inkeyW", "inkeyClientSdk", "initWallets", "initWs", "wId", "wInitParams", "w", "enabledWs", "wIds", "Pn", "Mo", "txId", "limitDelta", "log", "lastround", "limit", "returnValue", "pendingInfo", "er", "base64ProgramString", "program", "LogicSigAccount", "assetIndex", "optionalTxnArgs", "suggestedParams", "makeAssetTransferTxnWithSuggestedParamsFromObject", "callbacks", "transaction", "args", "optInState", "asset", "encodedArgs", "arg", "encodeUint64", "fromAddr", "metaBlockLength", "note", "totalIssuance", "manager", "reserve", "freeze", "clawback", "makeAssetCreateTxnWithSuggestedParams", "txn", "txStatus", "ptx", "assetId", "enc", "makeAssetDestroyTxnWithSuggestedParams", "isValidAddress", "makeApplicationOptInTxnFromObject", "appIndex", "makeApplicationDeleteTxn", "appId", "e", "processedArgs", "makeApplicationNoOpTxnFromObject", "makeApplicationCloseOutTxnFromObject", "getApplicationAddress", "proms", "promsRes", "info", "localState", "state", "approvalProgram", "clearProgram", "makeApplicationCreateTxnFromObject", "OnApplicationComplete", "result", "transactionResponse", "onComplete", "makeApplicationCreateTxn", "sender", "signedTxn", "signLogicSigTransactionObject", "makeApplicationUpdateTxn", "programSource", "programBytes", "compileResponse", "encodedNote", "makePaymentTxnWithSuggestedParamsFromObject", "address", "accountInfo", "bal", "applicationIndex", "accountInfoResponse", "n", "stateItem", "key", "type", "value", "valueAsAddr", "encodeAddress", "txnOrTxns", "txnArr", "algoTxnArr", "t", "nativeT", "gId", "txnBuffArr", "awTxnsToSign", "awTxnsSigned", "Jn", "tx", "str", "stateArray", "stateObj", "encoded", "decodeUnsignedTransaction", "to", "from", "microalgosToAlgos", "account", "generateAccount", "secretKeyToMnemonic", "mnemonicToSecretKey", "error", "buff", "src_default", "buffer"]
}
