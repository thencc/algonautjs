{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { Buffer } from 'buffer';\nimport algosdk from 'algosdk';\nimport {\n\tAlgonautConfig,\n\tAlgonautWallet,\n\tAlgonautTransactionStatus,\n\tAlgonautAtomicTransaction,\n\tAlgonautTransactionFields,\n\tAlgonautAppState,\n\tAlgonautStateData,\n\tWalletConnectListener,\n\tAlgonautTxnCallbacks,\n\tAlgonautContractSchema,\n\tAlgonautCreateAssetArguments,\n\tAlgonautSendAssetArguments,\n\tAlgonautCallAppArguments,\n\tAlgonautDeployArguments,\n\tAlgonautLsigDeployArguments,\n\tAlgonautLsigCallAppArguments,\n\tAlgonautLsigSendAssetArguments,\n\tAlgonautPaymentArguments,\n\tAlgonautLsigPaymentArguments,\n\tAlgonautUpdateAppArguments\n} from './AlgonautTypes';\n// import * as sha512 from 'js-sha512';\n// import * as CryptoJS from 'crypto-js';\n// import { decode, encode } from 'hi-base32';\n\n// @walletconnect/socket-transport incorrectly uses global in esm build... + @walletconnect/encoding uses Buffer in esm build... so use umd build\nimport WalletConnect from '@walletconnect/client/dist/umd/index.min.js'; // umd works in node + browser\nimport { IInternalEvent } from '@walletconnect/types';\nimport QRCodeModal from 'algorand-walletconnect-qrcode-modal';\nimport { formatJsonRpcRequest } from '@json-rpc-tools/utils';\nimport {\n\tisBrowser,\n\tisNode,\n\tisAndroid,\n\tisIOS,\n\tisMobile\n} from \"@walletconnect/utils\";\n\n// fix for wallectconnect websocket issue when backgrounded on mobile (uses request animation frame)\nvar wcReqAF = 0;\n\n// wc fix (audio)\nvar wcS: HTMLAudioElement;\n// FYI imports must be in this order!\nimport wcAudImport from './assets/rhodes.mp3'; // makes file avail in /dist build\nwcAudImport;\nconst wcAud = new URL('./assets/rhodes.mp3', import.meta.url);\n\n/*\n\nAlgonautJS should have some \"signing modes\" which you set at invocation time\n\nprobably in\nAlgonautConfig\n\n\n\n\nfor stateful contracts i think we want to read it in and hold all the\nNV pairs as fields\n\nand maybe read the TEAL and make wrapper methods for things we see in\na config file?\n\nTBD:\n\n- standard typed return values\n- standard error values, pre-parse the algo error goop\n\n\nthere are a couple ways to go for atomic txs, i THINK the more pleasant API is\n\nawait runAtomicTransaction([\n\tawait atomicSendASA(),\n\tawait atomicSendAlgo(),\n\tawait atomicCallApp()\n])\n\n\nTBD:\n\n\n\n*/\n\n\n// import { mainNetConfig as config } from './algoconfig';\n\n// good resource: https://developer.algorand.org/solutions/integrate-algosigner-to-js-app-on-algorand/\n\ndeclare global {\n\tinterface Window {\n\t\tAlgoSigner: any;\n\t}\n}\n\nexport default class Algonaut {\n\n\t// TBD: add algo wallet for mobile\n\talgodClient: algosdk.Algodv2;\n\tindexerClient = undefined as undefined | algosdk.Indexer;\n\taccount = undefined as undefined | algosdk.Account;\n\taddress = undefined as undefined | string;\n\tsKey = undefined as undefined | Uint8Array;\n\tmnemonic = undefined as undefined | string;\n\tconfig = undefined as undefined | AlgonautConfig;\n\tsdk = undefined as undefined | typeof algosdk;\n\tuiLoading = false;\n\twalletConnect = {\n\t\tconnected: false,\n\t\tconnector: undefined as undefined | WalletConnect,\n\t\taccounts: [] as any[],\n\t\taddress: '',\n\t\tassets: [] as any[],\n\t\tchain: undefined as any\n\t};\n\n\t/**\n\t * Instantiates Algonaut.js.\n\t *\n\t * @example\n\t * Usage:\n\t *\n\t * ```js\n\t * import Algonaut from 'algonaut.js';\n\t * const algonaut = new Algonaut({\n\t *\t BASE_SERVER: 'https://testnet-algorand.api.purestake.io/ps2',\n\t *\t INDEX_SERVER: 'https://testnet-algorand.api.purestake.io/idx2'\n\t *\t LEDGER: 'TestNet',\n\t *\t PORT: '',\n\t *\t API_TOKEN: { 'X-API-Key': 'YOUR_API_TOKEN' }\n\t * });\n\t * ```\n\t *\n\t * @param config config object\n\t */\n\tconstructor(config: AlgonautConfig) {\n\n\t\tthis.config = config;\n\t\tthis.algodClient = new algosdk.Algodv2(config.API_TOKEN, config.BASE_SERVER, config.PORT);\n\t\tif (config.INDEX_SERVER) {\n\t\t\tthis.indexerClient = new algosdk.Indexer(config.API_TOKEN, config.INDEX_SERVER, config.PORT);\n\t\t} else {\n\t\t\tconsole.warn('No indexer configured because INDEX_SERVER was not provided.');\n\t\t}\n\n\t\tthis.sdk = algosdk;\n\n\t}\n\n\t/**\n\t * @returns config object or `false` if no config is set\n\t */\n\tgetConfig(): AlgonautConfig | boolean {\n\t\tif (this.config) return this.config;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks status of Algorand network\n\t * @returns Promise resolving to status of Algorand network\n\t */\n\tasync checkStatus(): Promise<any> {\n\t\tconst status = await this.algodClient.status().do();\n\t\tconsole.log('Algorand network status: %o', status);\n\t\treturn status;\n\t}\n\n\t/**\n\t * if you already have an account, set it here\n\t * @param account an algosdk account already created\n\t */\n\tsetAccount(account: algosdk.Account): void {\n\t\tthis.account = account;\n\t\tthis.address = account.addr;\n\t\tif (this.config) this.config.SIGNING_MODE = 'local';\n\t\tthis.mnemonic = algosdk.secretKeyToMnemonic(account.sk);\n\t}\n\n\t/**\n\t * Sets account connected via WalletConnect\n\t * @param address account address\n\t */\n\tsetWalletConnectAccount(address: string) {\n\t\tthis.account = {\n\t\t\taddr: address,\n\t\t\tsk: new Uint8Array([])\n\t\t};\n\t\tif (this.config) this.config.SIGNING_MODE = 'walletconnect';\n\t}\n\n\t/**\n\t * Creates a wallet address + mnemonic from account's secret key\n\t * @returns AlgonautWallet Object containing `address` and `mnemonic`\n\t */\n\tcreateWallet(): AlgonautWallet {\n\t\tthis.account = algosdk.generateAccount();\n\n\t\tif (this.account) {\n\t\t\tthis.address = this.account.addr;\n\t\t\tthis.mnemonic = algosdk.secretKeyToMnemonic(this.account.sk);\n\t\t\treturn {\n\t\t\t\taddress: this.account.addr,\n\t\t\t\tmnemonic: this.mnemonic || ''\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('There was no account: could not create algonaut wallet!');\n\t\t}\n\n\t}\n\n\t/**\n\t * Recovers account from mnemonic\n\t * @param mnemonic Mnemonic associated with Algonaut account\n\t * @returns If mnemonic is valid, returns account. Otherwise, returns false.\n\t */\n\trecoverAccount(mnemonic: string): algosdk.Account | boolean {\n\t\ttry {\n\t\t\tthis.account = algosdk.mnemonicToSecretKey(mnemonic);\n\t\t\tif (algosdk.isValidAddress(this.account?.addr)) {\n\t\t\t\treturn this.account || false;\n\t\t\t}\n\t\t\tif (this.config) this.config.SIGNING_MODE = 'local';\n\t\t} catch (error) {\n\t\t\t// should we throw an error here instead of returning false?\n\t\t\tconsole.log(error);\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * General purpose method to await transaction confirmation\n\t * @param txId a string id of the transacion you want to watch\n\t * @param limitDelta how many rounds to wait, defaults to 50\n\t * @param log set to true if you'd like to see \"waiting for confirmation\" log messages\n\t */\n\tasync waitForConfirmation(txId: string, limitDelta?: number, log = false): Promise<AlgonautTransactionStatus> {\n\t\tlet lastround = (await this.algodClient.status().do())['last-round'];\n\t\tconst limit = lastround + (limitDelta ? limitDelta : 50);\n\n\t\tconst returnValue = {\n\t\t\tstatus: 'fail',\n\t\t\tmessage: ''\n\t\t} as AlgonautTransactionStatus;\n\n\t\twhile (lastround < limit) {\n\t\t\tlet pendingInfo = '' as any;\n\t\t\ttry {\n\t\t\t\tpendingInfo = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\t\t\t\tif (log) {\n\t\t\t\t\tconsole.log('waiting for confirmation');\n\t\t\t\t}\n\t\t\t} catch (er: any) {\n\t\t\t\tconsole.error(er.response?.text);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tpendingInfo['confirmed-round'] !== null &&\n\t\t\t\tpendingInfo['confirmed-round'] > 0\n\t\t\t) {\n\n\t\t\t\tconsole.log(\n\t\t\t\t\t'Transaction confirmed in round ' + pendingInfo['confirmed-round']\n\t\t\t\t);\n\n\t\t\t\treturnValue.txId = txId;\n\t\t\t\treturnValue.status = 'success';\n\t\t\t\treturnValue.message = 'Transaction confirmed in round ' + pendingInfo['confirmed-round'];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlastround++;\n\t\t}\n\n\t\treturn returnValue;\n\n\t}\n\n\t/**\n\t * Creates a LogicSig from a base64 program string.  Note that this method does not COMPILE\n\t * the program, just builds an LSig from an already compiled base64 result!\n\t * @param base64ProgramString\n\t * @returns an algosdk LogicSigAccount\n\t */\n\tgenerateLogicSig(base64ProgramString: string): algosdk.LogicSigAccount {\n\t\tconst program = new Uint8Array(\n\t\t\tBuffer.from(base64ProgramString, 'base64')\n\t\t);\n\n\t\treturn new algosdk.LogicSigAccount(program);\n\t}\n\n\tasync atomicOptInAsset(assetIndex: number): Promise<AlgonautAtomicTransaction> {\n\n\t\tif (this.account && assetIndex) {\n\n\t\t\tconst params = await this.algodClient.getTransactionParams().do();\n\t\t\tconst optInTransaction = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\tfrom: this.account.addr,\n\t\t\t\tto: this.account.addr,\n\t\t\t\tsuggestedParams: params,\n\t\t\t\tassetIndex: assetIndex,\n\t\t\t\tamount: 0\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: optInTransaction,\n\t\t\t\ttransactionSigner: this.account,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\n\t\t} else {\n\t\t\tthrow new Error('there was no account!');\n\t\t}\n\n\t}\n\n\t/**\n\t * Opt-in the current account for the a token or NFT Asset.\n\t * @param assetIndex number of asset to opt-in to\n\t * @param callbacks `AlgonautTxnCallbacks`, passed to {@link sendTransaction}\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync optInAsset(assetIndex: number, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tif (!this.account) throw new Error('There was no account!');\n\t\tconst { transaction } = await this.atomicOptInAsset(assetIndex);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\n\t// this is a bit harder with the algosdk api\n\t// what we may want to do be more opinionated and have a standard local\n\t// field we always set on apps when opted in\n\n\t// OR maybe we check for HAS STATE which might check for local state\n\t// of any kind on that app id?\n\n\t// async isOptedIntoApp(account: string, appId: number): boolean {\n\t// \tlet optInState = false;\n\n\t// \tconst accountInfo = await this.getAccountInfo(account);\n\t// \taccountInfo.assets.forEach((asset: any) => {\n\t// \t\tif (asset['asset-id'] == assetId) {\n\t// \t\t\toptInState = true;\n\t// \t\t}\n\n\t// \t});\n\n\t// \treturn optInState;\n\t// }\n\n\n\t/**\n\t * You can be opted into an asset but still have a zero balance. Use this call\n\t * for cases where you just need to know the address's opt-in state\n\t * @param assetId\n\t * @returns\n\t */\n\tasync isOptedIntoAsset(args: { account: string, assetId: number }): Promise<boolean> {\n\t\tlet optInState = false;\n\n\t\tconst accountInfo = await this.getAccountInfo(args.account);\n\t\taccountInfo.assets.forEach((asset: any) => {\n\t\t\tif (asset['asset-id'] == args.assetId) {\n\t\t\t\toptInState = true;\n\t\t\t}\n\n\t\t});\n\n\t\treturn optInState;\n\t}\n\n\t/**\n\t * Sync function that returns a correctly-encoded argument array for\n\t * an algo transaction\n\t * @param args must be an any[] array, as it will often need to be\n\t * a mix of strings and numbers. Valid types are: string, number, and bigint\n\t * @returns a Uint8Array of encoded arguments\n\t */\n\tencodeArguments(args: any[]): Uint8Array[] {\n\t\tconst encodedArgs = [] as Uint8Array[];\n\n\t\t// loop through args and encode them based on type\n\t\targs.forEach((arg: any) => {\n\t\t\tif (typeof arg == 'number') {\n\t\t\t\tencodedArgs.push(algosdk.encodeUint64(arg));\n\t\t\t} else if (typeof arg == 'bigint') {\n\t\t\t\tencodedArgs.push(algosdk.encodeUint64(arg));\n\t\t\t} else if (typeof arg == 'string') {\n\t\t\t\tencodedArgs.push(new Uint8Array(Buffer.from(arg)));\n\t\t\t}\n\t\t});\n\n\t\treturn encodedArgs;\n\t}\n\n\t/**\n\t * Create asset transaction\n\t * @param args {AlgonautCreateAssetArguments}  Must pass `assetName`, `symbol`, `decimals`, `amount`.\n\t * @returns atomic txn to create asset\n\t*/\n\tasync atomicCreateAsset(args: AlgonautCreateAssetArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!args.metaBlock) {\n\t\t\targs.metaBlock = 'wot? wot wot?';\n\t\t}\n\n\t\tif (!args.defaultFrozen) args.defaultFrozen = false;\n\t\tif (!args.assetURL) args.assetURL = undefined;\n\n\t\tconst metaBlockLength = args.metaBlock.length;\n\n\t\tif (metaBlockLength > 511) {\n\t\t\tconsole.error('meta block is ' + metaBlockLength);\n\t\t\tthrow new Error('drat! this meta block is too long!');\n\t\t}\n\n\t\tconst enc = new TextEncoder();\n\n\t\tif (!this.account) throw new Error('There was no account');\n\n\n\t\t//console.log('ok, starting ASA deploy');\n\n\t\t// arbitrary data: 512 bytes, ~512 characters\n\t\tconst note = enc.encode(args.metaBlock);\n\t\tconst addr = this.account.addr;\n\t\tconst totalIssuance = args.amount;\n\t\tconst manager = this.account.addr;\n\t\tconst reserve = this.account.addr;\n\t\tconst freeze = this.account.addr;\n\t\tconst clawback = this.account.addr;\n\n\t\tconst params = await this.algodClient.getTransactionParams().do();\n\n\t\t// signing and sending \"txn\" allows \"addr\" to create an asset\n\t\tconst txn = algosdk.makeAssetCreateTxnWithSuggestedParams(\n\t\t\taddr,\n\t\t\tnote,\n\t\t\ttotalIssuance,\n\t\t\targs.decimals,\n\t\t\targs.defaultFrozen,\n\t\t\tmanager,\n\t\t\treserve,\n\t\t\tfreeze,\n\t\t\tclawback,\n\t\t\targs.symbol,\n\t\t\targs.assetName,\n\t\t\targs.assetURL,\n\t\t\targs.assetMetadataHash,\n\t\t\tparams\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: txn,\n\t\t\ttransactionSigner: this.account,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\n\t/**\n\t * Create asset\n\t * @param args AlgonautCreateAssetArguments. Must pass `assetName`, `symbol`, `decimals`, `amount`.\n\t * @param callbacks AlgonautTxnCallbacks\n\t * @returns asset index\n\t*/\n\tasync createAsset(\n\t\targs: AlgonautCreateAssetArguments,\n\t\tcallbacks?: AlgonautTxnCallbacks\n\t): Promise<AlgonautTransactionStatus> {\n\t\tconst atomicTxn = await this.atomicCreateAsset(args);\n\t\tconst txn = atomicTxn.transaction;\n\n\t\ttry {\n\t\t\tconst assetID = null;\n\t\t\tconst txStatus = await this.sendTransaction(txn, callbacks);\n\n\t\t\tconst ptx = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(txn.txID().toString())\n\t\t\t\t.do();\n\t\t\ttxStatus.createdIndex = ptx['asset-index'];\n\n\t\t\treturn txStatus;\n\n\t\t} catch (er) {\n\t\t\tconsole.log('transaction error');\n\t\t\tconsole.log(er);\n\t\t\tthrow new Error(er as any);\n\t\t}\n\t}\n\n\tasync atomicDeleteAsset(assetId: number): Promise<AlgonautAtomicTransaction> {\n\t\tif (!this.account) throw new Error('there was no account!');\n\n\t\tconst enc = new TextEncoder();\n\n\t\tconst transaction = algosdk.makeAssetDestroyTxnWithSuggestedParams(\n\t\t\tthis.account.addr,\n\t\t\tenc.encode('doh!'),\n\t\t\tassetId,\n\t\t\tawait this.algodClient.getTransactionParams().do()\n\t\t);\n\n\t\treturn {\n\t\t\ttransaction: transaction,\n\t\t\ttransactionSigner: this.account,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Deletes asset\n\t * @param assetId Index of the ASA to delete\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync deleteAsset(assetId: number, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicDeleteAsset(assetId);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Creates send asset transaction.\n\t *\n\t * IMPORTANT: Before you can call this, the target account has to \"opt-in\"\n\t * to the ASA index.  You can't just send ASAs to people blind!\n\t *\n\t * @param args - object containing `to`, `assetIndex`, and `amount` properties\n\t * @returns Promise resolving to `AlgonautAtomicTransaction`\n\t */\n\tasync atomicSendAsset(args: AlgonautSendAssetArguments): Promise<AlgonautAtomicTransaction> {\n\n\t\tif (!this.account) throw new Error('there is no account!');\n\n\t\tconst transaction =\n\t\t\talgosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\tfrom: this.account.addr,\n\t\t\t\tto: args.to,\n\t\t\t\tamount: args.amount,\n\t\t\t\tassetIndex: args.assetIndex,\n\t\t\t\tsuggestedParams: await this.algodClient.getTransactionParams().do()\n\t\t\t});\n\n\t\treturn {\n\t\t\ttransaction: transaction,\n\t\t\ttransactionSigner: this.account,\n\t\t\tisLogigSig: false\n\t\t};\n\t}\n\n\t/**\n\t * Sends asset to an address.\n\t *\n\t * IMPORTANT: Before you can call this, the target account has to \"opt-in\"\n\t * to the ASA index.  You can't just send ASAs to people blind!\n\t *\n\t * @param args - object containing `to`, `assetIndex`, and `amount` properties\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync sendAsset(args: AlgonautSendAssetArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tif (!this.account) throw new Error('There was no account!');\n\t\tconst { transaction } = await this.atomicSendAsset(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Get info about an asset\n\t * @param assetIndex\n\t * @returns\n\t */\n\tasync getAssetInfo(assetIndex: number): Promise<any> {\n\t\tconst info = await this.algodClient.getAssetByID(assetIndex).do();\n\t\treturn info;\n\t}\n\n\t/**\n\t * Creates transaction to opt into an app\n\t * @param args AlgonautCallAppArgs\n\t * @returns AlgonautAtomicTransaction\n\t */\n\tasync atomicOptInApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (this.account && args.appIndex) {\n\n\t\t\tconst sender = this.account.addr;\n\t\t\tconst params = await this.algodClient.getTransactionParams().do();\n\t\t\tconst optInTransaction = algosdk.makeApplicationOptInTxnFromObject({\n\t\t\t\tfrom: sender,\n\t\t\t\tappIndex: args.appIndex,\n\t\t\t\tsuggestedParams: params,\n\t\t\t\tappArgs: args.appArgs ? this.encodeArguments(args.appArgs) : undefined,\n\t\t\t\taccounts: args.optionalFields?.accounts ? args.optionalFields?.accounts : undefined,\n\t\t\t\tforeignApps: args.optionalFields?.applications ? args.optionalFields?.applications : undefined,\n\t\t\t\tforeignAssets: args.optionalFields?.assets ? args.optionalFields?.assets : undefined\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: optInTransaction,\n\t\t\t\ttransactionSigner: this.account,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\n\t\t} else {\n\t\t\tthrow new Error('algonautjs has no account loaded!');\n\t\t}\n\n\t}\n\n\t/**\n\t * Opt-in the current account for an app.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields`\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync optInApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tif (this.account && args.appIndex) {\n\t\t\tconst { transaction } = await this.atomicOptInApp(args);\n\t\t\t//const txId = transaction.txID().toString();\n\t\t\treturn await this.sendTransaction(transaction, callbacks);\n\t\t} else {\n\t\t\tif (!this.account) throw new Error('No account set.');\n\t\t\tthrow new Error('Must provide appIndex');\n\t\t}\n\t}\n\n\t/**\n\t * Returns atomic transaction that deletes application\n\t * @param appIndex - ID of application\n\t * @returns Promise resolving to atomic transaction that deletes application\n\t */\n\tasync atomicDeleteApplication(appIndex: number): Promise<AlgonautAtomicTransaction> {\n\n\t\tif (this.account && appIndex) {\n\t\t\ttry {\n\t\t\t\tconst sender = this.account.addr;\n\t\t\t\tconst params = await this.algodClient.getTransactionParams().do();\n\n\t\t\t\t//console.log('delete: ' + appIndex);\n\n\t\t\t\tconst txn = algosdk.makeApplicationDeleteTxn(sender, params, appIndex);\n\n\t\t\t\treturn {\n\t\t\t\t\ttransaction: txn,\n\t\t\t\t\ttransactionSigner: this.account,\n\t\t\t\t\tisLogigSig: false\n\t\t\t\t};\n\n\t\t\t} catch (e: any) {\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('No account loaded');\n\t\t}\n\t}\n\n\t/**\n\t * Deletes an application from the blockchain\n\t * @param appIndex - ID of application\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync deleteApplication(appIndex: number, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tif (!this.account) throw new Error('There was no account');\n\n\t\ttry {\n\t\t\tconst { transaction } = await this.atomicDeleteApplication(appIndex);\n\t\t\tconst txId = transaction.txID().toString();\n\n\t\t\tconst status = await this.sendTransaction(transaction, callbacks);\n\n\t\t\t// display results\n\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t.do();\n\t\t\tconst appId = transactionResponse['txn']['txn'].apid;\n\t\t\tconsole.log('Deleted app-id: ', appId);\n\n\t\t\treturn {\n\t\t\t\tstatus: 'success',\n\t\t\t\tmessage: 'deleted app index ' + appId,\n\t\t\t\ttxId\n\t\t\t};\n\n\t\t} catch (e: any) {\n\t\t\tconsole.log(e);\n\t\t\tthrow new Error(e.response?.text);\n\t\t}\n\t}\n\n\tasync atomicCallApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\n\t\tif (this.account && args.appIndex && args.appArgs.length) {\n\n\t\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\t\tconst params = await this.algodClient.getTransactionParams().do();\n\t\t\tconst callAppTransaction = algosdk.makeApplicationNoOpTxnFromObject({\n\t\t\t\tfrom: this.account.addr,\n\t\t\t\tsuggestedParams: params,\n\t\t\t\tappIndex: args.appIndex,\n\t\t\t\tappArgs: processedArgs,\n\t\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: callAppTransaction,\n\t\t\t\ttransactionSigner: this.account,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\n\t\t} else {\n\t\t\tthrow new Error('there was no account!');\n\t\t}\n\t}\n\n\t/**\n\t * Call a \"method\" on a stateful contract.  In TEAL, you're really giving\n\t * an argument which branches to a specific place and reads the other args\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t */\n\tasync callApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tif (!this.account) throw new Error('There was no account!');\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\t\tif (!args.appArgs.length) throw new Error('Must provide at least one appArgs');\n\n\t\tconst { transaction } = await this.atomicCallApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\tasync atomicCallAppWithLSig(args: AlgonautLsigCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\n\t\tif (this.account && args.appIndex && args.appArgs.length) {\n\t\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\t\tconst params = await this.algodClient.getTransactionParams().do();\n\t\t\tconst callAppTransaction = algosdk.makeApplicationNoOpTxnFromObject({\n\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\tsuggestedParams: params,\n\t\t\t\tappIndex: args.appIndex,\n\t\t\t\tappArgs: processedArgs,\n\t\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: callAppTransaction,\n\t\t\t\ttransactionSigner: args.lsig,\n\t\t\t\tisLogigSig: true\n\t\t\t};\n\n\t\t} else {\n\t\t\tthrow new Error('there was no account!');\n\t\t}\n\t}\n\n\t/**\n\t * Returns an atomic transaction that closes out the user's local state in an application.\n\t * The opposite of {@link atomicOptInApp}.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t * @returns Promise resolving to atomic transaction\n\t */\n\tasync atomicCloseOutApp(args: AlgonautCallAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (this.account && args.appIndex && args.appArgs.length) {\n\t\t\ttry {\n\t\t\t\tconst params = await this.algodClient.getTransactionParams().do();\n\t\t\t\tconst processedArgs = this.encodeArguments(args.appArgs);\n\t\t\t\tconst closeOutTxn = algosdk.makeApplicationCloseOutTxnFromObject({\n\t\t\t\t\tfrom: this.account.addr,\n\t\t\t\t\tsuggestedParams: params,\n\t\t\t\t\tappIndex: args.appIndex,\n\t\t\t\t\tappArgs: processedArgs,\n\t\t\t\t\taccounts: args.optionalFields?.accounts || undefined,\n\t\t\t\t\tforeignApps: args.optionalFields?.applications || undefined,\n\t\t\t\t\tforeignAssets: args.optionalFields?.assets || undefined\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\ttransaction: closeOutTxn,\n\t\t\t\t\ttransactionSigner: this.account,\n\t\t\t\t\tisLogigSig: false\n\t\t\t\t};\n\t\t\t} catch (e: any) {\n\t\t\t\tthrow new Error(e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('requires app index');\n\t\t}\n\t}\n\n\t/**\n\t * Closes out the user's local state in an application.\n\t * The opposite of {@link optInApp}.\n\t * @param args Object containing `appIndex`, `appArgs`, and `optionalFields` properties\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to atomic transaction\n\t */\n\tasync closeOutApp(args: AlgonautCallAppArguments, callbacks?: AlgonautTxnCallbacks) {\n\t\tif (!this.account) throw new Error('There was no account!');\n\t\tif (!args.appIndex) throw new Error('Must provide appIndex');\n\t\tif (!args.appArgs.length) throw new Error('Must provide at least one appArgs');\n\n\t\tconst { transaction } = await this.atomicCloseOutApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Get an application's escrow account\n\t * @param appId - ID of application\n\t * @returns Escrow account address as string\n\t */\n\tgetAppEscrowAccount(appId: number | bigint): string {\n\n\t\treturn algosdk.getApplicationAddress(appId);\n\n\t}\n\n\n\n\n\t/**\n\t * Get info about an application (globals, locals, creator address, index)\n\t *\n\t * @param appId - ID of application\n\t * @returns Promise resolving to application state\n\t */\n\tasync getAppInfo(appId: number): Promise<AlgonautAppState> {\n\n\t\tconst info = await this.algodClient.getApplicationByID(appId).do();\n\n\t\t// decode state\n\t\tconst state = {\n\t\t\thasState: true,\n\t\t\tglobals: [],\n\t\t\tlocals: [],\n\t\t\tcreatorAddress: info.params.creator,\n\t\t\tindex: appId\n\t\t} as AlgonautAppState;\n\n\t\tif (info.params['global-state']) {\n\t\t\tstate.globals = this.decodeStateArray(info.params['global-state']);\n\t\t}\n\n\t\treturn state;\n\n\t}\n\n\t/**\n\t * Create and deploy a new Smart Contract from TEAL code\n\t *\n\t * @param args AlgonautDeployArguments\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns AlgonautTransactionStatus\n\t */\n\tasync createApp(\n\t\targs: AlgonautDeployArguments,\n\t\tcallbacks?: AlgonautTxnCallbacks\n\t): Promise<AlgonautTransactionStatus> {\n\t\tif (args.optionalFields &&\n\t\t\targs.optionalFields.note &&\n\t\t\targs.optionalFields.note.length > 1023) {\n\t\t\tconsole.warn('drat! your note is too long!');\n\t\t\tthrow new Error('Your note is too long');\n\t\t}\n\t\tif (!this.account) throw new Error('There was no account!');\n\t\ttry {\n\n\t\t\tconst sender = this.account.addr;\n\t\t\tconst onComplete = algosdk.OnApplicationComplete.NoOpOC;\n\t\t\tconst params = await this.algodClient.getTransactionParams().do();\n\n\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (approvalProgram && clearProgram) {\n\n\t\t\t\tconst txn = algosdk.makeApplicationCreateTxn(\n\t\t\t\t\tsender,\n\t\t\t\t\tparams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\t\targs.optionalFields?.note ? new Uint8Array(Buffer.from(args.optionalFields.note, 'utf8')) : undefined\n\t\t\t\t);\n\t\t\t\tconst txId = txn.txID().toString();\n\n\t\t\t\t// Wait for confirmation\n\t\t\t\tconst result = await this.sendTransaction(txn, callbacks);\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\n\t\t\t\tresult.message = 'Created App ID: ' + transactionResponse['application-index'];\n\t\t\t\tresult.createdIndex = transactionResponse['application-index'];\n\t\t\t\tresult.meta = transactionResponse;\n\t\t\t\tresult.txId = txId;\n\t\t\t\treturn result;\n\n\t\t\t} else {\n\t\t\t\tthrow new Error('could not compile teal code');\n\t\t\t}\n\n\t\t} catch (er: any) {\n\t\t\tthrow new Error(er.message);\n\t\t}\n\t}\n\n\t/**\n\t * Create an atomic transaction to deploy a\n\t * new Smart Contract from TEAL code\n\t *\n\t * @param args AlgonautDeployArguments\n\t * @returns AlgonautAtomicTransaction\n\t */\n\tasync atomicCreateApp(args: AlgonautDeployArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {\n\t\t\tthrow new Error('Your NOTE is too long, it must be less thatn 1024 Bytes');\n\t\t} else if (this.account) {\n\t\t\ttry {\n\t\t\t\tconst sender = this.account.addr;\n\t\t\t\tconst onComplete = algosdk.OnApplicationComplete.NoOpOC;\n\t\t\t\tconst params = await this.algodClient.getTransactionParams().do();\n\n\t\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t\t// create unsigned transaction\n\t\t\t\tif (!approvalProgram || !clearProgram) {\n\t\t\t\t\tthrow new Error('Error: you must provide an approval program and a clear state program.');\n\t\t\t\t}\n\n\t\t\t\tconst applicationCreateTransaction = algosdk.makeApplicationCreateTxn(\n\t\t\t\t\tsender,\n\t\t\t\t\tparams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\t\targs.optionalFields?.note ? new Uint8Array(Buffer.from(args.optionalFields.note, 'utf8')) : undefined\n\t\t\t\t);\n\n\t\t\t\treturn {\n\t\t\t\t\ttransaction: applicationCreateTransaction,\n\t\t\t\t\ttransactionSigner: this.account,\n\t\t\t\t\tisLogigSig: false\n\t\t\t\t};\n\n\t\t\t} catch (er: any) {\n\t\t\t\tthrow new Error('There was an error creating the transaction');\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Algonaut.js has no account loaded!');\n\t\t}\n\t}\n\n\n\t/**\n\t * deploys a contract from an lsig account\n\t * keep in mind that the local and global byte and int values have caps,\n\t * 16 for local and 32 for global and that the cost of deploying the\n\t * app goes up based on how many of these slots you want to allocate\n\t *\n\t * @param args AlgonautLsigDeployArguments\n\t * @returns\n\t */\n\tasync deployTealWithLSig(\n\t\targs: AlgonautLsigDeployArguments\n\t): Promise<AlgonautTransactionStatus> {\n\t\tif (args.noteText && args.noteText.length > 511) {\n\t\t\tthrow new Error('Your note is too long');\n\t\t}\n\n\t\tif (!this.account) throw new Error('there was no account');\n\n\t\tlet encodedArgs = [] as Uint8Array[];\n\t\tif (args.appArgs && args.appArgs.length) {\n\t\t\tencodedArgs = this.encodeArguments(args.appArgs);\n\t\t}\n\n\t\tconst sender = args.lsig.address();\n\t\tconst onComplete = algosdk.OnApplicationComplete.NoOpOC;\n\t\tconst params = await this.algodClient.getTransactionParams().do();\n\n\t\tlet approvalProgram = new Uint8Array();\n\t\tlet clearProgram = new Uint8Array();\n\n\t\ttry {\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (approvalProgram && clearProgram) {\n\t\t\t\tconst txn = algosdk.makeApplicationCreateTxn(\n\t\t\t\t\tsender,\n\t\t\t\t\tparams,\n\t\t\t\t\tonComplete,\n\t\t\t\t\tapprovalProgram,\n\t\t\t\t\tclearProgram,\n\t\t\t\t\targs.schema.localInts,\n\t\t\t\t\targs.schema.localBytes,\n\t\t\t\t\targs.schema.globalInts,\n\t\t\t\t\targs.schema.globalBytes,\n\t\t\t\t\tencodedArgs,\n\t\t\t\t\targs.optionalFields?.accounts || undefined\n\t\t\t\t);\n\n\t\t\t\tconst txId = txn.txID().toString();\n\t\t\t\tconst signedTxn = algosdk.signLogicSigTransactionObject(txn, args.lsig);\n\n\t\t\t\tawait this.algodClient.sendRawTransaction(signedTxn.blob).do();\n\t\t\t\tconst txStatus = await this.waitForConfirmation(txId);\n\n\t\t\t\t// TBD check txStatus\n\n\t\t\t\t// display results\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(txId)\n\t\t\t\t\t.do();\n\t\t\t\tconst appId = transactionResponse['application-index'];\n\n\t\t\t\treturn {\n\t\t\t\t\tstatus: 'success',\n\t\t\t\t\tmessage: 'created new app with id: ' + appId,\n\t\t\t\t\ttxId\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthrow new Error('Error compiling programs.');\n\t\t\t}\n\t\t} catch (er: any) {\n\t\t\tconsole.error('Error deploying contract:');\n\t\t\tthrow new Error(er);\n\t\t}\n\t}\n\n\t/**\n\t * Updates an application with `algosdk.makeApplicationUpdateTxn`\n\t * @param args AlgonautUpdateAppArguments\n\t * @returns atomic transaction that updates the app\n\t */\n\tasync atomicUpdateApp(args: AlgonautUpdateAppArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (!this.account) throw new Error('Algonaut.js has no account loaded!');\n\t\tif (args.optionalFields && args.optionalFields.note && args.optionalFields.note.length > 1023) {\n\t\t\tthrow new Error('Your NOTE is too long, it must be less thatn 1024 Bytes');\n\t\t}\n\n\t\ttry {\n\t\t\tconst sender = this.account.addr;\n\t\t\tconst onComplete = algosdk.OnApplicationComplete.NoOpOC;\n\t\t\tconst params = await this.algodClient.getTransactionParams().do();\n\n\t\t\tlet approvalProgram = new Uint8Array();\n\t\t\tlet clearProgram = new Uint8Array();\n\n\t\t\tapprovalProgram = await this.compileProgram(args.tealApprovalCode);\n\t\t\tclearProgram = await this.compileProgram(args.tealClearCode);\n\n\t\t\t// create unsigned transaction\n\t\t\tif (!approvalProgram || !clearProgram) {\n\t\t\t\tthrow new Error('Error: you must provide an approval program and a clear state program.');\n\t\t\t}\n\n\t\t\tconst applicationCreateTransaction = algosdk.makeApplicationUpdateTxn(\n\t\t\t\tsender,\n\t\t\t\tparams,\n\t\t\t\targs.appIndex,\n\t\t\t\tapprovalProgram,\n\t\t\t\tclearProgram,\n\t\t\t\tthis.encodeArguments(args.appArgs),\n\t\t\t\targs.optionalFields?.accounts ? args.optionalFields.accounts : undefined,\n\t\t\t\targs.optionalFields?.applications ? args.optionalFields.applications : undefined,\n\t\t\t\targs.optionalFields?.assets ? args.optionalFields.assets : undefined,\n\t\t\t\targs.optionalFields?.note ? new Uint8Array(Buffer.from(args.optionalFields.note, 'utf8')) : undefined\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\ttransaction: applicationCreateTransaction,\n\t\t\t\ttransactionSigner: this.account,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\n\t\t} catch (er: any) {\n\t\t\tthrow new Error('There was an error creating the transaction');\n\t\t}\n\t}\n\n\t/**\n\t * Sends an update app transaction\n\t * @param args AlgonautUpdateAppArguments\n\t * @param callbacks optional callbacks: `onSign`, `onSend`, `onConfirm`\n\t * @returns transaction status\n\t */\n\tasync updateApp(args: AlgonautUpdateAppArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tconst { transaction } = await this.atomicUpdateApp(args);\n\t\treturn await this.sendTransaction(transaction, callbacks);\n\t}\n\n\t/**\n\t * Compiles TEAL source via [algodClient.compile](https://py-algorand-sdk.readthedocs.io/en/latest/algosdk/v2client/algod.html#algosdk.v2client.algod.AlgodClient.compile)\n\t * @param programSource source to compile\n\t * @returns Promise resolving to Buffer of compiled bytes\n\t */\n\tasync compileProgram(programSource: string): Promise<Uint8Array> {\n\t\tconst encoder = new TextEncoder();\n\t\tconst programBytes = encoder.encode(programSource);\n\t\tconst compileResponse = await this.algodClient.compile(programBytes).do();\n\t\tconst compiledBytes = new Uint8Array(\n\t\t\tBuffer.from(compileResponse.result, 'base64')\n\t\t);\n\t\treturn compiledBytes;\n\t}\n\n\tasync atomicPayment(args: AlgonautPaymentArguments): Promise<AlgonautAtomicTransaction> {\n\n\t\tif (this.account) {\n\t\t\tconst encodedNote = args.note ? new Uint8Array(Buffer.from(args.note, 'utf8')) : new Uint8Array();\n\n\t\t\tconst transaction =\n\t\t\t\talgosdk.makePaymentTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: this.account.addr,\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tnote: encodedNote,\n\t\t\t\t\tsuggestedParams: await this.algodClient.getTransactionParams().do()\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\ttransactionSigner: this.account,\n\t\t\t\tisLogigSig: false\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no account!');\n\t\t}\n\t}\n\n\t/**\n\t * Sends ALGO from own account to `args.to`\n\t *\n\t * @param args `AlgonautPaymentArgs` object containing `to`, `amount`, and optional `note`\n\t * @param callbacks optional AlgonautTxnCallbacks\n\t * @returns Promise resolving to transaction status\n\t */\n\tasync sendAlgo(args: AlgonautPaymentArguments, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tif (!this.account) throw new Error('there was no account!');\n\t\tconst { transaction } = await this.atomicPayment(args);\n\t\treturn await this.sendTransaction(transaction);\n\t}\n\n\t/**\n\t * Fetch full account info for an account\n\t * @param address the accress to read info for\n\t * @returns Promise of type AccountInfo\n\t */\n\tasync getAccountInfo(address: string): Promise<any> {\n\t\t//console.log//('checking algo balance');\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\treturn accountInfo;\n\t}\n\n\n\t/**\n\t * Checks Algo balance of account\n\t * @param address - Wallet of balance to check\n\t * @returns Promise resolving to Algo balance\n\t */\n\tasync getAlgoBalance(address: string): Promise<any> {\n\t\t//console.log('checking algo balance');\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\treturn accountInfo.amount;\n\t}\n\n\t/**\n\t * Checks token balance of account\n\t * @param address - Wallet of balance to check\n\t * @param assetIndex - the ASA index\n\t * @returns Promise resolving to token balance\n\t */\n\tasync getTokenBalance(address: string, assetIndex: number): Promise<number> {\n\t\tconst accountInfo = await this.algodClient.accountInformation(address).do();\n\t\t//console.log(accountInfo);\n\n\t\tlet stkBalance = 0;\n\t\t//console.log(accountInfo.assets);\n\t\taccountInfo.assets.forEach((asset: any) => {\n\t\t\tif (asset['asset-id'] == assetIndex) {\n\t\t\t\tstkBalance = asset.amount;\n\t\t\t}\n\t\t});\n\n\t\treturn stkBalance;\n\t}\n\n\t/**\n\t * Checks if account has at least one token (before playback)\n\t * Keeping this here in case this is a faster/less expensive operation than checking actual balance\n\t * @param address - Address to check\n\t * @param assetIndex - the index of the ASA\n\t */\n\tasync accountHasTokens(address: string, assetIndex: number): Promise<any> {\n\t\treturn 'this is not done yet';\n\t}\n\n\t/**\n\t * Gets global state for an application.\n\t * @param applicationIndex - the applications index\n\t * @returns {object} object representing global state\n\t */\n\tasync getAppGlobalState(applicationIndex: number): Promise<any> {\n\t\tconst info = await this.getAppInfo(applicationIndex);\n\t\tif (info.hasState) {\n\t\t\treturn this.stateArrayToObject(info.globals);\n\t\t} else {\n\t\t\treturn {} as any;\n\t\t}\n\t}\n\n\n\n\t/**\n\t *\n\t * @param applicationIndex the applications index\n\t */\n\tasync getAppLocalState(applicationIndex: number): Promise<AlgonautAppState> {\n\n\t\tif (this.account) {\n\t\t\tconst state = {\n\t\t\t\thasState: false,\n\t\t\t\tglobals: [],\n\t\t\t\tlocals: [],\n\t\t\t\tcreatorAddress: '',\n\t\t\t\tindex: applicationIndex\n\t\t\t} as AlgonautAppState;\n\n\t\t\t// read state\n\n\t\t\t// can we detect addresses values and auto-convert them?\n\t\t\t// maybe a 32-byte field gets an address field added?\n\n\t\t\tconst accountInfoResponse = await this.algodClient\n\t\t\t\t.accountInformation(this.account?.addr)\n\t\t\t\t.do();\n\n\t\t\t//console.log(accountInfoResponse);\n\n\t\t\tfor (let i = 0; i < accountInfoResponse['apps-local-state'].length; i++) {\n\t\t\t\tif (accountInfoResponse['apps-local-state'][i].id == applicationIndex) {\n\t\t\t\t\t//console.log('Found Application');\n\n\t\t\t\t\tstate.hasState = true;\n\n\t\t\t\t\tfor (let n = 0; n < accountInfoResponse['apps-local-state'][i]['key-value'].length; n++) {\n\n\t\t\t\t\t\tconst stateItem = accountInfoResponse['apps-local-state'][i]['key-value'][n];\n\t\t\t\t\t\tconst key = Buffer.from(stateItem.key, 'base64').toString();\n\t\t\t\t\t\tconst type = stateItem.value.type;\n\t\t\t\t\t\tlet value = undefined as undefined | string | number;\n\t\t\t\t\t\tlet valueAsAddr = '';\n\n\t\t\t\t\t\tif (type == 1) {\n\t\t\t\t\t\t\tvalue = Buffer.from(stateItem.value.bytes, 'base64').toString();\n\t\t\t\t\t\t\tvalueAsAddr = algosdk.encodeAddress(Buffer.from(stateItem.value.bytes, 'base64'));\n\n\t\t\t\t\t\t} else if (stateItem.value.type == 2) {\n\t\t\t\t\t\t\tvalue = stateItem.value.uint;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.locals.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tvalue: value || '',\n\t\t\t\t\t\t\taddress: valueAsAddr\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn state;\n\t\t} else {\n\t\t\tthrow new Error('there is no account');\n\t\t}\n\t}\n\n\tasync atomicAssetTransferWithLSig(args: AlgonautLsigSendAssetArguments): Promise<AlgonautAtomicTransaction> {\n\n\t\tif (args.lsig) {\n\t\t\tconst transaction =\n\t\t\t\talgosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tassetIndex: args.assetIndex,\n\t\t\t\t\tsuggestedParams: await this.algodClient.getTransactionParams().do()\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\ttransactionSigner: args.lsig,\n\t\t\t\tisLogigSig: true\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no logic sig object!');\n\t\t}\n\t}\n\n\tasync atomicPaymentWithLSig(args: AlgonautLsigPaymentArguments): Promise<AlgonautAtomicTransaction> {\n\t\tif (args.lsig) {\n\n\t\t\tconst transaction =\n\t\t\t\talgosdk.makePaymentTxnWithSuggestedParamsFromObject({\n\t\t\t\t\tfrom: args.lsig.address(),\n\t\t\t\t\tto: args.to,\n\t\t\t\t\tamount: args.amount,\n\t\t\t\t\tsuggestedParams: await this.algodClient.getTransactionParams().do()\n\t\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttransaction: transaction,\n\t\t\t\ttransactionSigner: args.lsig,\n\t\t\t\tisLogigSig: true\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new Error('there is no account!');\n\t\t}\n\t}\n\n\t/**\n\t * Sends a transaction or multiple through the correct channels, depending on signing mode.\n\t * If no signing mode is set, we assume local signing.\n\t * @param txnOrTxns Either an array of atomic transactions or a single transaction to sign\n\t * @param callbacks Optional object with callbacks - `onSign`, `onSend`, and `onConfirm`\n\t * @returns Promise resolving to AlgonautTransactionStatus\n\t */\n\tasync sendTransaction(txnOrTxns: AlgonautAtomicTransaction[] | algosdk.Transaction | AlgonautAtomicTransaction, callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\t\tif (!this.account) throw new Error('There is no account');\n\t\tif (this.config && this.config.SIGNING_MODE && this.config.SIGNING_MODE === 'walletconnect') {\n\t\t\t// walletconnect must be sent as atomic transactions\n\t\t\tif (Array.isArray(txnOrTxns)) {\n\t\t\t\treturn await this.sendWalletConnectTxns(txnOrTxns, callbacks);\n\t\t\t} else {\n\t\t\t\tif ((txnOrTxns as any).transaction) {\n\t\t\t\t\t// we were sent an AlgonautAtomicTransaction\n\t\t\t\t\treturn await this.sendWalletConnectTxns([(txnOrTxns as AlgonautAtomicTransaction)], callbacks);\n\t\t\t\t} else {\n\t\t\t\t\t// we were sent an algosdk.Transaction\n\t\t\t\t\treturn await this.sendWalletConnectTxns([{\n\t\t\t\t\t\ttransaction: txnOrTxns as algosdk.Transaction,\n\t\t\t\t\t\ttransactionSigner: this.account,\n\t\t\t\t\t\tisLogigSig: false\n\t\t\t\t\t}], callbacks);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// assume local signing\n\t\t\tif (Array.isArray(txnOrTxns)) {\n\t\t\t\treturn await this.sendAtomicTransaction(txnOrTxns, callbacks);\n\t\t\t} else {\n\t\t\t\tlet txn: algosdk.Transaction;\n\t\t\t\tif (txnOrTxns && (txnOrTxns as any).transaction) {\n\t\t\t\t\t// sent an atomic Transaction\n\t\t\t\t\ttxn = (txnOrTxns as AlgonautAtomicTransaction).transaction;\n\t\t\t\t} else {\n\t\t\t\t\t// assume a transaction\n\t\t\t\t\ttxn = txnOrTxns as algosdk.Transaction;\n\t\t\t\t}\n\n\t\t\t\tif (!this.account || !this.account.sk) throw new Error('');\n\t\t\t\tconst signedTxn = (txn as algosdk.Transaction).signTxn(this.account.sk);\n\t\t\t\tif (callbacks?.onSign) callbacks.onSign(signedTxn);\n\n\t\t\t\tconst tx = await this.algodClient.sendRawTransaction(signedTxn).do();\n\t\t\t\tif (callbacks?.onSend) callbacks.onSend(signedTxn);\n\n\t\t\t\tconst txId = tx.txId || tx.id || tx.txId().toString();\n\t\t\t\tconsole.log('Transaction ID: ' + txId);\n\n\t\t\t\tconst txStatus = await this.waitForConfirmation(txId);\n\t\t\t\tif (callbacks?.onConfirm) callbacks.onConfirm(signedTxn);\n\n\t\t\t\treturn txStatus;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * run atomic takes an array of transactions to run in order, each\n\t * of the atomic transaction methods needs to return an object containing\n\t * the transaction and the signed transaction\n\t * \t[ atomicSendASA(),\n\t\t\tatomicSendAlgo(),\n\t\t\tatomicCallApp()]\n\t * @param transactions a Uint8Array of ALREADY SIGNED transactions\n\t */\n\tasync sendAtomicTransaction(transactions: AlgonautAtomicTransaction[], callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\n\t\ttry {\n\n\t\t\tconst txns = [] as algosdk.Transaction[];\n\t\t\tconst signed = [] as Uint8Array[];\n\t\t\ttransactions.forEach((txn: AlgonautAtomicTransaction) => {\n\t\t\t\ttxns.push(txn.transaction);\n\t\t\t});\n\n\t\t\t// this is critical, if the group doesn't have an id\n\t\t\t// the transactions are processed as one-offs!\n\t\t\tconst txnGroup = algosdk.assignGroupID(txns);\n\n\t\t\t// sign all transactions in the group:\n\t\t\ttransactions.forEach((txn: AlgonautAtomicTransaction, i) => {\n\t\t\t\tlet signedTx: {\n\t\t\t\t\ttxID: string;\n\t\t\t\t\tblob: Uint8Array;\n\t\t\t\t};\n\t\t\t\tif (txn.isLogigSig) {\n\t\t\t\t\tsignedTx = algosdk.signLogicSigTransaction(txnGroup[i], txn.transactionSigner as algosdk.LogicSigAccount);\n\t\t\t\t} else {\n\t\t\t\t\tsignedTx = algosdk.signTransaction(txnGroup[i], (txn.transactionSigner as algosdk.Account).sk);\n\t\t\t\t}\n\t\t\t\tsigned.push(signedTx.blob);\n\t\t\t});\n\n\t\t\tif (callbacks?.onSign) callbacks.onSign(signed);\n\n\t\t\tconst tx = await this.algodClient.sendRawTransaction(signed).do();\n\n\t\t\tif (callbacks?.onSend) callbacks.onSend(tx);\n\t\t\t//console.log('Transaction : ' + tx.txId);\n\n\t\t\t// Wait for transaction to be confirmed\n\t\t\tconst txStatus = await this.waitForConfirmation(tx.txId);\n\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t.pendingTransactionInformation(tx.txId)\n\t\t\t\t.do();\n\t\t\ttxStatus.meta = transactionResponse;\n\n\t\t\tif (callbacks?.onConfirm) callbacks.onConfirm(txStatus);\n\n\t\t\treturn txStatus;\n\t\t} catch (e: any) {\n\t\t\tconsole.error('Error sending atomic transaction:');\n\t\t\tthrow new Error(e);\n\t\t}\n\n\t}\n\n\t/**\n\t * Sends one or multiple transactions via WalletConnect, prompting the user to approve transaction on their phone.\n\t *\n\t * @remarks\n\t * Returns the results of `algodClient.pendingTransactionInformation` in `AlgonautTransactionStatus.meta`.\n\t * This is used to get the `application-index` from a `atomicDeployFromTeal` function, among other things.\n\t *\n\t * @param walletTxns Array of transactions to send\n\t * @param callbacks Transaction callbacks `{ onSign, onSend, onConfirm }`\n\t * @returns Promise resolving to transaction status\n\t */\n\tasync sendWalletConnectTxns(walletTxns: AlgonautAtomicTransaction[], callbacks?: AlgonautTxnCallbacks): Promise<AlgonautTransactionStatus> {\n\n\t\tif (this.walletConnect.connected) {\n\t\t\tlet txns = walletTxns.map(txn => txn.transaction);\n\n\t\t\t// this is critical, if the group doesn't have an id\n\t\t\t// the transactions are processed as one-offs\n\t\t\tif (walletTxns.length > 1) {\n\t\t\t\t//console.log('assigning group ID to transactions...');\n\t\t\t\ttxns = algosdk.assignGroupID(txns);\n\t\t\t}\n\n\t\t\t// encode txns\n\t\t\tconst txnsToSign = txns.map(txn => {\n\t\t\t\tconst encodedTxn = Buffer.from(algosdk.encodeUnsignedTransaction(txn)).toString('base64');\n\n\t\t\t\treturn {\n\t\t\t\t\ttxn: encodedTxn,\n\t\t\t\t\tmessage: 'txn description',\n\t\t\t\t\t// Note: if the transaction does not need to be signed (because it's part of an atomic group\n\t\t\t\t\t// that will be signed by another party), specify an empty singers array like so:\n\t\t\t\t\t// signers: [],\n\t\t\t\t};\n\t\t\t});\n\n\n\t\t\tconst requestParams = [txnsToSign];\n\t\t\tconst request = formatJsonRpcRequest('algo_signTxn', requestParams);\n\n\t\t\t// this will fail if they cancel... we think\n\t\t\tlet result: any;\n\t\t\ttry {\n\t\t\t\tresult = await this.walletConnect.connector?.sendCustomRequest(request);\n\t\t\t} catch (er) {\n\t\t\t\tthrow new Error('You canceled the transaction');\n\t\t\t}\n\n\t\t\tconst signedPartialTxns = result.map((r: any, i: number) => {\n\t\t\t\t// run whatever error checks here\n\t\t\t\tif (r == null) {\n\t\t\t\t\tthrow new Error(`Transaction at index ${i}: was not signed when it should have been`);\n\t\t\t\t}\n\t\t\t\tconst rawSignedTxn = Buffer.from(r, 'base64');\n\t\t\t\treturn new Uint8Array(rawSignedTxn);\n\t\t\t});\n\n\t\t\t//console.log('signed partial txns are');\n\t\t\t//console.log(signedPartialTxns);\n\t\t\tif (callbacks?.onSign) callbacks.onSign(signedPartialTxns);\n\n\t\t\tif (signedPartialTxns) {\n\t\t\t\tlet tx: any;\n\t\t\t\ttry {\n\t\t\t\t\ttx = await this.algodClient.sendRawTransaction(signedPartialTxns).do();\n\t\t\t\t} catch (er: any) {\n\t\t\t\t\ttx = er;\n\t\t\t\t\tconsole.error('Error sending raw transaction');\n\t\t\t\t\tthrow new Error(er);\n\t\t\t\t}\n\n\t\t\t\t//console.log('Transaction : ' + tx.txId);\n\t\t\t\tif (callbacks?.onSend) callbacks.onSend(tx);\n\n\t\t\t\t// Wait for transaction to be confirmed\n\t\t\t\tconst txStatus = await this.waitForConfirmation(tx.txId);\n\t\t\t\tconst transactionResponse = await this.algodClient\n\t\t\t\t\t.pendingTransactionInformation(tx.txId)\n\t\t\t\t\t.do();\n\t\t\t\ttxStatus.meta = transactionResponse;\n\t\t\t\tif (callbacks?.onConfirm) callbacks.onConfirm(txStatus);\n\t\t\t\treturn txStatus;\n\t\t\t} else {\n\t\t\t\tthrow new Error('there were no signed transactions returned');\n\t\t\t}\n\n\t\t} else {\n\t\t\tthrow new Error('There is no wallet connect session');\n\t\t}\n\t}\n\n\t/**\n\t * Interally used to determine how to sign transactions on more generic functions (e.g. {@link deployFromTeal})\n\t * @returns true if we are signing transactions with WalletConnect, false otherwise\n\t */\n\tusingWalletConnect(): boolean {\n\t\tif (this.config &&\n\t\t\tthis.config.SIGNING_MODE &&\n\t\t\tthis.config.SIGNING_MODE === 'walletconnect') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Prepare one or more transactions for wallet connect signature\n\t *\n\t * @param transactions one or more atomic transaction objects\n\t * @returns an array of Transactions\n\t */\n\tasync createWalletConnectTransactions(transactions: AlgonautAtomicTransaction[]): Promise<algosdk.Transaction[]> {\n\n\n\t\t//console.log('start wc transaction builder');\n\t\tconst txns = [] as algosdk.Transaction[];\n\t\ttransactions.forEach((txn: AlgonautAtomicTransaction) => {\n\t\t\ttxns.push(txn.transaction);\n\t\t});\n\n\t\t//console.log('done', txns);\n\n\t\treturn txns;\n\n\t}\n\n\n\t/**********************************************/\n\t/***** Below are the Algo Signer APIs *********/\n\t/**********************************************/\n\n\t/**\n\t * Sends a transaction via AlgoSigner.\n\t * @param params Transaction parameters to send\n\t * @returns Promise resolving to confirmed transaction or error\n\t */\n\tasync sendTxWithAlgoSigner(params: {\n\t\tassetIndex?: string;\n\t\tfrom: string;\n\t\tto: string;\n\t\tamount: number;\n\t\tnote?: string;\n\t\ttype: string;\n\t\tLEDGER: 'TestNet' | 'MainNet'\n\t}): Promise<any> {\n\t\ttry {\n\t\t\t// connect to algo signer extension\n\t\t\tawait this.connectToAlgoSigner();\n\n\t\t\t// fetch current parameters from the al(l knowing)god\n\t\t\tconst txParams = await window.AlgoSigner.algod({\n\t\t\t\tledger: params.LEDGER,\n\t\t\t\tpath: '/v2/transactions/params'\n\t\t\t});\n\n\t\t\t// sign the transaction\n\t\t\tconst signedTx = await window.AlgoSigner.sign({\n\t\t\t\tassetIndex: params.assetIndex || null,\n\t\t\t\tfrom: params.from,\n\t\t\t\tto: params.to,\n\t\t\t\tamount: +params.amount,\n\t\t\t\tnote: params.note || '',\n\t\t\t\ttype: params.type,\n\t\t\t\tfee: txParams['min-fee'],\n\t\t\t\tfirstRound: txParams['last-round'],\n\t\t\t\tlastRound: txParams['last-round'] + 1000,\n\t\t\t\tgenesisID: txParams['genesis-id'],\n\t\t\t\tgenesisHash: txParams['genesis-hash'],\n\t\t\t\tflatFee: true\n\t\t\t});\n\n\t\t\t// give us the signed transaction\n\t\t\tconst tx = window.AlgoSigner.send({\n\t\t\t\tledger: params.LEDGER,\n\t\t\t\ttx: signedTx.blob\n\t\t\t});\n\n\t\t\t// wait for confirmation, return result\n\t\t\treturn this.waitForAlgoSignerConfirmation(tx);\n\t\t} catch (error) {\n\t\t\tconsole.log(error);\n\t\t\tthrow new Error('Error sending transaction: ' + JSON.stringify(error));\n\t\t}\n\t}\n\n\t/**\n\t * Waits for confirmation of a transaction\n\t * @param tx Transaction to monitor\n\t * @returns Promise resolving to error or confirmed transaction\n\t */\n\tasync waitForAlgoSignerConfirmation(tx: any): Promise<any> {\n\t\tconsole.log(`Transaction ${tx.txId} waiting for confirmation...`);\n\t\tlet status = await window.AlgoSigner.algod({\n\t\t\tledger: 'TestNet',\n\t\t\tpath: '/v2/transactions/pending/' + tx.txId\n\t\t});\n\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tif (status['confirmed-round'] !== null && status['confirmed-round'] > 0) {\n\t\t\t\t//Got the completed Transaction\n\t\t\t\tconsole.log(\n\t\t\t\t\t`Transaction confirmed in round ${status['confirmed-round']}.`\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = await window.AlgoSigner.algod({\n\t\t\t\tledger: 'TestNet',\n\t\t\t\tpath: '/v2/transactions/pending/' + tx.txId\n\t\t\t});\n\t\t}\n\n\t\treturn tx;\n\t}\n\n\n\n\n\t/*\n\t* Wallet Connect API Stuff\n\t*/\n\n\n\tasync disconnectAlgoWallet() {\n\t\tif (this.walletConnect.connected) {\n\t\t\tthis.walletConnect.connector?.killSession();\n\t\t}\n\t}\n\n\t/**\n\t * Connects to algo wallet via WalletConnect, calling {@link subscribeToEvents}.\n\t * Implementation borrowed from [Algorand Docs](https://developer.algorand.org/docs/get-details/walletconnect/)\n\t *\n\t * @remarks\n\t *\n\t * There are three listeners you can use, defined by {@link WalletConnectListener}:\n\t *  - `onConnect(payload: IInternalEvent)` (`payload.params[0]` contains an array of account addresses)\n\t *  - `onDisconnect()`\n\t *  - `onSessionUpdate(accounts: string[])`\n\t *\n\t * @example\n\t * Usage:\n\t *\n\t * ```ts\n\t * await algonaut.connectAlgoWallet({\n\t *   onConnect: (payload) => console.log('Accounts: ' + payload.params[0]),\n\t *   onDisconnect: () => console.log('Do something on disconnect'),\n\t *   onSessionUpdate: (accounts) => console.log('Accounts: ' + accounts)\n\t * })\n\t * ```\n\t *\n\t * We can use the `onConnect` listener to store an address in application state, for example,\n\t * which allows us to conditionally display components depending on authentication status.\n\t *\n\t * @param clientListener object of listener functions (see {@link WalletConnectListener})\n\t */\n\tasync connectAlgoWallet(clientListener?: WalletConnectListener): Promise<void> {\n\t\t// console.log('connectAlgoWallet');\n\n\t\tif (isNode()) {\n\t\t\tconsole.warn('NOTE: this lib isnt made for using wallet connect in node yet...');\n\t\t\treturn;\n\t\t}\n\n\t\t// 4067ab2454244fb39835bfeafc285c8d\n\t\tif (!clientListener) clientListener = undefined;\n\n\t\tconst bridge = 'https://bridge.walletconnect.org';\n\n\t\tconst wcConnector = new WalletConnect({\n\t\t\tbridge,\n\t\t\tqrcodeModal: QRCodeModal\n\t\t});\n\t\tthis.walletConnect.connector = wcConnector;\n\n\t\t// console.log('connector created');\n\t\t// console.log(this.walletConnect.connector);\n\n\t\t//console.log('trying to create session');\n\n\t\t// Check if connection is already established\n\t\tif (!this.walletConnect.connector.connected) {\n\t\t\t// create new session\n\t\t\tthis.walletConnect.connector.createSession();\n\t\t\t// console.log('session created');\n\n\t\t\t// keeps some background tasks running while navigating to Pera Wallet to approve wc session link handshake\n\t\t\tthis.startReqAF();\n\t\t}\n\n\t\tthis.subscribeToEvents(clientListener);\n\t}\n\n\t/**\n\t * Sets up listeners for WalletConnect events\n\t * @param clientListener optional object of listener functions, to be used in an application\n\t */\n\tsubscribeToEvents(clientListener?: WalletConnectListener): void {\n\t\tif (!this.walletConnect.connector) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.walletConnect.connector.on('session_update', async (error: any, payload: any) => {\n\t\t\t// console.log('connector.on(\"session_update\")');\n\t\t\tif (error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tconst { accounts } = payload.params[0];\n\t\t\tif (clientListener) clientListener.onSessionUpdate(payload);\n\t\t\tthis.onSessionUpdate(accounts);\n\t\t});\n\n\t\tthis.walletConnect.connector.on('connect', (error: any, payload: any) => {\n\t\t\t// console.log('connector.on(\"connect\")');\n\t\t\tif (error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tif (clientListener) clientListener.onConnect(payload);\n\t\t\tthis.onConnect(payload);\n\t\t});\n\n\t\tthis.walletConnect.connector.on('disconnect', (error: any, payload: any) => {\n\t\t\t// console.log('connector.on(\"disconnect\")');\n\t\t\tif (error) {\n\t\t\t\tconsole.log(payload);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tif (clientListener) clientListener.onDisconnect(payload);\n\t\t\tthis.onDisconnect();\n\t\t});\n\n\t\tif (this.walletConnect.connector.connected) {\n\t\t\tconst { accounts } = this.walletConnect.connector;\n\t\t\tconst address = accounts[0];\n\n\t\t\tthis.walletConnect.connected = true;\n\t\t\tthis.walletConnect.accounts = accounts;\n\t\t\tthis.walletConnect.address = address;\n\t\t\tthis.onSessionUpdate(accounts);\n\t\t}\n\t}\n\n\t/**\n\t * Kills WalletConnect session and calls {@link resetApp}\n\t */\n\tasync killSession() {\n\t\tif (this.walletConnect.connector) {\n\t\t\tthis.walletConnect.connector.killSession();\n\t\t}\n\t\tthis.resetApp();\n\t}\n\n\t// this should get a ChainType\n\tasync chainUpdate(newChain: any) {\n\t\tthis.walletConnect.chain = newChain;\n\t}\n\n\n\tasync resetApp() {\n\t\tconsole.log('reset app called');\n\t\tconsole.log('TBD!');\n\t}\n\n\tstartReqAF() {\n\t\t// console.log('startReqAF');\n\t\t// keeps some background tasks running while navigating to Pera Wallet to approve wc session link handshake\n\n\t\t// TODO helpful for desktop debugging but redo isMobile check\n\t\tif (isBrowser()) {\n\t\t\t// if (isBrowser() && isMobile()) {\n\t\t\t// reqaf fix\n\t\t\tconst keepAlive = () => {\n\t\t\t\t// console.log('keepAlive');\n\t\t\t\twcReqAF = requestAnimationFrame(keepAlive);\n\t\t\t}\n\t\t\trequestAnimationFrame(keepAlive);\n\t\t\twcReqAF = 1;\n\n\t\t\t// audio fix\n\t\t\twcS = new Audio();\n\t\t\twcS.src = wcAud.href;\n\t\t\twcS.autoplay = true;\n\t\t\twcS.play();\n\t\t\t// console.log('wcS', wcS);\n\t\t}\n\t}\n\n\tstopReqAF() {\n\t\t// console.log('stopReqAF', wcReqAF);\n\t\t// CANCEL wcReqAF to free up CPU\n\t\tif (wcReqAF) {\n\t\t\tcancelAnimationFrame(wcReqAF);\n\t\t\twcReqAF = 0; // reset\n\n\t\t\t// TODO make audio end gracefully + upon return to dapp\n\t\t\t// audio fix\n\t\t\twcS.pause();\n\t\t} else {\n\t\t\tconsole.log('no wcReqAF to cancel'); // is this the browser?\n\t\t}\n\t}\n\n\t/**\n\t * Function called upon connection to WalletConnect. Sets account in AlgonautJS via {@link setWalletConnectAccount}.\n\t * @param payload Event payload, containing an array of account addresses\n\t */\n\tasync onConnect(payload: IInternalEvent) {\n\t\t// console.log('onConnect');\n\n\t\tconst { accounts } = payload.params[0];\n\t\tconst address = accounts[0];\n\n\t\tthis.setWalletConnectAccount(address);\n\n\t\tthis.walletConnect.connected = true;\n\t\tthis.walletConnect.accounts = accounts;\n\t\tthis.walletConnect.address = address;\n\n\t\t// CANCEL wcReqAF to free up CPU\n\t\tthis.stopReqAF(); // if ticking...\n\t}\n\n\t/**\n\t * Called upon disconnection from WalletConnect.\n\t */\n\tonDisconnect() {\n\t\t// console.log('onDisconnect');\n\t\tthis.walletConnect.connected = false;\n\t\tthis.walletConnect.accounts = [];\n\t\tthis.walletConnect.address = '';\n\t\tthis.account = undefined;\n\n\t\t// CANCEL wcReqAF to free up CPU\n\t\tthis.stopReqAF(); // if ticking...\n\t}\n\n\t/**\n\t * Called when WalletConnect session updates\n\t * @param accounts Array of account address strings\n\t */\n\tasync onSessionUpdate(accounts: string[]) {\n\t\t// console.log('onSessionUpdate');\n\t\tthis.walletConnect.address = accounts[0];\n\t\tthis.walletConnect.accounts = accounts;\n\t\tthis.setWalletConnectAccount(accounts[0]);\n\t}\n\n\t/**\n\t * Helper function to turn `globals` and `locals` array into more useful objects\n\t *\n\t * @param stateArray State array returned from functions like {@link getAppInfo}\n\t * @returns A more useful object: `{ array[0].key: array[0].value, array[1].key: array[1].value, ... }`\n\t */\n\tstateArrayToObject(stateArray: object[]): any {\n\t\tconst stateObj = {} as any;\n\t\tstateArray.forEach((value: any) => {\n\t\t\tif (value.key) stateObj[value.key] = value.value || null;\n\t\t});\n\t\treturn stateObj;\n\t}\n\n\tfromBase64(encoded: string) {\n\t\treturn Buffer.from(encoded, 'base64').toString();\n\t}\n\n\tvalueAsAddr(encoded: string) {\n\t\treturn algosdk.encodeAddress(Buffer.from(encoded, 'base64'));\n\t}\n\n\tdecodeStateArray(stateArray: { key: string, value: { bytes: string, type: number, uint: number } }[]) {\n\t\tconst result: any[] = [];\n\n\t\tfor (let n = 0;\n\t\t\tn < stateArray.length;\n\t\t\tn++) {\n\n\t\t\tconst stateItem = stateArray[n];\n\n\t\t\tconst key = this.fromBase64(stateItem.key);\n\t\t\tconst type = stateItem.value.type;\n\t\t\tlet value = undefined as undefined | string | number;\n\t\t\tlet valueAsAddr = '';\n\n\t\t\tif (type == 1) {\n\t\t\t\tvalue = this.fromBase64(stateItem.value.bytes);\n\t\t\t\tvalueAsAddr = this.valueAsAddr(stateItem.value.bytes);\n\n\t\t\t} else if (stateItem.value.type == 2) {\n\t\t\t\tvalue = stateItem.value.uint;\n\t\t\t}\n\n\t\t\tresult.push({\n\t\t\t\tkey: key,\n\t\t\t\tvalue: value || '',\n\t\t\t\taddress: valueAsAddr\n\t\t\t});\n\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/* BELOW HERE ARE ALL THE ALGO SIGNER APIS IF WE GO THAT ROUTE */\n\n\t/**\n\t * Function to determine if the AlgoSigner extension is installed.\n\t * @returns true if `window.AlgoSigner` is defined\n\t */\n\tisAlgoSignerInstalled(): boolean {\n\t\treturn typeof window.AlgoSigner !== 'undefined';\n\t}\n\n\t/**\n\t * Connects to AlgoSigner extension\n\t */\n\tasync connectToAlgoSigner(): Promise<any> {\n\t\treturn await window.AlgoSigner.connect();\n\t}\n\n\t/**\n\t * Async function that returns list of accounts in the wallet.\n\t * @param ledger must be 'TestNet' or 'MainNet'.\n\t * @returns Array of Objects with address fields: [{ address: <String> }, ...]\n\t */\n\tasync getAccounts(ledger: string): Promise<any> {\n\t\tawait this.connectToAlgoSigner();\n\t\tconst accounts = await window.AlgoSigner.accounts({ ledger });\n\t\treturn accounts;\n\t}\n\n\n}\n\n\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAuB;AACvB,qBAAoB;AA4BpB,uBAA0B;AAE1B,iDAAwB;AACxB,mBAAqC;AACrC,oBAMO;AAQP,oBAAwB;AA/CxB;AA0CA,IAAI,UAAU;AAGd,IAAI;AAGJ;AACA,MAAM,QAAQ,IAAI,IAAI,uBAAuB,YAAY,GAAG;AAkD5D,MAAO,SAAuB;AAAA,EAG7B;AAAA,EACA,gBAAgB;AAAA,EAChB,UAAU;AAAA,EACV,UAAU;AAAA,EACV,OAAO;AAAA,EACP,WAAW;AAAA,EACX,SAAS;AAAA,EACT,MAAM;AAAA,EACN,YAAY;AAAA,EACZ,gBAAgB;AAAA,IACf,WAAW;AAAA,IACX,WAAW;AAAA,IACX,UAAU,CAAC;AAAA,IACX,SAAS;AAAA,IACT,QAAQ,CAAC;AAAA,IACT,OAAO;AAAA,EACR;AAAA,EAqBA,YAAY,QAAwB;AAEnC,SAAK,SAAS;AACd,SAAK,cAAc,IAAI,uBAAQ,QAAQ,OAAO,WAAW,OAAO,aAAa,OAAO,IAAI;AACxF,QAAI,OAAO,cAAc;AACxB,WAAK,gBAAgB,IAAI,uBAAQ,QAAQ,OAAO,WAAW,OAAO,cAAc,OAAO,IAAI;AAAA,IAC5F,OAAO;AACN,cAAQ,KAAK,8DAA8D;AAAA,IAC5E;AAEA,SAAK,MAAM;AAAA,EAEZ;AAAA,EAKA,YAAsC;AACrC,QAAI,KAAK;AAAQ,aAAO,KAAK;AAC7B,WAAO;AAAA,EACR;AAAA,QAMM,cAA4B;AACjC,UAAM,SAAS,MAAM,KAAK,YAAY,OAAO,EAAE,GAAG;AAClD,YAAQ,IAAI,+BAA+B,MAAM;AACjD,WAAO;AAAA,EACR;AAAA,EAMA,WAAW,SAAgC;AAC1C,SAAK,UAAU;AACf,SAAK,UAAU,QAAQ;AACvB,QAAI,KAAK;AAAQ,WAAK,OAAO,eAAe;AAC5C,SAAK,WAAW,uBAAQ,oBAAoB,QAAQ,EAAE;AAAA,EACvD;AAAA,EAMA,wBAAwB,SAAiB;AACxC,SAAK,UAAU;AAAA,MACd,MAAM;AAAA,MACN,IAAI,IAAI,WAAW,CAAC,CAAC;AAAA,IACtB;AACA,QAAI,KAAK;AAAQ,WAAK,OAAO,eAAe;AAAA,EAC7C;AAAA,EAMA,eAA+B;AAC9B,SAAK,UAAU,uBAAQ,gBAAgB;AAEvC,QAAI,KAAK,SAAS;AACjB,WAAK,UAAU,KAAK,QAAQ;AAC5B,WAAK,WAAW,uBAAQ,oBAAoB,KAAK,QAAQ,EAAE;AAC3D,aAAO;AAAA,QACN,SAAS,KAAK,QAAQ;AAAA,QACtB,UAAU,KAAK,YAAY;AAAA,MAC5B;AAAA,IACD,OAAO;AACN,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC1E;AAAA,EAED;AAAA,EAOA,eAAe,UAA6C;AAC3D,QAAI;AACH,WAAK,UAAU,uBAAQ,oBAAoB,QAAQ;AACnD,UAAI,uBAAQ,eAAe,KAAK,SAAS,IAAI,GAAG;AAC/C,eAAO,KAAK,WAAW;AAAA,MACxB;AACA,UAAI,KAAK;AAAQ,aAAK,OAAO,eAAe;AAAA,IAC7C,SAAS,OAAP;AAED,cAAQ,IAAI,KAAK;AACjB,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR;AAAA,QAQM,oBAAoB,MAAc,YAAqB,MAAM,OAA2C;AAC7G,QAAI,YAAa,OAAM,KAAK,YAAY,OAAO,EAAE,GAAG,GAAG;AACvD,UAAM,QAAQ,YAAa,cAAa,aAAa;AAErD,UAAM,cAAc;AAAA,MACnB,QAAQ;AAAA,MACR,SAAS;AAAA,IACV;AAEA,WAAO,YAAY,OAAO;AACzB,UAAI,cAAc;AAClB,UAAI;AACH,sBAAc,MAAM,KAAK,YACvB,8BAA8B,IAAI,EAClC,GAAG;AACL,YAAI,KAAK;AACR,kBAAQ,IAAI,0BAA0B;AAAA,QACvC;AAAA,MACD,SAAS,IAAP;AACD,gBAAQ,MAAM,GAAG,UAAU,IAAI;AAAA,MAChC;AAEA,UACC,YAAY,uBAAuB,QACnC,YAAY,qBAAqB,GAChC;AAED,gBAAQ,IACP,oCAAoC,YAAY,kBACjD;AAEA,oBAAY,OAAO;AACnB,oBAAY,SAAS;AACrB,oBAAY,UAAU,oCAAoC,YAAY;AAEtE;AAAA,MACD;AAEA;AAAA,IACD;AAEA,WAAO;AAAA,EAER;AAAA,EAQA,iBAAiB,qBAAsD;AACtE,UAAM,UAAU,IAAI,WACnB,qBAAO,KAAK,qBAAqB,QAAQ,CAC1C;AAEA,WAAO,IAAI,uBAAQ,gBAAgB,OAAO;AAAA,EAC3C;AAAA,QAEM,iBAAiB,YAAwD;AAE9E,QAAI,KAAK,WAAW,YAAY;AAE/B,YAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAChE,YAAM,mBAAmB,uBAAQ,kDAAkD;AAAA,QAClF,MAAM,KAAK,QAAQ;AAAA,QACnB,IAAI,KAAK,QAAQ;AAAA,QACjB,iBAAiB;AAAA,QACjB;AAAA,QACA,QAAQ;AAAA,MACT,CAAC;AAED,aAAO;AAAA,QACN,aAAa;AAAA,QACb,mBAAmB,KAAK;AAAA,QACxB,YAAY;AAAA,MACb;AAAA,IAED,OAAO;AACN,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACxC;AAAA,EAED;AAAA,QAQM,WAAW,YAAoB,WAAsE;AAC1G,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,uBAAuB;AAC1D,UAAM,EAAE,gBAAgB,MAAM,KAAK,iBAAiB,UAAU;AAC9D,WAAO,MAAM,KAAK,gBAAgB,aAAa,SAAS;AAAA,EACzD;AAAA,QA+BM,iBAAiB,MAA8D;AACpF,QAAI,aAAa;AAEjB,UAAM,cAAc,MAAM,KAAK,eAAe,KAAK,OAAO;AAC1D,gBAAY,OAAO,QAAQ,CAAC,UAAe;AAC1C,UAAI,MAAM,eAAe,KAAK,SAAS;AACtC,qBAAa;AAAA,MACd;AAAA,IAED,CAAC;AAED,WAAO;AAAA,EACR;AAAA,EASA,gBAAgB,MAA2B;AAC1C,UAAM,cAAc,CAAC;AAGrB,SAAK,QAAQ,CAAC,QAAa;AAC1B,UAAI,OAAO,OAAO,UAAU;AAC3B,oBAAY,KAAK,uBAAQ,aAAa,GAAG,CAAC;AAAA,MAC3C,WAAW,OAAO,OAAO,UAAU;AAClC,oBAAY,KAAK,uBAAQ,aAAa,GAAG,CAAC;AAAA,MAC3C,WAAW,OAAO,OAAO,UAAU;AAClC,oBAAY,KAAK,IAAI,WAAW,qBAAO,KAAK,GAAG,CAAC,CAAC;AAAA,MAClD;AAAA,IACD,CAAC;AAED,WAAO;AAAA,EACR;AAAA,QAOM,kBAAkB,MAAwE;AAC/F,QAAI,CAAC,KAAK,WAAW;AACpB,WAAK,YAAY;AAAA,IAClB;AAEA,QAAI,CAAC,KAAK;AAAe,WAAK,gBAAgB;AAC9C,QAAI,CAAC,KAAK;AAAU,WAAK,WAAW;AAEpC,UAAM,kBAAkB,KAAK,UAAU;AAEvC,QAAI,kBAAkB,KAAK;AAC1B,cAAQ,MAAM,mBAAmB,eAAe;AAChD,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACrD;AAEA,UAAM,MAAM,IAAI,YAAY;AAE5B,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,sBAAsB;AAMzD,UAAM,OAAO,IAAI,OAAO,KAAK,SAAS;AACtC,UAAM,OAAO,KAAK,QAAQ;AAC1B,UAAM,gBAAgB,KAAK;AAC3B,UAAM,UAAU,KAAK,QAAQ;AAC7B,UAAM,UAAU,KAAK,QAAQ;AAC7B,UAAM,SAAS,KAAK,QAAQ;AAC5B,UAAM,WAAW,KAAK,QAAQ;AAE9B,UAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAGhE,UAAM,MAAM,uBAAQ,sCACnB,MACA,MACA,eACA,KAAK,UACL,KAAK,eACL,SACA,SACA,QACA,UACA,KAAK,QACL,KAAK,WACL,KAAK,UACL,KAAK,mBACL,MACD;AAEA,WAAO;AAAA,MACN,aAAa;AAAA,MACb,mBAAmB,KAAK;AAAA,MACxB,YAAY;AAAA,IACb;AAAA,EACD;AAAA,QASM,YACL,MACA,WACqC;AACrC,UAAM,YAAY,MAAM,KAAK,kBAAkB,IAAI;AACnD,UAAM,MAAM,UAAU;AAEtB,QAAI;AACH,YAAM,UAAU;AAChB,YAAM,WAAW,MAAM,KAAK,gBAAgB,KAAK,SAAS;AAE1D,YAAM,MAAM,MAAM,KAAK,YACrB,8BAA8B,IAAI,KAAK,EAAE,SAAS,CAAC,EACnD,GAAG;AACL,eAAS,eAAe,IAAI;AAE5B,aAAO;AAAA,IAER,SAAS,IAAP;AACD,cAAQ,IAAI,mBAAmB;AAC/B,cAAQ,IAAI,EAAE;AACd,YAAM,IAAI,MAAM,EAAS;AAAA,IAC1B;AAAA,EACD;AAAA,QAEM,kBAAkB,SAAqD;AAC5E,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,uBAAuB;AAE1D,UAAM,MAAM,IAAI,YAAY;AAE5B,UAAM,cAAc,uBAAQ,uCAC3B,KAAK,QAAQ,MACb,IAAI,OAAO,MAAM,GACjB,SACA,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG,CAClD;AAEA,WAAO;AAAA,MACN;AAAA,MACA,mBAAmB,KAAK;AAAA,MACxB,YAAY;AAAA,IACb;AAAA,EACD;AAAA,QAQM,YAAY,SAAiB,WAAsE;AACxG,UAAM,EAAE,gBAAgB,MAAM,KAAK,kBAAkB,OAAO;AAC5D,WAAO,MAAM,KAAK,gBAAgB,aAAa,SAAS;AAAA,EACzD;AAAA,QAWM,gBAAgB,MAAsE;AAE3F,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,sBAAsB;AAEzD,UAAM,cACL,uBAAQ,kDAAkD;AAAA,MACzD,MAAM,KAAK,QAAQ;AAAA,MACnB,IAAI,KAAK;AAAA,MACT,QAAQ,KAAK;AAAA,MACb,YAAY,KAAK;AAAA,MACjB,iBAAiB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAAA,IACnE,CAAC;AAEF,WAAO;AAAA,MACN;AAAA,MACA,mBAAmB,KAAK;AAAA,MACxB,YAAY;AAAA,IACb;AAAA,EACD;AAAA,QAYM,UAAU,MAAkC,WAAsE;AACvH,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,uBAAuB;AAC1D,UAAM,EAAE,gBAAgB,MAAM,KAAK,gBAAgB,IAAI;AACvD,WAAO,MAAM,KAAK,gBAAgB,aAAa,SAAS;AAAA,EACzD;AAAA,QAOM,aAAa,YAAkC;AACpD,UAAM,OAAO,MAAM,KAAK,YAAY,aAAa,UAAU,EAAE,GAAG;AAChE,WAAO;AAAA,EACR;AAAA,QAOM,eAAe,MAAoE;AACxF,QAAI,KAAK,WAAW,KAAK,UAAU;AAElC,YAAM,SAAS,KAAK,QAAQ;AAC5B,YAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAChE,YAAM,mBAAmB,uBAAQ,kCAAkC;AAAA,QAClE,MAAM;AAAA,QACN,UAAU,KAAK;AAAA,QACf,iBAAiB;AAAA,QACjB,SAAS,KAAK,UAAU,KAAK,gBAAgB,KAAK,OAAO,IAAI;AAAA,QAC7D,UAAU,KAAK,gBAAgB,WAAW,KAAK,gBAAgB,WAAW;AAAA,QAC1E,aAAa,KAAK,gBAAgB,eAAe,KAAK,gBAAgB,eAAe;AAAA,QACrF,eAAe,KAAK,gBAAgB,SAAS,KAAK,gBAAgB,SAAS;AAAA,MAC5E,CAAC;AAED,aAAO;AAAA,QACN,aAAa;AAAA,QACb,mBAAmB,KAAK;AAAA,QACxB,YAAY;AAAA,MACb;AAAA,IAED,OAAO;AACN,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACpD;AAAA,EAED;AAAA,QAQM,SAAS,MAAgC,WAAsE;AACpH,QAAI,KAAK,WAAW,KAAK,UAAU;AAClC,YAAM,EAAE,gBAAgB,MAAM,KAAK,eAAe,IAAI;AAEtD,aAAO,MAAM,KAAK,gBAAgB,aAAa,SAAS;AAAA,IACzD,OAAO;AACN,UAAI,CAAC,KAAK;AAAS,cAAM,IAAI,MAAM,iBAAiB;AACpD,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACxC;AAAA,EACD;AAAA,QAOM,wBAAwB,UAAsD;AAEnF,QAAI,KAAK,WAAW,UAAU;AAC7B,UAAI;AACH,cAAM,SAAS,KAAK,QAAQ;AAC5B,cAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAIhE,cAAM,MAAM,uBAAQ,yBAAyB,QAAQ,QAAQ,QAAQ;AAErE,eAAO;AAAA,UACN,aAAa;AAAA,UACb,mBAAmB,KAAK;AAAA,UACxB,YAAY;AAAA,QACb;AAAA,MAED,SAAS,GAAP;AACD,cAAM,IAAI,MAAM,CAAC;AAAA,MAClB;AAAA,IACD,OAAO;AACN,YAAM,IAAI,MAAM,mBAAmB;AAAA,IACpC;AAAA,EACD;AAAA,QAQM,kBAAkB,UAAkB,WAAsE;AAC/G,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,sBAAsB;AAEzD,QAAI;AACH,YAAM,EAAE,gBAAgB,MAAM,KAAK,wBAAwB,QAAQ;AACnE,YAAM,OAAO,YAAY,KAAK,EAAE,SAAS;AAEzC,YAAM,SAAS,MAAM,KAAK,gBAAgB,aAAa,SAAS;AAGhE,YAAM,sBAAsB,MAAM,KAAK,YACrC,8BAA8B,IAAI,EAClC,GAAG;AACL,YAAM,QAAQ,oBAAoB,OAAO,OAAO;AAChD,cAAQ,IAAI,oBAAoB,KAAK;AAErC,aAAO;AAAA,QACN,QAAQ;AAAA,QACR,SAAS,uBAAuB;AAAA,QAChC;AAAA,MACD;AAAA,IAED,SAAS,GAAP;AACD,cAAQ,IAAI,CAAC;AACb,YAAM,IAAI,MAAM,EAAE,UAAU,IAAI;AAAA,IACjC;AAAA,EACD;AAAA,QAEM,cAAc,MAAoE;AAEvF,QAAI,KAAK,WAAW,KAAK,YAAY,KAAK,QAAQ,QAAQ;AAEzD,YAAM,gBAAgB,KAAK,gBAAgB,KAAK,OAAO;AACvD,YAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAChE,YAAM,qBAAqB,uBAAQ,iCAAiC;AAAA,QACnE,MAAM,KAAK,QAAQ;AAAA,QACnB,iBAAiB;AAAA,QACjB,UAAU,KAAK;AAAA,QACf,SAAS;AAAA,QACT,UAAU,KAAK,gBAAgB,YAAY;AAAA,QAC3C,aAAa,KAAK,gBAAgB,gBAAgB;AAAA,QAClD,eAAe,KAAK,gBAAgB,UAAU;AAAA,MAC/C,CAAC;AAED,aAAO;AAAA,QACN,aAAa;AAAA,QACb,mBAAmB,KAAK;AAAA,QACxB,YAAY;AAAA,MACb;AAAA,IAED,OAAO;AACN,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACxC;AAAA,EACD;AAAA,QAOM,QAAQ,MAAgC,WAAsE;AACnH,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,uBAAuB;AAC1D,QAAI,CAAC,KAAK;AAAU,YAAM,IAAI,MAAM,uBAAuB;AAC3D,QAAI,CAAC,KAAK,QAAQ;AAAQ,YAAM,IAAI,MAAM,mCAAmC;AAE7E,UAAM,EAAE,gBAAgB,MAAM,KAAK,cAAc,IAAI;AACrD,WAAO,MAAM,KAAK,gBAAgB,aAAa,SAAS;AAAA,EACzD;AAAA,QAEM,sBAAsB,MAAwE;AAEnG,QAAI,KAAK,WAAW,KAAK,YAAY,KAAK,QAAQ,QAAQ;AACzD,YAAM,gBAAgB,KAAK,gBAAgB,KAAK,OAAO;AACvD,YAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAChE,YAAM,qBAAqB,uBAAQ,iCAAiC;AAAA,QACnE,MAAM,KAAK,KAAK,QAAQ;AAAA,QACxB,iBAAiB;AAAA,QACjB,UAAU,KAAK;AAAA,QACf,SAAS;AAAA,QACT,UAAU,KAAK,gBAAgB,YAAY;AAAA,QAC3C,aAAa,KAAK,gBAAgB,gBAAgB;AAAA,QAClD,eAAe,KAAK,gBAAgB,UAAU;AAAA,MAC/C,CAAC;AAED,aAAO;AAAA,QACN,aAAa;AAAA,QACb,mBAAmB,KAAK;AAAA,QACxB,YAAY;AAAA,MACb;AAAA,IAED,OAAO;AACN,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACxC;AAAA,EACD;AAAA,QAQM,kBAAkB,MAAoE;AAC3F,QAAI,KAAK,WAAW,KAAK,YAAY,KAAK,QAAQ,QAAQ;AACzD,UAAI;AACH,cAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAChE,cAAM,gBAAgB,KAAK,gBAAgB,KAAK,OAAO;AACvD,cAAM,cAAc,uBAAQ,qCAAqC;AAAA,UAChE,MAAM,KAAK,QAAQ;AAAA,UACnB,iBAAiB;AAAA,UACjB,UAAU,KAAK;AAAA,UACf,SAAS;AAAA,UACT,UAAU,KAAK,gBAAgB,YAAY;AAAA,UAC3C,aAAa,KAAK,gBAAgB,gBAAgB;AAAA,UAClD,eAAe,KAAK,gBAAgB,UAAU;AAAA,QAC/C,CAAC;AAED,eAAO;AAAA,UACN,aAAa;AAAA,UACb,mBAAmB,KAAK;AAAA,UACxB,YAAY;AAAA,QACb;AAAA,MACD,SAAS,GAAP;AACD,cAAM,IAAI,MAAM,CAAC;AAAA,MAClB;AAAA,IACD,OAAO;AACN,YAAM,IAAI,MAAM,oBAAoB;AAAA,IACrC;AAAA,EACD;AAAA,QASM,YAAY,MAAgC,WAAkC;AACnF,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,uBAAuB;AAC1D,QAAI,CAAC,KAAK;AAAU,YAAM,IAAI,MAAM,uBAAuB;AAC3D,QAAI,CAAC,KAAK,QAAQ;AAAQ,YAAM,IAAI,MAAM,mCAAmC;AAE7E,UAAM,EAAE,gBAAgB,MAAM,KAAK,kBAAkB,IAAI;AACzD,WAAO,MAAM,KAAK,gBAAgB,aAAa,SAAS;AAAA,EACzD;AAAA,EAOA,oBAAoB,OAAgC;AAEnD,WAAO,uBAAQ,sBAAsB,KAAK;AAAA,EAE3C;AAAA,QAWM,WAAW,OAA0C;AAE1D,UAAM,OAAO,MAAM,KAAK,YAAY,mBAAmB,KAAK,EAAE,GAAG;AAGjE,UAAM,QAAQ;AAAA,MACb,UAAU;AAAA,MACV,SAAS,CAAC;AAAA,MACV,QAAQ,CAAC;AAAA,MACT,gBAAgB,KAAK,OAAO;AAAA,MAC5B,OAAO;AAAA,IACR;AAEA,QAAI,KAAK,OAAO,iBAAiB;AAChC,YAAM,UAAU,KAAK,iBAAiB,KAAK,OAAO,eAAe;AAAA,IAClE;AAEA,WAAO;AAAA,EAER;AAAA,QASM,UACL,MACA,WACqC;AACrC,QAAI,KAAK,kBACR,KAAK,eAAe,QACpB,KAAK,eAAe,KAAK,SAAS,MAAM;AACxC,cAAQ,KAAK,8BAA8B;AAC3C,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACxC;AACA,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,uBAAuB;AAC1D,QAAI;AAEH,YAAM,SAAS,KAAK,QAAQ;AAC5B,YAAM,aAAa,uBAAQ,sBAAsB;AACjD,YAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAEhE,UAAI,kBAAkB,IAAI,WAAW;AACrC,UAAI,eAAe,IAAI,WAAW;AAElC,wBAAkB,MAAM,KAAK,eAAe,KAAK,gBAAgB;AACjE,qBAAe,MAAM,KAAK,eAAe,KAAK,aAAa;AAG3D,UAAI,mBAAmB,cAAc;AAEpC,cAAM,MAAM,uBAAQ,yBACnB,QACA,QACA,YACA,iBACA,cACA,KAAK,OAAO,WACZ,KAAK,OAAO,YACZ,KAAK,OAAO,YACZ,KAAK,OAAO,aACZ,KAAK,gBAAgB,KAAK,OAAO,GACjC,KAAK,gBAAgB,WAAW,KAAK,eAAe,WAAW,QAC/D,KAAK,gBAAgB,eAAe,KAAK,eAAe,eAAe,QACvE,KAAK,gBAAgB,SAAS,KAAK,eAAe,SAAS,QAC3D,KAAK,gBAAgB,OAAO,IAAI,WAAW,qBAAO,KAAK,KAAK,eAAe,MAAM,MAAM,CAAC,IAAI,MAC7F;AACA,cAAM,OAAO,IAAI,KAAK,EAAE,SAAS;AAGjC,cAAM,SAAS,MAAM,KAAK,gBAAgB,KAAK,SAAS;AACxD,cAAM,sBAAsB,MAAM,KAAK,YACrC,8BAA8B,IAAI,EAClC,GAAG;AAEL,eAAO,UAAU,qBAAqB,oBAAoB;AAC1D,eAAO,eAAe,oBAAoB;AAC1C,eAAO,OAAO;AACd,eAAO,OAAO;AACd,eAAO;AAAA,MAER,OAAO;AACN,cAAM,IAAI,MAAM,6BAA6B;AAAA,MAC9C;AAAA,IAED,SAAS,IAAP;AACD,YAAM,IAAI,MAAM,GAAG,OAAO;AAAA,IAC3B;AAAA,EACD;AAAA,QASM,gBAAgB,MAAmE;AACxF,QAAI,KAAK,kBAAkB,KAAK,eAAe,QAAQ,KAAK,eAAe,KAAK,SAAS,MAAM;AAC9F,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC1E,WAAW,KAAK,SAAS;AACxB,UAAI;AACH,cAAM,SAAS,KAAK,QAAQ;AAC5B,cAAM,aAAa,uBAAQ,sBAAsB;AACjD,cAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAEhE,YAAI,kBAAkB,IAAI,WAAW;AACrC,YAAI,eAAe,IAAI,WAAW;AAElC,0BAAkB,MAAM,KAAK,eAAe,KAAK,gBAAgB;AACjE,uBAAe,MAAM,KAAK,eAAe,KAAK,aAAa;AAG3D,YAAI,CAAC,mBAAmB,CAAC,cAAc;AACtC,gBAAM,IAAI,MAAM,wEAAwE;AAAA,QACzF;AAEA,cAAM,+BAA+B,uBAAQ,yBAC5C,QACA,QACA,YACA,iBACA,cACA,KAAK,OAAO,WACZ,KAAK,OAAO,YACZ,KAAK,OAAO,YACZ,KAAK,OAAO,aACZ,KAAK,gBAAgB,KAAK,OAAO,GACjC,KAAK,gBAAgB,WAAW,KAAK,eAAe,WAAW,QAC/D,KAAK,gBAAgB,eAAe,KAAK,eAAe,eAAe,QACvE,KAAK,gBAAgB,SAAS,KAAK,eAAe,SAAS,QAC3D,KAAK,gBAAgB,OAAO,IAAI,WAAW,qBAAO,KAAK,KAAK,eAAe,MAAM,MAAM,CAAC,IAAI,MAC7F;AAEA,eAAO;AAAA,UACN,aAAa;AAAA,UACb,mBAAmB,KAAK;AAAA,UACxB,YAAY;AAAA,QACb;AAAA,MAED,SAAS,IAAP;AACD,cAAM,IAAI,MAAM,6CAA6C;AAAA,MAC9D;AAAA,IACD,OAAO;AACN,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACrD;AAAA,EACD;AAAA,QAYM,mBACL,MACqC;AACrC,QAAI,KAAK,YAAY,KAAK,SAAS,SAAS,KAAK;AAChD,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACxC;AAEA,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,sBAAsB;AAEzD,QAAI,cAAc,CAAC;AACnB,QAAI,KAAK,WAAW,KAAK,QAAQ,QAAQ;AACxC,oBAAc,KAAK,gBAAgB,KAAK,OAAO;AAAA,IAChD;AAEA,UAAM,SAAS,KAAK,KAAK,QAAQ;AACjC,UAAM,aAAa,uBAAQ,sBAAsB;AACjD,UAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAEhE,QAAI,kBAAkB,IAAI,WAAW;AACrC,QAAI,eAAe,IAAI,WAAW;AAElC,QAAI;AACH,wBAAkB,MAAM,KAAK,eAAe,KAAK,gBAAgB;AACjE,qBAAe,MAAM,KAAK,eAAe,KAAK,aAAa;AAG3D,UAAI,mBAAmB,cAAc;AACpC,cAAM,MAAM,uBAAQ,yBACnB,QACA,QACA,YACA,iBACA,cACA,KAAK,OAAO,WACZ,KAAK,OAAO,YACZ,KAAK,OAAO,YACZ,KAAK,OAAO,aACZ,aACA,KAAK,gBAAgB,YAAY,MAClC;AAEA,cAAM,OAAO,IAAI,KAAK,EAAE,SAAS;AACjC,cAAM,YAAY,uBAAQ,8BAA8B,KAAK,KAAK,IAAI;AAEtE,cAAM,KAAK,YAAY,mBAAmB,UAAU,IAAI,EAAE,GAAG;AAC7D,cAAM,WAAW,MAAM,KAAK,oBAAoB,IAAI;AAKpD,cAAM,sBAAsB,MAAM,KAAK,YACrC,8BAA8B,IAAI,EAClC,GAAG;AACL,cAAM,QAAQ,oBAAoB;AAElC,eAAO;AAAA,UACN,QAAQ;AAAA,UACR,SAAS,8BAA8B;AAAA,UACvC;AAAA,QACD;AAAA,MACD,OAAO;AACN,cAAM,IAAI,MAAM,2BAA2B;AAAA,MAC5C;AAAA,IACD,SAAS,IAAP;AACD,cAAQ,MAAM,2BAA2B;AACzC,YAAM,IAAI,MAAM,EAAE;AAAA,IACnB;AAAA,EACD;AAAA,QAOM,gBAAgB,MAAsE;AAC3F,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,oCAAoC;AACvE,QAAI,KAAK,kBAAkB,KAAK,eAAe,QAAQ,KAAK,eAAe,KAAK,SAAS,MAAM;AAC9F,YAAM,IAAI,MAAM,yDAAyD;AAAA,IAC1E;AAEA,QAAI;AACH,YAAM,SAAS,KAAK,QAAQ;AAC5B,YAAM,aAAa,uBAAQ,sBAAsB;AACjD,YAAM,SAAS,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAEhE,UAAI,kBAAkB,IAAI,WAAW;AACrC,UAAI,eAAe,IAAI,WAAW;AAElC,wBAAkB,MAAM,KAAK,eAAe,KAAK,gBAAgB;AACjE,qBAAe,MAAM,KAAK,eAAe,KAAK,aAAa;AAG3D,UAAI,CAAC,mBAAmB,CAAC,cAAc;AACtC,cAAM,IAAI,MAAM,wEAAwE;AAAA,MACzF;AAEA,YAAM,+BAA+B,uBAAQ,yBAC5C,QACA,QACA,KAAK,UACL,iBACA,cACA,KAAK,gBAAgB,KAAK,OAAO,GACjC,KAAK,gBAAgB,WAAW,KAAK,eAAe,WAAW,QAC/D,KAAK,gBAAgB,eAAe,KAAK,eAAe,eAAe,QACvE,KAAK,gBAAgB,SAAS,KAAK,eAAe,SAAS,QAC3D,KAAK,gBAAgB,OAAO,IAAI,WAAW,qBAAO,KAAK,KAAK,eAAe,MAAM,MAAM,CAAC,IAAI,MAC7F;AAEA,aAAO;AAAA,QACN,aAAa;AAAA,QACb,mBAAmB,KAAK;AAAA,QACxB,YAAY;AAAA,MACb;AAAA,IAED,SAAS,IAAP;AACD,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC9D;AAAA,EACD;AAAA,QAQM,UAAU,MAAkC,WAAsE;AACvH,UAAM,EAAE,gBAAgB,MAAM,KAAK,gBAAgB,IAAI;AACvD,WAAO,MAAM,KAAK,gBAAgB,aAAa,SAAS;AAAA,EACzD;AAAA,QAOM,eAAe,eAA4C;AAChE,UAAM,UAAU,IAAI,YAAY;AAChC,UAAM,eAAe,QAAQ,OAAO,aAAa;AACjD,UAAM,kBAAkB,MAAM,KAAK,YAAY,QAAQ,YAAY,EAAE,GAAG;AACxE,UAAM,gBAAgB,IAAI,WACzB,qBAAO,KAAK,gBAAgB,QAAQ,QAAQ,CAC7C;AACA,WAAO;AAAA,EACR;AAAA,QAEM,cAAc,MAAoE;AAEvF,QAAI,KAAK,SAAS;AACjB,YAAM,cAAc,KAAK,OAAO,IAAI,WAAW,qBAAO,KAAK,KAAK,MAAM,MAAM,CAAC,IAAI,IAAI,WAAW;AAEhG,YAAM,cACL,uBAAQ,4CAA4C;AAAA,QACnD,MAAM,KAAK,QAAQ;AAAA,QACnB,IAAI,KAAK;AAAA,QACT,QAAQ,KAAK;AAAA,QACb,MAAM;AAAA,QACN,iBAAiB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAAA,MACnE,CAAC;AAEF,aAAO;AAAA,QACN;AAAA,QACA,mBAAmB,KAAK;AAAA,QACxB,YAAY;AAAA,MACb;AAAA,IACD,OAAO;AACN,YAAM,IAAI,MAAM,sBAAsB;AAAA,IACvC;AAAA,EACD;AAAA,QASM,SAAS,MAAgC,WAAsE;AACpH,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,uBAAuB;AAC1D,UAAM,EAAE,gBAAgB,MAAM,KAAK,cAAc,IAAI;AACrD,WAAO,MAAM,KAAK,gBAAgB,WAAW;AAAA,EAC9C;AAAA,QAOM,eAAe,SAA+B;AAEnD,UAAM,cAAc,MAAM,KAAK,YAAY,mBAAmB,OAAO,EAAE,GAAG;AAC1E,WAAO;AAAA,EACR;AAAA,QAQM,eAAe,SAA+B;AAEnD,UAAM,cAAc,MAAM,KAAK,YAAY,mBAAmB,OAAO,EAAE,GAAG;AAC1E,WAAO,YAAY;AAAA,EACpB;AAAA,QAQM,gBAAgB,SAAiB,YAAqC;AAC3E,UAAM,cAAc,MAAM,KAAK,YAAY,mBAAmB,OAAO,EAAE,GAAG;AAG1E,QAAI,aAAa;AAEjB,gBAAY,OAAO,QAAQ,CAAC,UAAe;AAC1C,UAAI,MAAM,eAAe,YAAY;AACpC,qBAAa,MAAM;AAAA,MACpB;AAAA,IACD,CAAC;AAED,WAAO;AAAA,EACR;AAAA,QAQM,iBAAiB,SAAiB,YAAkC;AACzE,WAAO;AAAA,EACR;AAAA,QAOM,kBAAkB,kBAAwC;AAC/D,UAAM,OAAO,MAAM,KAAK,WAAW,gBAAgB;AACnD,QAAI,KAAK,UAAU;AAClB,aAAO,KAAK,mBAAmB,KAAK,OAAO;AAAA,IAC5C,OAAO;AACN,aAAO,CAAC;AAAA,IACT;AAAA,EACD;AAAA,QAQM,iBAAiB,kBAAqD;AAE3E,QAAI,KAAK,SAAS;AACjB,YAAM,QAAQ;AAAA,QACb,UAAU;AAAA,QACV,SAAS,CAAC;AAAA,QACV,QAAQ,CAAC;AAAA,QACT,gBAAgB;AAAA,QAChB,OAAO;AAAA,MACR;AAOA,YAAM,sBAAsB,MAAM,KAAK,YACrC,mBAAmB,KAAK,SAAS,IAAI,EACrC,GAAG;AAIL,eAAS,IAAI,GAAG,IAAI,oBAAoB,oBAAoB,QAAQ,KAAK;AACxE,YAAI,oBAAoB,oBAAoB,GAAG,MAAM,kBAAkB;AAGtE,gBAAM,WAAW;AAEjB,mBAAS,IAAI,GAAG,IAAI,oBAAoB,oBAAoB,GAAG,aAAa,QAAQ,KAAK;AAExF,kBAAM,YAAY,oBAAoB,oBAAoB,GAAG,aAAa;AAC1E,kBAAM,MAAM,qBAAO,KAAK,UAAU,KAAK,QAAQ,EAAE,SAAS;AAC1D,kBAAM,OAAO,UAAU,MAAM;AAC7B,gBAAI,QAAQ;AACZ,gBAAI,cAAc;AAElB,gBAAI,QAAQ,GAAG;AACd,sBAAQ,qBAAO,KAAK,UAAU,MAAM,OAAO,QAAQ,EAAE,SAAS;AAC9D,4BAAc,uBAAQ,cAAc,qBAAO,KAAK,UAAU,MAAM,OAAO,QAAQ,CAAC;AAAA,YAEjF,WAAW,UAAU,MAAM,QAAQ,GAAG;AACrC,sBAAQ,UAAU,MAAM;AAAA,YACzB;AAEA,kBAAM,OAAO,KAAK;AAAA,cACjB;AAAA,cACA,OAAO,SAAS;AAAA,cAChB,SAAS;AAAA,YACV,CAAC;AAAA,UAEF;AAAA,QACD;AAAA,MACD;AAEA,aAAO;AAAA,IACR,OAAO;AACN,YAAM,IAAI,MAAM,qBAAqB;AAAA,IACtC;AAAA,EACD;AAAA,QAEM,4BAA4B,MAA0E;AAE3G,QAAI,KAAK,MAAM;AACd,YAAM,cACL,uBAAQ,kDAAkD;AAAA,QACzD,MAAM,KAAK,KAAK,QAAQ;AAAA,QACxB,IAAI,KAAK;AAAA,QACT,QAAQ,KAAK;AAAA,QACb,YAAY,KAAK;AAAA,QACjB,iBAAiB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAAA,MACnE,CAAC;AAEF,aAAO;AAAA,QACN;AAAA,QACA,mBAAmB,KAAK;AAAA,QACxB,YAAY;AAAA,MACb;AAAA,IACD,OAAO;AACN,YAAM,IAAI,MAAM,+BAA+B;AAAA,IAChD;AAAA,EACD;AAAA,QAEM,sBAAsB,MAAwE;AACnG,QAAI,KAAK,MAAM;AAEd,YAAM,cACL,uBAAQ,4CAA4C;AAAA,QACnD,MAAM,KAAK,KAAK,QAAQ;AAAA,QACxB,IAAI,KAAK;AAAA,QACT,QAAQ,KAAK;AAAA,QACb,iBAAiB,MAAM,KAAK,YAAY,qBAAqB,EAAE,GAAG;AAAA,MACnE,CAAC;AAEF,aAAO;AAAA,QACN;AAAA,QACA,mBAAmB,KAAK;AAAA,QACxB,YAAY;AAAA,MACb;AAAA,IACD,OAAO;AACN,YAAM,IAAI,MAAM,sBAAsB;AAAA,IACvC;AAAA,EACD;AAAA,QASM,gBAAgB,WAA0F,WAAsE;AACrL,QAAI,CAAC,KAAK;AAAS,YAAM,IAAI,MAAM,qBAAqB;AACxD,QAAI,KAAK,UAAU,KAAK,OAAO,gBAAgB,KAAK,OAAO,iBAAiB,iBAAiB;AAE5F,UAAI,MAAM,QAAQ,SAAS,GAAG;AAC7B,eAAO,MAAM,KAAK,sBAAsB,WAAW,SAAS;AAAA,MAC7D,OAAO;AACN,YAAK,UAAkB,aAAa;AAEnC,iBAAO,MAAM,KAAK,sBAAsB,CAAE,SAAuC,GAAG,SAAS;AAAA,QAC9F,OAAO;AAEN,iBAAO,MAAM,KAAK,sBAAsB,CAAC;AAAA,YACxC,aAAa;AAAA,YACb,mBAAmB,KAAK;AAAA,YACxB,YAAY;AAAA,UACb,CAAC,GAAG,SAAS;AAAA,QACd;AAAA,MACD;AAAA,IACD,OAAO;AAEN,UAAI,MAAM,QAAQ,SAAS,GAAG;AAC7B,eAAO,MAAM,KAAK,sBAAsB,WAAW,SAAS;AAAA,MAC7D,OAAO;AACN,YAAI;AACJ,YAAI,aAAc,UAAkB,aAAa;AAEhD,gBAAO,UAAwC;AAAA,QAChD,OAAO;AAEN,gBAAM;AAAA,QACP;AAEA,YAAI,CAAC,KAAK,WAAW,CAAC,KAAK,QAAQ;AAAI,gBAAM,IAAI,MAAM,EAAE;AACzD,cAAM,YAAa,IAA4B,QAAQ,KAAK,QAAQ,EAAE;AACtE,YAAI,WAAW;AAAQ,oBAAU,OAAO,SAAS;AAEjD,cAAM,KAAK,MAAM,KAAK,YAAY,mBAAmB,SAAS,EAAE,GAAG;AACnE,YAAI,WAAW;AAAQ,oBAAU,OAAO,SAAS;AAEjD,cAAM,OAAO,GAAG,QAAQ,GAAG,MAAM,GAAG,KAAK,EAAE,SAAS;AACpD,gBAAQ,IAAI,qBAAqB,IAAI;AAErC,cAAM,WAAW,MAAM,KAAK,oBAAoB,IAAI;AACpD,YAAI,WAAW;AAAW,oBAAU,UAAU,SAAS;AAEvD,eAAO;AAAA,MACR;AAAA,IACD;AAAA,EACD;AAAA,QAYM,sBAAsB,cAA2C,WAAsE;AAE5I,QAAI;AAEH,YAAM,OAAO,CAAC;AACd,YAAM,SAAS,CAAC;AAChB,mBAAa,QAAQ,CAAC,QAAmC;AACxD,aAAK,KAAK,IAAI,WAAW;AAAA,MAC1B,CAAC;AAID,YAAM,WAAW,uBAAQ,cAAc,IAAI;AAG3C,mBAAa,QAAQ,CAAC,KAAgC,MAAM;AAC3D,YAAI;AAIJ,YAAI,IAAI,YAAY;AACnB,qBAAW,uBAAQ,wBAAwB,SAAS,IAAI,IAAI,iBAA4C;AAAA,QACzG,OAAO;AACN,qBAAW,uBAAQ,gBAAgB,SAAS,IAAK,IAAI,kBAAsC,EAAE;AAAA,QAC9F;AACA,eAAO,KAAK,SAAS,IAAI;AAAA,MAC1B,CAAC;AAED,UAAI,WAAW;AAAQ,kBAAU,OAAO,MAAM;AAE9C,YAAM,KAAK,MAAM,KAAK,YAAY,mBAAmB,MAAM,EAAE,GAAG;AAEhE,UAAI,WAAW;AAAQ,kBAAU,OAAO,EAAE;AAI1C,YAAM,WAAW,MAAM,KAAK,oBAAoB,GAAG,IAAI;AACvD,YAAM,sBAAsB,MAAM,KAAK,YACrC,8BAA8B,GAAG,IAAI,EACrC,GAAG;AACL,eAAS,OAAO;AAEhB,UAAI,WAAW;AAAW,kBAAU,UAAU,QAAQ;AAEtD,aAAO;AAAA,IACR,SAAS,GAAP;AACD,cAAQ,MAAM,mCAAmC;AACjD,YAAM,IAAI,MAAM,CAAC;AAAA,IAClB;AAAA,EAED;AAAA,QAaM,sBAAsB,YAAyC,WAAsE;AAE1I,QAAI,KAAK,cAAc,WAAW;AACjC,UAAI,OAAO,WAAW,IAAI,SAAO,IAAI,WAAW;AAIhD,UAAI,WAAW,SAAS,GAAG;AAE1B,eAAO,uBAAQ,cAAc,IAAI;AAAA,MAClC;AAGA,YAAM,aAAa,KAAK,IAAI,SAAO;AAClC,cAAM,aAAa,qBAAO,KAAK,uBAAQ,0BAA0B,GAAG,CAAC,EAAE,SAAS,QAAQ;AAExF,eAAO;AAAA,UACN,KAAK;AAAA,UACL,SAAS;AAAA,QAIV;AAAA,MACD,CAAC;AAGD,YAAM,gBAAgB,CAAC,UAAU;AACjC,YAAM,UAAU,uCAAqB,gBAAgB,aAAa;AAGlE,UAAI;AACJ,UAAI;AACH,iBAAS,MAAM,KAAK,cAAc,WAAW,kBAAkB,OAAO;AAAA,MACvE,SAAS,IAAP;AACD,cAAM,IAAI,MAAM,8BAA8B;AAAA,MAC/C;AAEA,YAAM,oBAAoB,OAAO,IAAI,CAAC,GAAQ,MAAc;AAE3D,YAAI,KAAK,MAAM;AACd,gBAAM,IAAI,MAAM,wBAAwB,4CAA4C;AAAA,QACrF;AACA,cAAM,eAAe,qBAAO,KAAK,GAAG,QAAQ;AAC5C,eAAO,IAAI,WAAW,YAAY;AAAA,MACnC,CAAC;AAID,UAAI,WAAW;AAAQ,kBAAU,OAAO,iBAAiB;AAEzD,UAAI,mBAAmB;AACtB,YAAI;AACJ,YAAI;AACH,eAAK,MAAM,KAAK,YAAY,mBAAmB,iBAAiB,EAAE,GAAG;AAAA,QACtE,SAAS,IAAP;AACD,eAAK;AACL,kBAAQ,MAAM,+BAA+B;AAC7C,gBAAM,IAAI,MAAM,EAAE;AAAA,QACnB;AAGA,YAAI,WAAW;AAAQ,oBAAU,OAAO,EAAE;AAG1C,cAAM,WAAW,MAAM,KAAK,oBAAoB,GAAG,IAAI;AACvD,cAAM,sBAAsB,MAAM,KAAK,YACrC,8BAA8B,GAAG,IAAI,EACrC,GAAG;AACL,iBAAS,OAAO;AAChB,YAAI,WAAW;AAAW,oBAAU,UAAU,QAAQ;AACtD,eAAO;AAAA,MACR,OAAO;AACN,cAAM,IAAI,MAAM,4CAA4C;AAAA,MAC7D;AAAA,IAED,OAAO;AACN,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACrD;AAAA,EACD;AAAA,EAMA,qBAA8B;AAC7B,QAAI,KAAK,UACR,KAAK,OAAO,gBACZ,KAAK,OAAO,iBAAiB,iBAAiB;AAC9C,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR;AAAA,QAQM,gCAAgC,cAA2E;AAIhH,UAAM,OAAO,CAAC;AACd,iBAAa,QAAQ,CAAC,QAAmC;AACxD,WAAK,KAAK,IAAI,WAAW;AAAA,IAC1B,CAAC;AAID,WAAO;AAAA,EAER;AAAA,QAYM,qBAAqB,QAQV;AAChB,QAAI;AAEH,YAAM,KAAK,oBAAoB;AAG/B,YAAM,WAAW,MAAM,OAAO,WAAW,MAAM;AAAA,QAC9C,QAAQ,OAAO;AAAA,QACf,MAAM;AAAA,MACP,CAAC;AAGD,YAAM,WAAW,MAAM,OAAO,WAAW,KAAK;AAAA,QAC7C,YAAY,OAAO,cAAc;AAAA,QACjC,MAAM,OAAO;AAAA,QACb,IAAI,OAAO;AAAA,QACX,QAAQ,CAAC,OAAO;AAAA,QAChB,MAAM,OAAO,QAAQ;AAAA,QACrB,MAAM,OAAO;AAAA,QACb,KAAK,SAAS;AAAA,QACd,YAAY,SAAS;AAAA,QACrB,WAAW,SAAS,gBAAgB;AAAA,QACpC,WAAW,SAAS;AAAA,QACpB,aAAa,SAAS;AAAA,QACtB,SAAS;AAAA,MACV,CAAC;AAGD,YAAM,KAAK,OAAO,WAAW,KAAK;AAAA,QACjC,QAAQ,OAAO;AAAA,QACf,IAAI,SAAS;AAAA,MACd,CAAC;AAGD,aAAO,KAAK,8BAA8B,EAAE;AAAA,IAC7C,SAAS,OAAP;AACD,cAAQ,IAAI,KAAK;AACjB,YAAM,IAAI,MAAM,gCAAgC,KAAK,UAAU,KAAK,CAAC;AAAA,IACtE;AAAA,EACD;AAAA,QAOM,8BAA8B,IAAuB;AAC1D,YAAQ,IAAI,eAAe,GAAG,kCAAkC;AAChE,QAAI,SAAS,MAAM,OAAO,WAAW,MAAM;AAAA,MAC1C,QAAQ;AAAA,MACR,MAAM,8BAA8B,GAAG;AAAA,IACxC,CAAC;AAGD,WAAO,MAAM;AACZ,UAAI,OAAO,uBAAuB,QAAQ,OAAO,qBAAqB,GAAG;AAExE,gBAAQ,IACP,kCAAkC,OAAO,qBAC1C;AACA;AAAA,MACD;AAEA,eAAS,MAAM,OAAO,WAAW,MAAM;AAAA,QACtC,QAAQ;AAAA,QACR,MAAM,8BAA8B,GAAG;AAAA,MACxC,CAAC;AAAA,IACF;AAEA,WAAO;AAAA,EACR;AAAA,QAUM,uBAAuB;AAC5B,QAAI,KAAK,cAAc,WAAW;AACjC,WAAK,cAAc,WAAW,YAAY;AAAA,IAC3C;AAAA,EACD;AAAA,QA6BM,kBAAkB,gBAAuD;AAG9E,QAAI,0BAAO,GAAG;AACb,cAAQ,KAAK,kEAAkE;AAC/E;AAAA,IACD;AAGA,QAAI,CAAC;AAAgB,uBAAiB;AAEtC,UAAM,SAAS;AAEf,UAAM,cAAc,IAAI,yBAAc;AAAA,MACrC;AAAA,MACA,aAAa;AAAA,IACd,CAAC;AACD,SAAK,cAAc,YAAY;AAQ/B,QAAI,CAAC,KAAK,cAAc,UAAU,WAAW;AAE5C,WAAK,cAAc,UAAU,cAAc;AAI3C,WAAK,WAAW;AAAA,IACjB;AAEA,SAAK,kBAAkB,cAAc;AAAA,EACtC;AAAA,EAMA,kBAAkB,gBAA8C;AAC/D,QAAI,CAAC,KAAK,cAAc,WAAW;AAClC;AAAA,IACD;AAEA,SAAK,cAAc,UAAU,GAAG,kBAAkB,OAAO,OAAY,YAAiB;AAErF,UAAI,OAAO;AACV,cAAM;AAAA,MACP;AAEA,YAAM,EAAE,aAAa,QAAQ,OAAO;AACpC,UAAI;AAAgB,uBAAe,gBAAgB,OAAO;AAC1D,WAAK,gBAAgB,QAAQ;AAAA,IAC9B,CAAC;AAED,SAAK,cAAc,UAAU,GAAG,WAAW,CAAC,OAAY,YAAiB;AAExE,UAAI,OAAO;AACV,cAAM;AAAA,MACP;AACA,UAAI;AAAgB,uBAAe,UAAU,OAAO;AACpD,WAAK,UAAU,OAAO;AAAA,IACvB,CAAC;AAED,SAAK,cAAc,UAAU,GAAG,cAAc,CAAC,OAAY,YAAiB;AAE3E,UAAI,OAAO;AACV,gBAAQ,IAAI,OAAO;AACnB,cAAM;AAAA,MACP;AACA,UAAI;AAAgB,uBAAe,aAAa,OAAO;AACvD,WAAK,aAAa;AAAA,IACnB,CAAC;AAED,QAAI,KAAK,cAAc,UAAU,WAAW;AAC3C,YAAM,EAAE,aAAa,KAAK,cAAc;AACxC,YAAM,UAAU,SAAS;AAEzB,WAAK,cAAc,YAAY;AAC/B,WAAK,cAAc,WAAW;AAC9B,WAAK,cAAc,UAAU;AAC7B,WAAK,gBAAgB,QAAQ;AAAA,IAC9B;AAAA,EACD;AAAA,QAKM,cAAc;AACnB,QAAI,KAAK,cAAc,WAAW;AACjC,WAAK,cAAc,UAAU,YAAY;AAAA,IAC1C;AACA,SAAK,SAAS;AAAA,EACf;AAAA,QAGM,YAAY,UAAe;AAChC,SAAK,cAAc,QAAQ;AAAA,EAC5B;AAAA,QAGM,WAAW;AAChB,YAAQ,IAAI,kBAAkB;AAC9B,YAAQ,IAAI,MAAM;AAAA,EACnB;AAAA,EAEA,aAAa;AAKZ,QAAI,6BAAU,GAAG;AAGhB,YAAM,YAAY,MAAM;AAEvB,kBAAU,sBAAsB,SAAS;AAAA,MAC1C;AACA,4BAAsB,SAAS;AAC/B,gBAAU;AAGV,YAAM,IAAI,MAAM;AAChB,UAAI,MAAM,MAAM;AAChB,UAAI,WAAW;AACf,UAAI,KAAK;AAAA,IAEV;AAAA,EACD;AAAA,EAEA,YAAY;AAGX,QAAI,SAAS;AACZ,2BAAqB,OAAO;AAC5B,gBAAU;AAIV,UAAI,MAAM;AAAA,IACX,OAAO;AACN,cAAQ,IAAI,sBAAsB;AAAA,IACnC;AAAA,EACD;AAAA,QAMM,UAAU,SAAyB;AAGxC,UAAM,EAAE,aAAa,QAAQ,OAAO;AACpC,UAAM,UAAU,SAAS;AAEzB,SAAK,wBAAwB,OAAO;AAEpC,SAAK,cAAc,YAAY;AAC/B,SAAK,cAAc,WAAW;AAC9B,SAAK,cAAc,UAAU;AAG7B,SAAK,UAAU;AAAA,EAChB;AAAA,EAKA,eAAe;AAEd,SAAK,cAAc,YAAY;AAC/B,SAAK,cAAc,WAAW,CAAC;AAC/B,SAAK,cAAc,UAAU;AAC7B,SAAK,UAAU;AAGf,SAAK,UAAU;AAAA,EAChB;AAAA,QAMM,gBAAgB,UAAoB;AAEzC,SAAK,cAAc,UAAU,SAAS;AACtC,SAAK,cAAc,WAAW;AAC9B,SAAK,wBAAwB,SAAS,EAAE;AAAA,EACzC;AAAA,EAQA,mBAAmB,YAA2B;AAC7C,UAAM,WAAW,CAAC;AAClB,eAAW,QAAQ,CAAC,UAAe;AAClC,UAAI,MAAM;AAAK,iBAAS,MAAM,OAAO,MAAM,SAAS;AAAA,IACrD,CAAC;AACD,WAAO;AAAA,EACR;AAAA,EAEA,WAAW,SAAiB;AAC3B,WAAO,qBAAO,KAAK,SAAS,QAAQ,EAAE,SAAS;AAAA,EAChD;AAAA,EAEA,YAAY,SAAiB;AAC5B,WAAO,uBAAQ,cAAc,qBAAO,KAAK,SAAS,QAAQ,CAAC;AAAA,EAC5D;AAAA,EAEA,iBAAiB,YAAqF;AACrG,UAAM,SAAgB,CAAC;AAEvB,aAAS,IAAI,GACZ,IAAI,WAAW,QACf,KAAK;AAEL,YAAM,YAAY,WAAW;AAE7B,YAAM,MAAM,KAAK,WAAW,UAAU,GAAG;AACzC,YAAM,OAAO,UAAU,MAAM;AAC7B,UAAI,QAAQ;AACZ,UAAI,cAAc;AAElB,UAAI,QAAQ,GAAG;AACd,gBAAQ,KAAK,WAAW,UAAU,MAAM,KAAK;AAC7C,sBAAc,KAAK,YAAY,UAAU,MAAM,KAAK;AAAA,MAErD,WAAW,UAAU,MAAM,QAAQ,GAAG;AACrC,gBAAQ,UAAU,MAAM;AAAA,MACzB;AAEA,aAAO,KAAK;AAAA,QACX;AAAA,QACA,OAAO,SAAS;AAAA,QAChB,SAAS;AAAA,MACV,CAAC;AAAA,IAEF;AAEA,WAAO;AAAA,EACR;AAAA,EAQA,wBAAiC;AAChC,WAAO,OAAO,OAAO,eAAe;AAAA,EACrC;AAAA,QAKM,sBAAoC;AACzC,WAAO,MAAM,OAAO,WAAW,QAAQ;AAAA,EACxC;AAAA,QAOM,YAAY,QAA8B;AAC/C,UAAM,KAAK,oBAAoB;AAC/B,UAAM,WAAW,MAAM,OAAO,WAAW,SAAS,EAAE,OAAO,CAAC;AAC5D,WAAO;AAAA,EACR;AAGD;",
  "names": []
}
